{
  "chunks": [
    "PART \n\nI \nThe Java Language \n\nCHAPTER 1 \n\nThe History and Evolution \nof Java \n\nCHAPTER 2 \n\nAn Overview of Java \n\nCHAPTER 3 \n\nData Types, Variables, and \nArrays \n\nCHAPTER 4 \n\nOperators \n\nCHAPTER 5 \n\nControl Statements \n\nCHAPTER 6 \n\nIntroducing Classes \n\nCHAPTER 7 \n\nA Closer Look at Methods \nand Classes \n\nCHAPTER 8 \n\nInheritance \n\nCHAPTER 9 \n\nPackages and Interfaces \n\nCHAPTER 10 \n\nException Handling \n\nCHAPTER 11 \n\nMultithreaded \n\n\nProgramming \n\nCHAPTER 12 \n\nEnumerations, \nAutoboxing, and \nAnnotations ( Metadata ) \n\nCHAPTER 13 \n\nI/O, Applets, and Other \nTopics \n\nCHAPTER 14 \n\nGenerics \n\nCHAPTER 15 \n\nLambda Expressions \n\n\uf709 \nPREV \nFor Further Study \n\u23ee",
    "Enumerations, \nAutoboxing, and \nAnnotations ( Metadata ) \n\nCHAPTER 13 \n\nI/O, Applets, and Other \nTopics \n\nCHAPTER 14 \n\nGenerics \n\nCHAPTER 15 \n\nLambda Expressions \n\n\uf709 \nPREV \nFor Further Study \n\u23ee \n\nNEXT \nChapter 1: The History and Evolution of Java \u23ed \n\n\nPREV \nPart I: The Java Language \n\u23ee \n\nNEXT \nChapter 2: An Overview of Java \u23ed \n\nCHAPTER \n\n1 \nThe History and Evolution of Java",
    "PREV \nPart I: The Java Language \n\u23ee \n\nNEXT \nChapter 2: An Overview of Java \u23ed \n\nCHAPTER \n\n1 \nThe History and Evolution of Java \n\nTo fully understand Java, one must understand the reasons behind its creation, the forces \nthat shaped it, and the legacy that it inherits. Like the successful computer languages that \ncame before, Java is a blend of the best elements of its rich heritage combined with the \ninnovative concepts required by its unique mission. While the remaining chapters of this \nbook describe the practical aspects of Java\u2014including its syntax, key libraries, and \napplications\u2014this chapter explains how and why Java came about, what makes it so \nimportant, and how it has evolved over the years. \nAlthough Java has become inseparably linked with the online environment of the Internet, \nit is important to remember that Java is first and foremost a programming language. \nComputer language innovation and development occurs for two fundamental reasons:",
    "\u2022  To adapt to changing environments and uses \n\n\u2022  To implement refinements and improvements in the art of programming \n\nAs you will see, the development of Java was driven by both elements in nearly \nequal measure. \n\nJava\u2019s Lineage \n\nJava is related to C++, which is a direct descendant of C. Much of the character of Java is \ninherited from these two languages. From C, Java derives its syntax. Many of Java\u2019s objectoriented features were influenced by C++. In fact, several of Java\u2019s defining characteristics \ncome from\u2014or are responses to\u2014its predecessors. Moreover, the creation of Java was \ndeeply rooted in the process of refinement and adaptation that has been occurring in",
    "computer programming languages for the past several decades. For these reasons, this \nsection reviews the sequence of events and forces that led to Java. As you will see, each \ninnovation in language design was driven by the need to solve a fundamental problem that \nthe preceding languages could not solve. Java is no exception. \n\nThe Birth of Modern Programming: C \n\nThe C language shook the computer world. Its impact should not be underestimated, \n\nbecause it fundamentally changed the way programming was approached and thought \n\n\nabout. The creation of C was a direct result of the need for a structured, efficient, high-level \nlanguage that could replace assembly code when creating systems programs. As you \nprobably know, when a computer language is designed, trade-offs are often made, such as \nthe following: \n\n\u2022  Ease-of-use versus power \n\n\u2022  Safety versus efficiency \n\n\u2022  Rigidity versus extensibility",
    "Prior to C, programmers usually had to choose between languages that optimized \none set of traits or the other. For example, although FORTRAN could be used to \nwrite fairly efficient programs for scientific applications, it was not very good for \nsystem code. And while BASIC was easy to learn, it wasn\u2019t very powerful, and its \nlack of structure made its usefulness questionable for large programs. Assembly \nlanguage can be used to produce highly efficient programs, but it is not easy to \nlearn or use effectively. Further, debugging assembly code can be quite difficult. \nAnother compounding problem was that early computer languages such as BASIC, COBOL, \nand FORTRAN were not designed around structured principles. Instead, they relied upon \nthe GOTO as a primary means of program control. As a result, programs written using these \nlanguages tended to produce \u201cspaghetti code\u201d\u2014a mass of tangled jumps and conditional \nbranches that make a program virtually impossible to understand",
    ". As a result, programs written using these \nlanguages tended to produce \u201cspaghetti code\u201d\u2014a mass of tangled jumps and conditional \nbranches that make a program virtually impossible to understand. While languages like \nPascal are structured, they were not designed for efficiency, and failed to include certain \nfeatures necessary to make them applicable to a wide range of programs. ( Specifically, given \nthe standard dialects of Pascal available at the time, it was not practical to consider using \nPascal for systems-level code.) \nSo, just prior to the invention of C, no one language had reconciled the conflicting attributes \nthat had dogged earlier efforts. Yet the need for such a language was pressing. By the early \n1970s, the computer revolution was beginning to take hold, and the demand for software \nwas rapidly outpacing programmers\u2019 ability to produce it. A great deal of effort was being \nexpended in academic circles in an attempt to create a better computer language",
    ". A great deal of effort was being \nexpended in academic circles in an attempt to create a better computer language. But, and \nperhaps most importantly, a secondary force was beginning to be felt. Computer hardware \nwas finally becoming common enough that a critical mass was being reached. No longer \nwere computers kept behind locked doors. For the first time, programmers were gaining \nvirtually unlimited access to their machines. This allowed the freedom to experiment. It also \nallowed programmers to begin to create their own tools. On the eve of C\u2019s creation, the stage \nwas set for a quantum leap forward in computer languages. \nInvented and first implemented by Dennis Ritchie on a DEC PDP-11 running the UNIX",
    "operating system, C was the result of a development process that started with an older \nlanguage called BCPL, developed by Martin Richards. BCPL influenced a language called B, \ninvented by Ken Thompson, which led to the development of C in the 1970s. For many",
    "years, the de facto standard for C was the one supplied with the UNIX operating system and \ndescribed in The C Programming Language by Brian Kernighan and Dennis Ritchie \n( Prentice-Hall, 1978 ). C was formally standardized in December 1989, when the American \nNational Standards Institute ( ANSI ) standard for C was adopted. \nThe creation of C is considered by many to have marked the beginning of the modern age of \ncomputer languages. It successfully synthesized the conflicting attributes that had so \ntroubled earlier languages. The result was a powerful, efficient, structured language that was \nrelatively easy to learn. It also included one other, nearly intangible aspect: it was a \nprogrammer\u2019s language. Prior to the invention of C, computer languages were generally \ndesigned either as academic exercises or by bureaucratic committees. C is different",
    ". Prior to the invention of C, computer languages were generally \ndesigned either as academic exercises or by bureaucratic committees. C is different. It was \ndesigned, implemented, and developed by real, working programmers, reflecting the way \nthat they approached the job of programming. Its features were honed, tested, thought \nabout, and rethought by the people who actually used the language. The result was a \nlanguage that programmers liked to use. Indeed, C quickly attracted many followers who \nhad a near-religious zeal for it. As such, it found wide and rapid acceptance in the \nprogrammer community. In short, C is a language designed by and for programmers. As you \nwill see, Java inherited this legacy.",
    "During the late 1970s and early 1980s, C became the dominant computer programming \nlanguage, and it is still widely used today. Since C is a successful and useful language, you \nmight ask why a need for something else existed. The answer is complexity . Throughout the \nhistory of programming, the increasing complexity of programs has driven the need for \nbetter ways to manage that complexity. C++ is a response to that need. To better \nunderstand why managing program complexity is fundamental to the creation of C++, \nconsider the following. \nApproaches to programming have changed dramatically since the invention of the \ncomputer. For example, when computers were first invented, programming was done by \nmanually toggling in the binary machine instructions by use of the front panel. As long as \nprograms were just a few hundred instructions long, this approach worked",
    ". As long as \nprograms were just a few hundred instructions long, this approach worked. As programs \ngrew, assembly language was invented so that a programmer could deal with larger, \nincreasingly complex programs by using symbolic representations of the machine \ninstructions. As programs continued to grow, high-level languages were introduced that \ngave the programmer more tools with which to handle complexity. \nThe first widespread language was, of course, FORTRAN. While FORTRAN was an \nimpressive first step, it is hardly a language that encourages clear and easy-to-understand",
    "programs. The 1960s gave birth to structured programming . This is the method of \nprogramming championed by languages such as C. The use of structured languages enabled \nprogrammers to write, for the first time, moderately complex programs fairly easily. \nHowever, even with structured programming methods, once a project reaches a certain size, \nits complexity exceeds what a programmer can manage. By the early 1980s, many projects",
    "were pushing the structured approach past its limits. To solve this problem, a new way to \nprogram was invented, called object-oriented programming ( OOP ) . Object-oriented \nprogramming is discussed in detail later in this book, but here is a brief definition: OOP is a \nprogramming methodology that helps organize complex programs through the use of \ninheritance, encapsulation, and polymorphism. \nIn the final analysis, although C is one of the world\u2019s great programming languages, there is \na limit to its ability to handle complexity. Once the size of a program exceeds a certain \npoint, it becomes so complex that it is difficult to grasp as a totality. While the precise size \nat which this occurs differs, depending upon both the nature of the program and the \nprogrammer, there is always a threshold at which a program becomes unmanageable. C++ \nadded features that enabled this threshold to be broken, allowing programmers to \ncomprehend and manage larger programs",
    ". C++ \nadded features that enabled this threshold to be broken, allowing programmers to \ncomprehend and manage larger programs. \nC++ was invented by Bjarne Stroustrup in 1979, while he was working at Bell Laboratories \nin Murray Hill, New Jersey. Stroustrup initially called the new language \u201cC with Classes.\u201d \nHowever, in 1983, the name was changed to C++. C++ extends C by adding object-oriented \nfeatures. Because C++ is built on the foundation of C, it includes all of C\u2019s features, \nattributes, and benefits. This is a crucial reason for the success of C++ as a language. The \ninvention of C++ was not an attempt to create a completely new programming language. \nInstead, it was an enhancement to an already highly successful one.",
    "The Stage Is Set for Java \n\nBy the end of the 1980s and the early 1990s, object-oriented programming using C++ took \nhold. Indeed, for a brief moment it seemed as if programmers had finally found the perfect \nlanguage. Because C++ blended the high efficiency and stylistic elements of C with the \nobject-oriented paradigm, it was a language that could be used to create a wide range of \nprograms. However, just as in the past, forces were brewing that would, once again, drive \ncomputer language evolution forward. Within a few years, the World Wide Web and the \nInternet would reach critical mass. This event would precipitate another revolution in \nprogramming. \n\nThe Creation of Java \n\nJava was conceived by James Gosling, Patrick Naughton, Chris Warth, Ed Frank, and Mike \nSheridan at Sun Microsystems, Inc. in 1991. It took 18 months to develop the first working \nversion. This language was initially called \u201cOak,\u201d but was renamed \u201cJava\u201d in 1995. Between",
    "the initial implementation of Oak in the fall of 1992 and the public announcement of Java in \nthe spring of 1995, many more people contributed to the design and evolution of the \nlanguage. Bill Joy, Arthur van Hoff, Jonathan Payne, Frank Yellin, and Tim Lindholm were \nkey contributors to the maturing of the original prototype. \nSomewhat surprisingly, the original impetus for Java was not the Internet! Instead, the \nprimary motivation was the need for a platform-independent ( that is, architecture-neutral ) \n\nlanguage that could be used to create software to be embedded in various consumer \n\n\nelectronic devices, such as microwave ovens and remote controls. As you can probably guess,",
    "many different types of CPUs are used as controllers. The trouble with C and C++ ( and most \nother languages ) is that they are designed to be compiled for a specific target. Although it is \npossible to compile a C++ program for just about any type of CPU, to do so requires a full \nC++ compiler targeted for that CPU. The problem is that compilers are expensive and timeconsuming to create. An easier\u2014and more cost-efficient\u2014solution was needed. In an \nattempt to find such a solution, Gosling and others began work on a portable, platformindependent language that could be used to produce code that would run on a variety of \nCPUs under differing environments. This effort ultimately led to the creation of Java. \nAbout the time that the details of Java were being worked out, a second, and ultimately \nmore important, factor was emerging that would play a crucial role in the future of Java. \nThis second force was, of course, the World Wide Web",
    ". \nThis second force was, of course, the World Wide Web. Had the Web not taken shape at \nabout the same time that Java was being implemented, Java might have remained a useful \nbut obscure language for programming consumer electronics. However, with the emergence \nof the World Wide Web, Java was propelled to the forefront of computer language design, \nbecause the Web, too, demanded portable programs. \nMost programmers learn early in their careers that portable programs are as elusive as they \nare desirable. While the quest for a way to create efficient, portable ( platform-independent ) \nprograms is nearly as old as the discipline of programming itself, it had taken a back seat to \nother, more pressing problems. Further, because ( at that time ) much of the computer world \nhad divided itself into the three competing camps of Intel, Macintosh, and UNIX, most \nprogrammers stayed within their fortified boundaries, and the urgent need for portable code \nwas reduced",
    ". However, with the advent of the Internet and the Web, the old problem of \nportability returned with a vengeance. After all, the Internet consists of a diverse, \ndistributed universe populated with various types of computers, operating systems, and \nCPUs. Even though many kinds of platforms are attached to the Internet, users would like \nthem all to be able to run the same program. What was once an irritating but low-priority \nproblem had become a high-profile necessity. \nBy 1993, it became obvious to members of the Java design team that the problems of \nportability frequently encountered when creating code for embedded controllers are also \nfound when attempting to create code for the Internet. In fact, the same problem that Java \nwas initially designed to solve on a small scale could also be applied to the Internet on a \nlarge scale. This realization caused the focus of Java to switch from consumer electronics to \nInternet programming",
    ". This realization caused the focus of Java to switch from consumer electronics to \nInternet programming. So, while the desire for an architecture-neutral programming \nlanguage provided the initial spark, the Internet ultimately led to Java\u2019s large-scale success. \nAs mentioned earlier, Java derives much of its character from C and C++. This is by intent. \nThe Java designers knew that using the familiar syntax of C and echoing the object-oriented",
    "features of C++ would make their language appealing to the legions of experienced C/C++ \nprogrammers. In addition to the surface similarities, Java shares some of the other \nattributes that helped make C and C++ successful. First, Java was designed, tested, and",
    "refined by real, working programmers. It is a language grounded in the needs and \nexperiences of the people who devised it. Thus, Java is a programmer\u2019s language. Second, \nJava is cohesive and logically consistent. Third, except for those constraints imposed by the \nInternet environment, Java gives you, the programmer, full control. If you program well, \nyour programs reflect it. If you program poorly, your programs reflect that, too. Put \ndifferently, Java is not a language with training wheels. It is a language for professional \nprogrammers. \nBecause of the similarities between Java and C++, it is tempting to think of Java as simply \nthe \u201cInternet version of C++.\u201d However, to do so would be a large mistake. Java has \nsignificant practical and philosophical differences. While it is true that Java was influenced \nby C++, it is not an enhanced version of C++. For example, Java is neither upwardly nor \ndownwardly compatible with C++",
    ". While it is true that Java was influenced \nby C++, it is not an enhanced version of C++. For example, Java is neither upwardly nor \ndownwardly compatible with C++. Of course, the similarities with C++ are significant, and \nif you are a C++ programmer, then you will feel right at home with Java. One other point: \nJava was not designed to replace C++. Java was designed to solve a certain set of problems. \nC++ was designed to solve a different set of problems. Both will coexist for many years to \ncome. \nAs mentioned at the start of this chapter, computer languages evolve for two reasons: to \nadapt to changes in environment and to implement advances in the art of programming. \nThe environmental change that prompted Java was the need for platform-independent \nprograms destined for distribution on the Internet. However, Java also embodies changes in \nthe way that people approach the writing of programs",
    ". However, Java also embodies changes in \nthe way that people approach the writing of programs. For example, Java enhanced and \nrefined the object-oriented paradigm used by C++, added integrated support for \nmultithreading, and provided a library that simplified Internet access. In the final analysis, \nthough, it was not the individual features of Java that made it so remarkable. Rather, it was \nthe language as a whole. Java was the perfect response to the demands of the then newly \nemerging, highly distributed computing universe. Java was to Internet programming what C \nwas to system programming: a revolutionary force that changed the world.",
    "The C# Connection \n\nThe reach and power of Java continues to be felt in the world of computer language \ndevelopment. Many of its innovative features, constructs, and concepts have become part of \nthe baseline for any new language. The success of Java is simply too important to ignore. \nPerhaps the most important example of Java\u2019s influence is C#. Created by Microsoft to \nsupport the .NET Framework, C# is closely related to Java. For example, both share the \n\nsame general syntax, support distributed programming, and utilize the same object model. \nThere are, of course, differences between Java and C#, but the overall \u201clook and feel\u201d of \nthese languages is very similar. This \u201ccross-pollination\u201d from Java to C# is the strongest \ntestimonial to date that Java redefined the way we think about and use a computer \nlanguage. \n\nHow Java Changed the Internet",
    "How Java Changed the Internet \n\n\nThe Internet helped catapult Java to the forefront of programming, and Java, in turn, had a \nprofound effect on the Internet. In addition to simplifying web programming in general, \nJava innovated a new type of networked program called the applet that changed the way the \nonline world thought about content. Java also addressed some of the thorniest issues \nassociated with the Internet: portability and security. Let\u2019s look more closely at each of \nthese. \n\nJava Applets",
    "An applet is a special kind of Java program that is designed to be transmitted over the \nInternet and automatically executed by a Java-compatible web browser. Furthermore, an \napplet is downloaded on demand, without further interaction with the user. If the user \nclicks a link that contains an applet, the applet will be automatically downloaded and run in \nthe browser. Applets are intended to be small programs. They are typically used to display \ndata provided by the server, handle user input, or provide simple functions, such as a loan \ncalculator, that execute locally, rather than on the server. In essence, the applet allows some \nfunctionality to be moved from the server to the client. \nThe creation of the applet changed Internet programming because it expanded the universe \nof objects that can move about freely in cyberspace",
    ". \nThe creation of the applet changed Internet programming because it expanded the universe \nof objects that can move about freely in cyberspace. In general, there are two very broad \ncategories of objects that are transmitted between the server and the client: passive \ninformation and dynamic, active programs. For example, when you read your e-mail, you \nare viewing passive data. Even when you download a program, the program\u2019s code is still \nonly passive data until you execute it. By contrast, the applet is a dynamic, self-executing \nprogram. Such a program is an active agent on the client computer, yet it is initiated by the \nserver. \nAs desirable as dynamic, networked programs are, they also present serious problems in the \nareas of security and portability. Obviously, a program that downloads and executes \nautomatically on the client computer must be prevented from doing harm. It must also be \nable to run in a variety of different environments and under different operating systems",
    ". It must also be \nable to run in a variety of different environments and under different operating systems. As \nyou will see, Java solved these problems in an effective and elegant way. Let\u2019s look a bit \nmore closely at each.",
    "Security \n\nAs you are likely aware, every time you download a \u201cnormal\u201d program, you are taking a risk, \nbecause the code you are downloading might contain a virus, Trojan horse, or other harmful \ncode. At the core of the problem is the fact that malicious code can cause its damage \n\nbecause it has gained unauthorized access to system resources. For example, a virus \nprogram might gather private information, such as credit card numbers, bank account \nbalances, and passwords, by searching the contents of your computer\u2019s local file system. In \norder for Java to enable applets to be downloaded and executed on the client computer \nsafely, it was necessary to prevent an applet from launching such an attack. \nJava achieved this protection by confining an applet to the Java execution environment and",
    "not allowing it access to other parts of the computer. ( You will see how this is accomplished \nshortly.) The ability to download applets with confidence that no harm will be done and that \nno security will be breached may have been the single most innovative aspect of Java. \n\nPortability",
    "Portability \n\nPortability is a major aspect of the Internet because there are many different types of \ncomputers and operating systems connected to it. If a Java program were to be run on \nvirtually any computer connected to the Internet, there needed to be some way to enable \nthat program to execute on different systems. For example, in the case of an applet, the \nsame applet must be able to be downloaded and executed by the wide variety of CPUs, \noperating systems, and browsers connected to the Internet. It is not practical to have \ndifferent versions of the applet for different computers. The same code must work on all \ncomputers. Therefore, some means of generating portable executable code was needed. As \nyou will soon see, the same mechanism that helps ensure security also helps create \nportability. \n\nJava\u2019s Magic: The Bytecode",
    "The key that allows Java to solve both the security and the portability problems just \ndescribed is that the output of a Java compiler is not executable code. Rather, it is bytecode. \nBytecode is a highly optimized set of instructions designed to be executed by the Java runtime system, which is called the Java Virtual Machine ( JVM ) . In essence, the original JVM \nwas designed as an interpreter for bytecode . This may come as a bit of a surprise since \nmany modern languages are designed to be compiled into executable code because of \nperformance concerns. However, the fact that a Java program is executed by the JVM helps \nsolve the major problems associated with web-based programs. Here is why. \nTranslating a Java program into bytecode makes it much easier to run a program in a wide \nvariety of environments because only the JVM needs to be implemented for each platform. \nOnce the run-time package exists for a given system, any Java program can run on it",
    ". \nOnce the run-time package exists for a given system, any Java program can run on it. \nRemember, although the details of the JVM will differ from platform to platform, all \nunderstand the same Java bytecode. If a Java program were compiled to native code, then \ndifferent versions of the same program would have to exist for each type of CPU connected \nto the Internet. This is, of course, not a feasible solution. Thus, the execution of bytecode by \nthe JVM is the easiest way to create truly portable programs. \nThe fact that a Java program is executed by the JVM also helps to make it secure. Because \nthe JVM is in control, it can contain the program and prevent it from generating side effects",
    "outside of the system. As you will see, safety is also enhanced by certain restrictions that \nexist in the Java language. \n\nIn general, when a program is compiled to an intermediate form and then interpreted by a \nvirtual machine, it runs slower than it would run if compiled to executable code. However, \nwith Java, the differential between the two is not so great. Because bytecode has been highly \noptimized, the use of bytecode enables the JVM to execute programs much faster than you",
    "might expect. \nAlthough Java was designed as an interpreted language, there is nothing about Java that \nprevents on-the-fly compilation of bytecode into native code in order to boost performance. \nFor this reason, the HotSpot technology was introduced not long after Java\u2019s initial release. \nHotSpot provides a Just-In-Time ( JIT ) compiler for bytecode. When a JIT compiler is part \nof the JVM, selected portions of bytecode are compiled into executable code in real time, on \na piece-by-piece, demand basis. It is important to understand that it is not practical to \ncompile an entire Java program into executable code all at once, because Java performs \nvarious run-time checks that can be done only at run time. Instead, a JIT compiler compiles \ncode as it is needed, during execution. Furthermore, not all sequences of bytecode are \ncompiled\u2014only those that will benefit from compilation. The remaining code is simply \ninterpreted",
    ". Furthermore, not all sequences of bytecode are \ncompiled\u2014only those that will benefit from compilation. The remaining code is simply \ninterpreted. However, the just-in-time approach still yields a significant performance boost. \nEven when dynamic compilation is applied to bytecode, the portability and safety features \nstill apply, because the JVM is still in charge of the execution environment.",
    "As useful as applets can be, they are just one half of the client/server equation. Not long \nafter the initial release of Java, it became obvious that Java would also be useful on the \nserver side. The result was the servlet . A servlet is a small program that executes on the \nserver. Just as applets dynamically extend the functionality of a web browser, servlets \ndynamically extend the functionality of a web server. Thus, with the advent of the servlet, \nJava spanned both sides of the client/server connection. \nServlets are used to create dynamically generated content that is then served to the client. \nFor example, an online store might use a servlet to look up the price for an item in a \ndatabase. The price information is then used to dynamically generate a web page that is sent \nto the browser. Although dynamically generated content is available through mechanisms \nsuch as CGI ( Common Gateway Interface ), the servlet offers several advantages, including \nincreased performance",
    ". Although dynamically generated content is available through mechanisms \nsuch as CGI ( Common Gateway Interface ), the servlet offers several advantages, including \nincreased performance. \nBecause servlets ( like all Java programs ) are compiled into bytecode and executed by the \nJVM, they are highly portable. Thus, the same servlet can be used in a variety of different \nserver environments. The only requirements are that the server support the JVM and a \nservlet container.",
    "The Java Buzzwords \n\nNo discussion of Java\u2019s history is complete without a look at the Java buzzwords. Although \n\nthe fundamental forces that necessitated the invention of Java are portability and security, \nother factors also played an important role in molding the final form of the language. The \nkey considerations were summed up by the Java team in the following list of buzzwords: \n\n\u2022  Simple \n\n\u2022  Secure \n\n\n\u2022  Portable \n\n\u2022  Object-oriented \n\n\u2022  Robust \n\n\u2022  Multithreaded \n\n\u2022  Architecture-neutral \n\n\u2022  Interpreted \n\n\u2022  High performance \n\n\u2022  Distributed \n\n\u2022  Dynamic \n\nTwo of these buzzwords have already been discussed: secure and portable. Let\u2019s \nexamine what each of the others implies. \n\nSimple",
    "\u2022  High performance \n\n\u2022  Distributed \n\n\u2022  Dynamic \n\nTwo of these buzzwords have already been discussed: secure and portable. Let\u2019s \nexamine what each of the others implies. \n\nSimple \n\nJava was designed to be easy for the professional programmer to learn and use effectively. \nAssuming that you have some programming experience, you will not find Java hard to \nmaster. If you already understand the basic concepts of object-oriented programming, \nlearning Java will be even easier. Best of all, if you are an experienced C++ programmer, \nmoving to Java will require very little effort. Because Java inherits the C/C++ syntax and \nmany of the object-oriented features of C++, most programmers have little trouble learning \nJava. \n\nObject-Oriented",
    "Object-Oriented \n\nAlthough influenced by its predecessors, Java was not designed to be source-code \ncompatible with any other language. This allowed the Java team the freedom to design with \na blank slate. One outcome of this was a clean, usable, pragmatic approach to objects. \nBorrowing liberally from many seminal object-software environments of the last few \ndecades, Java manages to strike a balance between the purist\u2019s \u201ceverything is an object\u201d \nparadigm and the pragmatist\u2019s \u201cstay out of my way\u201d model. The object model in Java is \nsimple and easy to extend, while primitive types, such as integers, are kept as highperformance nonobjects. \n\nRobust",
    "Robust \n\nThe multiplatformed environment of the Web places extraordinary demands on a program, \nbecause the program must execute reliably in a variety of systems. Thus, the ability to create \nrobust programs was given a high priority in the design of Java. To gain reliability, Java \nrestricts you in a few key areas to force you to find your mistakes early in program \ndevelopment. At the same time, Java frees you from having to worry about many of the \n\nmost common causes of programming errors. Because Java is a strictly typed language, it \nchecks your code at compile time. However, it also checks your code at run time. Many \nhard-to-track-down bugs that often turn up in hard-to-reproduce run-time situations are",
    "simply impossible to create in Java. Knowing that what you have written will behave in a \npredictable way under diverse conditions is a key feature of Java. \nTo better understand how Java is robust, consider two of the main reasons for program \nfailure: memory management mistakes and mishandled exceptional conditions ( that is, runtime errors ). Memory management can be a difficult, tedious task in traditional \nprogramming environments. For example, in C/C++, the programmer will often manually \nallocate and free all dynamic memory. This sometimes leads to problems, because \nprogrammers will either forget to free memory that has been previously allocated or, worse, \ntry to free some memory that another part of their code is still using. Java virtually \neliminates these problems by managing memory allocation and deallocation for you",
    ". Java virtually \neliminates these problems by managing memory allocation and deallocation for you. ( In \nfact, deallocation is completely automatic, because Java provides garbage collection for \nunused objects.) Exceptional conditions in traditional environments often arise in situations \nsuch as division by zero or \u201cfile not found,\u201d and they must be managed with clumsy and \nhard-to-read constructs. Java helps in this area by providing object-oriented exception \nhandling. In a well-written Java program, all run-time errors can\u2014and should\u2014be managed \nby your program.",
    "Multithreaded \n\nJava was designed to meet the real-world requirement of creating interactive, networked \nprograms. To accomplish this, Java supports multithreaded programming, which allows you \nto write programs that do many things simultaneously. The Java run-time system comes \nwith an elegant yet sophisticated solution for multiprocess synchronization that enables you \nto construct smoothly running interactive systems. Java\u2019s easy-to-use approach to \nmultithreading allows you to think about the specific behavior of your program, not the \nmultitasking subsystem. \n\nArchitecture-Neutral",
    "Architecture-Neutral \n\nA central issue for the Java designers was that of code longevity and portability. At the time \nof Java\u2019s creation, one of the main problems facing programmers was that no guarantee \nexisted that if you wrote a program today, it would run tomorrow\u2014even on the same \nmachine. Operating system upgrades, processor upgrades, and changes in core system \nresources can all combine to make a program malfunction. The Java designers made several \nhard decisions in the Java language and the Java Virtual Machine in an attempt to alter this \nsituation. Their goal was \u201cwrite once ; run anywhere, any time, forever.\u201d To a great extent, \nthis goal was accomplished. \n\nInterpreted and High Performance",
    "Interpreted and High Performance \n\nAs described earlier, Java enables the creation of cross-platform programs by compiling into \nan intermediate representation called Java bytecode. This code can be executed on any \nsystem that implements the Java Virtual Machine. Most previous attempts at cross-platform \nsolutions have done so at the expense of performance. As explained earlier, the Java \n\nbytecode was carefully designed so that it would be easy to translate directly into native \n\n\nmachine code for very high performance by using a just-in-time compiler. Java run-time \nsystems that provide this feature lose none of the benefits of the platform-independent code. \n\nDistributed",
    "Distributed \n\nJava is designed for the distributed environment of the Internet because it handles TCP/IP \nprotocols. In fact, accessing a resource using a URL is not much different from accessing a \nfile. Java also supports Remote Method Invocation ( RMI ) . This feature enables a program \nto invoke methods across a network. \n\nDynamic \n\nJava programs carry with them substantial amounts of run-time type information that is \nused to verify and resolve accesses to objects at run time. This makes it possible to \ndynamically link code in a safe and expedient manner. This is crucial to the robustness of \nthe Java environment, in which small fragments of bytecode may be dynamically updated \non a running system. \n\nThe Evolution of Java",
    "The initial release of Java was nothing short of revolutionary, but it did not mark the end of \nJava\u2019s era of rapid innovation. Unlike most other software systems that usually settle into a \npattern of small, incremental improvements, Java continued to evolve at an explosive pace. \nSoon after the release of Java 1.0, the designers of Java had already created Java 1.1. The \nfeatures added by Java 1.1 were more significant and substantial than the increase in the \nminor revision number would have you think. Java 1.1 added many new library elements, \nredefined the way events are handled, and reconfigured many features of the 1.0 library. It \nalso deprecated ( rendered obsolete ) several features originally defined by Java 1.0. Thus, \nJava 1.1 both added to and subtracted from attributes of its original specification",
    ". It \nalso deprecated ( rendered obsolete ) several features originally defined by Java 1.0. Thus, \nJava 1.1 both added to and subtracted from attributes of its original specification. \nThe next major release of Java was Java 2, where the \u201c2\u201d indicates \u201csecond generation.\u201d The \ncreation of Java 2 was a watershed event, marking the beginning of Java\u2019s \u201cmodern age.\u201d \nThe first release of Java 2 carried the version number 1.2. It may seem odd that the first \nrelease of Java 2 used the 1.2 version number. The reason is that it originally referred to the \ninternal version number of the Java libraries, but then was generalized to refer to the entire \nrelease. With Java 2, Sun repackaged the Java product as J2SE ( Java 2 Platform Standard \nEdition ), and the version numbers began to be applied to that product. \nJava 2 added support for a number of new features, such as Swing and the Collections \nFramework, and it enhanced the Java Virtual Machine and various programming tools",
    ". \nJava 2 added support for a number of new features, such as Swing and the Collections \nFramework, and it enhanced the Java Virtual Machine and various programming tools. Java \n2 also contained a few deprecations. The most important affected the Thread class in which \nthe methods suspend ( ) , resume ( ) , and stop ( ) were deprecated.",
    "J2SE 1.3 was the first major upgrade to the original Java 2 release. For the most part, it \nadded to existing functionality and \u201ctightened up\u201d the development environment. In general, \nprograms written for version 1.2 and those written for version 1.3 are source-code \ncompatible. Although version 1.3 contained a smaller set of changes than the preceding \n\n\nthree major releases, it was nevertheless important.",
    "three major releases, it was nevertheless important. \n\nThe release of J2SE 1.4 further enhanced Java. This release contained several important \nupgrades, enhancements, and additions. For example, it added the new keyword assert , \nchained exceptions, and a channel-based I/O subsystem. It also made changes to the \nCollections Framework and the networking classes. In addition, numerous small changes \nwere made throughout. Despite the significant number of new features, version 1.4 \nmaintained nearly 100 percent source-code compatibility with prior versions. \nThe next release of Java was J2SE 5, and it was revolutionary. Unlike most of the previous \nJava upgrades, which offered important, but measured improvements, J2SE 5 \nfundamentally expanded the scope, power, and range of the language. To grasp the \nmagnitude of the changes that J2SE 5 made to Java, consider the following list of its major \nnew features: \n\n\u2022  Generics \n\n\u2022  Annotations \n\n\u2022  Autoboxing and auto-unboxing",
    "\u2022  Generics \n\n\u2022  Annotations \n\n\u2022  Autoboxing and auto-unboxing \n\n\u2022  Enumerations \n\n\u2022  Enhanced, for-each style for loop \n\n\u2022  Variable-length arguments ( varargs ) \n\n\u2022  Static import \n\n\u2022  Formatted I/O \n\n\u2022  Concurrency utilities",
    "\u2022  Autoboxing and auto-unboxing \n\n\u2022  Enumerations \n\n\u2022  Enhanced, for-each style for loop \n\n\u2022  Variable-length arguments ( varargs ) \n\n\u2022  Static import \n\n\u2022  Formatted I/O \n\n\u2022  Concurrency utilities \n\nThis is not a list of minor tweaks or incremental upgrades. Each item in the list \nrepresented a significant addition to the Java language. Some, such as generics, the \nenhanced for , and varargs, introduced new syntax elements. Others, such as \nautoboxing and auto-unboxing, altered the semantics of the language. Annotations \nadded an entirely new dimension to programming. In all cases, the impact of these \nadditions went beyond their direct effects. They changed the very character of Java \nitself. \nThe importance of these new features is reflected in the use of the version number \u201c5.\u201d The \nnext version number for Java would normally have been 1.5. However, the new features were \nso significant that a shift from 1.4 to 1.5 just didn\u2019t seem to express the magnitude of the",
    "change. Instead, Sun elected to increase the version number to 5 as a way of emphasizing \nthat a major event was taking place. Thus, it was named J2SE 5, and the developer\u2019s kit was \ncalled JDK 5. However, in order to maintain consistency, Sun decided to use 1.5 as its \ninternal version number, which is also referred to as the developer version number. The \u201c5\u201d \nin J2SE 5 is called the product version number. \nThe next release of Java was called Java SE 6. Sun once again decided to change the name \nof the Java platform. First, notice that the \u201c2\u201d was dropped. Thus, the platform was now \n\n\nnamed Java SE , and the official product name was Java Platform, Standard Edition 6 . The",
    "Java Development Kit was called JDK 6. As with J2SE 5, the 6 in Java SE 6 is the product \nversion number. The internal, developer version number is 1.6. \nJava SE 6 built on the base of J2SE 5, adding incremental improvements. Java SE 6 added \nno major features to the Java language proper, but it did enhance the API libraries, added \nseveral new packages, and offered improvements to the runtime. It also went through \nseveral updates during its ( in Java terms ) long life cycle, with several upgrades added along \nthe way. In general, Java SE 6 served to further solidify the advances made by J2SE 5. \nJava SE 7 was the next release of Java, with the Java Development Kit being called JDK 7, \nand an internal version number of 1.7. Java SE 7 was the first major release of Java since \nSun Microsystems was acquired by Oracle. Java SE 7 contained many new features, \nincluding significant additions to the language and the API libraries",
    ". Java SE 7 contained many new features, \nincluding significant additions to the language and the API libraries. Upgrades to the Java \nrun-time system that support non-Java languages were also included, but it is the language \nand library additions that were of most interest to Java programmers. \nThe new language features were developed as part of Project Coin . The purpose of Project \nCoin was to identify a number of small changes to the Java language that would be \nincorporated into JDK 7. Although these features were collectively referred to as \u201csmall,\u201d the \neffects of these changes have been quite large in terms of the code they impact. In fact, for \nmany programmers, these changes may well have been the most important new features in \nJava SE 7. Here is a list of the language features added by JDK 7:",
    "\u2022  A String can now control a switch statement. \n\n\u2022  Binary integer literals. \n\n\u2022  Underscores in numeric literals. \n\n\u2022  An expanded try statement, called try -with-resources , that supports \nautomatic resource management. ( For example, streams can be closed \nautomatically when they are no longer needed.) \n\n\u2022  Type inference ( via the diamond operator ) when constructing a generic \ninstance. \n\n\u2022  Enhanced exception handling in which two or more exceptions can be \ncaught by a single catch ( multi-catch ) and better type checking for \nexceptions that are rethrown. \n\n\u2022  Although not a syntax change, the compiler warnings associated with \nsome types of varargs methods were improved, and you have more control \n\nover the warnings.",
    "\u2022  Although not a syntax change, the compiler warnings associated with \nsome types of varargs methods were improved, and you have more control \n\nover the warnings. \n\nAs you can see, even though the Project Coin features were considered small \nchanges to the language, their benefits were much larger than the qualifier \u201csmall\u201d \nwould suggest. In particular, the try -with-resources statement has profoundly \naffected the way that stream-based code is written. Also, the ability to use a String",
    "to control a switch statement was a long-desired improvement that simplified \ncoding in many situations. \nJava SE 7 made several additions to the Java API library. Two of the most important were \nthe enhancements to the NIO Framework and the addition of the Fork/Join Framework. \nNIO ( which originally stood for New I/O ) was added to Java in version 1.4. However, the \nchanges added by Java SE 7 fundamentally expanded its capabilities. So significant were the \nchanges, that the term NIO.2 is often used. \nThe Fork/Join Framework provides important support for parallel programming . Parallel \nprogramming is the name commonly given to the techniques that make effective use of \ncomputers that contain more than one processor, including multicore systems. The \nadvantage that multicore environments offer is the prospect of significantly increased \nprogram performance. The Fork/Join Framework addressed parallel programming by",
    "\u2022  Simplifying the creation and use of tasks that can execute concurrently \n\n\u2022  Automatically making use of multiple processors \n\nTherefore, by using the Fork/Join Framework, you can easily create scaleable \napplications that automatically take advantage of the processors available in the \nexecution environment. Of course, not all algorithms lend themselves to \nparallelization, but for those that do, a significant improvement in execution speed \ncan be obtained. \n\nJava SE 8",
    "The newest release of Java is Java SE 8, with the developer\u2019s kit being called JDK 8. It has \nan internal version number of 1.8. JDK 8 represents a very significant upgrade to the Java \nlanguage because of the inclusion of a far-reaching new language feature: the lambda \nexpression . The impact of lambda expressions will be profound, changing both the way that \nprogramming solutions are conceptualized and how Java code is written. As explained in \ndetail in Chapter 15, lambda expressions add functional programming features to Java. In \nthe process, lambda expressions can simplify and reduce the amount of source code needed \nto create certain constructs, such as some types of anonymous classes. The addition of \nlambda expressions also causes a new operator ( the \u2013>) and a new syntax element to be \nadded to the language. Lambda expressions help ensure that Java will remain the vibrant, \nnimble language that users have come to expect",
    ". Lambda expressions help ensure that Java will remain the vibrant, \nnimble language that users have come to expect. \nThe inclusion of lambda expressions has also had a wide-ranging effect on the Java",
    "libraries, with new features being added to take advantage of them. One of the most \n\nimportant is the new stream API, which is packaged in java.util.stream . The stream API \nsupports pipeline operations on data and is optimized for lambda expressions. Another very \nimportant new package is java.util.function . It defines a number of functional interfaces , \nwhich provide additional support for lambda expressions. Other new lambda-related \nfeatures are found throughout the API library.",
    "Another lambda-inspired feature affects interface . Beginning with JDK 8, it is now \npossible to define a default implementation for a method specified by an interface. If no \nimplementation for a default method is created, then the default defined by the interface is \nused. This feature enables interfaces to be gracefully evolved over time because a new \nmethod can be added to an interface without breaking existing code. It can also streamline \nthe implementation of an interface when the defaults are appropriate. Other new features in \nJDK 8 include a new time and date API, type annotations, and the ability to use parallel \nprocessing when sorting an array, among others. JDK 8 also bundles support for JavaFX 8, \nthe latest version of Java\u2019s new GUI application framework. JavaFX is expected to soon play \nan important part in nearly all Java applications, ultimately replacing Swing for most GUIbased projects. Part IV of this book provides an introduction to it",
    ". JavaFX is expected to soon play \nan important part in nearly all Java applications, ultimately replacing Swing for most GUIbased projects. Part IV of this book provides an introduction to it. \nIn the final analysis, Java SE 8 is a major release that profoundly expands the capabilities of \nthe language and changes the way that Java code is written. Its effects will be felt \nthroughout the Java universe and for years to come. It truly is that important of a upgrade. \nThe material in this book has been updated to reflect Java SE 8, with many new features, \nupdates, and additions indicated throughout.",
    "A Culture of Innovation \n\nSince the beginning, Java has been at the center of a culture of innovation. Its original \nrelease redefined programming for the Internet. The Java Virtual Machine ( JVM ) and \nbytecode changed the way we think about security and portability. The applet ( and then the \nservlet ) made the Web come alive. The Java Community Process ( JCP ) redefined the way \nthat new ideas are assimilated into the language. The world of Java has never stood still for \nvery long. Java SE 8 is the latest release in Java\u2019s ongoing, dynamic history. \n\n\uf709 \nPREV \nPart I: The Java Language \n\u23ee \n\nNEXT \nChapter 2: An Overview of Java \u23ed \n\n\nCHAPTER \n\n2 \nAn Overview of Java",
    "\uf709 \nPREV \nPart I: The Java Language \n\u23ee \n\nNEXT \nChapter 2: An Overview of Java \u23ed \n\n\nCHAPTER \n\n2 \nAn Overview of Java \n\nAs in all other computer languages, the elements of Java do not exist in isolation. Rather, \nthey work together to form the language as a whole. However, this interrelatedness can \nmake it difficult to describe one aspect of Java without involving several others. Often a \ndiscussion of one feature implies prior knowledge of another. For this reason, this chapter \npresents a quick overview of several key features of Java. The material described here will \ngive you a foothold that will allow you to write and understand simple programs. Most of \nthe topics discussed will be examined in greater detail in the remaining chapters of Part I. \n\nObject-Oriented Programming",
    "Object-Oriented Programming \n\nObject-oriented programming ( OOP ) is at the core of Java. In fact, all Java programs are to \nat least some extent object-oriented. OOP is so integral to Java that it is best to understand \nits basic principles before you begin writing even simple Java programs. Therefore, this \nchapter begins with a discussion of the theoretical aspects of OOP. \n\nTwo Paradigms \n\nAll computer programs consist of two elements: code and data. Furthermore, a program can",
    "be conceptually organized around its code or around its data. That is, some programs are \nwritten around \u201cwhat is happening\u201d and others are written around \u201cwho is being affected.\u201d \nThese are the two paradigms that govern how a program is constructed. The first way is \ncalled the process-oriented model . This approach characterizes a program as a series of \nlinear steps ( that is, code ). The process-oriented model can be thought of as code acting on \ndata . Procedural languages such as C employ this model to considerable success. However, \nas mentioned in Chapter 1, problems with this approach appear as programs grow larger \nand more complex. \nTo manage increasing complexity, the second approach, called object-oriented \nprogramming , was conceived. Object-oriented programming organizes a program around \nits data ( that is, objects ) and a set of well-defined interfaces to that data. An object-oriented",
    "program can be characterized as data controlling access to code . As you will see, by \nswitching the controlling entity to data, you can achieve several organizational benefits. \n\nAbstraction \n\nAn essential element of object-oriented programming is abstraction . Humans manage",
    "complexity through abstraction. For example, people do not think of a car as a set of tens of \nthousands of individual parts. They think of it as a well-defined object with its own unique \nbehavior. This abstraction allows people to use a car to drive to the grocery store without \nbeing overwhelmed by the complexity of the parts that form the car. They can ignore the \ndetails of how the engine, transmission, and braking systems work. Instead, they are free to \nutilize the object as a whole. \nA powerful way to manage abstraction is through the use of hierarchical classifications. This \nallows you to layer the semantics of complex systems, breaking them into more manageable \npieces. From the outside, the car is a single object. Once inside, you see that the car consists \nof several subsystems: steering, brakes, sound system, seat belts, heating, cellular phone, \nand so on. In turn, each of these subsystems is made up of more specialized units",
    ". In turn, each of these subsystems is made up of more specialized units. For \ninstance, the sound system consists of a radio, a CD player, and/or a tape or MP3 player. \nThe point is that you manage the complexity of the car ( or any other complex system ) \nthrough the use of hierarchical abstractions. \nHierarchical abstractions of complex systems can also be applied to computer programs. \nThe data from a traditional process-oriented program can be transformed by abstraction \ninto its component objects. A sequence of process steps can become a collection of messages \nbetween these objects. Thus, each of these objects describes its own unique behavior. You \ncan treat these objects as concrete entities that respond to messages telling them to do \nsomething . This is the essence of object-oriented programming. \nObject-oriented concepts form the heart of Java just as they form the basis for human \nunderstanding",
    ". This is the essence of object-oriented programming. \nObject-oriented concepts form the heart of Java just as they form the basis for human \nunderstanding. It is important that you understand how these concepts translate into \nprograms. As you will see, object-oriented programming is a powerful and natural paradigm \nfor creating programs that survive the inevitable changes accompanying the life cycle of any \nmajor software project, including conception, growth, and aging. For example, once you \nhave well-defined objects and clean, reliable interfaces to those objects, you can gracefully \ndecommission or replace parts of an older system without fear.",
    "The Three OOP Principles \n\nAll object-oriented programming languages provide mechanisms that help you implement \nthe object-oriented model. They are encapsulation, inheritance, and polymorphism. Let\u2019s \ntake a look at these concepts now. \n\nEncapsulation \nEncapsulation is the mechanism that binds together code and the data it manipulates, and \nkeeps both safe from outside interference and misuse. One way to think about encapsulation \nis as a protective wrapper that prevents the code and data from being arbitrarily accessed by \nother code defined outside the wrapper. Access to the code and data inside the wrapper is \ntightly controlled through a well-defined interface. To relate this to the real world, consider \n\nthe automatic transmission on an automobile. It encapsulates hundreds of bits of \ninformation about your engine, such as how much you are accelerating, the pitch of the",
    "surface you are on, and the position of the shift lever. You, as the user, have only one \nmethod of affecting this complex encapsulation: by moving the gear-shift lever. You can\u2019t \naffect the transmission by using the turn signal or windshield wipers, for example. Thus, the \ngear-shift lever is a well-defined ( indeed, unique ) interface to the transmission. Further, \nwhat occurs inside the transmission does not affect objects outside the transmission. For \nexample, shifting gears does not turn on the headlights! Because an automatic transmission \nis encapsulated, dozens of car manufacturers can implement one in any way they please. \nHowever, from the driver\u2019s point of view, they all work the same. This same idea can be \napplied to programming. The power of encapsulated code is that everyone knows how to \naccess it and thus can use it regardless of the implementation details\u2014and without fear of \nunexpected side effects. \nIn Java, the basis of encapsulation is the class",
    ". \nIn Java, the basis of encapsulation is the class. Although the class will be examined in great \ndetail later in this book, the following brief discussion will be helpful now. A class defines \nthe structure and behavior ( data and code ) that will be shared by a set of objects. Each \nobject of a given class contains the structure and behavior defined by the class, as if it were \nstamped out by a mold in the shape of the class. For this reason, objects are sometimes \nreferred to as instances of a class . Thus, a class is a logical construct ; an object has physical \nreality. \nWhen you create a class, you will specify the code and data that constitute that class. \nCollectively, these elements are called members of the class. Specifically, the data defined by \nthe class are referred to as member variables or instance variables . The code that operates \non that data is referred to as member methods or just methods",
    ". Specifically, the data defined by \nthe class are referred to as member variables or instance variables . The code that operates \non that data is referred to as member methods or just methods . ( If you are familiar with \nC/C++, it may help to know that what a Java programmer calls a method , a C/C++ \nprogrammer calls a function .) In properly written Java programs, the methods define how \nthe member variables can be used. This means that the behavior and interface of a class are \ndefined by the methods that operate on its instance data. \nSince the purpose of a class is to encapsulate complexity, there are mechanisms for hiding \nthe complexity of the implementation inside the class. Each method or variable in a class \nmay be marked private or public. The public interface of a class represents everything that \nexternal users of the class need to know, or may know. The private methods and data can \nonly be accessed by code that is a member of the class",
    ". The private methods and data can \nonly be accessed by code that is a member of the class. Therefore, any other code that is not \na member of the class cannot access a private method or variable. Since the private \nmembers of a class may only be accessed by other parts of your program through the class\u2019",
    "public methods, you can ensure that no improper actions take place. Of course, this means \nthat the public interface should be carefully designed not to expose too much of the inner \nworkings of a class ( see Figure 2-1 ).",
    "Figure 2-1    Encapsulation: public methods can be used to protect \nprivate data.",
    "Inheritance \nInheritance is the process by which one object acquires the properties of another object. \nThis is important because it supports the concept of hierarchical classification. As \nmentioned earlier, most knowledge is made manageable by hierarchical ( that is, top-down ) \nclassifications. For example, a Golden Retriever is part of the classification dog , which in \nturn is part of the mammal class, which is under the larger class animal . Without the use of \nhierarchies, each object would need to define all of its characteristics explicitly. However, by \nuse of inheritance, an object need only define those qualities that make it unique within its \nclass. It can inherit its general attributes from its parent. Thus, it is the inheritance \nmechanism that makes it possible for one object to be a specific instance of a more general \ncase. Let\u2019s take a closer look at this process. \nMost people naturally view the world as made up of objects that are related to each other in",
    "a hierarchical way, such as animals, mammals, and dogs. If you wanted to describe animals \nin an abstract way, you would say they have some attributes, such as size, intelligence, and \ntype of skeletal system. Animals also have certain behavioral aspects ; they eat, breathe, and \nsleep. This description of attributes and behavior is the class definition for animals. \nIf you wanted to describe a more specific class of animals, such as mammals, they would \nhave more specific attributes, such as type of teeth and mammary glands. This is known as a \nsubclass of animals, where animals are referred to as mammals\u2019 superclass .",
    "Since mammals are simply more precisely specified animals, they inherit all of the \nattributes from animals. A deeply inherited subclass inherits all of the attributes from each \nof its ancestors in the class hierarchy . \nInheritance interacts with encapsulation as well. If a given class encapsulates some \nattributes, then any subclass will have the same attributes plus any that it adds as part of its \nspecialization ( see Figure 2-2 ). This is a key concept that lets object-oriented programs grow \nin complexity linearly rather than geometrically. A new subclass inherits all of the attributes \nof all of its ancestors. It does not have unpredictable interactions with the majority of the \nrest of the code in the system. \n\n\nFigure 2-2    Labrador inherits the encapsulation of all its \nsuperclasses.",
    "Figure 2-2    Labrador inherits the encapsulation of all its \nsuperclasses. \n\nPolymorphism \nPolymorphism ( from Greek, meaning \u201cmany forms\u201d) is a feature that allows one interface to \nbe used for a general class of actions. The specific action is determined by the exact nature \n\nof the situation. Consider a stack ( which is a last-in, first-out list ). You might have a \nprogram that requires three types of stacks. One stack is used for integer values, one for",
    "floating-point values, and one for characters. The algorithm that implements each stack is \nthe same, even though the data being stored differs. In a non\u2013object-oriented language, you \nwould be required to create three different sets of stack routines, with each set using \ndifferent names. However, because of polymorphism, in Java you can specify a general set of \nstack routines that all share the same names. \nMore generally, the concept of polymorphism is often expressed by the phrase \u201cone \ninterface, multiple methods.\u201d This means that it is possible to design a generic interface to a \ngroup of related activities. This helps reduce complexity by allowing the same interface to be \nused to specify a general class of action . It is the compiler\u2019s job to select the specific action \n( that is, method ) as it applies to each situation. You, the programmer, do not need to make \nthis selection manually. You need only remember and utilize the general interface",
    ". You, the programmer, do not need to make \nthis selection manually. You need only remember and utilize the general interface. \nExtending the dog analogy, a dog\u2019s sense of smell is polymorphic. If the dog smells a cat, it \nwill bark and run after it. If the dog smells its food, it will salivate and run to its bowl. The \nsame sense of smell is at work in both situations. The difference is what is being smelled, \nthat is, the type of data being operated upon by the dog\u2019s nose! This same general concept \ncan be implemented in Java as it applies to methods within a Java program.",
    "Polymorphism, Encapsulation, and Inheritance Work Together \nWhen properly applied, polymorphism, encapsulation, and inheritance combine to produce \na programming environment that supports the development of far more robust and \nscaleable programs than does the process-oriented model. A well-designed hierarchy of \nclasses is the basis for reusing the code in which you have invested time and effort \ndeveloping and testing. Encapsulation allows you to migrate your implementations over \ntime without breaking the code that depends on the public interface of your classes. \nPolymorphism allows you to create clean, sensible, readable, and resilient code. \nOf the two real-world examples, the automobile more completely illustrates the power of \nobject-oriented design. Dogs are fun to think about from an inheritance standpoint, but cars \nare more like programs. All drivers rely on inheritance to drive different types ( subclasses ) \nof vehicles",
    ". Dogs are fun to think about from an inheritance standpoint, but cars \nare more like programs. All drivers rely on inheritance to drive different types ( subclasses ) \nof vehicles. Whether the vehicle is a school bus, a Mercedes sedan, a Porsche, or the family \nminivan, drivers can all more or less find and operate the steering wheel, the brakes, and \nthe accelerator. After a bit of gear grinding, most people can even manage the difference \nbetween a stick shift and an automatic, because they fundamentally understand their \ncommon superclass, the transmission. \nPeople interface with encapsulated features on cars all the time. The brake and gas pedals \nhide an incredible array of complexity with an interface so simple you can operate them \nwith your feet! The implementation of the engine, the style of brakes, and the size of the \ntires have no effect on how you interface with the class definition of the pedals.",
    "The final attribute, polymorphism, is clearly reflected in the ability of car manufacturers to \noffer a wide array of options on basically the same vehicle. For example, you can get an \nantilock braking system or traditional brakes, power or rack-and-pinion steering, and 4-, 6- \n, or 8-cylinder engines. Either way, you will still press the brake pedal to stop, turn the",
    "steering wheel to change direction, and press the accelerator when you want to move. The \nsame interface can be used to control a number of different implementations. \nAs you can see, it is through the application of encapsulation, inheritance, and \npolymorphism that the individual parts are transformed into the object known as a car. The \nsame is also true of computer programs. By the application of object-oriented principles, the \nvarious parts of a complex program can be brought together to form a cohesive, robust, \nmaintainable whole. \nAs mentioned at the start of this section, every Java program is object-oriented. Or, put \nmore precisely, every Java program involves encapsulation, inheritance, and polymorphism. \nAlthough the short example programs shown in the rest of this chapter and in the next few \nchapters may not seem to exhibit all of these features, they are nevertheless present",
    ". \nAlthough the short example programs shown in the rest of this chapter and in the next few \nchapters may not seem to exhibit all of these features, they are nevertheless present. As you \nwill see, many of the features supplied by Java are part of its built-in class libraries, which \ndo make extensive use of encapsulation, inheritance, and polymorphism.",
    "A First Simple Program \n\nNow that the basic object-oriented underpinning of Java has been discussed, let\u2019s look at \nsome actual Java programs. Let\u2019s start by compiling and running the short sample program \nshown here. As you will see, this involves a little more work than you might imagine. \n\nNOTE    The descriptions that follow use the standard Java SE 8 \n\nDevelopment Kit ( JDK 8 ), which is available from Oracle. If you are using \nan integrated development environment ( IDE ), then you will need to \n\nfollow a different procedure for compiling and executing Java programs. \nIn this case, consult your IDE\u2019s documentation for details. \n\nEntering the Program",
    "For most computer languages, the name of the file that holds the source code to a program \nis immaterial. However, this is not the case with Java. The first thing that you must learn \nabout Java is that the name you give to a source file is very important. For this example, the \nname of the source file should be Example.java . Let\u2019s see why. \nIn Java, a source file is officially called a compilation unit . It is a text file that contains \n( among other things ) one or more class definitions. ( For now, we will be using source files \nthat contain only one class.) The Java compiler requires that a source file use the .java \nfilename extension. \nAs you can see by looking at the program, the name of the class defined by the program is \nalso Example . This is not a coincidence. In Java, all code must reside inside a class. By \nconvention, the name of the main class should match the name of the file that holds the \nprogram",
    ". This is not a coincidence. In Java, all code must reside inside a class. By \nconvention, the name of the main class should match the name of the file that holds the \nprogram. You should also make sure that the capitalization of the filename matches the class \nname. The reason for this is that Java is case-sensitive. At this point, the convention that \nfilenames correspond to class names may seem arbitrary. However, this convention makes \nit easier to maintain and organize your programs.",
    "Compiling the Program \n\nTo compile the Example program, execute the compiler, javac , specifying the name of the \nsource file on the command line, as shown here: \n\nThe javac compiler creates a file called Example.class that contains the bytecode version \nof the program. As discussed earlier, the Java bytecode is the intermediate representation of \nyour program that contains instructions the Java Virtual Machine will execute. Thus, the \noutput of javac is not code that can be directly executed. \nTo actually run the program, you must use the Java application launcher called java . To do \nso, pass the class name Example as a command-line argument, as shown here: \n\nWhen the program is run, the following output is displayed: \n\nWhen Java source code is compiled, each individual class is put into its own output file",
    "When the program is run, the following output is displayed: \n\nWhen Java source code is compiled, each individual class is put into its own output file \n\nnamed after the class and using the .class extension. This is why it is a good idea to give \nyour Java source files the same name as the class they contain\u2014the name of the source file \nwill match the name of the .class file. When you execute java as just shown, you are \nactually specifying the name of the class that you want to execute. It will automatically \nsearch for a file by that name that has the .class extension. If it finds the file, it will execute \nthe code contained in the specified class. \n\n\nA Closer Look at the First Sample Program \n\nAlthough Example.java is quite short, it includes several key features that are common to \nall Java programs. Let\u2019s closely examine each part of the program. \nThe program begins with the following lines:",
    "This is a comment . Like most other programming languages, Java lets you enter a remark \ninto a program\u2019s source file. The contents of a comment are ignored by the compiler. \nInstead, a comment describes or explains the operation of the program to anyone who is \nreading its source code. In this case, the comment describes the program and reminds you \nthat the source file should be called Example.java . Of course, in real applications, \ncomments generally explain how some part of the program works or what a specific feature \ndoes. \nJava supports three styles of comments. The one shown at the top of the program is called a \nmultiline comment . This type of comment must begin with /* and end with */. Anything \nbetween these two comment symbols is ignored by the compiler. As the name suggests, a \nmultiline comment may be several lines long. \nThe next line of code in the program is shown here:",
    "This line uses the keyword class to declare that a new class is being defined. Example is an \nidentifier that is the name of the class. The entire class definition, including all of its \nmembers, will be between the opening curly brace ({) and the closing curly brace (}). For the \nmoment, don\u2019t worry too much about the details of a class except to note that in Java, all \nprogram activity occurs within one. This is one reason why all Java programs are ( at least a \nlittle bit ) object-oriented. \nThe next line in the program is the single-line comment , shown here: \n\nThis is the second type of comment supported by Java. A single-line comment begins with a \n// and ends at the end of the line. As a general rule, programmers use multiline comments \nfor longer remarks and single-line comments for brief, line-by-line descriptions. The third \ntype of comment, a documentation comment , will be discussed in the \u201cComments\u201d section \nlater in this chapter. \nThe next line of code is shown here:",
    "This line begins the main ( ) method. As the comment preceding it suggests, this is the line \nat which the program will begin executing. All Java applications begin execution by calling \nmain ( ) . The full meaning of each part of this line cannot be given now, since it involves a \ndetailed understanding of Java\u2019s approach to encapsulation. However, since most of the \nexamples in the first part of this book will use this line of code, let\u2019s take a brief look at each \npart now. \nThe public keyword is an access modifier , which allows the programmer to control the \nvisibility of class members. When a class member is preceded by public , then that member \nmay be accessed by code outside the class in which it is declared. ( The opposite of public is \nprivate , which prevents a member from being used by code defined outside of its class.) In \nthis case, main ( ) must be declared as public , since it must be called by code outside of its",
    "class when the program is started. The keyword static allows main ( ) to be called without \nhaving to instantiate a particular instance of the class. This is necessary since main ( ) is \ncalled by the Java Virtual Machine before any objects are made. The keyword void simply \ntells the compiler that main ( ) does not return a value. As you will see, methods may also \nreturn values. If all this seems a bit confusing, don\u2019t worry. All of these concepts will be \ndiscussed in detail in subsequent chapters. \nAs stated, main ( ) is the method called when a Java application begins. Keep in mind that \nJava is case-sensitive. Thus, Main is different from main . It is important to understand \nthat the Java compiler will compile classes that do not contain a main ( ) method. But java \nhas no way to run these classes. So, if you had typed Main instead of main , the compiler \nwould still compile your program",
    ". But java \nhas no way to run these classes. So, if you had typed Main instead of main , the compiler \nwould still compile your program. However, java would report an error because it would be \nunable to find the main ( ) method. \nAny information that you need to pass to a method is received by variables specified within \nthe set of parentheses that follow the name of the method. These variables are called \nparameters . If there are no parameters required for a given method, you still need to \ninclude the empty parentheses. In main ( ) , there is only one parameter, albeit a \ncomplicated one. String args[ ] declares a parameter named args , which is an array of \ninstances of the class String . ( Arrays are collections of similar objects.) Objects of type \nString store character strings. In this case, args receives any command-line arguments \npresent when the program is executed. This program does not make use of this information, \nbut other programs shown later in this book will",
    ". In this case, args receives any command-line arguments \npresent when the program is executed. This program does not make use of this information, \nbut other programs shown later in this book will. \nThe last character on the line is the {. This signals the start of main ( ) \u2019s body. All of the",
    "code that comprises a method will occur between the method\u2019s opening curly brace and its \nclosing curly brace. \nOne other point: main ( ) is simply a starting place for your program. A complex program \nwill have dozens of classes, only one of which will need to have a main ( ) method to get \nthings started. Furthermore, in some cases, you won\u2019t need main ( ) at all. For example, \n\n\nwhen creating applets\u2014Java programs that are embedded in web browsers\u2014you won\u2019t use \nmain ( ) since the web browser uses a different means of starting the execution of applets. \nThe next line of code is shown here. Notice that it occurs inside main ( ) .",
    "This line outputs the string \"This is a simple Java program.\" followed by a new line on the \nscreen. Output is actually accomplished by the built-in println ( ) method. In this case, \nprintln ( ) displays the string which is passed to it. As you will see, println ( ) can be used \nto display other types of information, too. The line begins with System.out . While too \ncomplicated to explain in detail at this time, briefly, System is a predefined class that \nprovides access to the system, and out is the output stream that is connected to the console. \nAs you have probably guessed, console output ( and input ) is not used frequently in most \nreal-world Java applications. Since most modern computing environments are windowed \nand graphical in nature, console I/O is used mostly for simple utility programs, \ndemonstration programs, and server-side code. Later in this book, you will learn other ways \nto generate output using Java",
    ". Later in this book, you will learn other ways \nto generate output using Java. But for now, we will continue to use the console I/O \nmethods. \nNotice that the println ( ) statement ends with a semicolon. All statements in Java end \nwith a semicolon. The reason that the other lines in the program do not end in a semicolon \nis that they are not, technically, statements. \nThe first } in the program ends main ( ) , and the last } ends the Example class definition.",
    "A Second Short Program \n\nPerhaps no other concept is more fundamental to a programming language than that of a \nvariable. As you may know, a variable is a named memory location that may be assigned a \nvalue by your program. The value of a variable may be changed during the execution of the \nprogram. The next program shows how a variable is declared and how it is assigned a value. \nThe program also illustrates some new aspects of console output. As the comments at the \ntop of the program state, you should call this file Example2.java . \n\n\nWhen you run this program, you will see the following output: \n\nLet\u2019s take a close look at why this output is generated. The first new line in the program is \nshown here: \n\nThis line declares an integer variable called num . Java ( like most other languages ) requires \nthat variables be declared before they are used. \nFollowing is the general form of a variable declaration: \n\ntype var-name ;",
    "type var-name ; \n\nHere, type specifies the type of variable being declared, and var-name is the name \nof the variable. If you want to declare more than one variable of the specified type, \n\nyou may use a comma-separated list of variable names. Java defines several data \ntypes, including integer, character, and floating-point. The keyword int specifies \nan integer type. \nIn the program, the line \n\n\nassigns to num the value 100. In Java, the assignment operator is a single equal sign. \nThe next line of code outputs the value of num preceded by the string \"This is num:\".",
    "assigns to num the value 100. In Java, the assignment operator is a single equal sign. \nThe next line of code outputs the value of num preceded by the string \"This is num:\". \n\nIn this statement, the plus sign causes the value of num to be appended to the string that \nprecedes it, and then the resulting string is output. ( Actually, num is first converted from \nan integer into its string equivalent and then concatenated with the string that precedes it. \nThis process is described in detail later in this book.) This approach can be generalized. \nUsing the + operator, you can join together as many items as you want within a single \nprintln ( ) statement. \nThe next line of code assigns num the value of num times 2. Like most other languages, \nJava uses the * operator to indicate multiplication. After this line executes, num will \ncontain the value 200. \nHere are the next two lines in the program:",
    "Several new things are occurring here. First, the built-in method print ( ) is used to display \nthe string \"The value of num * 2 is \". This string is not followed by a newline. This means \nthat when the next output is generated, it will start on the same line. The print ( ) method \nis just like println ( ) , except that it does not output a newline character after each call. \nNow look at the call to println ( ) . Notice that num is used by itself. Both print ( ) and \nprintln ( ) can be used to output values of any of Java\u2019s built-in types. \n\nTwo Control Statements \n\nAlthough Chapter 5 will look closely at control statements, two are briefly introduced here \n\nso that they can be used in example programs in Chapters 3 and 4 . They will also help \n\nillustrate an important aspect of Java: blocks of code. \n\nThe if Statement \n\nThe Java if statement works much like the IF statement in any other language. Further, it is",
    "illustrate an important aspect of Java: blocks of code. \n\nThe if Statement \n\nThe Java if statement works much like the IF statement in any other language. Further, it is \n\nsyntactically identical to the if statements in C, C++, and C#. Its simplest form is shown \nhere: \n\nif ( condition ) statement ; \n\nHere, condition is a Boolean expression. If condition is true, then the statement is \nexecuted. If condition is false, then the statement is bypassed. Here is an example: \n\n\nIn this case, if num contains a value that is less than 100, the conditional expression is true, \nand println ( ) will execute. If num contains a value greater than or equal to 100, then the \nprintln ( ) method is bypassed. \nAs you will see in Chapter 4, Java defines a full complement of relational operators which \nmay be used in a conditional expression. Here are a few: \n\nOperator \nMeaning \n\n< \nLess than \n\n> \nGreater than \n\n== \nEqual to",
    "Operator \nMeaning \n\n< \nLess than \n\n> \nGreater than \n\n== \nEqual to \n\nNotice that the test for equality is the double equal sign. \nHere is a program that illustrates the if statement: \n\nThe output generated by this program is shown here: \n\n\nNotice one other thing in this program. The line \n\ndeclares two variables, x and y , by use of a comma-separated list. \n\nThe for Loop \n\nAs you may know from your previous programming experience, loop statements are an \nimportant part of nearly any programming language. Java is no exception. In fact, as you \nwill see in Chapter 5, Java supplies a powerful assortment of loop constructs. Perhaps the \nmost versatile is the for loop. The simplest form of the for loop is shown here: \n\nfor ( initialization ; condition ; iteration ) statement ;",
    "for ( initialization ; condition ; iteration ) statement ; \n\nIn its most common form, the initialization portion of the loop sets a loop control \nvariable to an initial value. The condition is a Boolean expression that tests the \nloop control variable. If the outcome of that test is true, the for loop continues to \niterate. If it is false, the loop terminates. The iteration expression determines how \nthe loop control variable is changed each time the loop iterates. Here is a short \nprogram that illustrates the for loop: \n\nThis program generates the following output:",
    "This program generates the following output: \n\n\nIn this example, x is the loop control variable. It is initialized to zero in the \ninitialization portion of the for . At the start of each iteration ( including the first \none ), the conditional test x < 10 is performed. If the outcome of this test is true, \nthe println ( ) statement is executed, and then the iteration portion of the loop is \nexecuted, which increases x by 1. This process continues until the conditional test \nis false. \nAs a point of interest, in professionally written Java programs you will almost never see the \niteration portion of the loop written as shown in the preceding program. That is, you will \nseldom see statements like this:",
    "The reason is that Java includes a special increment operator which performs this operation \nmore efficiently. The increment operator is ++. ( That is, two plus signs back to back.) The \nincrement operator increases its operand by one. By use of the increment operator, the \npreceding statement can be written like this: \n\nThus, the for in the preceding program will usually be written like this: \n\nYou might want to try this. As you will see, the loop still runs exactly the same as it did \n\nbefore. \nJava also provides a decrement operator, which is specified as \u2013 \u2013. This operator decreases \n\nits operand by one. \n\nUsing Blocks of Code \n\nJava allows two or more statements to be grouped into blocks of code , also called code \nblocks . This is done by enclosing the statements between opening and closing curly braces. \n\nOnce a block of code has been created, it becomes a logical unit that can be used any place",
    "Once a block of code has been created, it becomes a logical unit that can be used any place \n\n\nthat a single statement can. For example, a block can be a target for Java\u2019s if and for \nstatements. Consider this if statement: \n\nHere, if x is less than y , then both statements inside the block will be executed. Thus, the \ntwo statements inside the block form a logical unit, and one statement cannot execute \nwithout the other also executing. The key point here is that whenever you need to logically \nlink two or more statements, you do so by creating a block. \nLet\u2019s look at another example. The following program uses a block of code as the target of a \nfor loop. \n\nThe output generated by this program is shown here:",
    "The output generated by this program is shown here: \n\n\nIn this case, the target of the for loop is a block of code and not just a single statement. \nThus, each time the loop iterates, the three statements inside the block will be executed. \nThis fact is, of course, evidenced by the output generated by the program. \nAs you will see later in this book, blocks of code have additional properties and uses. \nHowever, the main reason for their existence is to create logically inseparable units of code. \n\nLexical Issues \n\nNow that you have seen several short Java programs, it is time to more formally describe \nthe atomic elements of Java. Java programs are a collection of whitespace, identifiers, \nliterals, comments, operators, separators, and keywords. The operators are described in the \nnext chapter. The others are described next. \n\nWhitespace",
    "Whitespace \n\nJava is a free-form language. This means that you do not need to follow any special \nindentation rules. For instance, the Example program could have been written all on one \nline or in any other strange way you felt like typing it, as long as there was at least one \nwhitespace character between each token that was not already delineated by an operator or \nseparator. In Java, whitespace is a space, tab, or newline. \n\nIdentifiers \n\nIdentifiers are used to name things, such as classes, variables, and methods. An identifier \nmay be any descriptive sequence of uppercase and lowercase letters, numbers, or the \nunderscore and dollar-sign characters. ( The dollar-sign character is not intended for general \n\n\nuse.) They must not begin with a number, lest they be confused with a numeric literal. \nAgain, Java is case-sensitive, so VALUE is a different identifier than Value . Some \nexamples of valid identifiers are \n\nInvalid identifier names include these:",
    "Invalid identifier names include these: \n\nNOTE    Beginning with JDK 8, the use of an underscore by itself as an \nidentifier is not recommended. \n\nLiterals \n\nA constant value in Java is created by using a literal representation of it. For example, here \nare some literals: \n\nLeft to right, the first literal specifies an integer, the next is a floating-point value, the third \nis a character constant, and the last is a string. A literal can be used anywhere a value of its \ntype is allowed. \n\nComments \n\nAs mentioned, there are three types of comments defined by Java. You have already seen \ntwo: single-line and multiline. The third type is called a documentation comment . This type \nof comment is used to produce an HTML file that documents your program. The \ndocumentation comment begins with a /** and ends with a */. Documentation comments \nare explained in the Appendix. \n\nSeparators",
    "Separators \n\nIn Java, there are a few characters that are used as separators. The most commonly used \nseparator in Java is the semicolon. As you have seen, it is used to terminate statements. The \nseparators are shown in the following table: \n\n\nThe Java Keywords \n\nThere are 50 keywords currently defined in the Java language ( see Table 2-1 ). These \nkeywords, combined with the syntax of the operators and separators, form the foundation of \nthe Java language. These keywords cannot be used as identifiers. Thus, they cannot be used \nas names for a variable, class, or method. \n\nTable 2-1    Java Keywords",
    "Table 2-1    Java Keywords \n\nThe keywords const and goto are reserved but not used. In the early days of Java, several \nother keywords were reserved for possible future use. However, the current specification for \nJava defines only the keywords shown in Table 2-1. \nIn addition to the keywords, Java reserves the following: true , false , and null . These are \nvalues defined by Java. You may not use these words for the names of variables, classes, and \nso on. \n\nThe Java Class Libraries",
    "The sample programs shown in this chapter make use of two of Java\u2019s built-in methods: \nprintln ( ) and print ( ) . As mentioned, these methods are available through System.out . \nSystem is a class predefined by Java that is automatically included in your programs. In \nthe larger view, the Java environment relies on several built-in class libraries that contain \nmany built-in methods that provide support for such things as I/O, string handling, \nnetworking, and graphics. The standard classes also provide support for a graphical user",
    "interface ( GUI ). Thus, Java as a totality is a combination of the Java language itself, plus its \nstandard classes. As you will see, the class libraries provide much of the functionality that \ncomes with Java. Indeed, part of becoming a Java programmer is learning to use the \nstandard Java classes. Throughout Part I of this book, various elements of the standard \nlibrary classes and methods are described as needed. In Part II, several class libraries are \ndescribed in detail.",
    "\uf709 \nPREV \nChapter 1: The History and Evolution of Java \n\u23ee \n\nNEXT \nChapter 3: Data Types, Variables, and Arrays \u23ed \n\n\nPREV \nChapter 2: An Overview of Java \n\u23ee \n\nNEXT \nChapter 4: Operators \u23ed \n\nCHAPTER \n\n3 \nData Types, Variables, and Arrays \n\nThis chapter examines three of Java\u2019s most fundamental elements: data types, variables, and \narrays. As with all modern programming languages, Java supports several types of data. You \nmay use these types to declare variables and to create arrays. As you will see, Java\u2019s \napproach to these items is clean, efficient, and cohesive. \n\nJava Is a Strongly Typed Language",
    "Java Is a Strongly Typed Language \n\nIt is important to state at the outset that Java is a strongly typed language. Indeed, part of \nJava\u2019s safety and robustness comes from this fact. Let\u2019s see what this means. First, every \nvariable has a type, every expression has a type, and every type is strictly defined. Second, \nall assignments, whether explicit or via parameter passing in method calls, are checked for \ntype compatibility. There are no automatic coercions or conversions of conflicting types as \nin some languages. The Java compiler checks all expressions and parameters to ensure that \nthe types are compatible. Any type mismatches are errors that must be corrected before the \ncompiler will finish compiling the class. \n\nThe Primitive Types",
    "The Primitive Types \n\nJava defines eight primitive types of data: byte , short , int , long , char , float , double , \nand boolean . The primitive types are also commonly referred to as simple types, and both \nterms will be used in this book. These can be put in four groups: \n\n\u2022   Integers     This group includes byte , short , int , and long , which are for \nwhole-valued signed numbers. \n\n\u2022   Floating-point numbers     This group includes float and double , \nwhich represent numbers with fractional precision. \n\n\u2022   Characters     This group includes char , which represents symbols in a \ncharacter set, like letters and numbers. \n\n\u2022   Boolean     This group includes boolean , which is a special type for \nrepresenting true/false values. \n\nYou can use these types as-is, or to construct arrays or your own class types. Thus, \n\n\nthey form the basis for all other types of data that you can create.",
    "The primitive types represent single values\u2014not complex objects. Although Java is \notherwise completely object-oriented, the primitive types are not. They are analogous to the \nsimple types found in most other non\u2013object-oriented languages. The reason for this is \nefficiency. Making the primitive types into objects would have degraded performance too \nmuch. \nThe primitive types are defined to have an explicit range and mathematical behavior. \nLanguages such as C and C++ allow the size of an integer to vary based upon the dictates of \nthe execution environment. However, Java is different. Because of Java\u2019s portability \nrequirement, all data types have a strictly defined range. For example, an int is always 32 \nbits, regardless of the particular platform. This allows programs to be written that are \nguaranteed to run without porting on any machine architecture",
    ". For example, an int is always 32 \nbits, regardless of the particular platform. This allows programs to be written that are \nguaranteed to run without porting on any machine architecture. While strictly specifying \nthe size of an integer may cause a small loss of performance in some environments, it is \nnecessary in order to achieve portability. \nLet\u2019s look at each type of data in turn.",
    "Java defines four integer types: byte , short , int , and long . All of these are signed, positive \nand negative values. Java does not support unsigned, positive-only integers. Many other \ncomputer languages support both signed and unsigned integers. However, Java\u2019s designers \nfelt that unsigned integers were unnecessary. Specifically, they felt that the concept of \nunsigned was used mostly to specify the behavior of the high-order bit , which defines the \nsign of an integer value. As you will see in Chapter 4, Java manages the meaning of the \nhigh-order bit differently, by adding a special \u201cunsigned right shift\u201d operator. Thus, the \nneed for an unsigned integer type was eliminated. \nThe width of an integer type should not be thought of as the amount of storage it consumes, \nbut rather as the behavior it defines for variables and expressions of that type. The Java \nrun-time environment is free to use whatever size it wants, as long as the types behave as \nyou declared them",
    ". The Java \nrun-time environment is free to use whatever size it wants, as long as the types behave as \nyou declared them. The width and ranges of these integer types vary widely, as shown in this \ntable:",
    "Let\u2019s look at each type of integer. \n\nbyte \n\nThe smallest integer type is byte . This is a signed 8-bit type that has a range from \u2013128 to \n\n\n127. Variables of type byte are especially useful when you\u2019re working with a stream of data \n\nfrom a network or file. They are also useful when you\u2019re working with raw binary data that \nmay not be directly compatible with Java\u2019s other built-in types. \nByte variables are declared by use of the byte keyword. For example, the following declares \ntwo byte variables called b and c : \n\nshort \n\nshort is a signed 16-bit type. It has a range from \u201332,768 to 32,767. It is probably the leastused Java type. Here are some examples of short variable declarations: \n\nint",
    "short \n\nshort is a signed 16-bit type. It has a range from \u201332,768 to 32,767. It is probably the leastused Java type. Here are some examples of short variable declarations: \n\nint \n\nThe most commonly used integer type is int . It is a signed 32-bit type that has a range from \n\u20132,147,483,648 to 2,147,483,647. In addition to other uses, variables of type int are \ncommonly employed to control loops and to index arrays. Although you might think that \nusing a byte or short would be more efficient than using an int in situations in which the \nlarger range of an int is not needed, this may not be the case. The reason is that when byte \nand short values are used in an expression, they are promoted to int when the expression \nis evaluated. ( Type promotion is described later in this chapter.) Therefore, int is often the \nbest choice when an integer is needed. \n\nlong",
    "long \n\nlong is a signed 64-bit type and is useful for those occasions where an int type is not large \nenough to hold the desired value. The range of a long is quite large. This makes it useful \nwhen big, whole numbers are needed. For example, here is a program that computes the \nnumber of miles that light will travel in a specified number of days: \n\n\nThis program generates the following output: \n\nClearly, the result could not have been held in an int variable. \n\nFloating-Point Types",
    "This program generates the following output: \n\nClearly, the result could not have been held in an int variable. \n\nFloating-Point Types \n\nFloating-point numbers, also known as real numbers, are used when evaluating expressions \nthat require fractional precision. For example, calculations such as square root, or \ntranscendentals such as sine and cosine, result in a value whose precision requires a \nfloating-point type. Java implements the standard ( IEEE\u2013754 ) set of floating-point types \nand operators. There are two kinds of floating-point types, float and double , which \nrepresent single- and double-precision numbers, respectively. Their width and ranges are \nshown here: \n\nEach of these floating-point types is examined next. \n\n\nfloat",
    "Each of these floating-point types is examined next. \n\n\nfloat \n\nThe type float specifies a single-precision value that uses 32 bits of storage. Single precision \nis faster on some processors and takes half as much space as double precision, but will \nbecome imprecise when the values are either very large or very small. Variables of type \nfloat are useful when you need a fractional component, but don\u2019t require a large degree of \nprecision. For example, float can be useful when representing dollars and cents. \nHere are some example float variable declarations: \n\ndouble",
    "double \n\nDouble precision, as denoted by the double keyword, uses 64 bits to store a value. Double \nprecision is actually faster than single precision on some modern processors that have been \noptimized for high-speed mathematical calculations. All transcendental math functions, such \nas sin ( ) , cos ( ) , and sqrt ( ) , return double values. When you need to maintain accuracy \nover many iterative calculations, or are manipulating large-valued numbers, double is the \nbest choice. \nHere is a short program that uses double variables to compute the area of a circle: \n\nCharacters",
    "Characters \n\nIn Java, the data type used to store characters is char . However, C/C++ programmers \nbeware: char in Java is not the same as char in C or C++. In C/C++, char is 8 bits wide. \nThis is not the case in Java. Instead, Java uses Unicode to represent characters. Unicode \ndefines a fully international character set that can represent all of the characters found in all \nhuman languages. It is a unification of dozens of character sets, such as Latin, Greek, \nArabic, Cyrillic, Hebrew, Katakana, Hangul, and many more. At the time of Java's creation, \nUnicode required 16 bits. Thus, in Java char is a 16-bit type. The range of a char is 0 to \n\n65,536. There are no negative char s. The standard set of characters known as ASCII still",
    "65,536. There are no negative char s. The standard set of characters known as ASCII still \n\n\nranges from 0 to 127 as always, and the extended 8-bit character set, ISO-Latin-1, ranges \nfrom 0 to 255. Since Java is designed to allow programs to be written for worldwide use, it \nmakes sense that it would use Unicode to represent characters. Of course, the use of \nUnicode is somewhat inefficient for languages such as English, German, Spanish, or French, \nwhose characters can easily be contained within 8 bits. But such is the price that must be \npaid for global portability. \n\nNOTE    More information about Unicode can be found at \n\nhttp://www.unicode.org. \n\nHere is a program that demonstrates char variables: \n\nThis program displays the following output:",
    "NOTE    More information about Unicode can be found at \n\nhttp://www.unicode.org. \n\nHere is a program that demonstrates char variables: \n\nThis program displays the following output: \n\nNotice that ch1 is assigned the value 88, which is the ASCII ( and Unicode ) value that \ncorresponds to the letter X . As mentioned, the ASCII character set occupies the first 127 \nvalues in the Unicode character set. For this reason, all the \u201cold tricks\u201d that you may have \nused with characters in other languages will work in Java, too. \nAlthough char is designed to hold Unicode characters, it can also be used as an integer type \non which you can perform arithmetic operations. For example, you can add two characters \n\ntogether, or increment the value of a character variable. Consider the following program: \n\n\nThe output generated by this program is shown here:",
    "together, or increment the value of a character variable. Consider the following program: \n\n\nThe output generated by this program is shown here: \n\nIn the program, ch1 is first given the value X . Next, ch1 is incremented. This results in ch1 \ncontaining Y , the next character in the ASCII ( and Unicode ) sequence. \n\nNOTE    In the formal specification for Java, char is referred to as an \nintegral type , which means that it is in the same general category as int , \nshort , long , and byte . However, because its principal use is for \nrepresenting Unicode characters, char is commonly considered to be in a \ncategory of its own. \n\nBooleans \n\nJava has a primitive type, called boolean , for logical values. It can have only one of two \n\npossible values, true or false . This is the type returned by all relational operators, as in the \ncase of a < b . boolean is also the type required by the conditional expressions that govern \nthe control statements such as if and for .",
    "Here is a program that demonstrates the boolean type: \n\n\nThe output generated by this program is shown here: \n\nThere are three interesting things to notice about this program. First, as you can see, when a \nboolean value is output by println ( ) , \"true\" or \"false\" is displayed. Second, the value of a \nboolean variable is sufficient, by itself, to control the if statement. There is no need to \nwrite an if statement like this: \n\nThird, the outcome of a relational operator, such as < , is a boolean value. This is why the \nexpression 10>9 displays the value \"true.\" Further, the extra set of parentheses around \n10>9 is necessary because the + operator has a higher precedence than the > . \n\nA Closer Look at Literals \n\nLiterals were mentioned briefly in Chapter 2. Now that the built-in types have been formally \ndescribed, let\u2019s take a closer look at them. \n\nInteger Literals",
    "Integers are probably the most commonly used type in the typical program. Any whole \nnumber value is an integer literal. Examples are 1, 2, 3, and 42. These are all decimal values, \nmeaning they are describing a base 10 number. Two other bases that can be used in integer \nliterals are octal ( base eight ) and hexadecimal ( base 16 ). Octal values are denoted in Java by \na leading zero. Normal decimal numbers cannot have a leading zero. Thus, the seemingly \nvalid value 09 will produce an error from the compiler, since 9 is outside of octal\u2019s 0 to 7 \nrange. A more common base for numbers used by programmers is hexadecimal, which \nmatches cleanly with modulo 8 word sizes, such as 8, 16, 32, and 64 bits. You signify a \nhexadecimal constant with a leading zero-x, ( 0x or 0X ). The range of a hexadecimal digit is \n0 to 15, so A through F ( or a through f ) are substituted for 10 through 15. \nInteger literals create an int value, which in Java is a 32-bit integer value",
    ". The range of a hexadecimal digit is \n0 to 15, so A through F ( or a through f ) are substituted for 10 through 15. \nInteger literals create an int value, which in Java is a 32-bit integer value. Since Java is \nstrongly typed, you might be wondering how it is possible to assign an integer literal to one \nof Java\u2019s other integer types, such as byte or long , without causing a type mismatch error. \nFortunately, such situations are easily handled. When a literal value is assigned to a byte or \nshort variable, no error is generated if the literal value is within the range of the target type. \nAn integer literal can always be assigned to a long variable. However, to specify a long \nliteral, you will need to explicitly tell the compiler that the literal value is of type long . You \ndo this by appending an upper- or lowercase L to the literal. For example, 0x7ffffffffffffffL or \n9223372036854775807L is the largest long",
    ". You \ndo this by appending an upper- or lowercase L to the literal. For example, 0x7ffffffffffffffL or \n9223372036854775807L is the largest long . An integer can also be assigned to a char as \nlong as it is within range. \nBeginning with JDK 7, you can also specify integer literals using binary. To do so, prefix the \nvalue with 0b or 0B . For example, this specifies the decimal value 10 using a binary literal:",
    "Among other uses, the addition of binary literals makes it easier to enter values used as \nbitmasks. In such a case, the decimal ( or hexadecimal ) representation of the value does not \nvisually convey its meaning relative to its use. The binary literal does. \nAlso beginning with JDK 7, you can embed one or more underscores in an integer literal. \nDoing so makes it easier to read large integer literals. When the literal is compiled, the \nunderscores are discarded. For example, given \n\nthe value given to x will be 123,456,789. The underscores will be ignored. Underscores can \nonly be used to separate digits. They cannot come at the beginning or the end of a literal. It \nis, however, permissible for more than one underscore to be used between two digits. For \nexample, this is valid: \n\nThe use of underscores in an integer literal is especially useful when encoding such things as",
    "The use of underscores in an integer literal is especially useful when encoding such things as \n\n\ntelephone numbers, customer ID numbers, part numbers, and so on. They are also useful \nfor providing visual groupings when specifying binary literals. For example, binary values \nare often visually grouped in four-digits units, as shown here: \n\nFloating-Point Literals",
    "Floating-point numbers represent decimal values with a fractional component. They can be \nexpressed in either standard or scientific notation. Standard notation consists of a whole \nnumber component followed by a decimal point followed by a fractional component. For \nexample, 2.0, 3.14159, and 0.6667 represent valid standard-notation floating-point \nnumbers. Scientific notation uses a standard-notation, floating-point number plus a suffix \nthat specifies a power of 10 by which the number is to be multiplied. The exponent is \nindicated by an E or e followed by a decimal number, which can be positive or negative. \nExamples include 6.022E23, 314159E\u201305, and 2e+100. \nFloating-point literals in Java default to double precision. To specify a float literal, you \nmust append an F or f to the constant. You can also explicitly specify a double literal by \nappending a D or d . Doing so is, of course, redundant",
    ". To specify a float literal, you \nmust append an F or f to the constant. You can also explicitly specify a double literal by \nappending a D or d . Doing so is, of course, redundant. The default double type consumes \n64 bits of storage, while the smaller float type requires only 32 bits. \nHexadecimal floating-point literals are also supported, but they are rarely used. They must \nbe in a form similar to scientific notation, but a P or p , rather than an E or e , is used. For \nexample, 0x12.2P2 is a valid floating-point literal. The value following the P , called the \nbinary exponent , indicates the power-of-two by which the number is multiplied. Therefore, \n0x12.2P2 represents 72.5. \nBeginning with JDK 7, you can embed one or more underscores in a floating-point literal. \nThis feature works the same as it does for integer literals, which were just described. Its \npurpose is to make it easier to read large floating-point literals",
    ". \nThis feature works the same as it does for integer literals, which were just described. Its \npurpose is to make it easier to read large floating-point literals. When the literal is \ncompiled, the underscores are discarded. For example, given",
    "the value given to num will be 9,423,497,862.0. The underscores will be ignored. As is the \n\ncase with integer literals, underscores can only be used to separate digits. They cannot come \nat the beginning or the end of a literal. It is, however, permissible for more than one \n\nunderscore to be used between two digits. It is also permissible to use underscores in the \nfractional portion of the number. For example, \n\nis legal. In this case, the fractional part is .109 . \n\nBoolean Literals \n\n\nBoolean literals are simple. There are only two logical values that a boolean value can have, \ntrue and false . The values of true and false do not convert into any numerical \nrepresentation. The true literal in Java does not equal 1, nor does the false literal equal 0. \nIn Java, the Boolean literals can only be assigned to variables declared as boolean or used \nin expressions with Boolean operators. \n\nCharacter Literals",
    "Characters in Java are indices into the Unicode character set. They are 16-bit values that \ncan be converted into integers and manipulated with the integer operators, such as the \naddition and subtraction operators. A literal character is represented inside a pair of single \nquotes. All of the visible ASCII characters can be directly entered inside the quotes, such as \n' a ', ' z ', and '@'. For characters that are impossible to enter directly, there are several escape \nsequences that allow you to enter the character you need, such as '\\' ' for the single-quote \ncharacter itself and '\\ n ' for the newline character. There is also a mechanism for directly \nentering the value of a character in octal or hexadecimal. For octal notation, use the \nbackslash followed by the three-digit number. For example, '\\ 141 ' is the letter ' a '. For \nhexadecimal, you enter a backslash-u ( \\ u ), then exactly four hexadecimal digits",
    ". For example, '\\ 141 ' is the letter ' a '. For \nhexadecimal, you enter a backslash-u ( \\ u ), then exactly four hexadecimal digits. For \nexample, ' \\ u0061 ' is the ISO-Latin-1 ' a ' because the top byte is zero. ' \\ ua432 ' is a \nJapanese Katakana character. Table 3-1 shows the character escape sequences.",
    "Table 3-1    Character Escape Sequences \n\nString Literals \n\nString literals in Java are specified like they are in most other languages\u2014by enclosing a \nsequence of characters between a pair of double quotes. Examples of string literals are \n\n\nThe escape sequences and octal/hexadecimal notations that were defined for character \nliterals work the same way inside of string literals. One important thing to note about Java \nstrings is that they must begin and end on the same line. There is no line-continuation \nescape sequence as there is in some other languages. \n\nNOTE    As you may know, in some other languages, including C/C++, \nstrings are implemented as arrays of characters. However, this is not the \ncase in Java.Strings are actually object types. As you will see later in this \nbook, because Java implements strings as objects, Java includes extensive \nstring-handling capabilities that are both powerful and easy to use. \n\nVariables",
    "Variables \n\nThe variable is the basic unit of storage in a Java program. A variable is defined by the \ncombination of an identifier, a type, and an optional initializer. In addition, all variables \nhave a scope, which defines their visibility, and a lifetime. These elements are examined \nnext. \n\nDeclaring a Variable \n\nIn Java, all variables must be declared before they can be used. The basic form of a variable \ndeclaration is shown here: \n\ntype identifier [= value ][, identifier [= value ] \u2026];",
    "In Java, all variables must be declared before they can be used. The basic form of a variable \ndeclaration is shown here: \n\ntype identifier [= value ][, identifier [= value ] \u2026]; \n\nHere, type is one of Java\u2019s atomic types, or the name of a class or interface. ( Class \nand interface types are discussed later in Part I of this book.) The identifier is the \nname of the variable. You can initialize the variable by specifying an equal sign and \na value. Keep in mind that the initialization expression must result in a value of the \nsame ( or compatible ) type as that specified for the variable. To declare more than \none variable of the specified type, use a comma-separated list. \nHere are several examples of variable declarations of various types. Note that some include \nan initialization. \n\n\nThe identifiers that you choose have nothing intrinsic in their names that indicates their \ntype. Java allows any properly formed identifier to have any declared type.",
    "The identifiers that you choose have nothing intrinsic in their names that indicates their \ntype. Java allows any properly formed identifier to have any declared type. \n\nDynamic Initialization \n\nAlthough the preceding examples have used only constants as initializers, Java allows \nvariables to be initialized dynamically, using any expression valid at the time the variable is \ndeclared. \nFor example, here is a short program that computes the length of the hypotenuse of a right \ntriangle given the lengths of its two opposing sides:",
    "Here, three local variables\u2014 a , b , and c \u2014are declared. The first two, a and b , are initialized \nby constants. However, c is initialized dynamically to the length of the hypotenuse ( using \nthe Pythagorean theorem ). The program uses another of Java\u2019s built-in methods, sqrt ( ) , \nwhich is a member of the Math class, to compute the square root of its argument. The key \npoint here is that the initialization expression may use any element valid at the time of the \ninitialization, including calls to methods, other variables, or literals. \n\nThe Scope and Lifetime of Variables",
    "The Scope and Lifetime of Variables \n\nSo far, all of the variables used have been declared at the start of the main ( ) method. \nHowever, Java allows variables to be declared within any block. As explained in Chapter 2, a \nblock is begun with an opening curly brace and ended by a closing curly brace. A block \ndefines a scope . Thus, each time you start a new block, you are creating a new scope. A \nscope determines what objects are visible to other parts of your program. It also determines \nthe lifetime of those objects. \nMany other computer languages define two general categories of scopes: global and local. \nHowever, these traditional scopes do not fit well with Java\u2019s strict, object-oriented model.",
    "While it is possible to create what amounts to being a global scope, it is by far the exception, \nnot the rule. In Java, the two major scopes are those defined by a class and those defined by \na method. Even this distinction is somewhat artificial. However, since the class scope has \nseveral unique properties and attributes that do not apply to the scope defined by a method,",
    "this distinction makes some sense. Because of the differences, a discussion of class scope \n( and variables declared within it ) is deferred until Chapter 6, when classes are described. \nFor now, we will only examine the scopes defined by or within a method. \nThe scope defined by a method begins with its opening curly brace. However, if that method \nhas parameters, they too are included within the method\u2019s scope. Although this book will \nlook more closely at parameters in Chapter 6, for the sake of this discussion, they work the \nsame as any other method variable. \nAs a general rule, variables declared inside a scope are not visible ( that is, accessible ) to \ncode that is defined outside that scope. Thus, when you declare a variable within a scope, \nyou are localizing that variable and protecting it from unauthorized access and/or \nmodification. Indeed, the scope rules provide the foundation for encapsulation. \nScopes can be nested",
    ". Indeed, the scope rules provide the foundation for encapsulation. \nScopes can be nested. For example, each time you create a block of code, you are creating a \nnew, nested scope. When this occurs, the outer scope encloses the inner scope. This means \nthat objects declared in the outer scope will be visible to code within the inner scope. \nHowever, the reverse is not true. Objects declared within the inner scope will not be visible \noutside it. \nTo understand the effect of nested scopes, consider the following program:",
    "As the comments indicate, the variable x is declared at the start of main ( ) \u2019s scope and is \n\naccessible to all subsequent code within main ( ) . Within the if block, y is declared. Since a \nblock defines a scope, y is only visible to other code within its block. This is why outside of \nits block, the line y = 100 ; is commented out. If you remove the leading comment symbol, a \ncompile-time error will occur, because y is not visible outside of its block. Within the if",
    "block, x can be used because code within a block ( that is, a nested scope ) has access to \nvariables declared by an enclosing scope. \nWithin a block, variables can be declared at any point, but are valid only after they are \ndeclared. Thus, if you define a variable at the start of a method, it is available to all of the \ncode within that method. Conversely, if you declare a variable at the end of a block, it is \neffectively useless, because no code will have access to it. For example, this fragment is \ninvalid because count cannot be used prior to its declaration:",
    "Here is another important point to remember: variables are created when their scope is \nentered, and destroyed when their scope is left. This means that a variable will not hold its \nvalue once it has gone out of scope. Therefore, variables declared within a method will not \nhold their values between calls to that method. Also, a variable declared within a block will \nlose its value when the block is left. Thus, the lifetime of a variable is confined to its scope. \nIf a variable declaration includes an initializer, then that variable will be reinitialized each \ntime the block in which it is declared is entered. For example, consider the next program: \n\nThe output generated by this program is shown here: \n\n\nAs you can see, y is reinitialized to \u20131 each time the inner for loop is entered. Even though",
    "The output generated by this program is shown here: \n\n\nAs you can see, y is reinitialized to \u20131 each time the inner for loop is entered. Even though \n\nit is subsequently assigned the value 100, this value is lost. \nOne last point: Although blocks can be nested, you cannot declare a variable to have the \nsame name as one in an outer scope. For example, the following program is illegal: \n\nType Conversion and Casting",
    "Type Conversion and Casting \n\nIf you have previous programming experience, then you already know that it is fairly \ncommon to assign a value of one type to a variable of another type. If the two types are \ncompatible, then Java will perform the conversion automatically. For example, it is always \npossible to assign an int value to a long variable. However, not all types are compatible, \nand thus, not all type conversions are implicitly allowed. For instance, there is no automatic \nconversion defined from double to byte . Fortunately, it is still possible to obtain a \nconversion between incompatible types. To do so, you must use a cast , which performs an \nexplicit conversion between incompatible types. Let\u2019s look at both automatic type \nconversions and casting. \n\nJava\u2019s Automatic Conversions \n\nWhen one type of data is assigned to another type of variable, an automatic type conversion \nwill take place if the following two conditions are met: \n\n\u2022  The two types are compatible.",
    "When one type of data is assigned to another type of variable, an automatic type conversion \nwill take place if the following two conditions are met: \n\n\u2022  The two types are compatible. \n\n\u2022  The destination type is larger than the source type. \n\nWhen these two conditions are met, a widening conversion takes place. For \nexample, the int type is always large enough to hold all valid byte values, so no \nexplicit cast statement is required. \n\nFor widening conversions, the numeric types, including integer and floating-point types, are \ncompatible with each other. However, there are no automatic conversions from the numeric \ntypes to char or boolean . Also, char and boolean are not compatible with each other. \nAs mentioned earlier, Java also performs an automatic type conversion when storing a \nliteral integer constant into variables of type byte , short , long , or char . \n\nCasting Incompatible Types",
    "Casting Incompatible Types \n\n\nAlthough the automatic type conversions are helpful, they will not fulfill all needs. For \nexample, what if you want to assign an int value to a byte variable? This conversion will \nnot be performed automatically, because a byte is smaller than an int . This kind of \nconversion is sometimes called a narrowing conversion , since you are explicitly making the \nvalue narrower so that it will fit into the target type. \nTo create a conversion between two incompatible types, you must use a cast. A cast is \nsimply an explicit type conversion. It has this general form: \n\n( target-type ) value \n\nHere, target-type specifies the desired type to convert the specified value to. For \nexample, the following fragment casts an int to a byte . If the integer\u2019s value is \nlarger than the range of a byte , it will be reduced modulo ( the remainder of an \ninteger division by the ) byte \u2019s range.",
    "A different type of conversion will occur when a floating-point value is assigned to an \ninteger type: truncation . As you know, integers do not have fractional components. Thus, \nwhen a floating-point value is assigned to an integer type, the fractional component is lost. \nFor example, if the value 1.23 is assigned to an integer, the resulting value will simply be 1. \nThe 0.23 will have been truncated. Of course, if the size of the whole number component is \ntoo large to fit into the target integer type, then that value will be reduced modulo the target \ntype\u2019s range. \nThe following program demonstrates some type conversions that require casts: \n\n\nThis program generates the following output: \n\nLet\u2019s look at each conversion. When the value 257 is cast into a byte variable, the result is",
    "This program generates the following output: \n\nLet\u2019s look at each conversion. When the value 257 is cast into a byte variable, the result is \n\nthe remainder of the division of 257 by 256 ( the range of a byte ), which is 1 in this case. \nWhen the d is converted to an int , its fractional component is lost. When d is converted to \na byte , its fractional component is lost, and the value is reduced modulo 256, which in this \ncase is 67. \n\nAutomatic Type Promotion in Expressions \n\nIn addition to assignments, there is another place where certain type conversions may \noccur: in expressions. To see why, consider the following. In an expression, the precision \nrequired of an intermediate value will sometimes exceed the range of either operand. For \nexample, examine the following expression:",
    "The result of the intermediate term a * b easily exceeds the range of either of its byte \noperands. To handle this kind of problem, Java automatically promotes each byte , short , \nor char operand to int when evaluating an expression. This means that the subexpression \na*b is performed using integers\u2014not bytes. Thus, 2,000, the result of the intermediate \nexpression, 50 * 40 , is legal even though a and b are both specified as type byte . \nAs useful as the automatic promotions are, they can cause confusing compile-time errors. \nFor example, this seemingly correct code causes a problem:",
    "The code is attempting to store 50 * 2, a perfectly valid byte value, back into a byte \nvariable. However, because the operands were automatically promoted to int when the \nexpression was evaluated, the result has also been promoted to int . Thus, the result of the \nexpression is now of type int , which cannot be assigned to a byte without the use of a cast. \nThis is true even if, as in this particular case, the value being assigned would still fit in the \ntarget type. \nIn cases where you understand the consequences of overflow, you should use an explicit \ncast, such as \n\nwhich yields the correct value of 100. \n\nThe Type Promotion Rules \n\nJava defines several type promotion rules that apply to expressions. They are as follows:",
    "which yields the correct value of 100. \n\nThe Type Promotion Rules \n\nJava defines several type promotion rules that apply to expressions. They are as follows: \n\nFirst, all byte , short , and char values are promoted to int , as just described. Then, if one \noperand is a long , the whole expression is promoted to long . If one operand is a float , the \nentire expression is promoted to float . If any of the operands are double , the result is \n\ndouble . \nThe following program demonstrates how each value in the expression gets promoted to \nmatch the second argument to each binary operator: \n\n\nLet\u2019s look closely at the type promotions that occur in this line from the program:",
    "Let\u2019s look closely at the type promotions that occur in this line from the program: \n\nIn the first subexpression, f * b, b is promoted to a float and the result of the \nsubexpression is float . Next, in the subexpression i/c, c is promoted to int , and the result \nis of type int . Then, in d * s , the value of s is promoted to double , and the type of the \nsubexpression is double . Finally, these three intermediate values, float , int , and double , \nare considered. The outcome of float plus an int is a float . Then the resultant float minus \nthe last double is promoted to double , which is the type for the final result of the \nexpression. \n\nArrays \n\nAn array is a group of like-typed variables that are referred to by a common name. Arrays \n\nof any type can be created and may have one or more dimensions. A specific element in an \narray is accessed by its index. Arrays offer a convenient means of grouping related \ninformation.",
    "of any type can be created and may have one or more dimensions. A specific element in an \narray is accessed by its index. Arrays offer a convenient means of grouping related \ninformation. \n\nNOTE    If you are familiar with C/C++, be careful. Arrays in Java work \ndifferently than they do in those languages. \n\nOne-Dimensional Arrays \n\nA one-dimensional array is, essentially, a list of like-typed variables. To create an array, you \nfirst must create an array variable of the desired type. The general form of a onedimensional array declaration is \n\ntype var-name [ ]; \n\n\nHere, type declares the element type ( also called the base type ) of the array. The \nelement type determines the data type of each element that comprises the array. \nThus, the element type for the array determines what type of data the array will \nhold. For example, the following declares an array named month_days with the \ntype \u201carray of int\u201d:",
    "Although this declaration establishes the fact that month_days is an array variable, no \narray actually exists. To link month_days with an actual, physical array of integers, you \nmust allocate one using new and assign it to month_days . new is a special operator that \nallocates memory. \nYou will look more closely at new in a later chapter, but you need to use it now to allocate \nmemory for arrays. The general form of new as it applies to one-dimensional arrays \nappears as follows: \n\narray-var = new type [ size ];",
    "array-var = new type [ size ]; \n\nHere, type specifies the type of data being allocated, size specifies the number of \nelements in the array, and array-var is the array variable that is linked to the \narray. That is, to use new to allocate an array, you must specify the type and \nnumber of elements to allocate. The elements in the array allocated by new will \nautomatically be initialized to zero ( for numeric types ), false ( for boolean ), or \nnull ( for reference types, which are described in a later chapter ). This example \nallocates a 12-element array of integers and links them to month_days :",
    "After this statement executes, month_days will refer to an array of 12 integers. Further, all \nelements in the array will be initialized to zero. \nLet\u2019s review: Obtaining an array is a two-step process. First, you must declare a variable of \nthe desired array type. Second, you must allocate the memory that will hold the array, using \nnew , and assign it to the array variable. Thus, in Java all arrays are dynamically allocated. \nIf the concept of dynamic allocation is unfamiliar to you, don\u2019t worry. It will be described at \nlength later in this book. \nOnce you have allocated an array, you can access a specific element in the array by \nspecifying its index within square brackets. All array indexes start at zero. For example, this \nstatement assigns the value 28 to the second element of month_days : \n\nThe next line displays the value stored at index 3: \n\n\nPutting together all the pieces, here is a program that creates an array of the number of days \nin each month:",
    "The next line displays the value stored at index 3: \n\n\nPutting together all the pieces, here is a program that creates an array of the number of days \nin each month: \n\nWhen you run this program, it prints the number of days in April. As mentioned, Java array \nindexes start with zero, so the number of days in April is month_days[3] or 30. \nIt is possible to combine the declaration of the array variable with the allocation of the array \nitself, as shown here:",
    "This is the way that you will normally see it done in professionally written Java programs. \nArrays can be initialized when they are declared. The process is much the same as that used \nto initialize the simple types. An array initializer is a list of comma-separated expressions \nsurrounded by curly braces. The commas separate the values of the array elements. The \narray will automatically be created large enough to hold the number of elements you specify \nin the array initializer. There is no need to use new . For example, to store the number of \n\ndays in each month, the following code creates an initialized array of integers:",
    "days in each month, the following code creates an initialized array of integers: \n\n\nWhen you run this program, you see the same output as that generated by the previous \nversion. \nJava strictly checks to make sure you do not accidentally try to store or reference values \noutside of the range of the array. The Java run-time system will check to be sure that all \narray indexes are in the correct range. For example, the run-time system will check the \nvalue of each index into month_days to make sure that it is between 0 and 11 inclusive. If \nyou try to access elements outside the range of the array ( negative numbers or numbers \ngreater than the length of the array ), you will cause a run-time error. \nHere is one more example that uses a one-dimensional array. It finds the average of a set of \nnumbers. \n\nMultidimensional Arrays",
    "Multidimensional Arrays \n\nIn Java, multidimensional arrays are actually arrays of arrays. These, as you might expect, \nlook and act like regular multidimensional arrays. However, as you will see, there are a \ncouple of subtle differences. To declare a multidimensional array variable, specify each \nadditional index using another set of square brackets. For example, the following declares a \ntwo-dimensional array variable called twoD : \n\nThis allocates a 4 by 5 array and assigns it to twoD . Internally, this matrix is implemented \n\n\nas an array of arrays of int . Conceptually, this array will look like the one shown in Figure \n3-1. \n\nFigure 3-1    A conceptual view of a 4 by 5, two-dimensional array \n\nThe following program numbers each element in the array from left to right, top to bottom, \nand then displays these values: \n\n\nThis program generates the following output:",
    "The following program numbers each element in the array from left to right, top to bottom, \nand then displays these values: \n\n\nThis program generates the following output: \n\nWhen you allocate memory for a multidimensional array, you need only specify the memory \nfor the first ( leftmost ) dimension. You can allocate the remaining dimensions separately. For \nexample, this following code allocates memory for the first dimension of twoD when it is \ndeclared. It allocates the second dimension manually. \n\nWhile there is no advantage to individually allocating the second dimension arrays in this \nsituation, there may be in others. For example, when you allocate dimensions manually, you \ndo not need to allocate the same number of elements for each dimension. As stated earlier, \nsince multidimensional arrays are actually arrays of arrays, the length of each array is under \nyour control. For example, the following program creates a two-dimensional array in which",
    "the sizes of the second dimension are unequal: \n\nThis program generates the following output: \n\nThe array created by this program looks like this:",
    "This program generates the following output: \n\nThe array created by this program looks like this: \n\n\nThe use of uneven ( or irregular ) multidimensional arrays may not be appropriate for many \napplications, because it runs contrary to what people expect to find when a \nmultidimensional array is encountered. However, irregular arrays can be used effectively in \nsome situations. For example, if you need a very large two-dimensional array that is \nsparsely populated ( that is, one in which not all of the elements will be used ), then an \nirregular array might be a perfect solution. \nIt is possible to initialize multidimensional arrays. To do so, simply enclose each \ndimension\u2019s initializer within its own set of curly braces. The following program creates a \nmatrix where each element contains the product of the row and column indexes. Also notice \nthat you can use expressions as well as literal values inside of array initializers.",
    "When you run this program, you will get the following output: \n\nAs you can see, each row in the array is initialized as specified in the initialization lists. \nLet\u2019s look at one more example that uses a multidimensional array. The following program \ncreates a 3 by 4 by 5, three-dimensional array. It then loads each element with the product \nof its indexes. Finally, it displays these products. \n\nThis program generates the following output: \n\n\nAlternative Array Declaration Syntax \n\nThere is a second form that may be used to declare an array: \n\ntype [ ] var-name ; \n\nHere, the square brackets follow the type specifier, and not the name of the array \nvariable. For example, the following two declarations are equivalent: \n\nThe following declarations are also equivalent: \n\nThis alternative declaration form offers convenience when declaring several arrays at the \nsame time. For example, \n\ncreates three array variables of type int . It is the same as writing",
    "This alternative declaration form offers convenience when declaring several arrays at the \nsame time. For example, \n\ncreates three array variables of type int . It is the same as writing \n\nThe alternative declaration form is also useful when specifying an array as a return type for \na method. Both forms are used in this book. \n\nA Few Words About Strings \n\nAs you may have noticed, in the preceding discussion of data types and arrays there has \n\nbeen no mention of strings or a string data type. This is not because Java does not support",
    "been no mention of strings or a string data type. This is not because Java does not support \n\n\nsuch a type\u2014it does. It is just that Java\u2019s string type, called String , is not a primitive type. \nNor is it simply an array of characters. Rather, String defines an object, and a full \ndescription of it requires an understanding of several object-related features. As such, it will \nbe covered later in this book, after objects are described. However, so that you can use \nsimple strings in example programs, the following brief introduction is in order. \nThe String type is used to declare string variables. You can also declare arrays of strings. A \nquoted string constant can be assigned to a String variable. A variable of type String can \nbe assigned to another variable of type String . You can use an object of type String as an \nargument to println ( ) . For example, consider the following fragment:",
    "Here, str is an object of type String . It is assigned the string \"this is a test\". This string is \ndisplayed by the println ( ) statement. \nAs you will see later, String objects have many special features and attributes that make \nthem quite powerful and easy to use. However, for the next few chapters, you will be using \nthem only in their simplest form. \n\nA Note to C/C++ Programmers About Pointers",
    "If you are an experienced C/C++ programmer, then you know that these languages provide \nsupport for pointers. However, no mention of pointers has been made in this chapter. The \nreason for this is simple: Java does not support or allow pointers. ( Or more properly, Java \ndoes not support pointers that can be accessed and/or modified by the programmer.) Java \ncannot allow pointers, because doing so would allow Java programs to breach the firewall \nbetween the Java execution environment and the host computer. ( Remember, a pointer an \nbe given any address in memory\u2014even addresses that might be outside the Java run-time \nsystem.) Since C/C++ make extensive use of pointers, you might be thinking that their loss \nis a significant disadvantage to Java. However, this is not true. Java is designed in such a \nway that as long as you stay within the confines of the execution environment, you will never \nneed to use a pointer, nor would there be any benefit in using one.",
    "\uf709 \nPREV \nChapter 2: An Overview of Java \n\u23ee \n\nNEXT \nChapter 4: Operators \u23ed \n\n\nPREV \nChapter 3: Data Types, Variables, and Arrays \n\u23ee \n\nNEXT \nChapter 5: Control Statements \n\u23ed \n\nCHAPTER \n\n4 \nOperators \n\nJava provides a rich operator environment. Most of its operators can be divided into the \nfollowing four groups: arithmetic, bitwise, relational, and logical. Java also defines some \nadditional operators that handle certain special situations. This chapter describes all of \nJava\u2019s operators except for the type comparison operator instanceof , which is examined in \nChapter 13 and the new arrow operator (\u2013>), which is described in Chapter 15. \n\nArithmetic Operators \n\nArithmetic operators are used in mathematical expressions in the same way that they are \nused in algebra. The following table lists the arithmetic operators: \n\nOperator \nResult \n\n+ \nAddition ( also unary plus ) \n\n\u2013 \nSubtraction ( also unary minus ) \n\n* \nMultiplication \n\n/ \nDivision \n\n% \nModulus \n\n++ \nIncrement",
    "Operator \nResult \n\n+ \nAddition ( also unary plus ) \n\n\u2013 \nSubtraction ( also unary minus ) \n\n* \nMultiplication \n\n/ \nDivision \n\n% \nModulus \n\n++ \nIncrement \n\n+= \nAddition assignment \n\n\u2013 = \nSubtraction assignment \n\n*= \nMultiplication assignment \n\n/= \nDivision assignment \n\n%= \nModulus assignment \n\n\u2013 \u2013 \nDecrement \n\nThe operands of the arithmetic operators must be of a numeric type. You cannot use them \non boolean types, but you can use them on char types, since the char type in Java is, \nessentially, a subset of int . \n\n\nThe Basic Arithmetic Operators",
    "The Basic Arithmetic Operators \n\nThe basic arithmetic operations\u2014addition, subtraction, multiplication, and division\u2014all \nbehave as you would expect for all numeric types. The unary minus operator negates its \nsingle operand. The unary plus operator simply returns the value of its operand. Remember \nthat when the division operator is applied to an integer type, there will be no fractional \ncomponent attached to the result. \nThe following simple example program demonstrates the arithmetic operators. It also \nillustrates the difference between floating-point division and integer division. \n\nWhen you run this program, you will see the following output: \n\n\nThe Modulus Operator \n\nThe modulus operator, % , returns the remainder of a division operation. It can be applied to \nfloating-point types as well as integer types. The following example program demonstrates \nthe % : \n\nWhen you run this program, you will get the following output:",
    "When you run this program, you will get the following output: \n\nArithmetic Compound Assignment Operators \n\nJava provides special operators that can be used to combine an arithmetic operation with an \nassignment. As you probably know, statements like the following are quite common in \nprogramming: \n\nIn Java, you can rewrite this statement as shown here: \n\n\nThis version uses the += compound assignment operator . Both statements perform the \nsame action: they increase the value of a by 4. \nHere is another example, \n\nwhich can be expressed as \n\nIn this case, the %= obtains the remainder of a /2 and puts that result back into a . \nThere are compound assignment operators for all of the arithmetic, binary operators. \nThus, any statement of the form \n\nvar = var op expression ; \n\ncan be rewritten as \n\nvar op= expression ;",
    "var = var op expression ; \n\ncan be rewritten as \n\nvar op= expression ; \n\nThe compound assignment operators provide two benefits. First, they save you a \nbit of typing, because they are \u201cshorthand\u201d for their equivalent long forms. Second, \nin some cases they are more efficient than are their equivalent long forms. For \nthese reasons, you will often see the compound assignment operators used in \nprofessionally written Java programs. \nHere is a sample program that shows several op = assignments in action: \n\n\nThe output of this program is shown here: \n\nIncrement and Decrement \n\nThe ++ and the \u2013 \u2013 are Java\u2019s increment and decrement operators. They were introduced in",
    "The output of this program is shown here: \n\nIncrement and Decrement \n\nThe ++ and the \u2013 \u2013 are Java\u2019s increment and decrement operators. They were introduced in \n\nChapter 2. Here they will be discussed in detail. As you will see, they have some special \nproperties that make them quite interesting. Let\u2019s begin by reviewing precisely what the \nincrement and decrement operators do. \nThe increment operator increases its operand by one. The decrement operator decreases its \noperand by one. For example, this statement: \n\ncan be rewritten like this by use of the increment operator: \n\nSimilarly, this statement: \n\nis equivalent to",
    "can be rewritten like this by use of the increment operator: \n\nSimilarly, this statement: \n\nis equivalent to \n\nThese operators are unique in that they can appear both in postfix form, where they follow \nthe operand as just shown, and prefix form, where they precede the operand. In the \nforegoing examples, there is no difference between the prefix and postfix forms. However, \nwhen the increment and/or decrement operators are part of a larger expression, then a \nsubtle, yet powerful, difference between these two forms appears. In the prefix form, the \noperand is incremented or decremented before the value is obtained for use in the \nexpression. In postfix form, the previous value is obtained for use in the expression, and \nthen the operand is modified. For example: \n\nIn this case, y is set to 43 as you would expect, because the increment occurs before x is \nassigned to y . Thus, the line y = ++x ; is the equivalent of these two statements: \n\n\nHowever, when written like this,",
    "However, when written like this, \n\nthe value of x is obtained before the increment operator is executed, so the value of y is 42. \nOf course, in both cases x is set to 43. Here, the line y = x++ ; is the equivalent of these two \nstatements: \n\nThe following program demonstrates the increment operator. \n\nThe output of this program follows: \n\nThe Bitwise Operators \n\nJava defines several bitwise operators that can be applied to the integer types: long , int , \nshort , char , and byte . These operators act upon the individual bits of their operands. They \nare summarized in the following table: \n\n\nOperator \nResult \n\n~ \nBitwise unary NOT \n\n& \nBitwise AND \n\n| \nBitwise OR \n\n^ \nBitwise exclusive OR \n\n>> \nShift right \n\n>>> \nShift right zero fill \n\n<< \nShift left \n\n&= \nBitwise AND assignment \n\n|= \nBitwise OR assignment \n\n^= \nBitwise exclusive OR assignment \n\n>>= \nShift right assignment \n\n>>>= \nShift right zero fill assignment \n\n<<= \nShift left assignment",
    "Since the bitwise operators manipulate the bits within an integer: it is important to \nunderstand what effects such manipulations may have on a value. Specifically, it is useful to \nknow how Java stores integer values and how it represents negative numbers. So, before \ncontinuing, let\u2019s briefly review these two topics. \nAll of the integer types are represented by binary numbers of varying bit widths. For \nexample, the byte value for 42 in binary is 00101010, where each position represents a \npower of two, starting with 2 at the rightmost bit. The next bit position to the left would be \n2 , or 2, continuing toward the left with 2 , or 4, then 8, 16, 32, and so on. So 42 has 1 bits \nset at positions 1, 3, and 5 ( counting from 0 at the right ); thus, 42 is the sum of 2 + 2 + 2 , \nwhich is 2 + 8 + 32. \nAll of the integer types ( except char ) are signed integers. This means that they can \nrepresent negative values as well as positive ones",
    ". \nAll of the integer types ( except char ) are signed integers. This means that they can \nrepresent negative values as well as positive ones. Java uses an encoding known as two\u2019s \ncomplement , which means that negative numbers are represented by inverting ( changing 1\u2019s \nto 0\u2019s and vice versa ) all of the bits in a value, then adding 1 to the result. For example, \u201342 \nis represented by inverting all of the bits in 42, or 00101010, which yields 11010101, then \nadding 1, which results in 11010110, or \u201342. To decode a negative number, first invert all of \nthe bits, then add 1. For example, \u201342, or 11010110 inverted, yields 00101001, or 41, so \nwhen you add 1 you get 42.",
    "The reason Java ( and most other computer languages ) uses two\u2019s complement is easy to see \nwhen you consider the issue of zero crossing . Assuming a byte value, zero is represented by \n00000000. In one\u2019s complement, simply inverting all of the bits creates 11111111, which \ncreates negative zero. The trouble is that negative zero is invalid in integer math. This \n\n0 \n\n1 \n2 \n\n1 \n3 \n5",
    "0 \n\n1 \n2 \n\n1 \n3 \n5 \n\n\nproblem is solved by using two\u2019s complement to represent negative values. When using \ntwo\u2019s complement, 1 is added to the complement, producing 100000000. This produces a 1 \nbit too far to the left to fit back into the byte value, resulting in the desired behavior, where \n\u20130 is the same as 0, and 11111111 is the encoding for \u20131. Although we used a byte value in \nthe preceding example, the same basic principle applies to all of Java\u2019s integer types. \nBecause Java uses two\u2019s complement to store negative numbers\u2014and because all integers \nare signed values in Java\u2014applying the bitwise operators can easily produce unexpected \nresults. For example, turning on the high-order bit will cause the resulting value to be \ninterpreted as a negative number, whether this is what you intended or not. To avoid \nunpleasant surprises, just remember that the high-order bit determines the sign of an \ninteger no matter how that high-order bit gets set.",
    "The Bitwise Logical Operators \n\nThe bitwise logical operators are & , | , ^ , and ~ . The following table shows the outcome of \neach operation. In the discussion that follows, keep in mind that the bitwise operators are \napplied to each individual bit within each operand. \n\nThe Bitwise NOT \nAlso called the bitwise complement , the unary NOT operator, ~, inverts all of the bits of its \noperand. For example, the number 42, which has the following bit pattern: \n\nbecomes \n\nafter the NOT operator is applied. \n\nThe Bitwise AND \n\nThe AND operator, & , produces a 1 bit if both operands are also 1. A zero is produced in all \nother cases. Here is an example: \n\n\nThe Bitwise OR \nThe OR operator, | , combines bits such that if either of the bits in the operands is a 1, then \nthe resultant bit is a 1, as shown here:",
    "The Bitwise OR \nThe OR operator, | , combines bits such that if either of the bits in the operands is a 1, then \nthe resultant bit is a 1, as shown here: \n\nThe Bitwise XOR \nThe XOR operator, ^ , combines bits such that if exactly one operand is 1, then the result is \n1. Otherwise, the result is zero. The following example shows the effect of the ^ . This \nexample also demonstrates a useful attribute of the XOR operation. Notice how the bit \npattern of 42 is inverted wherever the second operand has a 1 bit. Wherever the second \noperand has a 0 bit, the first operand is unchanged. You will find this property useful when \nperforming some types of bit manipulations. \n\nUsing the Bitwise Logical Operators \nThe following program demonstrates the bitwise logical operators:",
    "Using the Bitwise Logical Operators \nThe following program demonstrates the bitwise logical operators: \n\n\nIn this example, a and b have bit patterns that present all four possibilities for two binary \ndigits: 0-0, 0-1, 1-0, and 1-1. You can see how the | and & operate on each bit by the results \nin c and d . The values assigned to e and f are the same and illustrate how the ^ works. The \nstring array named binary holds the human-readable, binary representation of the \nnumbers 0 through 15. In this example, the array is indexed to show the binary \nrepresentation of each result. The array is constructed such that the correct string \nrepresentation of a binary value n is stored in binary[n] . The value of ~a is ANDed with \n0x0f ( 0000 1111 in binary ) in order to reduce its value to less than 16, so it can be printed \nby use of the binary array. Here is the output from this program: \n\nThe Left Shift",
    "The Left Shift \n\nThe left shift operator, <<, shifts all of the bits in a value to the left a specified number of \ntimes. It has this general form: \n\nvalue << num \n\n\nHere, num specifies the number of positions to left-shift the value in value . That",
    "is, the << moves all of the bits in the specified value to the left by the number of \nbit positions specified by num . For each shift left, the high-order bit is shifted out \n( and lost ), and a zero is brought in on the right. This means that when a left shift \nis applied to an int operand, bits are lost once they are shifted past bit position 31. \nIf the operand is a long , then bits are lost after bit position 63. \nJava\u2019s automatic type promotions produce unexpected results when you are shifting byte \nand short values. As you know, byte and short values are promoted to int when an \nexpression is evaluated. Furthermore, the result of such an expression is also an int . This \nmeans that the outcome of a left shift on a byte or short value will be an int , and the bits \nshifted left will not be lost until they shift past bit position 31. Furthermore, a negative byte \nor short value will be sign-extended when it is promoted to int . Thus, the high-order bits \nwill be filled with 1\u2019s",
    ". Furthermore, a negative byte \nor short value will be sign-extended when it is promoted to int . Thus, the high-order bits \nwill be filled with 1\u2019s. For these reasons, to perform a left shift on a byte or short implies \nthat you must discard the high-order bytes of the int result. For example, if you left-shift a \nbyte value, that value will first be promoted to int and then shifted. This means that you \nmust discard the top three bytes of the result if what you want is the result of a shifted byte \nvalue. The easiest way to do this is to simply cast the result back into a byte . The following \nprogram demonstrates this concept:",
    "The output generated by this program is shown here: \n\nSince a is promoted to int for the purposes of evaluation, left-shifting the value 64 ( 0100 \n0000 ) twice results in i containing the value 256 ( 1 0000 0000 ). However, the value in b \n\ncontains 0 because after the shift, the low-order byte is now zero. Its only 1 bit has been \nshifted out. \nSince each left shift has the effect of doubling the original value, programmers frequently \n\n\nuse this fact as an efficient alternative to multiplying by 2. But you need to watch out. If you \nshift a 1 bit into the high-order position ( bit 31 or 63 ), the value will become negative. The \nfollowing program illustrates this point: \n\nThe program generates the following output: \n\nThe starting value was carefully chosen so that after being shifted left 4 bit positions, it \nwould produce \u201332. As you can see, when a 1 bit is shifted into bit 31, the number is \ninterpreted as negative. \n\nThe Right Shift",
    "The Right Shift \n\nThe right shift operator, >> , shifts all of the bits in a value to the right a specified number \nof times. Its general form is shown here: \n\nvalue >> num \n\nHere, num specifies the number of positions to right-shift the value in value . That \nis, the >> moves all of the bits in the specified value to the right the number of bit \npositions specified by num . \n\nThe following code fragment shifts the value 32 to the right by two positions, resulting in a \nbeing set to 8 : \n\nWhen a value has bits that are \u201cshifted off,\u201d those bits are lost. For example, the next code \n\n\nfragment shifts the value 35 to the right two positions, which causes the two low-order bits \nto be lost, resulting again in a being set to 8: \n\nLooking at the same operation in binary shows more clearly how this happens:",
    "Looking at the same operation in binary shows more clearly how this happens: \n\nEach time you shift a value to the right, it divides that value by two\u2014and discards any \nremainder. In some cases, you can take advantage of this for high-performance integer \ndivision by 2. \nWhen you are shifting right, the top ( leftmost ) bits exposed by the right shift are filled in \nwith the previous contents of the top bit. This is called sign extension and serves to preserve \nthe sign of negative numbers when you shift them right. For example, \u20138 >> 1 is \u20134, which, \nin binary, is",
    "It is interesting to note that if you shift \u20131 right, the result always remains \u20131, since sign \nextension keeps bringing in more ones in the high-order bits. \nSometimes it is not desirable to sign-extend values when you are shifting them to the right. \nFor example, the following program converts a byte value to its hexadecimal string \nrepresentation. Notice that the shifted value is masked by ANDing it with 0x0f to discard \nany sign-extended bits so that the value can be used as an index into the array of \nhexadecimal characters. \n\n\nHere is the output of this program: \n\nThe Unsigned Right Shift",
    "The Unsigned Right Shift \n\nAs you have just seen, the >> operator automatically fills the high-order bit with its \nprevious contents each time a shift occurs. This preserves the sign of the value. However, \nsometimes this is undesirable. For example, if you are shifting something that does not \nrepresent a numeric value, you may not want sign extension to take place. This situation is \ncommon when you are working with pixel-based values and graphics. In these cases, you \nwill generally want to shift a zero into the high-order bit no matter what its initial value \nwas. This is known as an unsigned shift . To accomplish this, you will use Java\u2019s unsigned, \nshift-right operator, >>>, which always shifts zeros into the high-order bit. \nThe following code fragment demonstrates the >>>. Here, a is set to \u20131, which sets all 32 \nbits to 1 in binary. This value is then shifted right 24 bits, filling the top 24 bits with zeros, \nignoring normal sign extension. This sets a to 255.",
    "Here is the same operation in binary form to further illustrate what is happening: \n\n11111111 11111111 11111111 11111111 \u20131 in binary as an int \n\n>>>24 \n00000000 00000000 00000000 11111111 255 in binary as an int \n\nThe >>> operator is often not as useful as you might like, since it is only \nmeaningful for 32- and 64-bit values. Remember, smaller values are automatically \npromoted to int in expressions. This means that sign-extension occurs and that \nthe shift will take place on a 32-bit rather than on an 8- or 16-bit value. That is, \none might expect an unsigned right shift on a byte value to zero-fill beginning at \nbit 7. But this is not the case, since it is a 32-bit value that is actually being shifted. \n\n\nThe following program demonstrates this effect:",
    "The following program demonstrates this effect: \n\nThe following output of this program shows how the >>> operator appears to do nothing \nwhen dealing with bytes. The variable b is set to an arbitrary negative byte value for this \ndemonstration. Then c is assigned the byte value of b shifted right by four, which is 0xff \nbecause of the expected sign extension. Then d is assigned the byte value of b unsigned \nshifted right by four, which you might have expected to be 0x0f, but is actually 0xff because \nof the sign extension that happened when b was promoted to int before the shift. The last \nexpression sets e to the byte value of b masked to 8 bits using the AND operator, then \nshifted right by four, which produces the expected value of 0x0f. Notice that the unsigned \nshift right operator was not used for d , since the state of the sign bit after the AND was \nknown. \n\nBitwise Operator Compound Assignments",
    "Bitwise Operator Compound Assignments \n\nAll of the binary bitwise operators have a compound form similar to that of the algebraic \n\n\noperators, which combines the assignment with the bitwise operation. For example, the \nfollowing two statements, which shift the value in a right by four bits, are equivalent: \n\nLikewise, the following two statements, which result in a being assigned the bitwise \nexpression a OR b , are equivalent: \n\nThe following program creates a few integer variables and then uses compound bitwise \noperator assignments to manipulate the variables: \n\nThe output of this program is shown here: \n\nRelational Operators \n\nThe relational operators determine the relationship that one operand has to the other. \nSpecifically, they determine equality and ordering. The relational operators are shown here: \n\nOperator \nResult \n\n== \nEqual to \n\n!= \nNot equal to \n\n\n> \nGreater than \n\n< \nLess than \n\n>= \nGreater than or equal to \n\n<= \nLess than or equal to",
    "Operator \nResult \n\n== \nEqual to \n\n!= \nNot equal to \n\n\n> \nGreater than \n\n< \nLess than \n\n>= \nGreater than or equal to \n\n<= \nLess than or equal to \n\nThe outcome of these operations is a boolean value. The relational operators are most \nfrequently used in the expressions that control the if statement and the various loop \nstatements. \nAny type in Java, including integers, floating-point numbers, characters, and Booleans can \nbe compared using the equality test, == , and the inequality test, != . Notice that in Java \nequality is denoted with two equal signs, not one. ( Remember: a single equal sign is the \nassignment operator.) Only numeric types can be compared using the ordering operators. \nThat is, only integer, floating-point, and character operands may be compared to see which \nis greater or less than the other. \nAs stated, the result produced by a relational operator is a boolean value. For example, the \nfollowing code fragment is perfectly valid:",
    "In this case, the result of a<b ( which is false ) is stored in c . \nIf you are coming from a C/C++ background, please note the following. In C/C++, these \ntypes of statements are very common: \n\nIn Java, these statements must be written like this: \n\nThe reason is that Java does not define true and false in the same way as C/C++. In C/ C++, \ntrue is any nonzero value and false is zero. In Java, true and false are nonnumeric values \n\nthat do not relate to zero or nonzero. Therefore, to test for zero or nonzero, you must \nexplicitly employ one or more of the relational operators. \n\n\nBoolean Logical Operators \n\nThe Boolean logical operators shown here operate only on boolean operands. All of the \nbinary logical operators combine two boolean values to form a resultant boolean value. \n\nOperator \nResult \n\n& \nLogical AND \n\n| \nLogical OR \n\n^ \nLogical XOR ( exclusive OR ) \n\n|| \nShort-circuit OR \n\n&& \nShort-circuit AND \n\n! \nLogical unary NOT \n\n&= \nAND assignment \n\n|= \nOR assignment",
    "Operator \nResult \n\n& \nLogical AND \n\n| \nLogical OR \n\n^ \nLogical XOR ( exclusive OR ) \n\n|| \nShort-circuit OR \n\n&& \nShort-circuit AND \n\n! \nLogical unary NOT \n\n&= \nAND assignment \n\n|= \nOR assignment \n\n^= \nXOR assignment \n\n== \nEqual to \n\n!= \nNot equal to \n\n?: \nTernary if-then-else \n\nThe logical Boolean operators, & , |, and ^, operate on boolean values in the same way that \nthey operate on the bits of an integer. The logical ! operator inverts the Boolean state: !true \n== false and !false == true . The following table shows the effect of each logical operation: \n\nHere is a program that is almost the same as the BitLogic example shown earlier, but it \n\noperates on boolean logical values instead of binary bits: \n\n\nAfter running this program, you will see that the same logical rules apply to boolean values \nas they did to bits. As you can see from the following output, the string representation of a \nJava boolean value is one of the literal values true or false :",
    "Short-Circuit Logical Operators \n\nJava provides two interesting Boolean operators not found in some other computer \nlanguages. These are secondary versions of the Boolean AND and OR operators, and are \ncommonly known as short-circuit logical operators. As you can see from the preceding table, \nthe OR operator results in true when A is true , no matter what B is. Similarly, the AND \n\noperator results in false when A is false , no matter what B is. If you use the || and && \nforms, rather than the | and & forms of these operators, Java will not bother to evaluate the \nright-hand operand when the outcome of the expression can be determined by the left \noperand alone. This is very useful when the right-hand operand depends on the value of the \nleft one in order to function properly. For example, the following code fragment shows how \nyou can take advantage of short-circuit logical evaluation to be sure that a division operation \n\n\nwill be valid before evaluating it:",
    "will be valid before evaluating it: \n\nSince the short-circuit form of AND ( && ) is used, there is no risk of causing a run-time \nexception when denom is zero. If this line of code were written using the single & version \nof AND, both sides would be evaluated, causing a run-time exception when denom is zero. \nIt is standard practice to use the short-circuit forms of AND and OR in cases involving \nBoolean logic, leaving the single-character versions exclusively for bitwise operations. \nHowever, there are exceptions to this rule. For example, consider the following statement: \n\nHere, using a single & ensures that the increment operation will be applied to e whether c is \nequal to 1 or not. \n\nNOTE    The formal specification for Java refers to the short-circuit \noperators as the conditional-and and the conditional-or . \n\nThe Assignment Operator",
    "NOTE    The formal specification for Java refers to the short-circuit \noperators as the conditional-and and the conditional-or . \n\nThe Assignment Operator \n\nYou have been using the assignment operator since Chapter 2. Now it is time to take a \nformal look at it. The assignment operator is the single equal sign, =. The assignment \noperator works in Java much as it does in any other computer language. It has this general \nform: \n\nvar = expression ; \n\nHere, the type of var must be compatible with the type of expression . \nThe assignment operator does have one interesting attribute that you may not be familiar \nwith: it allows you to create a chain of assignments. For example, consider this fragment:",
    "This fragment sets the variables x , y , and z to 100 using a single statement. This works \nbecause the = is an operator that yields the value of the right-hand expression. Thus, the \nvalue of z = 100 is 100, which is then assigned to y , which in turn is assigned to x . Using a \n\u201cchain of assignment\u201d is an easy way to set a group of variables to a common value. \n\n\nThe ? Operator \n\nJava includes a special ternary ( three-way ) operator that can replace certain types of ifthen-else statements. This operator is the ? . It can seem somewhat confusing at first, but the \n? can be used very effectively once mastered. The ? has this general form: \n\nexpression1 ? expression2 : expression3",
    "expression1 ? expression2 : expression3 \n\nHere, expression1 can be any expression that evaluates to a boolean value. If \nexpression1 is true , then expression2 is evaluated ; otherwise, expression3 is \nevaluated. The result of the ? operation is that of the expression evaluated. Both \nexpression2 and expression3 are required to return the same ( or compatible ) type, \nwhich can\u2019t be void . \nHere is an example of the way that the ? is employed:",
    "When Java evaluates this assignment expression, it first looks at the expression to the left of \nthe question mark. If denom equals zero, then the expression between the question mark \nand the colon is evaluated and used as the value of the entire ? expression. If denom does \nnot equal zero, then the expression after the colon is evaluated and used for the value of the \nentire ? expression. The result produced by the ? operator is then assigned to ratio . \nHere is a program that demonstrates the ? operator. It uses it to obtain the absolute value \nof a variable. \n\nThe output generated by the program is shown here: \n\n\nOperator Precedence",
    "The output generated by the program is shown here: \n\n\nOperator Precedence \n\nTable 4-1 shows the order of precedence for Java operators, from highest to lowest. \nOperators in the same row are equal in precedence. In binary operations, the order of \nevaluation is left to right ( except for assignment, which evaluates right to left ). Although \nthey are technically separators, the [ ] , ( ) , and . can also act like operators. In that \ncapacity, they would have the highest precedence. Also, notice the arrow operator (->). It \nwas added by JDK 8 and is used in lambda expressions. \n\nTable 4-1    The Precedence of the Java Operators \n\nUsing Parentheses \n\nParentheses raise the precedence of the operations that are inside them. This is often \n\nnecessary to obtain the result you desire. For example, consider the following expression: \n\nThis expression first adds 3 to b and then shifts a right by that result. That is, this",
    "necessary to obtain the result you desire. For example, consider the following expression: \n\nThis expression first adds 3 to b and then shifts a right by that result. That is, this \n\nexpression can be rewritten using redundant parentheses like this: \n\nHowever, if you want to first shift a right by b positions and then add 3 to that result, you \nwill need to parenthesize the expression like this: \n\nIn addition to altering the normal precedence of an operator, parentheses can sometimes be \n\n\nused to help clarify the meaning of an expression. For anyone reading your code, a \ncomplicated expression can be difficult to understand. Adding redundant but clarifying \nparentheses to complex expressions can help prevent confusion later. For example, which of \nthe following expressions is easier to read?",
    "One other point: parentheses ( redundant or not ) do not degrade the performance of your \nprogram. Therefore, adding parentheses to reduce ambiguity does not negatively affect your \nprogram. \n\n\uf709 \nPREV \nChapter 3: Data Types, Variables, and Arrays \n\u23ee \n\nNEXT \nChapter 5: Control Statements \n\u23ed \n\n\nPREV \nChapter 4: Operators \n\u23ee \n\nNEXT \nChapter 6: Introducing Classes \n\u23ed \n\nCHAPTER \n\n5 \nControl Statements",
    "NEXT \nChapter 5: Control Statements \n\u23ed \n\n\nPREV \nChapter 4: Operators \n\u23ee \n\nNEXT \nChapter 6: Introducing Classes \n\u23ed \n\nCHAPTER \n\n5 \nControl Statements \n\nA programming language uses control statements to cause the flow of execution to advance \nand branch based on changes to the state of a program. Java\u2019s program control statements \ncan be put into the following categories: selection, iteration, and jump. Selection statements \nallow your program to choose different paths of execution based upon the outcome of an \nexpression or the state of a variable. Iteration statements enable program execution to \nrepeat one or more statements ( that is, iteration statements form loops ). Jump statements \nallow your program to execute in a nonlinear fashion. All of Java\u2019s control statements are \nexamined here. \n\nJava\u2019s Selection Statements",
    "Java\u2019s Selection Statements \n\nJava supports two selection statements: if and switch . These statements allow you to \ncontrol the flow of your program\u2019s execution based upon conditions known only during run \ntime. You will be pleasantly surprised by the power and flexibility contained in these two \nstatements. \n\nif \n\nThe if statement was introduced in Chapter 2. It is examined in detail here. The if statement \nis Java\u2019s conditional branch statement. It can be used to route program execution through \ntwo different paths. Here is the general form of the if statement: \n\nif ( condition ) statement1 ; \nelse statement2 ; \n\nHere, each statement may be a single statement or a compound statement \n\nenclosed in curly braces ( that is, a block ). The condition is any expression that \nreturns a boolean value. The else clause is optional.",
    "enclosed in curly braces ( that is, a block ). The condition is any expression that \nreturns a boolean value. The else clause is optional. \n\nThe if works like this: If the condition is true, then statement1 is executed. Otherwise, \nstatement2 ( if it exists ) is executed. In no case will both statements be executed. For \nexample, consider the following: \n\n\nHere, if a is less than b , then a is set to zero. Otherwise, b is set to zero. In no case are they \nboth set to zero. \nMost often, the expression used to control the if will involve the relational operators. \nHowever, this is not technically necessary. It is possible to control the if using a single \nboolean variable, as shown in this code fragment: \n\nRemember, only one statement can appear directly after the if or the else . If you want to \ninclude more statements, you\u2019ll need to create a block, as in this fragment:",
    "Remember, only one statement can appear directly after the if or the else . If you want to \ninclude more statements, you\u2019ll need to create a block, as in this fragment: \n\nHere, both statements within the if block will execute if bytesAvailable is greater than \nzero. \nSome programmers find it convenient to include the curly braces when using the if , even \nwhen there is only one statement in each clause. This makes it easy to add another \nstatement at a later date, and you don\u2019t have to worry about forgetting the braces. In fact, \n\nforgetting to define a block when one is needed is a common cause of errors. For example, \nconsider the following code fragment:",
    "forgetting to define a block when one is needed is a common cause of errors. For example, \nconsider the following code fragment: \n\n\nIt seems clear that the statement bytesAvailable = n ; was intended to be executed inside \nthe else clause, because of the indentation level. However, as you recall, whitespace is \ninsignificant to Java, and there is no way for the compiler to know what was intended. This \ncode will compile without complaint, but it will behave incorrectly when run. The preceding \nexample is fixed in the code that follows: \n\nNested ifs \nA nested if is an if statement that is the target of another if or else . Nested if s are very \ncommon in programming. When you nest if s, the main thing to remember is that an else \nstatement always refers to the nearest if statement that is within the same block as the else \nand that is not already associated with an else . Here is an example:",
    "As the comments indicate, the final else is not associated with if ( j<20 ) because it is not in \nthe same block ( even though it is the nearest if without an else ). Rather, the final else is \nassociated with if ( i==10 ) . The inner else refers to if ( k>100 ) because it is the closest if \nwithin the same block. \n\n\nThe if-else-if Ladder \nA common programming construct that is based upon a sequence of nested if s is the if-elseif ladder. It looks like this:",
    "The if-else-if Ladder \nA common programming construct that is based upon a sequence of nested if s is the if-elseif ladder. It looks like this: \n\nThe if statements are executed from the top down. As soon as one of the conditions \ncontrolling the if is true , the statement associated with that if is executed, and the rest of \nthe ladder is bypassed. If none of the conditions is true, then the final else statement will be \nexecuted. The final else acts as a default condition ; that is, if all other conditional tests fail, \nthen the last else statement is performed. If there is no final else and all other conditions \nare false , then no action will take place. \nHere is a program that uses an if-else-if ladder to determine which season a particular \nmonth is in. \n\n\nHere is the output produced by the program:",
    "Here is the output produced by the program: \n\nYou might want to experiment with this program before moving on. As you will find, no \nmatter what value you give month , one and only one assignment statement within the \nladder will be executed. \n\nswitch \n\nThe switch statement is Java\u2019s multiway branch statement. It provides an easy way to \ndispatch execution to different parts of your code based on the value of an expression. As \nsuch, it often provides a better alternative than a large series of if-else-if statements. Here \nis the general form of a switch statement:",
    "For versions of Java prior to JDK 7, expression must be of type byte , short , int , char , or \nan enumeration. ( Enumerations are described in Chapter 12.) Beginning with JDK 7, \nexpression can also be of type String . Each value specified in the case statements must be \na unique constant expression ( such as a literal value ). Duplicate case values are not \nallowed. The type of each value must be compatible with the type of expression . \nThe switch statement works like this: The value of the expression is compared with each of \nthe values in the case statements. If a match is found, the code sequence following that \ncase statement is executed. If none of the constants matches the value of the expression, \nthen the default statement is executed. However, the default statement is optional. If no \ncase matches and no default is present, then no further action is taken. \nThe break statement is used inside the switch to terminate a statement sequence",
    ". If no \ncase matches and no default is present, then no further action is taken. \nThe break statement is used inside the switch to terminate a statement sequence. When a \nbreak statement is encountered, execution branches to the first line of code that follows the \nentire switch statement. This has the effect of \u201cjumping out\u201d of the switch . \nHere is a simple example that uses a switch statement:",
    "The output produced by this program is shown here: \n\nAs you can see, each time through the loop, the statements associated with the case \n\nconstant that matches i are executed. All others are bypassed. After i is greater than 3, no \ncase statements match, so the default statement is executed. \nThe break statement is optional. If you omit the break , execution will continue on into the \nnext case . It is sometimes desirable to have multiple case s without break statements \n\nbetween them. For example, consider the following program: \n\n\nThis program generates the following output: \n\nAs you can see, execution falls through each case until a break statement ( or the end of the \nswitch ) is reached. \nWhile the preceding example is, of course, contrived for the sake of illustration, omitting the \nbreak statement has many practical applications in real programs. To sample its more \nrealistic usage, consider the following rewrite of the season example shown earlier. This",
    "version uses a switch to provide a more efficient implementation. \n\nAs mentioned, beginning with JDK 7, you can use a string to control a switch statement. \nFor example, \n\n\nAs you would expect, the output from the program is \n\nThe string contained in str ( which is \"two\" in this program ) is tested against the case \nconstants. When a match is found ( as it is in the second case ), the code sequence \nassociated with that sequence is executed. \nBeing able to use strings in a switch statement streamlines many situations. For example, \nusing a string-based switch is an improvement over using the equivalent sequence of \nif/else statements. However, switching on strings can be more expensive than switching on \nintegers. Therefore, it is best to switch on strings only in cases in which the controlling data \nis already in string form. In other words, don\u2019t use strings in a switch unnecessarily.",
    "Nested switch Statements \nYou can use a switch as part of the statement sequence of an outer switch . This is called a \n\nnested switch . Since a switch statement defines its own block, no conflicts arise between \nthe case constants in the inner switch and those in the outer switch . For example, the \nfollowing fragment is perfectly valid: \n\n\nHere, the case 1: statement in the inner switch does not conflict with the case 1: statement \nin the outer switch. The count variable is compared only with the list of cases at the outer \nlevel. If count is 1, then target is compared with the inner list cases. \nIn summary, there are three important features of the switch statement to note: \n\n\u2022  The switch differs from the if in that switch can only test for equality, \nwhereas if can evaluate any type of Boolean expression. That is, the switch \nlooks only for a match between the value of the expression and one of its \ncase constants.",
    "\u2022  No two case constants in the same switch can have identical values. Of \ncourse, a switch statement and an enclosing outer switch can have case \nconstants in common. \n\n\u2022  A switch statement is usually more efficient than a set of nested if s. \n\nThe last point is particularly interesting because it gives insight into how the Java \ncompiler works. When it compiles a switch statement, the Java compiler will \ninspect each of the case constants and create a \u201cjump table\u201d that it will use for \nselecting the path of execution depending on the value of the expression. \nTherefore, if you need to select among a large group of values, a switch statement \nwill run much faster than the equivalent logic coded using a sequence of if-else s. \nThe compiler can do this because it knows that the case constants are all the same \ntype and simply must be compared for equality with the switch expression. The \n\ncompiler has no such knowledge of a long list of if expressions. \n\nIteration Statements",
    "compiler has no such knowledge of a long list of if expressions. \n\nIteration Statements \n\nJava\u2019s iteration statements are for , while , and do-while . These statements create what we \ncommonly call loops . As you probably know, a loop repeatedly executes the same set of \n\ninstructions until a termination condition is met. As you will see, Java has a loop to fit any \nprogramming need. \n\n\nwhile \n\nThe while loop is Java\u2019s most fundamental loop statement. It repeats a statement or block \nwhile its controlling expression is true. Here is its general form: \n\nThe condition can be any Boolean expression. The body of the loop will be executed as long \nas the conditional expression is true. When condition becomes false, control passes to the \nnext line of code immediately following the loop. The curly braces are unnecessary if only a \nsingle statement is being repeated. \nHere is a while loop that counts down from 10, printing exactly ten lines of \"tick\":",
    "When you run this program, it will \u201ctick\u201d ten times: \n\nSince the while loop evaluates its conditional expression at the top of the loop, the body of \nthe loop will not execute even once if the condition is false to begin with. For example, in the \nfollowing fragment, the call to println () is never executed: \n\n\nThe body of the while ( or any other of Java\u2019s loops ) can be empty. This is because a null \nstatement ( one that consists only of a semicolon ) is syntactically valid in Java. For example, \nconsider the following program: \n\nThis program finds the midpoint between i and j . It generates the following output:",
    "This program finds the midpoint between i and j . It generates the following output: \n\nHere is how this while loop works. The value of i is incremented, and the value of j is \ndecremented. These values are then compared with one another. If the new value of i is still \nless than the new value of j , then the loop repeats. If i is equal to or greater than j , the loop \nstops. Upon exit from the loop, i will hold a value that is midway between the original \nvalues of i and j . ( Of course, this procedure only works when i is less than j to begin with.) \nAs you can see, there is no need for a loop body ; all of the action occurs within the \nconditional expression, itself. In professionally written Java code, short loops are frequently \n\ncoded without bodies when the controlling expression can handle all of the details itself. \n\ndo-while",
    "coded without bodies when the controlling expression can handle all of the details itself. \n\ndo-while \n\nAs you just saw, if the conditional expression controlling a while loop is initially false, then \nthe body of the loop will not be executed at all. However, sometimes it is desirable to \nexecute the body of a loop at least once, even if the conditional expression is false to begin \n\nwith. In other words, there are times when you would like to test the termination expression \n\n\nat the end of the loop rather than at the beginning. Fortunately, Java supplies a loop that \ndoes just that: the do-while . The do-while loop always executes its body at least once, \nbecause its conditional expression is at the bottom of the loop. Its general form is",
    "Each iteration of the do-while loop first executes the body of the loop and then evaluates \nthe conditional expression. If this expression is true, the loop will repeat. Otherwise, the \nloop terminates. As with all of Java\u2019s loops, condition must be a Boolean expression. \nHere is a reworked version of the \u201ctick\u201d program that demonstrates the do-while loop. It \ngenerates the same output as before. \n\nThe loop in the preceding program, while technically correct, can be written more efficiently \nas follows: \n\nIn this example, the expression (\u2013 \u2013n > 0 ) combines the decrement of n and the test for \n\nzero into one expression. Here is how it works. First, the \u2013 \u2013n statement executes, \ndecrementing n and returning the new value of n . This value is then compared with zero. If",
    "zero into one expression. Here is how it works. First, the \u2013 \u2013n statement executes, \ndecrementing n and returning the new value of n . This value is then compared with zero. If \n\nit is greater than zero, the loop continues ; otherwise, it terminates. \nThe do-while loop is especially useful when you process a menu selection, because you will \nusually want the body of a menu loop to execute at least once. Consider the following \nprogram, which implements a very simple help system for Java\u2019s selection and iteration \n\n\nstatements: \n\nHere is a sample run produced by this program:",
    "statements: \n\nHere is a sample run produced by this program: \n\n\nIn the program, the do-while loop is used to verify that the user has entered a valid choice. \nIf not, then the user is reprompted. Since the menu must be displayed at least once, the dowhile is the perfect loop to accomplish this. \nA few other points about this example: Notice that characters are read from the keyboard by \ncalling System.in.read ( ) . This is one of Java\u2019s console input functions. Although Java\u2019s \nconsole I/O methods won\u2019t be discussed in detail until Chapter 13, System.in.read ( ) is \nused here to obtain the user\u2019s choice. It reads characters from standard input ( returned as \nintegers, which is why the return value was cast to char ). By default, standard input is line \nbuffered, so you must press ENTER before any characters that you type will be sent to your",
    "program. \nJava\u2019s console input can be a bit awkward to work with. Further, most real-world Java \nprograms will be graphical and window-based. For these reasons, not much use of console \ninput has been made in this book. However, it is useful in this context. One other point to \nconsider: Because System.in.read ( ) is being used, the program must specify the throws \njava.io.IOException clause. This line is necessary to handle input errors. It is part of \nJava\u2019s exception handling features, which are discussed in Chapter 10. \n\nfor \n\nYou were introduced to a simple form of the for loop in Chapter 2. As you will see, it is a \n\npowerful and versatile construct. \nBeginning with JDK 5, there are two forms of the for loop. The first is the traditional form \nthat has been in use since the original version of Java. The second is the newer \u201cfor-each\u201d",
    "form. Both types of for loops are discussed here, beginning with the traditional form. \nHere is the general form of the traditional for statement:",
    "If only one statement is being repeated, there is no need for the curly braces. \nThe for loop operates as follows. When the loop first starts, the initialization portion of the \nloop is executed. Generally, this is an expression that sets the value of the loop control \nvariable , which acts as a counter that controls the loop. It is important to understand that \nthe initialization expression is executed only once. Next, condition is evaluated. This must be \na Boolean expression. It usually tests the loop control variable against a target value. If this \nexpression is true, then the body of the loop is executed. If it is false, the loop terminates. \nNext, the iteration portion of the loop is executed. This is usually an expression that \nincrements or decrements the loop control variable. The loop then iterates, first evaluating \nthe conditional expression, then executing the body of the loop, and then executing the \niteration expression with each pass",
    ". The loop then iterates, first evaluating \nthe conditional expression, then executing the body of the loop, and then executing the \niteration expression with each pass. This process repeats until the controlling expression is \nfalse. \nHere is a version of the \u201ctick\u201d program that uses a for loop:",
    "Declaring Loop Control Variables Inside the for Loop \n\nOften the variable that controls a for loop is needed only for the purposes of the loop and is \nnot used elsewhere. When this is the case, it is possible to declare the variable inside the \ninitialization portion of the for . For example, here is the preceding program recoded so that \nthe loop control variable n is declared as an int inside the for : \n\nWhen you declare a variable inside a for loop, there is one important point to remember:",
    "When you declare a variable inside a for loop, there is one important point to remember: \n\n\nthe scope of that variable ends when the for statement does. ( That is, the scope of the \nvariable is limited to the for loop.) Outside the for loop, the variable will cease to exist. If \nyou need to use the loop control variable elsewhere in your program, you will not be able to \ndeclare it inside the for loop. \nWhen the loop control variable will not be needed elsewhere, most Java programmers \ndeclare it inside the for . For example, here is a simple program that tests for prime \nnumbers. Notice that the loop control variable, i , is declared inside the for since it is not \nneeded elsewhere. \n\nUsing the Comma \n\nThere will be times when you will want to include more than one statement in the \ninitialization and iteration portions of the for loop. For example, consider the loop in the \nfollowing program:",
    "There will be times when you will want to include more than one statement in the \ninitialization and iteration portions of the for loop. For example, consider the loop in the \nfollowing program: \n\n\nAs you can see, the loop is controlled by the interaction of two variables. Since the loop is \ngoverned by two variables, it would be useful if both could be included in the for statement, \nitself, instead of b being handled manually. Fortunately, Java provides a way to accomplish \nthis. To allow two or more variables to control a for loop, Java permits you to include \nmultiple statements in both the initialization and iteration portions of the for . Each \nstatement is separated from the next by a comma. \nUsing the comma, the preceding for loop can be more efficiently coded, as shown here:",
    "In this example, the initialization portion sets the values of both a and b . The two commaseparated statements in the iteration portion are executed each time the loop repeats. The \nprogram generates the following output: \n\n\nNOTE    If you are familiar with C/C++, then you know that in those \nlanguages the comma is an operator that can be used in any valid \nexpression. However, this is not the case with Java. In Java, the comma is \na separator.",
    "Some for Loop Variations \nThe for loop supports a number of variations that increase its power and applicability. The \nreason it is so flexible is that its three parts\u2014the initialization, the conditional test, and the \niteration\u2014do not need to be used for only those purposes. In fact, the three sections of the \nfor can be used for any purpose you desire. Let\u2019s look at some examples. \nOne of the most common variations involves the conditional expression. Specifically, this \nexpression does not need to test the loop control variable against some target value. In fact, \nthe condition controlling the for can be any Boolean expression. For example, consider the \nfollowing fragment: \n\nIn this example, the for loop continues to run until the boolean variable done is set to \ntrue . It does not test the value of i . \nHere is another interesting for loop variation. Either the initialization or the iteration \nexpression or both may be absent, as in this next program:",
    "Here, the initialization and iteration expressions have been moved out of the for . Thus, \nparts of the for are empty. While this is of no value in this simple example\u2014indeed, it \nwould be considered quite poor style\u2014there can be times when this type of approach makes \nsense. For example, if the initial condition is set through a complex expression elsewhere in \nthe program or if the loop control variable changes in a nonsequential manner determined \nby actions that occur within the body of the loop, it may be appropriate to leave these parts \nof the for empty. \nHere is one more for loop variation. You can intentionally create an infinite loop ( a loop \nthat never terminates ) if you leave all three parts of the for empty. For example:",
    "This loop will run forever because there is no condition under which it will terminate. \nAlthough there are some programs, such as operating system command processors, that \nrequire an infinite loop, most \u201cinfinite loops\u201d are really just loops with special termination \nrequirements. As you will soon see, there is a way to terminate a loop\u2014even an infinite loop \nlike the one shown\u2014that does not make use of the normal loop conditional expression. \n\nThe For-Each Version of the for Loop",
    "The For-Each Version of the for Loop \n\nBeginning with JDK 5, a second form of for was defined that implements a \u201cfor-each\u201d style \nloop. As you may know, contemporary language theory has embraced the for-each concept, \nand it has become a standard feature that programmers have come to expect. A for-each \nstyle loop is designed to cycle through a collection of objects, such as an array, in strictly \nsequential fashion, from start to finish. Unlike some languages, such as C#, that implement \na for-each loop by using the keyword foreach , Java adds the for-each capability by \n\n\nenhancing the for statement. The advantage of this approach is that no new keyword is \nrequired, and no preexisting code is broken. The for-each style of for is also referred to as \nthe enhanced for loop. \nThe general form of the for-each version of the for is shown here: \n\nfor ( type itr-var : collection ) statement-block",
    "Here, type specifies the type and itr-var specifies the name of an iteration \nvariable that will receive the elements from a collection, one at a time, from \nbeginning to end. The collection being cycled through is specified by collection . \nThere are various types of collections that can be used with the for , but the only \ntype used in this chapter is the array. ( Other types of collections that can be used \nwith the for , such as those defined by the Collections Framework, are discussed \nlater in this book.) With each iteration of the loop, the next element in the \ncollection is retrieved and stored in itr-var . The loop repeats until all elements in \nthe collection have been obtained. \nBecause the iteration variable receives values from the collection, type must be the same as \n( or compatible with ) the elements stored in the collection. Thus, when iterating over arrays, \ntype must be compatible with the element type of the array",
    ". Thus, when iterating over arrays, \ntype must be compatible with the element type of the array. \nTo understand the motivation behind a for-each style loop, consider the type of for loop \nthat it is designed to replace. The following fragment uses a traditional for loop to compute \nthe sum of the values in an array:",
    "To compute the sum, each element in nums is read, in order, from start to finish. Thus, the \nentire array is read in strictly sequential order. This is accomplished by manually indexing \nthe nums array by i , the loop control variable. \nThe for-each style for automates the preceding loop. Specifically, it eliminates the need to \nestablish a loop counter, specify a starting and ending value, and manually index the array. \nInstead, it automatically cycles through the entire array, obtaining one element at a time, in \nsequence, from beginning to end. For example, here is the preceding fragment rewritten \nusing a for-each version of the for :",
    "With each pass through the loop, x is automatically given a value equal to the next element \nin nums . Thus, on the first iteration, x contains 1 ; on the second iteration, x contains 2 ; \nand so on. Not only is the syntax streamlined, but it also prevents boundary errors. \nHere is an entire program that demonstrates the for-each version of the for just described: \n\nThe output from the program is shown here: \n\nAs this output shows, the for-each style for automatically cycles through an array in \nsequence from the lowest index to the highest. \nAlthough the for-each for loop iterates until all elements in an array have been examined, it \nis possible to terminate the loop early by using a break statement. For example, this \n\nprogram sums only the first five elements of nums : \n\n\nThis is the output produced:",
    "program sums only the first five elements of nums : \n\n\nThis is the output produced: \n\nAs is evident, the for loop stops after the fifth element has been obtained. The break \nstatement can also be used with Java\u2019s other loops, and it is discussed in detail later in this \nchapter. \nThere is one important point to understand about the for-each style loop. Its iteration \nvariable is \u201cread-only\u201d as it relates to the underlying array. An assignment to the iteration \nvariable has no effect on the underlying array. In other words, you can\u2019t change the contents \nof the array by assigning the iteration variable a new value. For example, consider this \nprogram: \n\n\nThe first for loop increases the value of the iteration variable by a factor of 10. However, \nthis assignment has no effect on the underlying array nums , as the second for loop \nillustrates. The output, shown here, proves this point:",
    "Iterating Over Multidimensional Arrays \nThe enhanced version of the for also works on multidimensional arrays. Remember, \nhowever, that in Java, multidimensional arrays consist of arrays of arrays . ( For example, a \ntwo-dimensional array is an array of one-dimensional arrays.) This is important when \niterating over a multidimensional array, because each iteration obtains the next array , not \nan individual element. Furthermore, the iteration variable in the for loop must be \ncompatible with the type of array being obtained. For example, in the case of a twodimensional array, the iteration variable must be a reference to a one-dimensional array. In \ngeneral, when using the for-each for to iterate over an array of N dimensions, the objects \nobtained will be arrays of N \u20131 dimensions. To understand the implications of this, consider \n\nthe following program. It uses nested for loops to obtain the elements of a two-dimensional \narray in row-order, from first to last.",
    "the following program. It uses nested for loops to obtain the elements of a two-dimensional \narray in row-order, from first to last. \n\n\nThe output from this program is shown here: \n\nIn the program, pay special attention to this line: \n\n\nNotice how x is declared. It is a reference to a one-dimensional array of integers. This is \n\nnecessary because each iteration of the for obtains the next array in nums , beginning with \nthe array specified by nums[0] . The inner for loop then cycles through each of these \narrays, displaying the values of each element. \n\nApplying the Enhanced for \nSince the for-each style for can only cycle through an array sequentially, from start to \nfinish, you might think that its use is limited, but this is not true. A large number of \nalgorithms require exactly this mechanism. One of the most common is searching. For \nexample, the following program uses a for loop to search an unsorted array for a value. It \nstops if the value is found.",
    "The for-each style for is an excellent choice in this application because searching an \nunsorted array involves examining each element in sequence. ( Of course, if the array were \nsorted, a binary search could be used, which would require a different style loop.) Other \ntypes of applications that benefit from for-each style loops include computing an average, \n\nfinding the minimum or maximum of a set, looking for duplicates, and so on. \nAlthough we have been using arrays in the examples in this chapter, the for-each style for is \nespecially useful when operating on collections defined by the Collections Framework, which \nis described in Part II. More generally, the for can cycle through the elements of any \ncollection of objects, as long as that collection satisfies a certain set of constraints, which are \n\ndescribed in Chapter 18. \n\nNested Loops",
    "described in Chapter 18. \n\nNested Loops \n\n\nLike all other programming languages, Java allows loops to be nested. That is, one loop may \nbe inside another. For example, here is a program that nests for loops: \n\nThe output produced by this program is shown here: \n\nJump Statements \n\nJava supports three jump statements: break , continue , and return . These statements \ntransfer control to another part of your program. Each is examined here. \n\nNOTE    In addition to the jump statements discussed here, Java supports \none other way that you can change your program\u2019s flow of execution: \n\nthrough exception handling. Exception handling provides a structured \nmethod by which run-time errors can be trapped and handled by your \nprogram. It is supported by the keywords try , catch , throw , throws , \nand finally . In essence, the exception handling mechanism allows your \nprogram to perform a nonlocal branch. Since exception handling is a",
    "large topic, it is discussed in its own chapter, Chapter 10. \n\nUsing break \n\nIn Java, the break statement has three uses. First, as you have seen, it terminates a \nstatement sequence in a switch statement. Second, it can be used to exit a loop. Third, it \ncan be used as a \u201ccivilized\u201d form of goto. The last two uses are explained here. \n\nUsing break to Exit a Loop \nBy using break , you can force immediate termination of a loop, bypassing the conditional \nexpression and any remaining code in the body of the loop. When a break statement is \nencountered inside a loop, the loop is terminated and program control resumes at the next \nstatement following the loop. Here is a simple example: \n\nThis program generates the following output:",
    "This program generates the following output: \n\nAs you can see, although the for loop is designed to run from 0 to 99, the break statement \ncauses it to terminate early, when i equals 10. \nThe break statement can be used with any of Java\u2019s loops, including intentionally infinite \nloops. For example, here is the preceding program coded by use of a while loop. The output \n\n\nfrom this program is the same as just shown. \n\nWhen used inside a set of nested loops, the break statement will only break out of the \ninnermost loop. For example: \n\nThis program generates the following output: \n\nAs you can see, the break statement in the inner loop only causes termination of that loop. \nThe outer loop is unaffected.",
    "This program generates the following output: \n\nAs you can see, the break statement in the inner loop only causes termination of that loop. \nThe outer loop is unaffected. \n\n\nHere are two other points to remember about break . First, more than one break \nstatement may appear in a loop. However, be careful. Too many break statements have the \ntendency to destructure your code. Second, the break that terminates a switch statement \naffects only that switch statement and not any enclosing loops. \n\nREMEMBER  break was not designed to provide the normal means by \nwhich a loop is terminated. The loop\u2019s conditional expression serves this \npurpose. The break statement should be used to cancel a loop only when \nsome sort of special situation occurs.",
    "Using break as a Form of Goto \nIn addition to its uses with the switch statement and loops, the break statement can also \nbe employed by itself to provide a \u201ccivilized\u201d form of the goto statement. Java does not have \na goto statement because it provides a way to branch in an arbitrary and unstructured \nmanner. This usually makes goto-ridden code hard to understand and hard to maintain. It \nalso prohibits certain compiler optimizations. There are, however, a few places where the \ngoto is a valuable and legitimate construct for flow control. For example, the goto can be \nuseful when you are exiting from a deeply nested set of loops. To handle such situations, \nJava defines an expanded form of the break statement. By using this form of break , you \ncan, for example, break out of one or more blocks of code. These blocks need not be part of \na loop or a switch . They can be any block",
    ". By using this form of break , you \ncan, for example, break out of one or more blocks of code. These blocks need not be part of \na loop or a switch . They can be any block. Further, you can specify precisely where \nexecution will resume, because this form of break works with a label. As you will see, \nbreak gives you the benefits of a goto without its problems. \nThe general form of the labeled break statement is shown here:",
    "break label ; \n\nMost often, label is the name of a label that identifies a block of code. This can be a \nstandalone block of code but it can also be a block that is the target of another \nstatement. When this form of break executes, control is transferred out of the \nnamed block. The labeled block must enclose the break statement, but it does not \nneed to be the immediately enclosing block. This means, for example, that you can \n\nuse a labeled break statement to exit from a set of nested blocks. But you cannot \n\nuse break to transfer control out of a block that does not enclose the break \nstatement. \nTo name a block, put a label at the start of it. A label is any valid Java identifier followed by \na colon. Once you have labeled a block, you can then use this label as the target of a break \nstatement. Doing so causes execution to resume at the end of the labeled block. For \n\n\nexample, the following program shows three nested blocks, each with its own label. The",
    "example, the following program shows three nested blocks, each with its own label. The \n\nbreak statement causes execution to jump forward, past the end of the block labeled \nsecond , skipping the two println ( ) statements. \n\nRunning this program generates the following output: \n\nOne of the most common uses for a labeled break statement is to exit from nested loops. \n\nFor example, in the following program, the outer loop executes only once: \n\n\nThis program generates the following output: \n\nAs you can see, when the inner loop breaks to the outer loop, both loops have been \nterminated. Notice that this example labels the for statement, which has a block of code as \nits target. \nKeep in mind that you cannot break to any label which is not defined for an enclosing block. \nFor example, the following program is invalid and will not compile: \n\nSince the loop labeled one does not enclose the break statement, it is not possible to \n\ntransfer control out of that block.",
    "Since the loop labeled one does not enclose the break statement, it is not possible to \n\ntransfer control out of that block. \n\nUsing continue \n\nSometimes it is useful to force an early iteration of a loop. That is, you might want to \ncontinue running the loop but stop processing the remainder of the code in its body for this \nparticular iteration. This is, in effect, a goto just past the body of the loop, to the loop\u2019s end. \nThe continue statement performs such an action. In while and do-while loops, a \ncontinue statement causes control to be transferred directly to the conditional expression \nthat controls the loop. In a for loop, control goes first to the iteration portion of the for \nstatement and then to the conditional expression. For all three loops, any intermediate code \nis bypassed. \nHere is an example program that uses continue to cause two numbers to be printed on \n\neach line:",
    "each line: \n\n\nThis code uses the % operator to check if i is even. If it is, the loop continues without \nprinting a newline. Here is the output from this program: \n\nAs with the break statement, continue may specify a label to describe which enclosing \nloop to continue. Here is an example program that uses continue to print a triangular \nmultiplication table for 0 through 9: \n\nThe continue statement in this example terminates the loop counting j and continues with \nthe next iteration of the loop counting i . Here is the output of this program: \n\n\nGood uses of continue are rare. One reason is that Java provides a rich set of loop \nstatements which fit most applications. However, for those special circumstances in which \nearly iteration is needed, the continue statement provides a structured way to accomplish \nit.",
    "return \nThe last control statement is return . The return statement is used to explicitly return \nfrom a method. That is, it causes program control to transfer back to the caller of the \nmethod. As such, it is categorized as a jump statement. Although a full discussion of return \nmust wait until methods are discussed in Chapter 6, a brief look at return is presented \nhere. \nAt any time in a method, the return statement can be used to cause execution to branch \nback to the caller of the method. Thus, the return statement immediately terminates the \nmethod in which it is executed. The following example illustrates this point. Here, return \ncauses execution to return to the Java run-time system, since it is the run-time system that \ncalls main ( ) : \n\nThe output from this program is shown here:",
    "The output from this program is shown here: \n\n\nAs you can see, the final println ( ) statement is not executed. As soon as return is \nexecuted, control passes back to the caller. \nOne last point: In the preceding program, the if ( t ) statement is necessary. Without it, the \nJava compiler would flag an \u201cunreachable code\u201d error because the compiler would know \nthat the last println ( ) statement would never be executed. To prevent this error, the if \nstatement is used here to trick the compiler for the sake of this demonstration. \n\n\uf709 \nPREV \nChapter 4: Operators \n\u23ee \n\nNEXT \nChapter 6: Introducing Classes \n\u23ed \n\n\nPREV \nChapter 5: Control Statements \n\u23ee \n\nNEXT \nChapter 7: A Closer Look at Methods and Classes \n\u23ed \n\nCHAPTER \n\n6 \nIntroducing Classes",
    "NEXT \nChapter 6: Introducing Classes \n\u23ed \n\n\nPREV \nChapter 5: Control Statements \n\u23ee \n\nNEXT \nChapter 7: A Closer Look at Methods and Classes \n\u23ed \n\nCHAPTER \n\n6 \nIntroducing Classes \n\nThe class is at the core of Java. It is the logical construct upon which the entire Java \nlanguage is built because it defines the shape and nature of an object. As such, the class \nforms the basis for object-oriented programming in Java. Any concept you wish to \nimplement in a Java program must be encapsulated within a class. \nBecause the class is so fundamental to Java, this and the next few chapters will be devoted \nto it. Here, you will be introduced to the basic elements of a class and learn how a class can \nbe used to create objects. You will also learn about methods, constructors, and the this \nkeyword. \n\nClass Fundamentals",
    "Class Fundamentals \n\nClasses have been used since the beginning of this book. However, until now, only the most \nrudimentary form of a class has been shown. The classes created in the preceding chapters \nprimarily exist simply to encapsulate the main ( ) method, which has been used to \ndemonstrate the basics of the Java syntax. As you will see, classes are substantially more \npowerful than the limited ones presented so far. \nPerhaps the most important thing to understand about a class is that it defines a new data \ntype. Once defined, this new type can be used to create objects of that type. Thus, a class is a \ntemplate for an object, and an object is an instance of a class. Because an object is an \ninstance of a class, you will often see the two words object and instance used \ninterchangeably. \n\nThe General Form of a Class",
    "The General Form of a Class \n\nWhen you define a class, you declare its exact form and nature. You do this by specifying the \ndata that it contains and the code that operates on that data. While very simple classes may \ncontain only code or only data, most real-world classes contain both. As you will see, a class\u2019 \ncode defines the interface to its data. \nA class is declared by use of the class keyword. The classes that have been used up to this \n\npoint are actually very limited examples of its complete form. Classes can ( and usually do ) \nget much more complex. A simplified general form of a class definition is shown here:",
    "The data, or variables, defined within a class are called instance variables . The code is \ncontained within methods . Collectively, the methods and variables defined within a class are \ncalled members of the class. In most classes, the instance variables are acted upon and \naccessed by the methods defined for that class. Thus, as a general rule, it is the methods \nthat determine how a class\u2019 data can be used. \nVariables defined within a class are called instance variables because each instance of the",
    "class ( that is, each object of the class ) contains its own copy of these variables. Thus, the \ndata for one object is separate and unique from the data for another. We will come back to \nthis point shortly, but it is an important concept to learn early. \nAll methods have the same general form as main ( ) , which we have been using thus far. \nHowever, most methods will not be specified as static or public . Notice that the general \nform of a class does not specify a main ( ) method. Java classes do not need to have a \nmain ( ) method. You only specify one if that class is the starting point for your program. \nFurther, some kinds of Java applications, such as applets, don\u2019t require a main ( ) method \nat all.",
    "A Simple Class \n\nLet\u2019s begin our study of the class with a simple example. Here is a class called Box that \ndefines three instance variables: width , height , and depth . Currently, Box does not \ncontain any methods ( but some will be added soon ). \n\n\nAs stated, a class defines a new type of data. In this case, the new data type is called Box . \nYou will use this name to declare objects of type Box . It is important to remember that a \nclass declaration only creates a template ; it does not create an actual object. Thus, the \npreceding code does not cause any objects of type Box to come into existence. \nTo actually create a Box object, you will use a statement like the following:",
    "After this statement executes, mybox will be an instance of Box . Thus, it will have \n\u201cphysical\u201d reality. For the moment, don\u2019t worry about the details of this statement. \nAs mentioned earlier, each time you create an instance of a class, you are creating an object \nthat contains its own copy of each instance variable defined by the class. Thus, every Box \nobject will contain its own copies of the instance variables width , height , and depth . To \naccess these variables, you will use the dot (.) operator. The dot operator links the name of \nthe object with the name of an instance variable. For example, to assign the width variable \nof mybox the value 100, you would use the following statement:",
    "This statement tells the compiler to assign the copy of width that is contained within the \nmybox object the value of 100. In general, you use the dot operator to access both the \ninstance variables and the methods within an object. One other point: Although commonly \nreferred to as the dot operator , the formal specification for Java categorizes the . as a \nseparator. However, since the use of the term \u201cdot operator\u201d is widespread, it is used in this \nbook. \nHere is a complete program that uses the Box class:",
    "You should call the file that contains this program BoxDemo.java , because the main ( ) \nmethod is in the class called BoxDemo , not the class called Box . When you compile this \nprogram, you will find that two .class files have been created, one for Box and one for \nBoxDemo . The Java compiler automatically puts each class into its own .class file. It is \nnot necessary for both the Box and the BoxDemo class to actually be in the same source \nfile. You could put each class in its own file, called Box.java and BoxDemo.java , \nrespectively. \nTo run this program, you must execute BoxDemo.class . When you do, you will see the \nfollowing output:",
    "As stated earlier, each object has its own copies of the instance variables. This means that if \nyou have two Box objects, each has its own copy of depth , width , and height . It is \nimportant to understand that changes to the instance variables of one object have no effect \non the instance variables of another. For example, the following program declares two Box \n\n\nobjects: \n\nThe output produced by this program is shown here: \n\nAs you can see, mybox1 \u2019s data is completely separate from the data contained in mybox2 . \n\nDeclaring Objects \n\nAs just explained, when you create a class, you are creating a new data type. You can use",
    "As just explained, when you create a class, you are creating a new data type. You can use \n\n\nthis type to declare objects of that type. However, obtaining objects of a class is a two-step \nprocess. First, you must declare a variable of the class type. This variable does not define an \nobject. Instead, it is simply a variable that can refer to an object. Second, you must acquire \nan actual, physical copy of the object and assign it to that variable. You can do this using the \nnew operator. The new operator dynamically allocates ( that is, allocates at run time ) \nmemory for an object and returns a reference to it. This reference is, more or less, the \naddress in memory of the object allocated by new . This reference is then stored in the \nvariable. Thus, in Java, all class objects must be dynamically allocated. Let\u2019s look at the \ndetails of this procedure. \nIn the preceding sample programs, a line similar to the following is used to declare an \nobject of type Box :",
    "This statement combines the two steps just described. It can be rewritten like this to show \neach step more clearly: \n\nThe first line declares mybox as a reference to an object of type Box . At this point, mybox \ndoes not yet refer to an actual object. The next line allocates an object and assigns a \nreference to it to mybox . After the second line executes, you can use mybox as if it were a \nBox object. But in reality, mybox simply holds, in essence, the memory address of the \nactual Box object. The effect of these two lines of code is depicted in Figure 6-1. \n\nFigure 6-1    Declaring an object of type Box",
    "Figure 6-1    Declaring an object of type Box \n\n\nNOTE    Those readers familiar with C/C++ have probably noticed that \nobject references appear to be similar to pointers. This suspicion is, \nessentially, correct. An object reference is similar to a memory pointer. \nThe main difference\u2014and the key to Java\u2019s safety\u2014is that you cannot \nmanipulate references as you can actual pointers. Thus, you cannot cause \nan object reference to point to an arbitrary memory location or \nmanipulate it like an integer. \n\nA Closer Look at new \n\nAs just explained, the new operator dynamically allocates memory for an object. It has this \ngeneral form: \n\nclass-var = new classname ( );",
    "Here, class-var is a variable of the class type being created. The classname is the \nname of the class that is being instantiated. The class name followed by \nparentheses specifies the constructor for the class. A constructor defines what \noccurs when an object of a class is created. Constructors are an important part of \nall classes and have many significant attributes. Most real-world classes explicitly \ndefine their own constructors within their class definition. However, if no explicit \nconstructor is specified, then Java will automatically supply a default constructor. \nThis is the case with Box . For now, we will use the default constructor. Soon, you \nwill see how to define your own constructors. \nAt this point, you might be wondering why you do not need to use new for such things as \nintegers or characters. The answer is that Java\u2019s primitive types are not implemented as \nobjects. Rather, they are implemented as \u201cnormal\u201d variables. This is done in the interest of \nefficiency",
    ". The answer is that Java\u2019s primitive types are not implemented as \nobjects. Rather, they are implemented as \u201cnormal\u201d variables. This is done in the interest of \nefficiency. As you will see, objects have many features and attributes that require Java to \ntreat them differently than it treats the primitive types. By not applying the same overhead \nto the primitive types that applies to objects, Java can implement the primitive types more \nefficiently. Later, you will see object versions of the primitive types that are available for \nyour use in those situations in which complete objects of these types are needed.",
    "It is important to understand that new allocates memory for an object during run time. The \nadvantage of this approach is that your program can create as many or as few objects as it \nneeds during the execution of your program. However, since memory is finite, it is possible \nthat new will not be able to allocate memory for an object because insufficient memory \nexists. If this happens, a run-time exception will occur. ( You will learn how to handle \nexceptions in Chapter 10.) For the sample programs in this book, you won\u2019t need to worry \nabout running out of memory, but you will need to consider this possibility in real-world",
    "programs that you write. \nLet\u2019s once again review the distinction between a class and an object. A class creates a new \ndata type that can be used to create objects. That is, a class creates a logical framework that \ndefines the relationship between its members. When you declare an object of a class, you \nare creating an instance of that class. Thus, a class is a logical construct. An object has \nphysical reality. ( That is, an object occupies space in memory.) It is important to keep this \ndistinction clearly in mind. \n\nAssigning Object Reference Variables \n\nObject reference variables act differently than you might expect when an assignment takes \nplace. For example, what do you think the following fragment does?",
    "Assigning Object Reference Variables \n\nObject reference variables act differently than you might expect when an assignment takes \nplace. For example, what do you think the following fragment does? \n\nYou might think that b2 is being assigned a reference to a copy of the object referred to by \nb1 . That is, you might think that b1 and b2 refer to separate and distinct objects. However, \nthis would be wrong. Instead, after this fragment executes, b1 and b2 will both refer to the \nsame object. The assignment of b1 to b2 did not allocate any memory or copy any part of \nthe original object. It simply makes b2 refer to the same object as does b1 . Thus, any \nchanges made to the object through b2 will affect the object to which b1 is referring, since \nthey are the same object. \nThis situation is depicted here: \n\nAlthough b1 and b2 both refer to the same object, they are not linked in any other way. For",
    "Although b1 and b2 both refer to the same object, they are not linked in any other way. For \n\nexample, a subsequent assignment to b1 will simply unhook b1 from the original object \nwithout affecting the object or affecting b2 . For example: \n\n\nHere, b1 has been set to null , but b2 still points to the original object. \n\nREMEMBER   When you assign one object reference variable to another \nobject reference variable, you are not creating a copy of the object, you are \nonly making a copy of the reference. \n\nIntroducing Methods \n\nAs mentioned at the beginning of this chapter, classes usually consist of two things: instance \nvariables and methods. The topic of methods is a large one because Java gives them so \nmuch power and flexibility. In fact, much of the next chapter is devoted to methods. \nHowever, there are some fundamentals that you need to learn now so that you can begin to \nadd methods to your classes. \nThis is the general form of a method:",
    "Here, type specifies the type of data returned by the method. This can be any valid type, \nincluding class types that you create. If the method does not return a value, its return type \nmust be void . The name of the method is specified by name . This can be any legal identifier \nother than those already used by other items within the current scope. The parameter-list is \na sequence of type and identifier pairs separated by commas. Parameters are essentially \nvariables that receive the value of the arguments passed to the method when it is called. If \nthe method has no parameters, then the parameter list will be empty. \nMethods that have a return type other than void return a value to the calling routine using \nthe following form of the return statement: \n\nreturn value ; \n\nHere, value is the value returned. \nIn the next few sections, you will see how to create various types of methods, including those \n\nthat take parameters and those that return values.",
    "Here, value is the value returned. \nIn the next few sections, you will see how to create various types of methods, including those \n\nthat take parameters and those that return values. \n\nAdding a Method to the Box Class \n\nAlthough it is perfectly fine to create a class that contains only data, it rarely happens. Most \nof the time, you will use methods to access the instance variables defined by the class. In \nfact, methods define the interface to most classes. This allows the class implementor to hide",
    "the specific layout of internal data structures behind cleaner method abstractions. In \naddition to defining methods that provide access to data, you can also define methods that \nare used internally by the class itself. \nLet\u2019s begin by adding a method to the Box class. It may have occurred to you while looking \nat the preceding programs that the computation of a box\u2019s volume was something that was \nbest handled by the Box class rather than the BoxDemo class. After all, since the volume \nof a box is dependent upon the size of the box, it makes sense to have the Box class \ncompute it. To do this, you must add a method to Box , as shown here: \n\n\nThis program generates the following output, which is the same as the previous version. \n\nLook closely at the following two lines of code:",
    "The first line here invokes the volume ( ) method on mybox1 . That is, it calls volume ( ) \nrelative to the mybox1 object, using the object\u2019s name followed by the dot operator. Thus, \nthe call to mybox1.volume ( ) displays the volume of the box defined by mybox1 , and the \ncall to mybox2.volume ( ) displays the volume of the box defined by mybox2 . Each time \nvolume ( ) is invoked, it displays the volume for the specified box. \nIf you are unfamiliar with the concept of calling a method, the following discussion will help \nclear things up. When mybox1.volume ( ) is executed, the Java run-time system transfers \ncontrol to the code defined inside volume ( ) . After the statements inside volume ( ) have \nexecuted, control is returned to the calling routine, and execution resumes with the line of \ncode following the call. In the most general sense, a method is Java\u2019s way of implementing \nsubroutines",
    ". In the most general sense, a method is Java\u2019s way of implementing \nsubroutines. \nThere is something very important to notice inside the volume ( ) method: the instance \nvariables width , height , and depth are referred to directly, without preceding them with \nan object name or the dot operator. When a method uses an instance variable that is \ndefined by its class, it does so directly, without explicit reference to an object and without \nuse of the dot operator. This is easy to understand if you think about it. A method is always \ninvoked relative to some object of its class. Once this invocation has occurred, the object is \nknown. Thus, within a method, there is no need to specify the object a second time. This \nmeans that width , height , and depth inside volume ( ) implicitly refer to the copies of \nthose variables found in the object that invokes volume ( )",
    ". This \nmeans that width , height , and depth inside volume ( ) implicitly refer to the copies of \nthose variables found in the object that invokes volume ( ) . \nLet\u2019s review: When an instance variable is accessed by code that is not part of the class in \nwhich that instance variable is defined, it must be done through an object, by use of the dot \noperator. However, when an instance variable is accessed by code that is part of the same",
    "class as the instance variable, that variable can be referred to directly. The same thing \napplies to methods.",
    "Returning a Value \n\nWhile the implementation of volume ( ) does move the computation of a box\u2019s volume \ninside the Box class where it belongs, it is not the best way to do it. For example, what if \nanother part of your program wanted to know the volume of a box, but not display its \nvalue? A better way to implement volume ( ) is to have it compute the volume of the box \nand return the result to the caller. The following example, an improved version of the \npreceding program, does just that: \n\n\nAs you can see, when volume ( ) is called, it is put on the right side of an assignment \nstatement. On the left is a variable, in this case vol , that will receive the value returned by \nvolume ( ) . Thus, after \n\n\nexecutes, the value of myboxl.volume ( ) is 3,000 and this value then is stored in vol . \nThere are two important things to understand about returning values:",
    "executes, the value of myboxl.volume ( ) is 3,000 and this value then is stored in vol . \nThere are two important things to understand about returning values: \n\n\u2022  The type of data returned by a method must be compatible with the return \ntype specified by the method. For example, if the return type of some \nmethod is boolean , you could not return an integer. \n\n\u2022  The variable receiving the value returned by a method ( such as vol , in this \ncase ) must also be compatible with the return type specified for the method. \n\nOne more point: The preceding program can be written a bit more efficiently \nbecause there is actually no need for the vol variable. The call to volume ( ) could \nhave been used in the println ( ) statement directly, as shown here: \n\nIn this case, when println ( ) is executed, mybox1.volume ( ) will be called automatically \nand its value will be passed to println ( ) . \n\nAdding a Method That Takes Parameters",
    "In this case, when println ( ) is executed, mybox1.volume ( ) will be called automatically \nand its value will be passed to println ( ) . \n\nAdding a Method That Takes Parameters \n\nWhile some methods don\u2019t need parameters, most do. Parameters allow a method to be \ngeneralized. That is, a parameterized method can operate on a variety of data and/or be \nused in a number of slightly different situations. To illustrate this point, let\u2019s use a very \nsimple example. Here is a method that returns the square of the number 10: \n\nWhile this method does, indeed, return the value of 10 squared, its use is very limited. \nHowever, if you modify the method so that it takes a parameter, as shown next, then you \ncan make square ( ) much more useful. \n\nNow, square ( ) will return the square of whatever value it is called with. That is, square ( ) \n\nis now a general-purpose method that can compute the square of any integer value, rather \nthan just 10. \nHere is an example:",
    "In the first call to square ( ) , the value 5 will be passed into parameter i . In the second call, \ni will receive the value 9. The third invocation passes the value of y , which is 2 in this \nexample. As these examples show, square ( ) is able to return the square of whatever data it \nis passed. \nIt is important to keep the two terms parameter and argument straight. A parameter is a \nvariable defined by a method that receives a value when the method is called. For example, \nin square ( ) , i is a parameter. An argument is a value that is passed to a method when it is \ninvoked. For example, square ( 100 ) passes 100 as an argument. Inside square ( ) , the \nparameter i receives that value. \nYou can use a parameterized method to improve the Box class. In the preceding examples, \nthe dimensions of each box had to be set separately by use of a sequence of statements, such \nas:",
    "While this code works, it is troubling for two reasons. First, it is clumsy and error prone. For \nexample, it would be easy to forget to set a dimension. Second, in well-designed Java \nprograms, instance variables should be accessed only through methods defined by their \nclass. In the future, you can change the behavior of a method, but you can\u2019t change the \nbehavior of an exposed instance variable. \nThus, a better approach to setting the dimensions of a box is to create a method that takes \nthe dimensions of a box in its parameters and sets each instance variable appropriately. This \nconcept is implemented by the following program: \n\n\nAs you can see, the setDim ( ) method is used to set the dimensions of each box. For \nexample, when \n\nis executed, 10 is copied into parameter w , 20 is copied into h , and 15 is copied into d .",
    "is executed, 10 is copied into parameter w , 20 is copied into h , and 15 is copied into d . \n\n\nInside setDim ( ) the values of w , h , and d are then assigned to width , height , and \ndepth , respectively. \nFor many readers, the concepts presented in the preceding sections will be familiar. \nHowever, if such things as method calls, arguments, and parameters are new to you, then \nyou might want to take some time to experiment before moving on. The concepts of the \nmethod invocation, parameters, and return values are fundamental to Java programming. \n\nConstructors",
    "It can be tedious to initialize all of the variables in a class each time an instance is created. \nEven when you add convenience functions like setDim ( ) , it would be simpler and more \nconcise to have all of the setup done at the time the object is first created. Because the \nrequirement for initialization is so common, Java allows objects to initialize themselves \nwhen they are created. This automatic initialization is performed through the use of a \nconstructor. \nA constructor initializes an object immediately upon creation. It has the same name as the",
    "class in which it resides and is syntactically similar to a method. Once defined, the \nconstructor is automatically called when the object is created, before the new operator \ncompletes. Constructors look a little strange because they have no return type, not even \nvoid . This is because the implicit return type of a class\u2019 constructor is the class type itself. It \nis the constructor\u2019s job to initialize the internal state of an object so that the code creating \nan instance will have a fully initialized, usable object immediately. \nYou can rework the Box example so that the dimensions of a box are automatically \ninitialized when an object is constructed. To do so, replace setDim ( ) with a constructor. \nLet\u2019s begin by defining a simple constructor that simply sets the dimensions of each box to \nthe same values. This version is shown here:",
    "When this program is run, it generates the following results: \n\n\nAs you can see, both mybox1 and mybox2 were initialized by the Box ( ) constructor when \nthey were created. Since the constructor gives all boxes the same dimensions, 10 by 10 by \n10, both mybox1 and mybox2 will have the same volume. The println ( ) statement inside \nBox ( ) is for the sake of illustration only. Most constructors will not display anything. They \nwill simply initialize an object. \nBefore moving on, let\u2019s reexamine the new operator. As you know, when you allocate an \nobject, you use the following general form: \n\nclass-var = new classname ( ); \n\nNow you can understand why the parentheses are needed after the class name. \nWhat is actually happening is that the constructor for the class is being called. \nThus, in the line",
    "Now you can understand why the parentheses are needed after the class name. \nWhat is actually happening is that the constructor for the class is being called. \nThus, in the line \n\nnew Box ( ) is calling the Box ( ) constructor. When you do not explicitly define a \nconstructor for a class, then Java creates a default constructor for the class. This is why the \npreceding line of code worked in earlier versions of Box that did not define a constructor. \nThe default constructor automatically initializes all instance variables to their default values, \nwhich are zero, null , and false , for numeric types, reference types, and boolean , \nrespectively. The default constructor is often sufficient for simple classes, but it usually \nwon\u2019t do for more sophisticated ones. Once you define your own constructor, the default \nconstructor is no longer used. \n\nParameterized Constructors",
    "Parameterized Constructors \n\nWhile the Box ( ) constructor in the preceding example does initialize a Box object, it is not \nvery useful\u2014all boxes have the same dimensions. What is needed is a way to construct Box \nobjects of various dimensions. The easy solution is to add parameters to the constructor. As \nyou can probably guess, this makes it much more useful. For example, the following version \nof Box defines a parameterized constructor that sets the dimensions of a box as specified by \nthose parameters. Pay special attention to how Box objects are created. \n\n\nThe output from this program is shown here: \n\nAs you can see, each object is initialized as specified in the parameters to its constructor. For \nexample, in the following line, \n\n\nthe values 10, 20, and 15 are passed to the Box ( ) constructor when new creates the object. \nThus, mybox1 \u2019s copy of width , height , and depth will contain the values 10, 20, and 15, \nrespectively. \n\nThe this Keyword",
    "The this Keyword \n\nSometimes a method will need to refer to the object that invoked it. To allow this, Java \ndefines the this keyword. this can be used inside any method to refer to the current object. \nThat is, this is always a reference to the object on which the method was invoked. You can \nuse this anywhere a reference to an object of the current class\u2019 type is permitted. \nTo better understand what this refers to, consider the following version of Box ( ) : \n\nThis version of Box ( ) operates exactly like the earlier version. The use of this is redundant, \nbut perfectly correct. Inside Box ( ) , this will always refer to the invoking object. While it is \nredundant in this case, this is useful in other contexts, one of which is explained in the next \nsection. \n\nInstance Variable Hiding",
    "Instance Variable Hiding \n\nAs you know, it is illegal in Java to declare two local variables with the same name inside \nthe same or enclosing scopes. Interestingly, you can have local variables, including formal \nparameters to methods, which overlap with the names of the class\u2019 instance variables. \nHowever, when a local variable has the same name as an instance variable, the local variable \nhides the instance variable. This is why width , height , and depth were not used as the \nnames of the parameters to the Box ( ) constructor inside the Box class. If they had been, \nthen width, for example, would have referred to the formal parameter, hiding the instance \nvariable width . While it is usually easier to simply use different names, there is another \nway around this situation. Because this lets you refer directly to the object, you can use it to",
    "resolve any namespace collisions that might occur between instance variables and local \nvariables. For example, here is another version of Box ( ) , which uses width , height , and \ndepth for parameter names and then uses this to access the instance variables by the same \nname: \n\n\nA word of caution: The use of this in such a context can sometimes be confusing, and some \nprogrammers are careful not to use local variables and formal parameter names that hide \ninstance variables. Of course, other programmers believe the contrary\u2014that it is a good \nconvention to use the same names for clarity, and use this to overcome the instance \nvariable hiding. It is a matter of taste which approach you adopt. \n\nGarbage Collection",
    "Since objects are dynamically allocated by using the new operator, you might be wondering \nhow such objects are destroyed and their memory released for later reallocation. In some \nlanguages, such as C++, dynamically allocated objects must be manually released by use of a \ndelete operator. Java takes a different approach ; it handles deallocation for you \nautomatically. The technique that accomplishes this is called garbage collection . It works \nlike this: when no references to an object exist, that object is assumed to be no longer \nneeded, and the memory occupied by the object can be reclaimed. There is no explicit need \nto destroy objects as in C++. Garbage collection only occurs sporadically ( if at all ) during \nthe execution of your program. It will not occur simply because one or more objects exist \nthat are no longer used",
    ". Garbage collection only occurs sporadically ( if at all ) during \nthe execution of your program. It will not occur simply because one or more objects exist \nthat are no longer used. Furthermore, different Java run-time implementations will take \nvarying approaches to garbage collection, but for the most part, you should not have to \nthink about it while writing your programs.",
    "The finalize ( ) Method \n\nSometimes an object will need to perform some action when it is destroyed. For example, if \nan object is holding some non-Java resource such as a file handle or character font, then \nyou might want to make sure these resources are freed before an object is destroyed. To \nhandle such situations, Java provides a mechanism called finalization . By using finalization, \nyou can define specific actions that will occur when an object is just about to be reclaimed by \nthe garbage collector. \nTo add a finalizer to a class, you simply define the finalize ( ) method. The Java run time \ncalls that method whenever it is about to recycle an object of that class. Inside the finalize ( \n) method, you will specify those actions that must be performed before an object is",
    "destroyed. The garbage collector runs periodically, checking for objects that are no longer \nreferenced by any running state or indirectly through other referenced objects. Right before \nan asset is freed, the Java run time calls the finalize ( ) method on the object. \nThe finalize ( ) method has this general form: \n\n\nHere, the keyword protected is a specifier that limits access to finalize ( ) . This and the \nother access modifiers are explained in Chapter 7. \nIt is important to understand that finalize ( ) is only called just prior to garbage collection. \nIt is not called when an object goes out-of-scope, for example. This means that you cannot \nknow when\u2014or even if\u2014 finalize ( ) will be executed. Therefore, your program should \nprovide other means of releasing system resources, etc., used by the object. It must not rely \non finalize ( ) for normal program operation.",
    "NOTE    If you are familiar with C++, then you know that C++ allows you \nto define a destructor for a class, which is called when an object goes outof-scope. Java does not support this idea or provide for destructors. The \nfinalize ( ) method only approximates the function of a destructor. As \nyou get more experienced with Java, you will see that the need for \ndestructor functions is minimal because of Java\u2019s garbage collection \nsubsystem. \n\nA Stack Class \n\nWhile the Box class is useful to illustrate the essential elements of a class, it is of little",
    "A Stack Class \n\nWhile the Box class is useful to illustrate the essential elements of a class, it is of little \n\npractical value. To show the real power of classes, this chapter will conclude with a more \nsophisticated example. As you recall from the discussion of object-oriented programming \n( OOP ) presented in Chapter 2, one of OOP\u2019s most important benefits is the encapsulation of \ndata and the code that manipulates that data. As you have seen, the class is the mechanism \nby which encapsulation is achieved in Java. By creating a class, you are creating a new data \ntype that defines both the nature of the data being manipulated and the routines used to \nmanipulate it. Further, the methods define a consistent and controlled interface to the class\u2019 \ndata. Thus, you can use the class through its methods without having to worry about the \ndetails of its implementation or how the data is actually managed within the class. In a",
    "sense, a class is like a \u201cdata engine.\u201d No knowledge of what goes on inside the engine is \nrequired to use the engine through its controls. In fact, since the details are hidden, its inner \nworkings can be changed as needed. As long as your code uses the class through its",
    "methods, internal details can change without causing side effects outside the class. \nTo see a practical application of the preceding discussion, let\u2019s develop one of the archetypal \nexamples of encapsulation: the stack. A stack stores data using first-in, last-out ordering. \nThat is, a stack is like a stack of plates on a table\u2014the first plate put down on the table is the \nlast plate to be used. Stacks are controlled through two operations traditionally called push \nand pop . To put an item on top of the stack, you will use push. To take an item off the stack, \nyou will use pop. As you will see, it is easy to encapsulate the entire stack mechanism. \nHere is a class called Stack that implements a stack for up to ten integers:",
    "As you can see, the Stack class defines two data items and three methods. The stack of \nintegers is held by the array stck . This array is indexed by the variable tos , which always \ncontains the index of the top of the stack. The Stack ( ) constructor initializes tos to \u20131, \nwhich indicates an empty stack. The method push ( ) puts an item on the stack. To retrieve \nan item, call pop ( ) . Since access to the stack is through push ( ) and pop ( ) , the fact that \nthe stack is held in an array is actually not relevant to using the stack. For example, the \n\nstack could be held in a more complicated data structure, such as a linked list, yet the \ninterface defined by push ( ) and pop ( ) would remain the same. \n\n\nThe class TestStack , shown here, demonstrates the Stack class. It creates two integer \nstacks, pushes some values onto each, and then pops them off. \n\nThis program generates the following output:",
    "This program generates the following output: \n\n\nAs you can see, the contents of each stack are separate. \nOne last point about the Stack class. As it is currently implemented, it is possible for the \narray that holds the stack, stck , to be altered by code outside of the Stack class. This leaves \nStack open to misuse or mischief. In the next chapter, you will see how to remedy this \nsituation. \n\n\uf709 \nPREV \nChapter 5: Control Statements \n\u23ee \n\nNEXT \nChapter 7: A Closer Look at Methods and Classes \n\u23ed \n\n\nPREV \nChapter 6: Introducing Classes \n\u23ee \n\nNEXT \nChapter 8: Inheritance \u23ed \n\nCHAPTER \n\n7 \nA Closer Look at Methods and Classes",
    "NEXT \nChapter 7: A Closer Look at Methods and Classes \n\u23ed \n\n\nPREV \nChapter 6: Introducing Classes \n\u23ee \n\nNEXT \nChapter 8: Inheritance \u23ed \n\nCHAPTER \n\n7 \nA Closer Look at Methods and Classes \n\nThis chapter continues the discussion of methods and classes begun in the preceding \nchapter. It examines several topics relating to methods, including overloading, parameter \npassing, and recursion. The chapter then returns to the class, discussing access control, the \nuse of the keyword static , and one of Java\u2019s most important built-in classes: String . \n\nOverloading Methods",
    "In Java, it is possible to define two or more methods within the same class that share the \nsame name, as long as their parameter declarations are different. When this is the case, the \nmethods are said to be overloaded, and the process is referred to as method overloading . \nMethod overloading is one of the ways that Java supports polymorphism. If you have never \nused a language that allows the overloading of methods, then the concept may seem strange \nat first. But as you will see, method overloading is one of Java\u2019s most exciting and useful \nfeatures. \nWhen an overloaded method is invoked, Java uses the type and/or number of arguments as \nits guide to determine which version of the overloaded method to actually call. Thus, \noverloaded methods must differ in the type and/or number of their parameters. While \noverloaded methods may have different return types, the return type alone is insufficient to \ndistinguish two versions of a method",
    ". While \noverloaded methods may have different return types, the return type alone is insufficient to \ndistinguish two versions of a method. When Java encounters a call to an overloaded \nmethod, it simply executes the version of the method whose parameters match the \narguments used in the call. \nHere is a simple example that illustrates method overloading:",
    "This program generates the following output: \n\nAs you can see, test ( ) is overloaded four times. The first version takes no parameters, the \nsecond takes one integer parameter, the third takes two integer parameters, and the fourth \n\ntakes one double parameter. The fact that the fourth version of test ( ) also returns a value \nis of no consequence relative to overloading, since return types do not play a role in \n\n\noverload resolution. \nWhen an overloaded method is called, Java looks for a match between the arguments used \nto call the method and the method\u2019s parameters. However, this match need not always be \nexact. In some cases, Java\u2019s automatic type conversions can play a role in overload \nresolution. For example, consider the following program: \n\nThis program generates the following output: \n\nAs you can see, this version of OverloadDemo does not define test ( int ) . Therefore, when",
    "test ( ) is called with an integer argument inside Overload , no matching method is found. \nHowever, Java can automatically convert an integer into a double , and this conversion can \nbe used to resolve the call. Therefore, after test ( int ) is not found, Java elevates i to double \nand then calls test ( double ) . Of course, if test ( int ) had been defined, it would have been \ncalled instead. Java will employ its automatic type conversions only if no exact match is \nfound. \nMethod overloading supports polymorphism because it is one way that Java implements the \n\u201cone interface, multiple methods\u201d paradigm. To understand how, consider the following. In \nlanguages that do not support method overloading, each method must be given a unique \nname. However, frequently you will want to implement essentially the same method for \ndifferent types of data. Consider the absolute value function",
    ". However, frequently you will want to implement essentially the same method for \ndifferent types of data. Consider the absolute value function. In languages that do not \nsupport overloading, there are usually three or more versions of this function, each with a \nslightly different name. For instance, in C, the function abs ( ) returns the absolute value of \nan integer, labs ( ) returns the absolute value of a long integer, and fabs ( ) returns the \nabsolute value of a floating-point value. Since C does not support overloading, each function \nhas its own name, even though all three functions do essentially the same thing. This makes \nthe situation more complex, conceptually, than it actually is. Although the underlying \nconcept of each function is the same, you still have three names to remember. This situation \ndoes not occur in Java, because each absolute value method can use the same name. Indeed, \nJava\u2019s standard class library includes an absolute value method, called abs ( )",
    ". This situation \ndoes not occur in Java, because each absolute value method can use the same name. Indeed, \nJava\u2019s standard class library includes an absolute value method, called abs ( ) . This method \nis overloaded by Java\u2019s Math class to handle all numeric types. Java determines which \nversion of abs ( ) to call based upon the type of argument. \nThe value of overloading is that it allows related methods to be accessed by use of a \ncommon name. Thus, the name abs represents the general action that is being performed. \nIt is left to the compiler to choose the right specific version for a particular circumstance. \nYou, the programmer, need only remember the general operation being performed. Through \nthe application of polymorphism, several names have been reduced to one. Although this \nexample is fairly simple, if you expand the concept, you can see how overloading can help \nyou manage greater complexity",
    ". Although this \nexample is fairly simple, if you expand the concept, you can see how overloading can help \nyou manage greater complexity. \nWhen you overload a method, each version of that method can perform any activity you \ndesire. There is no rule stating that overloaded methods must relate to one another. \nHowever, from a stylistic point of view, method overloading implies a relationship. Thus, \nwhile you can use the same name to overload unrelated methods, you should not. For \nexample, you could use the name sqr to create methods that return the square of an integer \nand the square root of a floating-point value. But these two operations are fundamentally \ndifferent. Applying method overloading in this manner defeats its original purpose. In",
    "practice, you should only overload closely related operations. \n\nOverloading Constructors \n\nIn addition to overloading normal methods, you can also overload constructor methods. In \nfact, for most real-world classes that you create, overloaded constructors will be the norm, \n\n\nnot the exception. To understand why, let\u2019s return to the Box class developed in the \n\npreceding chapter. Following is the latest version of Box : \n\nAs you can see, the Box ( ) constructor requires three parameters. This means that all \ndeclarations of Box objects must pass three arguments to the Box ( ) constructor. For \nexample, the following statement is currently invalid:",
    "Since Box ( ) requires three arguments, it\u2019s an error to call it without them. This raises some \nimportant questions. What if you simply wanted a box and did not care ( or know ) what its \ninitial dimensions were? Or, what if you want to be able to initialize a cube by specifying \nonly one value that would be used for all three dimensions? As the Box class is currently \nwritten, these other options are not available to you. \nFortunately, the solution to these problems is quite easy: simply overload the Box \nconstructor so that it handles the situations just described. Here is a program that contains \nan improved version of Box that does just that: \n\n\nThe output produced by this program is shown here: \n\n\nAs you can see, the proper overloaded constructor is called based upon the parameters \nspecified when new is executed. \n\nUsing Objects as Parameters",
    "As you can see, the proper overloaded constructor is called based upon the parameters \nspecified when new is executed. \n\nUsing Objects as Parameters \n\nSo far, we have only been using simple types as parameters to methods. However, it is both \ncorrect and common to pass objects to methods. For example, consider the following short \nprogram: \n\nThis program generates the following output: \n\nAs you can see, the equalTo ( ) method inside Test compares two objects for equality and",
    "This program generates the following output: \n\nAs you can see, the equalTo ( ) method inside Test compares two objects for equality and \n\n\nreturns the result. That is, it compares the invoking object with the one that it is passed. If \nthey contain the same values, then the method returns true . Otherwise, it returns false . \nNotice that the parameter o in equalTo ( ) specifies Test as its type. Although Test is a \nclass type created by the program, it is used in just the same way as Java\u2019s built-in types. \nOne of the most common uses of object parameters involves constructors. Frequently, you \nwill want to construct a new object so that it is initially the same as some existing object. To \ndo this, you must define a constructor that takes an object of its class as a parameter. For \nexample, the following version of Box allows one object to initialize another:",
    "As you will see when you begin to create your own classes, providing many forms of \nconstructors is usually required to allow objects to be constructed in a convenient and \nefficient manner. \n\nA Closer Look at Argument Passing",
    "A Closer Look at Argument Passing \n\nIn general, there are two ways that a computer language can pass an argument to a \nsubroutine. The first way is call-by-value . This approach copies the value of an argument \ninto the formal parameter of the subroutine. Therefore, changes made to the parameter of \nthe subroutine have no effect on the argument. The second way an argument can be passed \nis call-by-reference . In this approach, a reference to an argument ( not the value of the \nargument ) is passed to the parameter. Inside the subroutine, this reference is used to access \nthe actual argument specified in the call. This means that changes made to the parameter \nwill affect the argument used to call the subroutine. As you will see, although Java uses callby-value to pass all arguments, the precise effect differs between whether a primitive type or \na reference type is passed.",
    "When you pass a primitive type to a method, it is passed by value. Thus, a copy of the \nargument is made, and what occurs to the parameter that receives the argument has no \neffect outside the method. For example, consider the following program: \n\n\nThe output from this program is shown here: \n\nAs you can see, the operations that occur inside meth ( ) have no effect on the values of a",
    "The output from this program is shown here: \n\nAs you can see, the operations that occur inside meth ( ) have no effect on the values of a \n\nand b used in the call ; their values here did not change to 30 and 10. \nWhen you pass an object to a method, the situation changes dramatically, because objects \nare passed by what is effectively call-by-reference. Keep in mind that when you create a \nvariable of a class type, you are only creating a reference to an object. Thus, when you pass \nthis reference to a method, the parameter that receives it will refer to the same object as that \nreferred to by the argument. This effectively means that objects act as if they are passed to \nmethods by use of call-by-reference. Changes to the object inside the method do affect the \nobject used as an argument. For example, consider the following program: \n\n\nThis program generates the following output:",
    "This program generates the following output: \n\nAs you can see, in this case, the actions inside meth ( ) have affected the object used as an \nargument. \n\nREMEMBER   When an object reference is passed to a method, the \nreference itself is passed by use of call-by-value. However, since the value \nbeing passed refers to an object, the copy of that value will still refer to \nthe same object that its corresponding argument does. \n\n\nReturning Objects \n\nA method can return any type of data, including class types that you create. For example, in \nthe following program, the incrByTen ( ) method returns an object in which the value of a \nis ten greater than it is in the invoking object. \n\nThe output generated by this program is shown here: \n\nAs you can see, each time incrByTen ( ) is invoked, a new object is created, and a reference \nto it is returned to the calling routine. \nThe preceding program makes another important point: Since all objects are dynamically",
    "allocated using new , you don\u2019t need to worry about an object going out-of-scope because \nthe method in which it was created terminates. The object will continue to exist as long as \nthere is a reference to it somewhere in your program. When there are no references to it, \nthe object will be reclaimed the next time garbage collection takes place. \n\nRecursion \n\nJava supports recursion . Recursion is the process of defining something in terms of itself. \nAs it relates to Java programming, recursion is the attribute that allows a method to call \nitself. A method that calls itself is said to be recursive . \nThe classic example of recursion is the computation of the factorial of a number. The \nfactorial of a number N is the product of all the whole numbers between 1 and N . For \nexample, 3 factorial is 1 \u00d7 2 \u00d7 3 \u00d7, or 6. Here is how a factorial can be computed by use of a \nrecursive method: \n\nThe output from this program is shown here:",
    "The output from this program is shown here: \n\nIf you are unfamiliar with recursive methods, then the operation of fact ( ) may seem a bit \n\nconfusing. Here is how it works. When fact ( ) is called with an argument of 1, the function",
    "returns 1 ; otherwise, it returns the product of fact ( n\u20131 )*n . To evaluate this expression, \nfact ( ) is called with n\u20131 . This process repeats until n equals 1 and the calls to the method \nbegin returning. \nTo better understand how the fact ( ) method works, let\u2019s go through a short example. \nWhen you compute the factorial of 3, the first call to fact ( ) will cause a second call to be \nmade with an argument of 2. This invocation will cause fact ( ) to be called a third time \nwith an argument of 1. This call will return 1, which is then multiplied by 2 ( the value of n \nin the second invocation ). This result ( which is 2 ) is then returned to the original invocation \nof fact ( ) and multiplied by 3 ( the original value of n ). This yields the answer, 6. You might \nfind it interesting to insert println ( ) statements into fact ( ) , which will show at what level \neach call is and what the intermediate answers are",
    ". This yields the answer, 6. You might \nfind it interesting to insert println ( ) statements into fact ( ) , which will show at what level \neach call is and what the intermediate answers are. \nWhen a method calls itself, new local variables and parameters are allocated storage on the \nstack, and the method code is executed with these new variables from the start. As each \nrecursive call returns, the old local variables and parameters are removed from the stack, \nand execution resumes at the point of the call inside the method. Recursive methods could \nbe said to \u201ctelescope\u201d out and back. \nRecursive versions of many routines may execute a bit more slowly than the iterative \nequivalent because of the added overhead of the additional method calls. Many recursive \ncalls to a method could cause a stack overrun. Because storage for parameters and local \nvariables is on the stack and each new call creates a new copy of these variables, it is \npossible that the stack could be exhausted",
    ". Because storage for parameters and local \nvariables is on the stack and each new call creates a new copy of these variables, it is \npossible that the stack could be exhausted. If this occurs, the Java run-time system will \ncause an exception. However, you probably will not have to worry about this unless a \nrecursive routine runs wild. \nThe main advantage to recursive methods is that they can be used to create clearer and \nsimpler versions of several algorithms than can their iterative relatives. For example, the \nQuickSort sorting algorithm is quite difficult to implement in an iterative way. Also, some \ntypes of AI-related algorithms are most easily implemented using recursive solutions. \nWhen writing recursive methods, you must have an if statement somewhere to force the \nmethod to return without the recursive call being executed. If you don\u2019t do this, once you \ncall the method, it will never return. This is a very common error in working with recursion",
    ". If you don\u2019t do this, once you \ncall the method, it will never return. This is a very common error in working with recursion. \nUse println ( ) statements liberally during development so that you can watch what is going \non and abort execution if you see that you have made a mistake. \nHere is one more example of recursion. The recursive method printArray ( ) prints the \nfirst i elements in the array values .",
    "This program generates the following output: \n\nIntroducing Access Control \n\nAs you know, encapsulation links data with the code that manipulates it. However, \nencapsulation provides another important attribute: access control . Through encapsulation, \nyou can control what parts of a program can access the members of a class. By controlling \naccess, you can prevent misuse. For example, allowing access to data only through a welldefined set of methods, you can prevent the misuse of that data. Thus, when correctly",
    "implemented, a class creates a \u201cblack box\u201d which may be used, but the inner workings of \nwhich are not open to tampering. However, the classes that were presented earlier do not \ncompletely meet this goal. For example, consider the Stack class shown at the end of \nChapter 6. While it is true that the methods push ( ) and pop ( ) do provide a controlled",
    "interface to the stack, this interface is not enforced. That is, it is possible for another part of \nthe program to bypass these methods and access the stack directly. Of course, in the wrong \nhands, this could lead to trouble. In this section, you will be introduced to the mechanism \nby which you can precisely control access to the various members of a class. \nHow a member can be accessed is determined by the access modifier attached to its \ndeclaration. Java supplies a rich set of access modifiers. Some aspects of access control are \nrelated mostly to inheritance or packages. ( A package is, essentially, a grouping of classes.) \nThese parts of Java\u2019s access control mechanism will be discussed later. Here, let\u2019s begin by \nexamining access control as it applies to a single class. Once you understand the \nfundamentals of access control, the rest will be easy. \nJava\u2019s access modifiers are public , private , and protected . Java also defines a default \naccess level",
    ". Once you understand the \nfundamentals of access control, the rest will be easy. \nJava\u2019s access modifiers are public , private , and protected . Java also defines a default \naccess level. protected applies only when inheritance is involved. The other access \nmodifiers are described next. \nLet\u2019s begin by defining public and private . When a member of a class is modified by",
    "public , then that member can be accessed by any other code. When a member of a class is \nspecified as private , then that member can only be accessed by other members of its class. \nNow you can understand why main ( ) has always been preceded by the public modifier. It \nis called by code that is outside the program\u2014that is, by the Java run-time system. When no \naccess modifier is used, then by default the member of a class is public within its own \npackage, but cannot be accessed outside of its package. ( Packages are discussed in the \nfollowing chapter.) \nIn the classes developed so far, all members of a class have used the default access mode. \nHowever, this is not what you will typically want to be the case. Usually, you will want to \nrestrict access to the data members of a class\u2014allowing access only through methods. Also, \nthere will be times when you will want to define methods that are private to a class. \nAn access modifier precedes the rest of a member\u2019s type specification",
    ". Also, \nthere will be times when you will want to define methods that are private to a class. \nAn access modifier precedes the rest of a member\u2019s type specification. That is, it must begin \na member\u2019s declaration statement. Here is an example:",
    "To understand the effects of public and private access, consider the following program: \n\n\nAs you can see, inside the Test class, a uses default access, which for this example is the \n\nsame as specifying public . b is explicitly specified as public . Member c is given private \naccess. This means that it cannot be accessed by code outside of its class. So, inside the \nAccessTest class, c cannot be used directly. It must be accessed through its public \n\nmethods: setc ( ) and getc ( ) . If you were to remove the comment symbol from the \nbeginning of the following line, \n\nthen you would not be able to compile this program because of the access violation. \nTo see how access control can be applied to a more practical example, consider the \n\n\nfollowing improved version of the Stack class shown at the end of Chapter 6. \n\nAs you can see, now both stck , which holds the stack, and tos , which is the index of the top",
    "following improved version of the Stack class shown at the end of Chapter 6. \n\nAs you can see, now both stck , which holds the stack, and tos , which is the index of the top \n\nof the stack, are specified as private . This means that they cannot be accessed or altered \nexcept through push ( ) and pop ( ) . Making tos private, for example, prevents other parts \nof your program from inadvertently setting it to a value that is beyond the end of the stck \narray. \nThe following program demonstrates the improved Stack class. Try removing the \ncommented-out lines to prove to yourself that the stck and tos members are, indeed, \n\ninaccessible.",
    "inaccessible. \n\n\nAlthough methods will usually provide access to the data defined by a class, this does not \nalways have to be the case. It is perfectly proper to allow an instance variable to be public \nwhen there is good reason to do so. For example, most of the simple classes in this book \nwere created with little concern about controlling access to instance variables for the sake of \nsimplicity. However, in most real-world classes, you will need to allow operations on data \nonly through methods. The next chapter will return to the topic of access control. As you will \nsee, it is particularly important when inheritance is involved. \n\nUnderstanding static \n\nThere will be times when you will want to define a class member that will be used \nindependently of any object of that class. Normally, a class member must be accessed only \nin conjunction with an object of its class. However, it is possible to create a member that",
    "can be used by itself, without reference to a specific instance. To create such a member, \nprecede its declaration with the keyword static . When a member is declared static , it can \nbe accessed before any objects of its class are created, and without reference to any object. \nYou can declare both methods and variables to be static . The most common example of a \nstatic member is main ( ) . main ( ) is declared as static because it must be called before \nany objects exist. \n\n\nInstance variables declared as static are, essentially, global variables. When objects of its \nclass are declared, no copy of a static variable is made. Instead, all instances of the class \nshare the same static variable. \nMethods declared as static have several restrictions: \n\n\u2022  They can only directly call other static methods. \n\n\u2022  They can only directly access static data.",
    "\u2022  They can only directly call other static methods. \n\n\u2022  They can only directly access static data. \n\n\u2022  They cannot refer to this or super in any way. ( The keyword super \nrelates to inheritance and is described in the next chapter.) \n\nIf you need to do computation in order to initialize your static variables, you can \ndeclare a static block that gets executed exactly once, when the class is first \nloaded. The following example shows a class that has a static method, some static \nvariables, and a static initialization block: \n\nAs soon as the UseStatic class is loaded, all of the static statements are run. First, a is set \nto 3 , then the static block executes, which prints a message and then initializes b to a*4 or \n12 . Then main ( ) is called, which calls meth ( ) , passing 42 to x . The three println ( ) \nstatements refer to the two static variables a and b , as well as to the local variable x . \n\nHere is the output of the program:",
    "Here is the output of the program: \n\n\nOutside of the class in which they are defined, static methods and variables can be used \nindependently of any object. To do so, you need only specify the name of their class followed \nby the dot operator. For example, if you wish to call a static method from outside its class, \nyou can do so using the following general form: \n\nclassname.method ( ) \n\nHere, classname is the name of the class in which the static method is declared. \nAs you can see, this format is similar to that used to call non- static methods \nthrough object-reference variables. A static variable can be accessed in the same \nway\u2014by use of the dot operator on the name of the class. This is how Java \nimplements a controlled version of global methods and global variables. \nHere is an example. Inside main ( ) , the static method callme ( ) and the static variable b \nare accessed through their class name StaticDemo . \n\nHere is the output of this program: \n\nIntroducing final",
    "Here is the output of this program: \n\nIntroducing final \n\nA field can be declared as final . Doing so prevents its contents from being modified, making \nit, essentially, a constant. This means that you must initialize a final field when it is \n\n\ndeclared. You can do this in one of two ways: First, you can give it a value when it is \ndeclared. Second, you can assign it a value within a constructor. The first approach is the \nmost common. Here is an example:",
    "Subsequent parts of your program can now use FILE_OPEN , etc., as if they were \nconstants, without fear that a value has been changed. It is a common coding convention to \nchoose all uppercase identifiers for final fields, as this example shows. \nIn addition to fields, both method parameters and local variables can be declared final . \nDeclaring a parameter final prevents it from being changed within the method. Declaring a \nlocal variable final prevents it from being assigned a value more than once. \nThe keyword final can also be applied to methods, but its meaning is substantially different \nthan when it is applied to variables. This additional usage of final is described in the next \nchapter, when inheritance is described. \n\nArrays Revisited",
    "Arrays Revisited \n\nArrays were introduced earlier in this book, before classes had been discussed. Now that you \nknow about classes, an important point can be made about arrays: they are implemented as \nobjects. Because of this, there is a special array attribute that you will want to take \nadvantage of. Specifically, the size of an array\u2014that is, the number of elements that an array \ncan hold\u2014is found in its length instance variable. All arrays have this variable, and it will \nalways hold the size of the array. Here is a program that demonstrates this property: \n\nThis program displays the following output:",
    "This program displays the following output: \n\n\nAs you can see, the size of each array is displayed. Keep in mind that the value of length \nhas nothing to do with the number of elements that are actually in use. It only reflects the \nnumber of elements that the array is designed to hold. \nYou can put the length member to good use in many situations. For example, here is an \nimproved version of the Stack class. As you might recall, the earlier versions of this class \nalways created a ten-element stack. The following version lets you create stacks of any size. \nThe value of stck.length is used to prevent the stack from overflowing. \n\n\nNotice that the program creates two stacks: one five elements deep and the other eight \nelements deep. As you can see, the fact that arrays maintain their own length information \nmakes it easy to create stacks of any size. \n\nIntroducing Nested and Inner Classes",
    "It is possible to define a class within another class ; such classes are known as nested classes . \nThe scope of a nested class is bounded by the scope of its enclosing class. Thus, if class B is \ndefined within class A, then B does not exist independently of A. A nested class has access \nto the members, including private members, of the class in which it is nested. However, the \nenclosing class does not have access to the members of the nested class. A nested class that \nis declared directly within its enclosing class scope is a member of its enclosing class. It is \nalso possible to declare a nested class that is local to a block. \nThere are two types of nested classes: static and non-static . A static nested class is one that \nhas the static modifier applied. Because it is static, it must access the non-static members \nof its enclosing class through an object. That is, it cannot refer to non-static members of its \nenclosing class directly",
    ". Because it is static, it must access the non-static members \nof its enclosing class through an object. That is, it cannot refer to non-static members of its \nenclosing class directly. Because of this restriction, static nested classes are seldom used. \nThe most important type of nested class is the inner class. An inner class is a non-static \nnested class. It has access to all of the variables and methods of its outer class and may refer \nto them directly in the same way that other non-static members of the outer class do. \nThe following program illustrates how to define and use an inner class. The class named \nOuter has one instance variable named outer_x , one instance method named test ( ) , and \ndefines one inner class called Inner .",
    "In the program, an inner class named Inner is defined within the scope of class Outer . \nTherefore, any code in class Inner can directly access the variable outer_x . An instance \nmethod named display ( ) is defined inside Inner . This method displays outer_x on the \nstandard output stream. The main ( ) method of InnerClassDemo creates an instance of \nclass Outer and invokes its test ( ) method. That method creates an instance of class Inner \nand the display ( ) method is called. \nIt is important to realize that an instance of Inner can be created only in the context of \nclass Outer . The Java compiler generates an error message otherwise. In general, an inner \nclass instance is often created by code within its enclosing scope, as the example does. \nAs explained, an inner class has access to all of the members of its enclosing class, but the \nreverse is not true. Members of the inner class are known only within the scope of the inner",
    "Here, y is declared as an instance variable of Inner . Thus, it is not known outside of that \nclass and it cannot be used by showy ( ) . \nAlthough we have been focusing on inner classes declared as members within an outer class \nscope, it is possible to define inner classes within any block scope. For example, you can \ndefine a nested class within the block defined by a method or even within the body of a for \nloop, as this next program shows: \n\nThe output from this version of the program is shown here: \n\nWhile nested classes are not applicable to all situations, they are particularly helpful when \n\nhandling events. We will return to the topic of nested classes in Chapter 24. There you will",
    "While nested classes are not applicable to all situations, they are particularly helpful when \n\nhandling events. We will return to the topic of nested classes in Chapter 24. There you will \n\n\nsee how inner classes can be used to simplify the code needed to handle certain types of \nevents. You will also learn about anonymous inner classes , which are inner classes that \ndon\u2019t have a name. \nOne final point: Nested classes were not allowed by the original 1.0 specification for Java. \nThey were added by Java 1.1. \n\nExploring the String Class",
    "Exploring the String Class \n\nAlthough the String class will be examined in depth in Part II of this book, a short \nexploration of it is warranted now, because we will be using strings in some of the example \nprograms shown toward the end of Part I. String is probably the most commonly used class \nin Java\u2019s class library. The obvious reason for this is that strings are a very important part of \nprogramming. \nThe first thing to understand about strings is that every string you create is actually an \nobject of type String . Even string constants are actually String objects. For example, in the \nstatement \n\nthe string \"This is a String, too\" is a String object. \nThe second thing to understand about strings is that objects of type String are immutable ; \nonce a String object is created, its contents cannot be altered. While this may seem like a \nserious restriction, it is not, for two reasons:",
    "\u2022  If you need to change a string, you can always create a new one that \ncontains the modifications. \n\n\u2022  Java defines peer classes of String , called StringBuffer and \nStringBuilder , which allow strings to be altered, so all of the normal \nstring manipulations are still available in Java. ( StringBuffer and \nStringBuilder are described in Part II of this book.) \n\nStrings can be constructed in a variety of ways. The easiest is to use a statement \nlike this: \n\nOnce you have created a String object, you can use it anywhere that a string is allowed. For \nexample, this statement displays myString : \n\nJava defines one operator for String objects: + . It is used to concatenate two strings. For \nexample, this statement \n\n\nresults in myString containing \"I like Java.\" \nThe following program demonstrates the preceding concepts: \n\nThe output produced by this program is shown here:",
    "results in myString containing \"I like Java.\" \nThe following program demonstrates the preceding concepts: \n\nThe output produced by this program is shown here: \n\nThe String class contains several methods that you can use. Here are a few. You can test \ntwo strings for equality by using equals ( ) . You can obtain the length of a string by calling \nthe length ( ) method. You can obtain the character at a specified index within a string by \ncalling charAt ( ) . The general forms of these three methods are shown here: \n\nboolean equals ( secondStr ) \nint length ( ) \nchar charAt ( index ) \n\nHere is a program that demonstrates these methods: \n\n\nThis program generates the following output: \n\nOf course, you can have arrays of strings, just like you can have arrays of any other type of \n\nobject. For example: \n\n\nHere is the output from this program: \n\nAs you will see in the following section, string arrays play an important part in many Java \nprograms.",
    "object. For example: \n\n\nHere is the output from this program: \n\nAs you will see in the following section, string arrays play an important part in many Java \nprograms. \n\nUsing Command-Line Arguments \n\nSometimes you will want to pass information into a program when you run it. This is \naccomplished by passing command-line arguments to main ( ) . A command-line argument \nis the information that directly follows the program\u2019s name on the command line when it is \nexecuted. To access the command-line arguments inside a Java program is quite easy\u2014they \nare stored as strings in a String array passed to the args parameter of main ( ) . The first \ncommand-line argument is stored at args[0] , the second at args[1] , and so on. For \nexample, the following program displays all of the command-line arguments that it is called \nwith: \n\nTry executing this program, as shown here: \n\n\nWhen you do, you will see the following output:",
    "Try executing this program, as shown here: \n\n\nWhen you do, you will see the following output: \n\nREMEMBER   All command-line arguments are passed as strings. You \nmust convert numeric values to their internal forms manually, as \nexplained in Chapter 17. \n\nVarargs: Variable-Length Arguments",
    "Varargs: Variable-Length Arguments \n\nBeginning with JDK 5, Java has included a feature that simplifies the creation of methods \nthat need to take a variable number of arguments. This feature is called varargs and it is \nshort for variable-length arguments . A method that takes a variable number of arguments \nis called a variable-arity method , or simply a varargs method . \nSituations that require that a variable number of arguments be passed to a method are not \nunusual. For example, a method that opens an Internet connection might take a user name, \npassword, filename, protocol, and so on, but supply defaults if some of this information is \nnot provided. In this situation, it would be convenient to pass only the arguments to which \nthe defaults did not apply. Another example is the printf ( ) method that is part of Java\u2019s \nI/O library. As you will see in Chapter 20, it takes a variable number of arguments, which it",
    "formats and then outputs. \nPrior to JDK 5, variable-length arguments could be handled two ways, neither of which was \nparticularly pleasing. First, if the maximum number of arguments was small and known, \nthen you could create overloaded versions of the method, one for each way the method could \nbe called. Although this works and is suitable for some cases, it applies to only a narrow \n\nclass of situations. \nIn cases where the maximum number of potential arguments was larger, or unknowable, a \nsecond approach was used in which the arguments were put into an array, and then the \narray was passed to the method. This approach is illustrated by the following program: \n\n\nThe output from the program is shown here: \n\nIn the program, the method vaTest ( ) is passed its arguments through the array v . This",
    "The output from the program is shown here: \n\nIn the program, the method vaTest ( ) is passed its arguments through the array v . This \n\nold-style approach to variable-length arguments does enable vaTest ( ) to take an arbitrary \nnumber of arguments. However, it requires that these arguments be manually packaged into \nan array prior to calling vaTest ( ) . Not only is it tedious to construct an array each time \n\nvaTest ( ) is called, it is potentially error-prone. The varargs feature offers a simpler, better \noption. \nA variable-length argument is specified by three periods ( \u2026 ). For example, here is how \nvaTest ( ) is written using a vararg: \n\n\nThis syntax tells the compiler that vaTest ( ) can be called with zero or more arguments. As \na result, v is implicitly declared as an array of type int[ ] . Thus, inside vaTest ( ) , v is \naccessed using the normal array syntax. Here is the preceding program rewritten using a \nvararg:",
    "The output from the program is the same as the original version. \nThere are two important things to notice about this program. First, as explained, inside \nvaTest ( ) , v is operated on as an array. This is because v is an array. The \u2026 syntax simply \ntells the compiler that a variable number of arguments will be used, and that these \narguments will be stored in the array referred to by v . Second, in main ( ) , vaTest ( ) is \ncalled with different numbers of arguments, including no arguments at all. The arguments \nare automatically put in an array and passed to v . In the case of no arguments, the length of \nthe array is zero. \n\nA method can have \u201cnormal\u201d parameters along with a variable-length parameter. However, \nthe variable-length parameter must be the last parameter declared by the method. For \nexample, this method declaration is perfectly acceptable: \n\nIn this case, the first three arguments used in a call to doIt ( ) are matched to the first three",
    "In this case, the first three arguments used in a call to doIt ( ) are matched to the first three \n\n\nparameters. Then, any remaining arguments are assumed to belong to vals . \nRemember, the varargs parameter must be last. For example, the following declaration is \nincorrect: \n\nHere, there is an attempt to declare a regular parameter after the varargs parameter, which \nis illegal. \nThere is one more restriction to be aware of: there must be only one varargs parameter. For \nexample, this declaration is also invalid: \n\nThe attempt to declare the second varargs parameter is illegal. \nHere is a reworked version of the vaTest ( ) method that takes a regular argument and a \nvariable-length argument: \n\nThe output from this program is shown here: \n\n\nOverloading Vararg Methods \n\nYou can overload a method that takes a variable-length argument. For example, the \nfollowing program overloads vaTest ( ) three times:",
    "Overloading Vararg Methods \n\nYou can overload a method that takes a variable-length argument. For example, the \nfollowing program overloads vaTest ( ) three times: \n\n\nThe output produced by this program is shown here:",
    "The output produced by this program is shown here: \n\n\nThis program illustrates both ways that a varargs method can be overloaded. First, the types \nof its vararg parameter can differ. This is the case for vaTest ( int \u2026) and vaTest ( boolean \n\u2026 ). Remember, the \u2026 causes the parameter to be treated as an array of the specified type. \nTherefore, just as you can overload methods by using different types of array parameters, \nyou can overload vararg methods by using different types of varargs. In this case, Java uses \nthe type difference to determine which overloaded method to call. \nThe second way to overload a varargs method is to add one or more normal parameters. \nThis is what was done with vaTest ( String, int \u2026) . In this case, Java uses both the number \nof arguments and the type of the arguments to determine which method to call.",
    "NOTE    A varargs method can also be overloaded by a non-varargs \nmethod. For example, vaTest ( int x ) is a valid overload of vaTest ( ) in \nthe foregoing program. This version is invoked only when one int \nargument is present. When two or more int arguments are passed, the \nvarargs version vaTest ( int\u2026v ) is used. \n\nVarargs and Ambiguity \n\nSomewhat unexpected errors can result when overloading a method that takes a variablelength argument. These errors involve ambiguity because it is possible to create an \nambiguous call to an overloaded varargs method. For example, consider the following \nprogram: \n\n\nIn this program, the overloading of vaTest ( ) is perfectly correct. However, this program \nwill not compile because of the following call: \n\nBecause the vararg parameter can be empty, this call could be translated into a call to \nvaTest ( int \u2026) or vaTest ( boolean \u2026) . Both are equally valid. Thus, the call is inherently \nambiguous.",
    "Because the vararg parameter can be empty, this call could be translated into a call to \nvaTest ( int \u2026) or vaTest ( boolean \u2026) . Both are equally valid. Thus, the call is inherently \nambiguous. \n\n\nHere is another example of ambiguity. The following overloaded versions of vaTest ( ) are \ninherently ambiguous even though one takes a normal parameter: \n\nAlthough the parameter lists of vaTest ( ) differ, there is no way for the compiler to resolve \nthe following call:",
    "Although the parameter lists of vaTest ( ) differ, there is no way for the compiler to resolve \nthe following call: \n\nDoes this translate into a call to vaTest ( int \u2026) , with one varargs argument, or into a call \nto vaTest ( int, int \u2026) with no varargs arguments? There is no way for the compiler to \nanswer this question. Thus, the situation is ambiguous. \nBecause of ambiguity errors like those just shown, sometimes you will need to forego \noverloading and simply use two different method names. Also, in some cases, ambiguity \nerrors expose a conceptual flaw in your code, which you can remedy by more carefully \ncrafting a solution. \n\n\uf709 \nPREV \nChapter 6: Introducing Classes \n\u23ee \n\nNEXT \nChapter 8: Inheritance \u23ed \n\n\nPREV \nChapter 7: A Closer Look at Methods and Classes \n\u23ee \n\nNEXT \nChapter 9: Packages and Interfaces \u23ed \n\nCHAPTER \n\n8 \nInheritance",
    "NEXT \nChapter 8: Inheritance \u23ed \n\n\nPREV \nChapter 7: A Closer Look at Methods and Classes \n\u23ee \n\nNEXT \nChapter 9: Packages and Interfaces \u23ed \n\nCHAPTER \n\n8 \nInheritance \n\nInheritance is one of the cornerstones of object-oriented programming because it allows the \ncreation of hierarchical classifications. Using inheritance, you can create a general class that \ndefines traits common to a set of related items. This class can then be inherited by other, \nmore specific classes, each adding those things that are unique to it. In the terminology of \nJava, a class that is inherited is called a superclass . The class that does the inheriting is \ncalled a subclass . Therefore, a subclass is a specialized version of a superclass. It inherits all \nof the members defined by the superclass and adds its own, unique elements. \n\nInheritance Basics",
    "Inheritance Basics \n\nTo inherit a class, you simply incorporate the definition of one class into another by using \nthe extends keyword. To see how, let\u2019s begin with a short example. The following program \ncreates a superclass called A and a subclass called B . Notice how the keyword extends is \nused to create a subclass of A . \n\n\nThe output from this program is shown here: \n\n\nAs you can see, the subclass B includes all of the members of its superclass, A . This is why \nsubOb can access i and j and call showij ( ) . Also, inside sum ( ) , i and j can be referred to \ndirectly, as if they were part of B . \nEven though A is a superclass for B , it is also a completely independent, stand-alone class. \nBeing a superclass for a subclass does not mean that the superclass cannot be used by itself. \nFurther, a subclass can be a superclass for another subclass. \nThe general form of a class declaration that inherits a superclass is shown here:",
    "You can only specify one superclass for any subclass that you create. Java does not support \nthe inheritance of multiple superclasses into a single subclass. You can, as stated, create a \nhierarchy of inheritance in which a subclass becomes a superclass of another subclass. \nHowever, no class can be a superclass of itself. \n\nMember Access and Inheritance \n\nAlthough a subclass includes all of the members of its superclass, it cannot access those \nmembers of the superclass that have been declared as private . For example, consider the \nfollowing simple class hierarchy: \n\n\nThis program will not compile because the use of j inside the sum ( ) method of B causes an \naccess violation. Since j is declared as private , it is only accessible by other members of its \nown class. Subclasses have no access to it. \n\nREMEMBER   A class member that has been declared as private will",
    "REMEMBER   A class member that has been declared as private will \n\n\nremain private to its class. It is not accessible by any code outside its \nclass, including subclasses. \n\nA More Practical Example \n\nLet\u2019s look at a more practical example that will help illustrate the power of inheritance. \nHere, the final version of the Box class developed in the preceding chapter will be extended \nto include a fourth component called weight . Thus, the new class will contain a box\u2019s \nwidth, height, depth, and weight. \n\n\n\n\nThe output from this program is shown here: \n\nBoxWeight inherits all of the characteristics of Box and adds to them the weight \ncomponent. It is not necessary for BoxWeight to re-create all of the features found in Box . \nIt can simply extend Box to meet its own purposes. \nA major advantage of inheritance is that once you have created a superclass that defines the",
    "attributes common to a set of objects, it can be used to create any number of more specific \nsubclasses. Each subclass can precisely tailor its own classification. For example, the \nfollowing class inherits Box and adds a color attribute: \n\n\nRemember, once you have created a superclass that defines the general aspects of an object, \nthat superclass can be inherited to form specialized classes. Each subclass simply adds its \nown unique attributes. This is the essence of inheritance. \n\nA Superclass Variable Can Reference a Subclass Object \n\nA reference variable of a superclass can be assigned a reference to any subclass derived from \nthat superclass. You will find this aspect of inheritance quite useful in a variety of situations. \nFor example, consider the following:",
    "Here, weightbox is a reference to BoxWeight objects, and plainbox is a reference to \nBox objects. Since BoxWeight is a subclass of Box , it is permissible to assign plainbox a \nreference to the weightbox object.",
    "It is important to understand that it is the type of the reference variable\u2014not the type of the \nobject that it refers to\u2014that determines what members can be accessed. That is, when a \nreference to a subclass object is assigned to a superclass reference variable, you will have \naccess only to those parts of the object defined by the superclass. This is why plainbox \ncan\u2019t access weight even when it refers to a BoxWeight object. If you think about it, this \nmakes sense, because the superclass has no knowledge of what a subclass adds to it. This is \nwhy the last line of code in the preceding fragment is commented out. It is not possible for a \nBox reference to access the weight field, because Box does not define one. \nAlthough the preceding may seem a bit esoteric, it has some important practical \napplications\u2014two of which are discussed later in this chapter. \n\nUsing super",
    "In the preceding examples, classes derived from Box were not implemented as efficiently or \nas robustly as they could have been. For example, the constructor for BoxWeight explicitly \ninitializes the width , height , and depth fields of Box . Not only does this duplicate code \nfound in its superclass, which is inefficient, but it implies that a subclass must be granted \naccess to these members. However, there will be times when you will want to create a \nsuperclass that keeps the details of its implementation to itself ( that is, that keeps its data \nmembers private ). In this case, there would be no way for a subclass to directly access or \ninitialize these variables on its own. Since encapsulation is a primary attribute of OOP, it is \nnot surprising that Java provides a solution to this problem. Whenever a subclass needs to \nrefer to its immediate superclass, it can do so by use of the keyword super . \nsuper has two general forms. The first calls the superclass\u2019 constructor",
    ". Whenever a subclass needs to \nrefer to its immediate superclass, it can do so by use of the keyword super . \nsuper has two general forms. The first calls the superclass\u2019 constructor. The second is used \nto access a member of the superclass that has been hidden by a member of a subclass. Each \nuse is examined here.",
    "Using super to Call Superclass Constructors \n\nA subclass can call a constructor defined by its superclass by use of the following form of \nsuper : \n\nsuper ( arg-list ); \n\nHere, arg-list specifies any arguments needed by the constructor in the superclass. \nsuper ( ) must always be the first statement executed inside a subclass\u2019 \nconstructor. \nTo see how super ( ) is used, consider this improved version of the BoxWeight class:",
    "Here, BoxWeight ( ) calls super ( ) with the arguments w , h , and d . This causes the Box \nconstructor to be called, which initializes width , height , and depth using these values. \nBoxWeight no longer initializes these values itself. It only needs to initialize the value \nunique to it: weight . This leaves Box free to make these values private if desired. \nIn the preceding example, super ( ) was called with three arguments. Since constructors can \nbe overloaded, super ( ) can be called using any form defined by the superclass. The \nconstructor executed will be the one that matches the arguments. For example, here is a \ncomplete implementation of BoxWeight that provides constructors for the various ways \nthat a box can be constructed. In each case, super ( ) is called using the appropriate \narguments. Notice that width , height , and depth have been made private within Box . \n\n\n\n\nThis program generates the following output:",
    "This program generates the following output: \n\n\nPay special attention to this constructor in BoxWeight : \n\nNotice that super ( ) is passed an object of type BoxWeight \u2014not of type Box . This still \ninvokes the constructor Box ( Box ob ) . As mentioned earlier, a superclass variable can be \nused to reference any object derived from that class. Thus, we are able to pass a \nBoxWeight object to the Box constructor. Of course, Box only has knowledge of its own \nmembers. \nLet\u2019s review the key concepts behind super ( ) . When a subclass calls super ( ) , it is calling \nthe constructor of its immediate superclass. Thus, super ( ) always refers to the superclass \nimmediately above the calling class. This is true even in a multileveled hierarchy. Also, \nsuper ( ) must always be the first statement executed inside a subclass constructor. \n\nA Second Use for super",
    "A Second Use for super \n\nThe second form of super acts somewhat like this , except that it always refers to the \nsuperclass of the subclass in which it is used. This usage has the following general form: \n\nsuper. member \n\nHere, member can be either a method or an instance variable. \nThis second form of super is most applicable to situations in which member names of a \n\nsubclass hide members by the same name in the superclass. Consider this simple class \nhierarchy: \n\n\nThis program displays the following: \n\nAlthough the instance variable i in B hides the i in A , super allows access to the i defined \nin the superclass. As you will see, super can also be used to call methods that are hidden by \na subclass. \n\nCreating a Multilevel Hierarchy",
    "Creating a Multilevel Hierarchy \n\nUp to this point, we have been using simple class hierarchies that consist of only a \nsuperclass and a subclass. However, you can build hierarchies that contain as many layers of \ninheritance as you like. As mentioned, it is perfectly acceptable to use a subclass as a \nsuperclass of another. For example, given three classes called A , B , and C , C can be a \n\nsubclass of B , which is a subclass of A . When this type of situation occurs, each subclass \ninherits all of the traits found in all of its superclasses. In this case, C inherits all aspects of \n\nB and A . To see how a multilevel hierarchy can be useful, consider the following program. \n\n\nIn it, the subclass BoxWeight is used as a superclass to create the subclass called \nShipment . Shipment inherits all of the traits of BoxWeight and Box , and adds a field \ncalled cost , which holds the cost of shipping such a parcel.",
    "The output of this program is shown here: \n\nBecause of inheritance, Shipment can make use of the previously defined classes of Box \nand BoxWeight , adding only the extra information it needs for its own, specific \napplication. This is part of the value of inheritance ; it allows the reuse of code. \nThis example illustrates one other important point: super ( ) always refers to the \nconstructor in the closest superclass. The super ( ) in Shipment calls the constructor in \nBoxWeight . The super ( ) in BoxWeight calls the constructor in Box . In a class \nhierarchy, if a superclass constructor requires parameters, then all subclasses must pass \nthose parameters \u201cup the line.\u201d This is true whether or not a subclass needs parameters of \nits own.",
    "NOTE In the preceding program, the entire class hierarchy, including \nBox , BoxWeight , and Shipment , is shown all in one file. This is for \nyour convenience only. In Java, all three classes could have been placed \ninto their own files and compiled separately. In fact, using separate files is \nthe norm, not the exception, in creating class hierarchies. \n\nWhen Constructors Are Executed \n\nWhen a class hierarchy is created, in what order are the constructors for the classes that \nmake up the hierarchy executed? For example, given a subclass called B and a superclass \n\ncalled A , is A \u2019s constructor executed before B \u2019s, or vice versa? The answer is that in a class",
    "called A , is A \u2019s constructor executed before B \u2019s, or vice versa? The answer is that in a class \n\n\nhierarchy, constructors complete their execution in order of derivation, from superclass to \nsubclass. Further, since super ( ) must be the first statement executed in a subclass\u2019 \nconstructor, this order is the same whether or not super ( ) is used. If super ( ) is not used, \nthen the default or parameterless constructor of each superclass will be executed. The \nfollowing program illustrates when constructors are executed: \n\nThe output from this program is shown here: \n\nAs you can see, the constructors are executed in order of derivation. \n\nIf you think about it, it makes sense that constructors complete their execution in order of \nderivation. Because a superclass has no knowledge of any subclass, any initialization it \nneeds to perform is separate from and possibly prerequisite to any initialization performed",
    "by the subclass. Therefore, it must complete its execution first. \n\nMethod Overriding \n\nIn a class hierarchy, when a method in a subclass has the same name and type signature as \na method in its superclass, then the method in the subclass is said to override the method \nin the superclass. When an overridden method is called from within its subclass, it will \nalways refer to the version of that method defined by the subclass. The version of the \nmethod defined by the superclass will be hidden. Consider the following: \n\nThe output produced by this program is shown here:",
    "The output produced by this program is shown here: \n\n\nWhen show ( ) is invoked on an object of type B , the version of show ( ) defined within B \nis used. That is, the version of show ( ) inside B overrides the version declared in A . \nIf you wish to access the superclass version of an overridden method, you can do so by using \nsuper . For example, in this version of B , the superclass version of show ( ) is invoked \nwithin the subclass\u2019 version. This allows all instance variables to be displayed. \n\nIf you substitute this version of A into the previous program, you will see the following \noutput: \n\nHere, super.show ( ) calls the superclass version of show ( ) . \nMethod overriding occurs only when the names and the type signatures of the two methods \nare identical. If they are not, then the two methods are simply overloaded. For example, \nconsider this modified version of the preceding example: \n\n\nThe output produced by this program is shown here:",
    "The output produced by this program is shown here: \n\nThe version of show ( ) in B takes a string parameter. This makes its type signature \ndifferent from the one in A , which takes no parameters. Therefore, no overriding ( or name \nhiding ) takes place. Instead, the version of show ( ) in B simply overloads the version of \nshow ( ) in A . \n\n\nDynamic Method Dispatch",
    "While the examples in the preceding section demonstrate the mechanics of method \noverriding, they do not show its power. Indeed, if there were nothing more to method \noverriding than a name space convention, then it would be, at best, an interesting curiosity, \nbut of little real value. However, this is not the case. Method overriding forms the basis for \none of Java\u2019s most powerful concepts: dynamic method dispatch . Dynamic method dispatch \nis the mechanism by which a call to an overridden method is resolved at run time, rather \nthan compile time. Dynamic method dispatch is important because this is how Java \nimplements run-time polymorphism. \nLet\u2019s begin by restating an important principle: a superclass reference variable can refer to a \nsubclass object. Java uses this fact to resolve calls to overridden methods at run time. Here \nis how",
    ". Java uses this fact to resolve calls to overridden methods at run time. Here \nis how. When an overridden method is called through a superclass reference, Java \ndetermines which version of that method to execute based upon the type of the object being \nreferred to at the time the call occurs. Thus, this determination is made at run time. When \ndifferent types of objects are referred to, different versions of an overridden method will be \ncalled. In other words, it is the type of the object being referred to ( not the type of the \nreference variable ) that determines which version of an overridden method will be executed. \nTherefore, if a superclass contains a method that is overridden by a subclass, then when \ndifferent types of objects are referred to through a superclass reference variable, different \nversions of the method are executed. \nHere is an example that illustrates dynamic method dispatch:",
    "The output from the program is shown here: \n\n\nThis program creates one superclass called A and two subclasses of it, called B and C . \nSubclasses B and C override callme ( ) declared in A . Inside the main ( ) method, objects \nof type A , B , and C are declared. Also, a reference of type A , called r , is declared. The \nprogram then in turn assigns a reference to each type of object to r and uses that reference \nto invoke callme ( ) . As the output shows, the version of callme ( ) executed is determined \nby the type of object being referred to at the time of the call. Had it been determined by the \ntype of the reference variable, r , you would see three calls to A \u2019s callme ( ) method. \n\nNOTE Readers familiar with C++ or C# will recognize that overridden \nmethods in Java are similar to virtual functions in those languages. \n\nWhy Overridden Methods?",
    "As stated earlier, overridden methods allow Java to support run-time polymorphism. \nPolymorphism is essential to object-oriented programming for one reason: it allows a \ngeneral class to specify methods that will be common to all of its derivatives, while allowing \nsubclasses to define the specific implementation of some or all of those methods. \nOverridden methods are another way that Java implements the \u201cone interface, multiple \nmethods\u201d aspect of polymorphism. \nPart of the key to successfully applying polymorphism is understanding that the \nsuperclasses and subclasses form a hierarchy which moves from lesser to greater \nspecialization. Used correctly, the superclass provides all elements that a subclass can use \ndirectly. It also defines those methods that the derived class must implement on its own. \nThis allows the subclass the flexibility to define its own methods, yet still enforces a \nconsistent interface",
    ". It also defines those methods that the derived class must implement on its own. \nThis allows the subclass the flexibility to define its own methods, yet still enforces a \nconsistent interface. Thus, by combining inheritance with overridden methods, a superclass \ncan define the general form of the methods that will be used by all of its subclasses. \nDynamic, run-time polymorphism is one of the most powerful mechanisms that objectoriented design brings to bear on code reuse and robustness. The ability of existing code \nlibraries to call methods on instances of new classes without recompiling while maintaining \na clean abstract interface is a profoundly powerful tool.",
    "Applying Method Overriding \n\nLet\u2019s look at a more practical example that uses method overriding. The following program \ncreates a superclass called Figure that stores the dimensions of a two-dimensional object. \nIt also defines a method called area ( ) that computes the area of an object. The program \nderives two subclasses from Figure . The first is Rectangle and the second is Triangle . \nEach of these subclasses overrides area ( ) so that it returns the area of a rectangle and a \n\ntriangle, respectively. \n\n\n\n\nThe output from the program is shown here: \n\nThrough the dual mechanisms of inheritance and run-time polymorphism, it is possible to \ndefine one consistent interface that is used by several different, yet related, types of objects. \nIn this case, if an object is derived from Figure , then its area can be obtained by calling \narea ( ) . The interface to this operation is the same no matter what type of figure is being \nused. \n\nUsing Abstract Classes",
    "Using Abstract Classes \n\nThere are situations in which you will want to define a superclass that declares the structure \nof a given abstraction without providing a complete implementation of every method. That \nis, sometimes you will want to create a superclass that only defines a generalized form that \nwill be shared by all of its subclasses, leaving it to each subclass to fill in the details. Such a \nclass determines the nature of the methods that the subclasses must implement. One way \nthis situation can occur is when a superclass is unable to create a meaningful",
    "implementation for a method. This is the case with the class Figure used in the preceding \nexample. The definition of area ( ) is simply a placeholder. It will not compute and display \nthe area of any type of object. \nAs you will see as you create your own class libraries, it is not uncommon for a method to \nhave no meaningful definition in the context of its superclass. You can handle this situation \ntwo ways. One way, as shown in the previous example, is to simply have it report a warning \n\n\nmessage. While this approach can be useful in certain situations\u2014such as debugging\u2014it is",
    "message. While this approach can be useful in certain situations\u2014such as debugging\u2014it is \n\nnot usually appropriate. You may have methods that must be overridden by the subclass in \norder for the subclass to have any meaning. Consider the class Triangle . It has no meaning \nif area ( ) is not defined. In this case, you want some way to ensure that a subclass does, \nindeed, override all necessary methods. Java\u2019s solution to this problem is the abstract \nmethod . \nYou can require that certain methods be overridden by subclasses by specifying the \nabstract type modifier. These methods are sometimes referred to as subclasser \nresponsibility because they have no implementation specified in the superclass. Thus, a \nsubclass must override them\u2014it cannot simply use the version defined in the superclass. To \ndeclare an abstract method, use this general form: \n\nabstract type name ( parameter-list );",
    "abstract type name ( parameter-list ); \n\nAs you can see, no method body is present. \nAny class that contains one or more abstract methods must also be declared abstract. To \ndeclare a class abstract, you simply use the abstract keyword in front of the class keyword \nat the beginning of the class declaration. There can be no objects of an abstract class. That \nis, an abstract class cannot be directly instantiated with the new operator. Such objects \nwould be useless, because an abstract class is not fully defined. Also, you cannot declare \nabstract constructors, or abstract static methods. Any subclass of an abstract class must \neither implement all of the abstract methods in the superclass, or be declared abstract \nitself. \nHere is a simple example of a class with an abstract method, followed by a class which \nimplements that method:",
    "Notice that no objects of class A are declared in the program. As mentioned, it is not \npossible to instantiate an abstract class. One other point: class A implements a concrete \nmethod called callmetoo ( ) . This is perfectly acceptable. Abstract classes can include as \nmuch implementation as they see fit. \nAlthough abstract classes cannot be used to instantiate objects, they can be used to create \nobject references, because Java\u2019s approach to run-time polymorphism is implemented \nthrough the use of superclass references. Thus, it must be possible to create a reference to \nan abstract class so that it can be used to point to a subclass object. You will see this feature \nput to use in the next example. \nUsing an abstract class, you can improve the Figure class shown earlier. Since there is no \nmeaningful concept of area for an undefined two-dimensional figure, the following version \nof the program declares area ( ) as abstract inside Figure",
    ". Since there is no \nmeaningful concept of area for an undefined two-dimensional figure, the following version \nof the program declares area ( ) as abstract inside Figure . This, of course, means that all \nclasses derived from Figure must override area ( ) .",
    "As the comment inside main ( ) indicates, it is no longer possible to declare objects of type \nFigure , since it is now abstract. And, all subclasses of Figure must override area ( ) . To \n\nprove this to yourself, try creating a subclass that does not override area ( ) . You will receive \na compile-time error. \nAlthough it is not possible to create an object of type Figure , you can create a reference \n\n\nvariable of type Figure . The variable figref is declared as a reference to Figure , which \n\nmeans that it can be used to refer to an object of any class derived from Figure . As \nexplained, it is through superclass reference variables that overridden methods are resolved \nat run time. \n\nUsing final with Inheritance \n\nThe keyword final has three uses. First, it can be used to create the equivalent of a named \nconstant. This use was described in the preceding chapter. The other two uses of final apply \nto inheritance. Both are examined here.",
    "Using final to Prevent Overriding \n\nWhile method overriding is one of Java\u2019s most powerful features, there will be times when \nyou will want to prevent it from occurring. To disallow a method from being overridden, \nspecify final as a modifier at the start of its declaration. Methods declared as final cannot \nbe overridden. The following fragment illustrates final :",
    "Because meth ( ) is declared as final , it cannot be overridden in B . If you attempt to do so, \na compile-time error will result. \nMethods declared as final can sometimes provide a performance enhancement: The \ncompiler is free to inline calls to them because it \u201cknows\u201d they will not be overridden by a \nsubclass. When a small final method is called, often the Java compiler can copy the \nbytecode for the subroutine directly inline with the compiled code of the calling method, \nthus eliminating the costly overhead associated with a method call. Inlining is an option \nonly with final methods. Normally, Java resolves calls to methods dynamically, at run time. \n\nThis is called late binding . However, since final methods cannot be overridden, a call to \none can be resolved at compile time. This is called early binding. \n\nUsing final to Prevent Inheritance",
    "This is called late binding . However, since final methods cannot be overridden, a call to \none can be resolved at compile time. This is called early binding. \n\nUsing final to Prevent Inheritance \n\nSometimes you will want to prevent a class from being inherited. To do this, precede the \nclass declaration with final . Declaring a class as final implicitly declares all of its methods \n\n\nas final , too. As you might expect, it is illegal to declare a class as both abstract and final \nsince an abstract class is incomplete by itself and relies upon its subclasses to provide \ncomplete implementations. \nHere is an example of a final class: \n\nAs the comments imply, it is illegal for B to inherit A since A is declared as final . \n\nThe Object Class",
    "As the comments imply, it is illegal for B to inherit A since A is declared as final . \n\nThe Object Class \n\nThere is one special class, Object , defined by Java. All other classes are subclasses of \nObject . That is, Object is a superclass of all other classes. This means that a reference \nvariable of type Object can refer to an object of any other class. Also, since arrays are \nimplemented as classes, a variable of type Object can also refer to any array. \nObject defines the following methods, which means that they are available in every object. \n\nMethod \nPurpose \n\nObject clone ( ) \nCreates a new object that is the same as the \nobject being cloned. \n\nboolean equals ( Object \nobject ) \nDetermines whether one object is equal to \nanother. \n\nvoid finalize ( ) \nCalled before an unused object is recycled. \n\nClass<?> getClass ( ) \nObtains the class of an object at run time. \n\nint hashCode ( ) \nReturns the hash code associated with the \n\ninvoking object.",
    "Class<?> getClass ( ) \nObtains the class of an object at run time. \n\nint hashCode ( ) \nReturns the hash code associated with the \n\ninvoking object. \n\nvoid notify ( ) \nResumes execution of a thread waiting on \nthe invoking object. \n\nvoid notifyAll ( ) \nResumes execution of all threads waiting on \nthe invoking object. \n\nString toString ( ) \nReturns a string that describes the object. \n\n\nvoid wait ( ) \n\nvoid wait ( long milliseconds ) \nvoid wait ( long milliseconds , int \nnanoseconds ) \n\nWaits on another thread of execution.",
    "Waits on another thread of execution. \n\nThe methods getClass ( ) , notify ( ) , notifyAll ( ) , and wait ( ) are declared as final . You \nmay override the others. These methods are described elsewhere in this book. However, \nnotice two methods now: equals ( ) and toString ( ) . The equals ( ) method compares two \nobjects. It returns true if the objects are equal, and false otherwise. The precise definition \nof equality can vary, depending on the type of objects being compared. The toString ( ) \nmethod returns a string that contains a description of the object on which it is called. Also, \nthis method is automatically called when an object is output using println ( ) . Many classes \noverride this method. Doing so allows them to tailor a description specifically for the types \nof objects that they create. \nOne last point: Notice the unusual syntax in the return type for getClass ( ) . This relates to \nJava\u2019s generics feature, which is described in Chapter 14.",
    "\uf709 \nPREV \nChapter 7: A Closer Look at Methods and Classes \n\u23ee \n\nNEXT \nChapter 9: Packages and Interfaces \u23ed \n\n\nPREV \nChapter 8: Inheritance \n\u23ee \n\nNEXT \nChapter 10: Exception Handling \u23ed \n\nCHAPTER \n\n9 \nPackages and Interfaces",
    "This chapter examines two of Java\u2019s most innovative features: packages and interfaces. \nPackages are containers for classes. They are used to keep the class name space \ncompartmentalized. For example, a package allows you to create a class named List , which \nyou can store in your own package without concern that it will collide with some other class \nnamed List stored elsewhere. Packages are stored in a hierarchical manner and are \nexplicitly imported into new class definitions. \nIn previous chapters, you have seen how methods define the interface to the data in a class. \nThrough the use of the interface keyword, Java allows you to fully abstract an interface \nfrom its implementation. Using interface , you can specify a set of methods that can be \nimplemented by one or more classes. In its traditional form, the interface , itself, does not \nactually define any implementation. Although they are similar to abstract classes,",
    "interface s have an additional capability: A class can implement more than one interface. \nBy contrast, a class can only inherit a single superclass ( abstract or otherwise ).",
    "Packages \n\nIn the preceding chapters, the name of each example class was taken from the same name \nspace. This means that a unique name had to be used for each class to avoid name \ncollisions. After a while, without some way to manage the name space, you could run out of \nconvenient, descriptive names for individual classes. You also need some way to be assured \nthat the name you choose for a class will be reasonably unique and not collide with class \nnames chosen by other programmers. ( Imagine a small group of programmers fighting over \nwho gets to use the name \u201cFoobar\u201d as a class name. Or, imagine the entire Internet \ncommunity arguing over who first named a class \u201cEspresso.\u201d) Thankfully, Java provides a \nmechanism for partitioning the class name space into more manageable chunks. This \nmechanism is the package. The package is both a naming and a visibility control \nmechanism. You can define classes inside a package that are not accessible by code outside",
    "that package. You can also define class members that are exposed only to other members of \nthe same package. This allows your classes to have intimate knowledge of each other, but \nnot expose that knowledge to the rest of the world. \n\n\nDefining a Package \n\nTo create a package is quite easy: simply include a package command as the first statement \nin a Java source file. Any classes declared within that file will belong to the specified \npackage. The package statement defines a name space in which classes are stored. If you \nomit the package statement, the class names are put into the default package, which has no \nname. ( This is why you haven\u2019t had to worry about packages before now.) While the default \npackage is fine for short, sample programs, it is inadequate for real applications. Most of the \ntime, you will define a package for your code. \nThis is the general form of the package statement: \n\npackage pkg ;",
    "package pkg ; \n\nHere, pkg is the name of the package. For example, the following statement creates \na package called MyPackage : \n\nJava uses file system directories to store packages. For example, the .class files for any \nclasses you declare to be part of MyPackage must be stored in a directory called \nMyPackage . Remember that case is significant, and the directory name must match the \npackage name exactly. \nMore than one file can include the same package statement. The package statement \nsimply specifies to which package the classes defined in a file belong. It does not exclude \nother classes in other files from being part of that same package. Most real-world packages \nare spread across many files. \nYou can create a hierarchy of packages. To do so, simply separate each package name from \nthe one above it by use of a period. The general form of a multileveled package statement is \nshown here: \n\npackage pkg1 [. pkg2 [. pkg3 ]];",
    "package pkg1 [. pkg2 [. pkg3 ]]; \n\nA package hierarchy must be reflected in the file system of your Java development \nsystem. For example, a package declared as \n\nneeds to be stored in java\\awt\\image in a Windows environment. Be sure to choose your \npackage names carefully. You cannot rename a package without renaming the directory in \nwhich the classes are stored. \n\nFinding Packages and CLASSPATH \n\nAs just explained, packages are mirrored by directories. This raises an important question: \nHow does the Java run-time system know where to look for packages that you create? The \nanswer has three parts. First, by default, the Java run-time system uses the current working",
    "directory as its starting point. Thus, if your package is in a subdirectory of the current \ndirectory, it will be found. Second, you can specify a directory path or paths by setting the \nCLASSPATH environmental variable. Third, you can use the -classpath option with java \nand javac to specify the path to your classes. \nFor example, consider the following package specification: \n\nIn order for a program to find MyPack , one of three things must be true. Either the \nprogram can be executed from a directory immediately above MyPack , or the \nCLASSPATH must be set to include the path to MyPack , or the -classpath option must \nspecify the path to MyPack when the program is run via java . \nWhen the second two options are used, the class path must not include MyPack , itself. It \nmust simply specify the path to MyPack . For example, in a Windows environment, if the \npath to MyPack is \n\nthen the class path to MyPack is",
    "then the class path to MyPack is \n\nThe easiest way to try the examples shown in this book is to simply create the package \ndirectories below your current development directory, put the .class files into the \nappropriate directories, and then execute the programs from the development directory. \nThis is the approach used in the following example. \n\nA Short Package Example \n\nKeeping the preceding discussion in mind, you can try this simple package: \n\n\nCall this file AccountBalance.java and put it in a directory called MyPack . \nNext, compile the file. Make sure that the resulting .class file is also in the MyPack \ndirectory. Then, try executing the AccountBalance class, using the following command \nline:",
    "Remember, you will need to be in the directory above MyPack when you execute this \ncommand. ( Alternatively, you can use one of the other two options described in the \npreceding section to specify the path MyPack .) \nAs explained, AccountBalance is now part of the package MyPack . This means that it \n\ncannot be executed by itself. That is, you cannot use this command line: \n\n\nAccountBalance must be qualified with its package name. \n\nAccess Protection",
    "AccountBalance must be qualified with its package name. \n\nAccess Protection \n\nIn the preceding chapters, you learned about various aspects of Java\u2019s access control \nmechanism and its access modifiers. For example, you already know that access to a \nprivate member of a class is granted only to other members of that class. Packages add \nanother dimension to access control. As you will see, Java provides many levels of \nprotection to allow fine-grained control over the visibility of variables and methods within \nclasses, subclasses, and packages. \nClasses and packages are both means of encapsulating and containing the name space and \nscope of variables and methods. Packages act as containers for classes and other subordinate \npackages. Classes act as containers for data and code. The class is Java\u2019s smallest unit of \nabstraction. Because of the interplay between classes and packages, Java addresses four \ncategories of visibility for class members:",
    "\u2022  Subclasses in the same package \n\n\u2022  Non-subclasses in the same package \n\n\u2022  Subclasses in different packages \n\n\u2022  Classes that are neither in the same package nor subclasses \n\nThe three access modifiers, private , public , and protected , provide a variety of \nways to produce the many levels of access required by these categories. Table 9-1 \nsums up the interactions. \n\nTable 9-1    Class Member Access \n\nWhile Java\u2019s access control mechanism may seem complicated, we can simplify it as follows. \nAnything declared public can be accessed from anywhere. Anything declared private \ncannot be seen outside of its class. When a member does not have an explicit access \nspecification, it is visible to subclasses as well as to other classes in the same package. This \nis the default access. If you want to allow an element to be seen outside your current \n\npackage, but only to classes that subclass your class directly, then declare that element \nprotected .",
    "package, but only to classes that subclass your class directly, then declare that element \nprotected . \n\nTable 9-1 applies only to members of classes. A non-nested class has only two \n\n\npossible access levels: default and public. When a class is declared as public , it is \naccessible by any other code. If a class has default access, then it can only be \naccessed by other code within its same package. When a class is public, it must be \nthe only public class declared in the file, and the file must have the same name as \nthe class. \n\nAn Access Example",
    "The following example shows all combinations of the access control modifiers. This example \nhas two packages and five classes. Remember that the classes for the two different packages \nneed to be stored in directories named after their respective packages\u2014in this case, p1 and \np2 . \nThe source for the first package defines three classes: Protection , Derived , and \nSamePackage . The first class defines four int variables in each of the legal protection \nmodes. The variable n is declared with the default protection, n_pri is private , n_pro is",
    "protected , and n_pub is public . \nEach subsequent class in this example will try to access the variables in an instance of this \nclass. The lines that will not compile due to access restrictions are commented out. Before \neach of these lines is a comment listing the places from which this level of protection would \nallow access. \nThe second class, Derived , is a subclass of Protection in the same package, p1 . This \ngrants Derived access to every variable in Protection except for n_pri , the private one. \nThe third class, SamePackage , is not a subclass of Protection , but is in the same package \nand also has access to all but n_pri . \nThis is file Protection.java :",
    "This is file Derived.java : \n\n\nThis is file SamePackage.java : \n\nFollowing is the source code for the other package, p2 . The two classes defined in p2 cover \nthe other two conditions that are affected by access control. The first class, Protection2 , is \n\na subclass of p1.Protection . This grants access to all of p1.Protection \u2019s variables except \nfor n_pri ( because it is private ) and n , the variable declared with the default protection. \nRemember, the default only allows access from within the class or the package, not \nextrapackage subclasses. Finally, the class OtherPackage has access to only one variable, \nn_pub , which was declared public . \nThis is file Protection2.java : \n\n\nThis is file OtherPackage.java : \n\nIf you want to try these two packages, here are two test files you can use. The one for \npackage p1 is shown here: \n\n\nThe test file for p2 is shown next: \n\nImporting Packages",
    "Given that packages exist and are a good mechanism for compartmentalizing diverse classes \nfrom each other, it is easy to see why all of the built-in Java classes are stored in packages. \nThere are no core Java classes in the unnamed default package ; all of the standard classes \nare stored in some named package. Since classes within packages must be fully qualified \nwith their package name or names, it could become tedious to type in the long dotseparated package path name for every class you want to use. For this reason, Java includes \nthe import statement to bring certain classes, or entire packages, into visibility. Once \nimported, a class can be referred to directly, using only its name. The import statement is a \nconvenience to the programmer and is not technically needed to write a complete Java \nprogram. If you are going to refer to a few dozen classes in your application, however, the \nimport statement will save a lot of typing",
    ". If you are going to refer to a few dozen classes in your application, however, the \nimport statement will save a lot of typing. \nIn a Java source file, import statements occur immediately following the package",
    "statement ( if it exists ) and before any class definitions. This is the general form of the \nimport statement: \n\nimport pkg1 [. pkg2 ].( classname | *); \n\nHere, pkg1 is the name of a top-level package, and pkg2 is the name of a \n\n\nsubordinate package inside the outer package separated by a dot ( . ). There is no \npractical limit on the depth of a package hierarchy, except that imposed by the file \nsystem. Finally, you specify either an explicit classname or a star (*), which \nindicates that the Java compiler should import the entire package. This code \nfragment shows both forms in use:",
    "All of the standard Java classes included with Java are stored in a package called java . The \nbasic language functions are stored in a package inside of the java package called \njava.lang . Normally, you have to import every package or class that you want to use, but \nsince Java is useless without much of the functionality in java.lang , it is implicitly \nimported by the compiler for all programs. This is equivalent to the following line being at \nthe top of all of your programs:",
    "If a class with the same name exists in two different packages that you import using the star \nform, the compiler will remain silent, unless you try to use one of the classes. In that case, \nyou will get a compile-time error and have to explicitly name the class specifying its \npackage. \nIt must be emphasized that the import statement is optional. Any place you use a class \nname, you can use its fully qualified name , which includes its full package hierarchy. For \nexample, this fragment uses an import statement: \n\nThe same example without the import statement looks like this: \n\nIn this version, Date is fully-qualified.",
    "The same example without the import statement looks like this: \n\nIn this version, Date is fully-qualified. \n\nAs shown in Table 9-1, when a package is imported, only those items within the package \ndeclared as public will be available to non-subclasses in the importing code. For example, if \nyou want the Balance class of the package MyPack shown earlier to be available as a \nstandalone class for general use outside of MyPack , then you will need to declare it as \npublic and put it into its own file, as shown here: \n\n\nAs you can see, the Balance class is now public . Also, its constructor and its show ( ) \nmethod are public , too. This means that they can be accessed by any type of code outside \nthe MyPack package. For example, here TestBalance imports MyPack and is then able \nto make use of the Balance class: \n\nAs an experiment, remove the public specifier from the Balance class and then try \n\ncompiling TestBalance . As explained, errors will result. \n\nInterfaces",
    "As an experiment, remove the public specifier from the Balance class and then try \n\ncompiling TestBalance . As explained, errors will result. \n\nInterfaces \n\nUsing the keyword interface , you can fully abstract a class\u2019 interface from its",
    "implementation. That is, using interface , you can specify what a class must do, but not how \nit does it. Interfaces are syntactically similar to classes, but they lack instance variables, and, \nas a general rule, their methods are declared without any body. In practice, this means that \nyou can define interfaces that don\u2019t make assumptions about how they are implemented. \nOnce it is defined, any number of classes can implement an interface . Also, one class can \nimplement any number of interfaces. \nTo implement an interface, a class must provide the complete set of methods required by \nthe interface. However, each class is free to determine the details of its own implementation. \nBy providing the interface keyword, Java allows you to fully utilize the \u201cone interface, \nmultiple methods\u201d aspect of polymorphism. \nInterfaces are designed to support dynamic method resolution at run time",
    ". \nInterfaces are designed to support dynamic method resolution at run time. Normally, in \norder for a method to be called from one class to another, both classes need to be present at \ncompile time so the Java compiler can check to ensure that the method signatures are \ncompatible. This requirement by itself makes for a static and nonextensible classing \nenvironment. Inevitably in a system like this, functionality gets pushed up higher and \nhigher in the class hierarchy so that the mechanisms will be available to more and more \nsubclasses. Interfaces are designed to avoid this problem. They disconnect the definition of \na method or set of methods from the inheritance hierarchy. Since interfaces are in a \ndifferent hierarchy from classes, it is possible for classes that are unrelated in terms of the",
    "class hierarchy to implement the same interface. This is where the real power of interfaces is \nrealized.",
    "Defining an Interface \n\nAn interface is defined much like a class. This is a simplified general form of an interface: \n\nWhen no access modifier is included, then default access results, and the interface is only \navailable to other members of the package in which it is declared. When it is declared as \npublic , the interface can be used by any other code. In this case, the interface must be the \nonly public interface declared in the file, and the file must have the same name as the",
    "interface. name is the name of the interface, and can be any valid identifier. Notice that the \nmethods that are declared have no bodies. They end with a semicolon after the parameter \nlist. They are, essentially, abstract methods. Each class that includes such an interface must \nimplement all of the methods. \nBefore continuing an important point needs to be made. JDK 8 added a feature to",
    "interface that makes a significant change to its capabilities. Prior to JDK 8, an interface \ncould not define any implementation whatsoever. This is the type of interface that the \npreceding simplified form shows, in which no method declaration supplies a body. Thus, \nprior to JDK 8, an interface could define only \u201cwhat,\u201d but not \u201chow.\u201d JDK 8 changes this. \nBeginning with JDK 8, it is possible to add a default implementation to an interface \nmethod. Thus, it is now possible for interface to specify some behavior. However, default \nmethods constitute what is, in essence, a special-use feature, and the original intent behind \ninterface still remains. Therefore, as a general rule, you will still often create and use \ninterfaces in which no default methods exist. For this reason, we will begin by discussing the",
    "interface still remains. Therefore, as a general rule, you will still often create and use \ninterfaces in which no default methods exist. For this reason, we will begin by discussing the \ninterface in its traditional form. The default method is described at the end of this chapter. \nAs the general form shows, variables can be declared inside of interface declarations. They \nare implicitly final and static , meaning they cannot be changed by the implementing class. \nThey must also be initialized. All methods and variables are implicitly public . \nHere is an example of an interface definition. It declares a simple interface that contains \none method called callback ( ) that takes a single integer parameter.",
    "Implementing Interfaces \n\nOnce an interface has been defined, one or more classes can implement that interface. To \n\nimplement an interface, include the implements clause in a class definition, and then \ncreate the methods required by the interface. The general form of a class that includes the \nimplements clause looks like this: \n\nIf a class implements more than one interface, the interfaces are separated with a comma. If \n\na class implements two interfaces that declare the same method, then the same method will \nbe used by clients of either interface. The methods that implement an interface must be \ndeclared public . Also, the type signature of the implementing method must match exactly \n\n\nthe type signature specified in the interface definition. \n\nHere is a small example class that implements the Callback interface shown earlier: \n\nNotice that callback ( ) is declared using the public access modifier.",
    "Here is a small example class that implements the Callback interface shown earlier: \n\nNotice that callback ( ) is declared using the public access modifier. \n\nREMEMBER   When you implement an interface method, it must be \ndeclared as public . \n\nIt is both permissible and common for classes that implement interfaces to define additional \nmembers of their own. For example, the following version of Client implements callback ( \n) and adds the method nonIfaceMeth ( ) : \n\nAccessing Implementations Through Interface References \n\nYou can declare variables as object references that use an interface rather than a class type. \nAny instance of any class that implements the declared interface can be referred to by such",
    "You can declare variables as object references that use an interface rather than a class type. \nAny instance of any class that implements the declared interface can be referred to by such \n\na variable. When you call a method through one of these references, the correct version will \nbe called based on the actual instance of the interface being referred to. This is one of the \nkey features of interfaces. The method to be executed is looked up dynamically at run time, \nallowing classes to be created later than the code which calls methods on them. The calling \n\n\ncode can dispatch through an interface without having to know anything about the \u201ccallee.\u201d \nThis process is similar to using a superclass reference to access a subclass object, as \ndescribed in Chapter 8.",
    "CAUTION   Because dynamic lookup of a method at run time incurs a \nsignificant overhead when compared with the normal method invocation \nin Java, you should be careful not to use interfaces casually in \nperformance-critical code. \n\nThe following example calls the callback ( ) method via an interface reference variable: \n\nThe output of this program is shown here: \n\nNotice that variable c is declared to be of the interface type Callback , yet it was assigned",
    "The output of this program is shown here: \n\nNotice that variable c is declared to be of the interface type Callback , yet it was assigned \n\nan instance of Client . Although c can be used to access the callback ( ) method, it cannot \naccess any other members of the Client class. An interface reference variable has \nknowledge only of the methods declared by its interface declaration. Thus, c could not be \nused to access nonIfaceMeth ( ) since it is defined by Client but not Callback . \nWhile the preceding example shows, mechanically, how an interface reference variable can \naccess an implementation object, it does not demonstrate the polymorphic power of such a \nreference. To sample this usage, first create the second implementation of Callback , shown \nhere: \n\n\nNow, try the following class: \n\nThe output from this program is shown here:",
    "Now, try the following class: \n\nThe output from this program is shown here: \n\nAs you can see, the version of callback ( ) that is called is determined by the type of object \nthat c refers to at run time. While this is a very simple example, you will see another, more \npractical one shortly. \n\nPartial Implementations \nIf a class includes an interface but does not fully implement the methods required by that \ninterface, then that class must be declared as abstract . For example: \n\n\nHere, the class Incomplete does not implement callback ( ) and must be declared as \nabstract . Any class that inherits Incomplete must implement callback ( ) or be declared \nabstract itself. \n\nNested Interfaces",
    "Nested Interfaces \n\nAn interface can be declared a member of a class or another interface. Such an interface is \ncalled a member interface or a nested interface . A nested interface can be declared as \npublic , private , or protected . This differs from a top-level interface, which must either \nbe declared as public or use the default access level, as previously described. When a \nnested interface is used outside of its enclosing scope, it must be qualified by the name of \nthe class or interface of which it is a member. Thus, outside of the class or interface in \nwhich a nested interface is declared, its name must be fully qualified. \nHere is an example that demonstrates a nested interface: \n\n\nNotice that A defines a member interface called NestedIF and that it is declared public . \n\nNext, B implements the nested interface by specifying",
    "Notice that A defines a member interface called NestedIF and that it is declared public . \n\nNext, B implements the nested interface by specifying \n\nNotice that the name is fully qualified by the enclosing class\u2019 name. Inside the main ( ) \nmethod, an A.NestedIF reference called nif is created, and it is assigned a reference to a B \nobject. Because B implements A.NestedIF , this is legal. \n\nApplying Interfaces \n\nTo understand the power of interfaces, let\u2019s look at a more practical example. In earlier \n\nchapters, you developed a class called Stack that implemented a simple fixed-size stack. \nHowever, there are many ways to implement a stack. For example, the stack can be of a \nfixed size or it can be \u201cgrowable.\u201d The stack can also be held in an array, a linked list, a \nbinary tree, and so on. No matter how the stack is implemented, the interface to the stack",
    "remains the same. That is, the methods push ( ) and pop ( ) define the interface to the stack \nindependently of the details of the implementation. Because the interface to a stack is \nseparate from its implementation, it is easy to define a stack interface, leaving it to each \nimplementation to define the specifics. Let\u2019s look at two examples. \nFirst, here is the interface that defines an integer stack. Put this in a file called \nIntStack.java . This interface will be used by both stack implementations. \n\nThe following program creates a class called FixedStack that implements a fixed-length \nversion of an integer stack: \n\n\nFollowing is another implementation of IntStack that creates a dynamic stack by use of the \nsame interface definition. In this implementation, each stack is constructed with an initial \nlength. If this initial length is exceeded, then the stack is increased in size. Each time more \nroom is needed, the size of the stack is doubled.",
    "The following class uses both the FixedStack and DynStack implementations. It does so \nthrough an interface reference. This means that calls to push ( ) and pop ( ) are resolved at \nrun time rather than at compile time. \n\n\nIn this program, mystack is a reference to the IntStack interface. Thus, when it refers to \nds , it uses the versions of push ( ) and pop ( ) defined by the DynStack implementation. \nWhen it refers to fs , it uses the versions of push ( ) and pop ( ) defined by FixedStack . As \nexplained, these determinations are made at run time. Accessing multiple implementations \nof an interface through an interface reference variable is the most powerful way that Java \nachieves run-time polymorphism. \n\nVariables in Interfaces",
    "Variables in Interfaces \n\nYou can use interfaces to import shared constants into multiple classes by simply declaring \nan interface that contains variables that are initialized to the desired values. When you \ninclude that interface in a class ( that is, when you \u201cimplement\u201d the interface ), all of those \nvariable names will be in scope as constants. ( This is similar to using a header file in C/C++ \nto create a large number of #defined constants or const declarations.) If an interface \n\ncontains no methods, then any class that includes such an interface doesn\u2019t actually \nimplement anything. It is as if that class were importing the constant fields into the class \nname space as final variables. The next example uses this technique to implement an \nautomated \u201cdecision maker\u201d:",
    "Notice that this program makes use of one of Java\u2019s standard classes: Random . This class \nprovides pseudorandom numbers. It contains several methods that allow you to obtain \nrandom numbers in the form required by your program. In this example, the method \nnextDouble ( ) is used. It returns random numbers in the range 0.0 to 1.0. \nIn this sample program, the two classes, Question and AskMe , both implement the \n\n\nSharedConstants interface where NO , YES , MAYBE , SOON , LATER , and NEVER \nare defined. Inside each class, the code refers to these constants as if each class had defined \nor inherited them directly. Here is the output of a sample run of this program. Note that the \nresults are different each time it is run. \n\nNOTE The technique of using an interface to define shared constants, as \njust described, is controversial. It is described here for completeness. \n\nInterfaces Can Be Extended",
    "NOTE The technique of using an interface to define shared constants, as \njust described, is controversial. It is described here for completeness. \n\nInterfaces Can Be Extended \n\nOne interface can inherit another by use of the keyword extends . The syntax is the same as \nfor inheriting classes. When a class implements an interface that inherits another interface, \nit must provide implementations for all methods required by the interface inheritance chain. \nFollowing is an example: \n\n\nAs an experiment, you might want to try removing the implementation for meth1 ( ) in \nMyClass . This will cause a compile-time error. As stated earlier, any class that implements \nan interface must implement all methods required by that interface, including any that are \ninherited from other interfaces. \n\nDefault Interface Methods",
    "Default Interface Methods \n\nAs explained earlier, prior to JDK 8, an interface could not define any implementation \nwhatsoever. This meant that for all previous versions of Java, the methods specified by an \ninterface were abstract, containing no body. This is the traditional form of an interface and \nis the type of interface that the preceding discussions have used. The release of JDK 8 has",
    "changed this by adding a new capability to interface called the default method . A default \nmethod lets you define a default implementation for an interface method. In other words, by \nuse of a default method, it is now possible for an interface method to provide a body, rather \nthan being abstract. During its development, the default method was also referred to as an \nextension method , and you will likely see both terms used. \nA primary motivation for the default method was to provide a means by which interfaces \ncould be expanded without breaking existing code. Recall that there must be \nimplementations for all methods defined by an interface. In the past, if a new method were \nadded to a popular, widely used interface, then the addition of that method would break \nexisting code because no implementation would be found for that new method",
    ". In the past, if a new method were \nadded to a popular, widely used interface, then the addition of that method would break \nexisting code because no implementation would be found for that new method. The default \nmethod solves this problem by supplying an implementation that will be used if no other \nimplementation is explicitly provided. Thus, the addition of a default method will not cause \npreexisting code to break. \nAnother motivation for the default method was the desire to specify methods in an interface \nthat are, essentially, optional, depending on how the interface is used. For example, an",
    "interface might define a group of methods that act on a sequence of elements. One of these \nmethods might be called remove ( ) , and its purpose is to remove an element from the \nsequence. However, if the interface is intended to support both modifiable and \nnonmodifiable sequences, then remove ( ) is essentially optional because it won\u2019t be used \nby nonmodifiable sequences. In the past, a class that implemented a nonmodifiable \nsequence would have had to define an empty implementation of remove ( ) , even though it \nwas not needed. Today, a default implementation for remove ( ) can be specified in the",
    "interface that does nothing ( or throws an exception ). Providing this default prevents a class \nused for nonmodifiable sequences from having to define its own, placeholder version of \nremove ( ) . Thus, by providing a default, the interface makes the implementation of \nremove ( ) by a class optional. \nIt is important to point out that the addition of default methods does not change a key \naspect of interface : its inability to maintain state information. An interface still cannot \nhave instance variables, for example. Thus, the defining difference between an interface and \na class is that a class can maintain state information, but an interface cannot. Furthermore, \nit is still not possible to create an instance of an interface by itself. It must be implemented \nby a class. Therefore, even though, beginning with JDK 8, an interface can define default \nmethods, the interface must still be implemented by a class if an instance is to be created",
    ". Therefore, even though, beginning with JDK 8, an interface can define default \nmethods, the interface must still be implemented by a class if an instance is to be created. \nOne last point: As a general rule, default methods constitute a special-purpose feature. \nInterfaces that you create will still be used primarily to specify what and not how . However, \nthe inclusion of the default method gives you added flexibility.",
    "Default Method Fundamentals \n\nAn interface default method is defined similar to the way a method is defined by a class . \nThe primary difference is that the declaration is preceded by the keyword default . For \nexample, consider this simple interface:",
    "MyIF declares two methods. The first, getNumber ( ) , is a standard interface method \ndeclaration. It defines no implementation whatsoever. The second method is getString ( ) , \nand it does include a default implementation. In this case, it simply returns the string \n\"Default String\". Pay special attention to the way getString ( ) is declared. Its declaration is \npreceded by the default modifier. This syntax can be generalized. To define a default \nmethod, precede its declaration with default . \nBecause getString ( ) includes a default implementation, it is not necessary for an \nimplementing class to override it. In other words, if an implementing class does not provide \nits own implementation, the default is used. For example, the MyIFImp class shown next is \nperfectly valid: \n\nThe following code creates an instance of MyIFImp and uses it to call both getNumber ( ) \nand getString ( ) . \n\n\nThe output is shown here:",
    "The following code creates an instance of MyIFImp and uses it to call both getNumber ( ) \nand getString ( ) . \n\n\nThe output is shown here: \n\nAs you can see, the default implementation of getString ( ) was automatically used. It was \nnot necessary for MyIFImp to define it. Thus, for getString ( ) , implementation by a class \nis optional. ( Of course, its implementation by a class will be required if the class uses \ngetString ( ) for some purpose beyond that supported by its default.) \nIt is both possible and common for an implementing class to define its own implementation \nof a default method. For example, MyIFImp2 overrides getString ( ) : \n\nNow, when getString ( ) is called, a different string is returned. \n\nA More Practical Example",
    "Now, when getString ( ) is called, a different string is returned. \n\nA More Practical Example \n\nAlthough the preceding shows the mechanics of using default methods, it doesn\u2019t illustrate \ntheir usefulness in a more practical setting. To do this, let\u2019s once again return to the \nIntStack interface shown earlier in this chapter. For the sake of discussion, assume that \nIntStack is widely used and many programs rely on it. Further assume that we now want to \n\n\nadd a method to IntStack that clears the stack, enabling the stack to be re-used. Thus, we \nwant to evolve the IntStack interface so that it defines new functionality, but we don\u2019t want \nto break any preexisting code. In the past, this would be impossible, but with the inclusion \nof default methods, it is now easy to do. For example, the IntStack interface can be \nenhanced like this:",
    "Here, the default behavior of clear ( ) simply displays a message indicating that it is not \nimplemented. This is acceptable because no preexisting class that implements IntStack \nwould ever call clear ( ) because it was not defined by the earlier version of IntStack . \nHowever, clear ( ) can be implemented by a new class that implements IntStack . \nFurthermore, clear ( ) needs to be defined by a new implementation only if it is used. Thus, \nthe default method gives you \n\n\u2022  a way to gracefully evolve interfaces over time, and \n\n\u2022  a way to provide optional functionality without requiring that a class \nprovide a placeholder implementation when that functionality is not \nneeded. \n\nOne other point: In real-world code, clear ( ) would have thrown an exception,",
    "One other point: In real-world code, clear ( ) would have thrown an exception, \n\nrather than displaying an error message. Exceptions are described in the next \nchapter. After working through that material, you might want to try modifying \nclear ( ) so that its default implementation throws an \nUnsupportedOperationException . \n\nMultiple Inheritance Issues \n\nAs explained earlier in this book, Java does not support the multiple inheritance of classes. \nNow that an interface can include default methods, you might be wondering if an interface \ncan provide a way around this restriction. The answer is, essentially, no. Recall that there is \nstill a key difference between a class and an interface: a class can maintain state information \n\n( especially through the use of instance variables ), but an interface cannot. \nThe preceding notwithstanding, default methods do offer a bit of what one would normally",
    "( especially through the use of instance variables ), but an interface cannot. \nThe preceding notwithstanding, default methods do offer a bit of what one would normally \n\nassociate with the concept of multiple inheritance. For example, you might have a class that",
    "implements two interfaces. If each of these interfaces provides default methods, then some \nbehavior is inherited from both. Thus, to a limited extent, default methods do support \nmultiple inheritance of behavior. As you might guess, in such a situation, it is possible that a \nname conflict will occur. \nFor example, assume that two interfaces called Alpha and Beta are implemented by a class \ncalled MyClass . What happens if both Alpha and Beta provide a method called reset ( ) \nfor which both declare a default implementation? Is the version by Alpha or the version by \nBeta used by MyClass ? Or, consider a situation in which Beta extends Alpha . Which \nversion of the default method is used? Or, what if MyClass provides its own \nimplementation of the method? To handle these and other similar types of situations, Java \ndefines a set of rules that resolves such conflicts. \nFirst, in all cases, a class implementation takes priority over an interface default \nimplementation",
    ". \nFirst, in all cases, a class implementation takes priority over an interface default \nimplementation. Thus, if MyClass provides an override of the reset ( ) default method, \nMyClass \u2019 version is used. This is the case even if MyClass implements both Alpha and \nBeta . In this case, both defaults are overridden by MyClass \u2019 implementation. \nSecond, in cases in which a class implements two interfaces that both have the same default \nmethod, but the class does not override that method, then an error will result. Continuing \nwith the example, if MyClass implements both Alpha and Beta , but does not override \nreset ( ) , then an error will occur. \nIn cases in which one interface inherits another, with both defining a common default \nmethod, the inheriting interface\u2019s version of the method takes precedence. Therefore, \ncontinuing the example, if Beta extends Alpha , then Beta \u2019s version of reset ( ) will be \nused",
    ". Therefore, \ncontinuing the example, if Beta extends Alpha , then Beta \u2019s version of reset ( ) will be \nused. \nIt is possible to explicitly refer to a default implementation in an inherited interface by \nusing a new form of super . Its general form is shown here:",
    "InterfaceName .super. methodName ( ) \n\nFor example, if Beta wants to refer to Alpha \u2019s default for reset ( ) , it can use this \nstatement: \n\nUse static Methods in an Interface \n\nJDK 8 added another new capability to interface : the ability to define one or more static \nmethods. Like static methods in a class, a static method defined by an interface can be \ncalled independently of any object. Thus, no implementation of the interface is necessary, \nand no instance of the interface is required, in order to call a static method. Instead, a \nstatic method is called by specifying the interface name, followed by a period, followed by \nthe method name. Here is the general form: \n\nInterfaceName . staticMethodName \n\n\nNotice that this is similar to the way that a static method in a class is called. \nThe following shows an example of a static method in an interface by adding one to MyIF , \nshown in the previous section. The static method is getDefaultNumber ( ) . It returns \nzero.",
    "The getDefaultNumber ( ) method can be called, as shown here: \n\nAs mentioned, no implementation or instance of MyIF is required to call \ngetDefaultNumber ( ) because it is static . \nOne last point: static interface methods are not inherited by either an implementing class \nor a subinterface. \n\nFinal Thoughts on Packages and Interfaces \n\nAlthough the examples we\u2019ve included in this book do not make frequent use of packages or \ninterfaces, both of these tools are an important part of the Java programming environment. \nVirtually all real programs that you write in Java will be contained within packages. A \nnumber will probably implement interfaces as well. It is important, therefore, that you be \ncomfortable with their usage. \n\n\uf709 \nPREV \nChapter 8: Inheritance \n\u23ee \n\nNEXT \nChapter 10: Exception Handling \u23ed \n\n\n\n\nPREV \nChapter 9: Packages and Interfaces \n\u23ee \n\nNEXT \nChapter 11: Multithreaded Programming \u23ed \n\nCHAPTER \n\n10 \nException Handling",
    "NEXT \nChapter 10: Exception Handling \u23ed \n\n\n\n\nPREV \nChapter 9: Packages and Interfaces \n\u23ee \n\nNEXT \nChapter 11: Multithreaded Programming \u23ed \n\nCHAPTER \n\n10 \nException Handling \n\nThis chapter examines Java\u2019s exception-handling mechanism. An exception is an abnormal \ncondition that arises in a code sequence at run time. In other words, an exception is a \nruntime error. In computer languages that do not support exception handling, errors must \nbe checked and handled manually\u2014typically through the use of error codes, and so on. This \napproach is as cumbersome as it is troublesome. Java\u2019s exception handling avoids these \nproblems and, in the process, brings run-time error management into the object-oriented \nworld. \n\nException-Handling Fundamentals",
    "A Java exception is an object that describes an exceptional ( that is, error ) condition that has \noccurred in a piece of code. When an exceptional condition arises, an object representing \nthat exception is created and thrown in the method that caused the error. That method may \nchoose to handle the exception itself, or pass it on. Either way, at some point, the exception \nis caught and processed. Exceptions can be generated by the Java run-time system, or they \ncan be manually generated by your code. Exceptions thrown by Java relate to fundamental \nerrors that violate the rules of the Java language or the constraints of the Java execution \nenvironment. Manually generated exceptions are typically used to report some error \ncondition to the caller of a method. \nJava exception handling is managed via five keywords: try , catch , throw , throws , and \nfinally . Briefly, here is how they work. Program statements that you want to monitor for \nexceptions are contained within a try block",
    ". Briefly, here is how they work. Program statements that you want to monitor for \nexceptions are contained within a try block. If an exception occurs within the try block, it is \nthrown. Your code can catch this exception ( using catch ) and handle it in some rational \nmanner. System-generated exceptions are automatically thrown by the Java runtime",
    "system. To manually throw an exception, use the keyword throw . Any exception that is \nthrown out of a method must be specified as such by a throws clause. Any code that \nabsolutely must be executed after a try block completes is put in a finally block. \nThis is the general form of an exception-handling block: \n\n\nHere, ExceptionType is the type of exception that has occurred. The remainder of this \nchapter describes how to apply this framework. \n\nNOTE    Beginning with JDK 7, there is another form of the try statement \nthat supports automatic resource management . This form of try , called \ntry - with-resources , is described in Chapter 13 in the context of managing \n\nfiles because files are some of the most commonly used resources. \n\nException Types \n\nAll exception types are subclasses of the built-in class Throwable . Thus, Throwable is at",
    "files because files are some of the most commonly used resources. \n\nException Types \n\nAll exception types are subclasses of the built-in class Throwable . Thus, Throwable is at \n\nthe top of the exception class hierarchy. Immediately below Throwable are two subclasses \nthat partition exceptions into two distinct branches. One branch is headed by Exception . \nThis class is used for exceptional conditions that user programs should catch. This is also",
    "the class that you will subclass to create your own custom exception types. There is an \nimportant subclass of Exception , called RuntimeException . Exceptions of this type are \nautomatically defined for the programs that you write and include things such as division by \nzero and invalid array indexing. \nThe other branch is topped by Error , which defines exceptions that are not expected to be \ncaught under normal circumstances by your program. Exceptions of type Error are used by \nthe Java run-time system to indicate errors having to do with the run-time environment, \n\n\nitself. Stack overflow is an example of such an error. This chapter will not be dealing with \nexceptions of type Error , because these are typically created in response to catastrophic \nfailures that cannot usually be handled by your program. \nThe top-level exception hierarchy is shown here: \n\nUncaught Exceptions",
    "Uncaught Exceptions \n\nBefore you learn how to handle exceptions in your program, it is useful to see what happens \nwhen you don\u2019t handle them. This small program includes an expression that intentionally \ncauses a divide-by-zero error: \n\nWhen the Java run-time system detects the attempt to divide by zero, it constructs a new \n\nexception object and then throws this exception. This causes the execution of Exc0 to stop, \nbecause once an exception has been thrown, it must be caught by an exception handler and \ndealt with immediately. In this example, we haven\u2019t supplied any exception handlers of our",
    "own, so the exception is caught by the default handler provided by the Java run-time \nsystem. Any exception that is not caught by your program will ultimately be processed by \nthe default handler. The default handler displays a string describing the exception, prints a \nstack trace from the point at which the exception occurred, and terminates the program. \nHere is the exception generated when this example is executed:",
    "Notice how the class name, Exc0 ; the method name, main ; the filename, Exc0.java ; and \nthe line number, 4 , are all included in the simple stack trace. Also, notice that the type of \nexception thrown is a subclass of Exception called ArithmeticException , which more \nspecifically describes what type of error happened. As discussed later in this chapter, Java \nsupplies several built-in exception types that match the various sorts of run-time errors that \ncan be generated. \nThe stack trace will always show the sequence of method invocations that led up to the \nerror. For example, here is another version of the preceding program that introduces the \nsame error but in a method separate from main ( ) : \n\nThe resulting stack trace from the default exception handler shows how the entire call stack \nis displayed: \n\nAs you can see, the bottom of the stack is main \u2019s line 7, which is the call to subroutine ( ) ,",
    "As you can see, the bottom of the stack is main \u2019s line 7, which is the call to subroutine ( ) , \n\nwhich caused the exception at line 4. The call stack is quite useful for debugging, because it \npinpoints the precise sequence of steps that led to the error. \n\nUsing try and catch \n\nAlthough the default exception handler provided by the Java run-time system is useful for \ndebugging, you will usually want to handle an exception yourself. Doing so provides two \nbenefits. First, it allows you to fix the error. Second, it prevents the program from \nautomatically terminating. Most users would be confused ( to say the least ) if your program \nstopped running and printed a stack trace whenever an error occurred! Fortunately, it is \n\nquite easy to prevent this.",
    "quite easy to prevent this. \n\n\nTo guard against and handle a run-time error, simply enclose the code that you want to \nmonitor inside a try block. Immediately following the try block, include a catch clause that \nspecifies the exception type that you wish to catch. To illustrate how easily this can be done, \nthe following program includes a try block and a catch clause that processes the \nArithmeticException generated by the division-by-zero error: \n\nThis program generates the following output:",
    "Notice that the call to println ( ) inside the try block is never executed. Once an exception \nis thrown, program control transfers out of the try block into the catch block. Put \ndifferently, catch is not \u201ccalled,\u201d so execution never \u201creturns\u201d to the try block from a \ncatch . Thus, the line \"This will not be printed.\" is not displayed. Once the catch statement \nhas executed, program control continues with the next line in the program following the \nentire try / catch mechanism. \nA try and its catch statement form a unit. The scope of the catch clause is restricted to \nthose statements specified by the immediately preceding try statement. A catch statement \ncannot catch an exception thrown by another try statement ( except in the case of nested try \nstatements, described shortly ). The statements that are protected by try must be \nsurrounded by curly braces. ( That is, they must be within a block.) You cannot use try on a \nsingle statement",
    ". The statements that are protected by try must be \nsurrounded by curly braces. ( That is, they must be within a block.) You cannot use try on a \nsingle statement. \nThe goal of most well-constructed catch clauses should be to resolve the exceptional \ncondition and then continue on as if the error had never happened. For example, in the next \nprogram each iteration of the for loop obtains two random integers. Those two integers are",
    "divided by each other, and the result is used to divide the value 12345. The final result is put \ninto a . If either division operation causes a divide-by-zero error, it is caught, the value of a \nis set to zero, and the program continues. \n\n\nDisplaying a Description of an Exception \n\nThrowable overrides the toString ( ) method ( defined by Object ) so that it returns a \nstring containing a description of the exception. You can display this description in a \nprintln ( ) statement by simply passing the exception as an argument. For example, the \ncatch block in the preceding program can be rewritten like this: \n\nWhen this version is substituted in the program, and the program is run, each divide-byzero error displays the following message: \n\nWhile it is of no particular value in this context, the ability to display a description of an \n\nexception is valuable in other circumstances\u2014particularly when you are experimenting with \nexceptions or when you are debugging.",
    "exception is valuable in other circumstances\u2014particularly when you are experimenting with \nexceptions or when you are debugging. \n\nMultiple catch Clauses \n\n\nIn some cases, more than one exception could be raised by a single piece of code. To handle \nthis type of situation, you can specify two or more catch clauses, each catching a different \ntype of exception. When an exception is thrown, each catch statement is inspected in order, \nand the first one whose type matches that of the exception is executed. After one catch \nstatement executes, the others are bypassed, and execution continues after the try / catch \nblock. The following example traps two different exception types:",
    "This program will cause a division-by-zero exception if it is started with no command-line \narguments, since a will equal zero. It will survive the division if you provide a command-line \nargument, setting a to something larger than zero. But it will cause an \nArrayIndexOutOfBoundsException , since the int array c has a length of 1, yet the \nprogram attempts to assign a value to c[42] . \nHere is the output generated by running it both ways: \n\nWhen you use multiple catch statements, it is important to remember that exception \nsubclasses must come before any of their superclasses. This is because a catch statement \n\n\nthat uses a superclass will catch exceptions of that type plus any of its subclasses. Thus, a \nsubclass would never be reached if it came after its superclass. Further, in Java, unreachable \ncode is an error. For example, consider the following program: \n\nIf you try to compile this program, you will receive an error message stating that the second",
    "If you try to compile this program, you will receive an error message stating that the second \n\ncatch statement is unreachable because the exception has already been caught. Since \nArithmeticException is a subclass of Exception , the first catch statement will handle \nall Exception -based errors, including ArithmeticException . This means that the second \ncatch statement will never execute. To fix the problem, reverse the order of the catch \nstatements. \n\nNested try Statements \n\nThe try statement can be nested. That is, a try statement can be inside the block of another \ntry . Each time a try statement is entered, the context of that exception is pushed on the \nstack. If an inner try statement does not have a catch handler for a particular exception, \nthe stack is unwound and the next try statement\u2019s catch handlers are inspected for a",
    "match. This continues until one of the catch statements succeeds, or until all of the nested \ntry statements are exhausted. If no catch statement matches, then the Java run-time \nsystem will handle the exception. Here is an example that uses nested try statements: \n\n\nAs you can see, this program nests one try block within another. The program works as \n\nfollows. When you execute the program with no command-line arguments, a divide-by-zero \nexception is generated by the outer try block. Execution of the program with one commandline argument generates a divide-by-zero exception from within the nested try block. Since \nthe inner block does not catch this exception, it is passed on to the outer try block, where it \nis handled. If you execute the program with two command-line arguments, an array \n\nboundary exception is generated from within the inner try block. Here are sample runs that \nillustrate each case:",
    "boundary exception is generated from within the inner try block. Here are sample runs that \nillustrate each case: \n\n\nNesting of try statements can occur in less obvious ways when method calls are involved. \nFor example, you can enclose a call to a method within a try block. Inside that method is \nanother try statement. In this case, the try within the method is still nested inside the outer \ntry block, which calls the method. Here is the previous program recoded so that the nested \ntry block is moved inside the method nesttry ( ) : \n\n\nThe output of this program is identical to that of the preceding example. \n\nthrow \n\nSo far, you have only been catching exceptions that are thrown by the Java run-time system. \nHowever, it is possible for your program to throw an exception explicitly, using the throw \nstatement. The general form of throw is shown here: \n\nthrow ThrowableInstance ; \n\nHere, ThrowableInstance must be an object of type Throwable or a subclass of",
    "throw ThrowableInstance ; \n\nHere, ThrowableInstance must be an object of type Throwable or a subclass of \n\nThrowable . Primitive types, such as int or char , as well as non- Throwable \nclasses, such as String and Object , cannot be used as exceptions. There are two",
    "Throwable . Primitive types, such as int or char , as well as non- Throwable \nclasses, such as String and Object , cannot be used as exceptions. There are two \n\n\nways you can obtain a Throwable object: using a parameter in a catch clause or \ncreating one with the new operator. \nThe flow of execution stops immediately after the throw statement ; any subsequent \nstatements are not executed. The nearest enclosing try block is inspected to see if it has a \ncatch statement that matches the type of exception. If it does find a match, control is \ntransferred to that statement. If not, then the next enclosing try statement is inspected, and \nso on. If no matching catch is found, then the default exception handler halts the program \nand prints the stack trace. \nHere is a sample program that creates and throws an exception. The handler that catches \nthe exception rethrows it to the outer handler.",
    "This program gets two chances to deal with the same error. First, main ( ) sets up an \nexception context and then calls demoproc ( ) . The demoproc ( ) method then sets up \nanother exception-handling context and immediately throws a new instance of \nNullPointerException , which is caught on the next line. The exception is then rethrown. \nHere is the resulting output: \n\nThe program also illustrates how to create one of Java\u2019s standard exception objects. Pay \nclose attention to this line: \n\n\nHere, new is used to construct an instance of NullPointerException . Many of Java\u2019s \nbuilt-in run-time exceptions have at least two constructors: one with no parameter and one \nthat takes a string parameter. When the second form is used, the argument specifies a string \nthat describes the exception. This string is displayed when the object is used as an argument \nto print ( ) or println ( ) . It can also be obtained by a call to getMessage ( ) , which is \ndefined by Throwable . \n\nthrows",
    "throws \n\nIf a method is capable of causing an exception that it does not handle, it must specify this \nbehavior so that callers of the method can guard themselves against that exception. You do \nthis by including a throws clause in the method\u2019s declaration. A throws clause lists the \ntypes of exceptions that a method might throw. This is necessary for all exceptions, except \nthose of type Error or RuntimeException , or any of their subclasses. All other \nexceptions that a method can throw must be declared in the throws clause. If they are not, \na compile-time error will result. \nThis is the general form of a method declaration that includes a throws clause: \n\nHere, exception-list is a comma-separated list of the exceptions that a method can throw. \n\nFollowing is an example of an incorrect program that tries to throw an exception that it \ndoes not catch. Because the program does not specify a throws clause to declare this fact, \nthe program will not compile.",
    "To make this example compile, you need to make two changes. First, you need to declare \nthat throwOne ( ) throws IllegalAccessException . Second, main ( ) must define a try / \n\n\ncatch statement that catches this exception. \nThe corrected example is shown here: \n\nHere is the output generated by running this example program: \n\nfinally",
    "When exceptions are thrown, execution in a method takes a rather abrupt, nonlinear path \nthat alters the normal flow through the method. Depending upon how the method is coded, \nit is even possible for an exception to cause the method to return prematurely. This could be \na problem in some methods. For example, if a method opens a file upon entry and closes it \nupon exit, then you will not want the code that closes the file to be bypassed by the \nexception-handling mechanism. The finally keyword is designed to address this \ncontingency. \nfinally creates a block of code that will be executed after a try / catch block has completed \nand before the code following the try/catch block. The finally block will execute whether \nor not an exception is thrown. If an exception is thrown, the finally block will execute even \nif no catch statement matches the exception",
    ". The finally block will execute whether \nor not an exception is thrown. If an exception is thrown, the finally block will execute even \nif no catch statement matches the exception. Any time a method is about to return to the \ncaller from inside a try/catch block, via an uncaught exception or an explicit return \nstatement, the finally clause is also executed just before the method returns. This can be \nuseful for closing file handles and freeing up any other resources that might have been",
    "allocated at the beginning of a method with the intent of disposing of them before returning. \nThe finally clause is optional. However, each try statement requires at least one catch or a \nfinally clause. \nHere is an example program that shows three methods that exit in various ways, none \nwithout executing their finally clauses: \n\n\nIn this example, procA ( ) prematurely breaks out of the try by throwing an exception. The \nfinally clause is executed on the way out. procB ( ) \u2019s try statement is exited via a return \nstatement. The finally clause is executed before procB ( ) returns. In procC ( ) , the try \nstatement executes normally, without error. However, the finally block is still executed. \n\n\nREMEMBER   If a finally block is associated with a try , the finally \nblock will be executed upon conclusion of the try . \n\nHere is the output generated by the preceding program: \n\nJava\u2019s Built-in Exceptions",
    "Here is the output generated by the preceding program: \n\nJava\u2019s Built-in Exceptions \n\nInside the standard package java.lang , Java defines several exception classes. A few have \nbeen used by the preceding examples. The most general of these exceptions are subclasses of \nthe standard type RuntimeException . As previously explained, these exceptions need not \nbe included in any method\u2019s throws list. In the language of Java, these are called \nunchecked exceptions because the compiler does not check to see if a method handles or \nthrows these exceptions. The unchecked exceptions defined in java.lang are listed in Table \n10-1. Table 10-2 lists those exceptions defined by java.lang that must be included in a \n\nmethod\u2019s throws list if that method can generate one of these exceptions and does not \nhandle it itself. These are called checked exceptions . In addition to the exceptions in \njava.lang , Java defines several more that relate to its other standard packages.",
    "Table 10-1    Java\u2019s Unchecked RuntimeException Subclasses Defined \nin java.lang \n\nTable 10-2    Java\u2019s Checked Exceptions Defined in java.lang \n\nCreating Your Own Exception Subclasses \n\nAlthough Java\u2019s built-in exceptions handle most common errors, you will probably want to \ncreate your own exception types to handle situations specific to your applications. This is \nquite easy to do: just define a subclass of Exception ( which is, of course, a subclass of \nThrowable ). Your subclasses don\u2019t need to actually implement anything\u2014it is their \nexistence in the type system that allows you to use them as exceptions. \n\nThe Exception class does not define any methods of its own. It does, of course, inherit \nthose methods provided by Throwable . Thus, all exceptions, including those that you",
    "The Exception class does not define any methods of its own. It does, of course, inherit \nthose methods provided by Throwable . Thus, all exceptions, including those that you \n\n\ncreate, have the methods defined by Throwable available to them. They are shown in \nTable 10-3. You may also wish to override one or more of these methods in exception \nclasses that you create. \n\nTable 10-3    The Methods Defined by Throwable \n\nException defines four public constructors. Two support chained exceptions, described in \nthe next section. The other two are shown here: \n\nException ( ) \nException ( String msg ) \n\nThe first form creates an exception that has no description. The second form lets \nyou specify a description of the exception. \nAlthough specifying a description when an exception is created is often useful, sometimes it \nis better to override toString ( ) . Here\u2019s why: The version of toString ( ) defined by",
    "Throwable ( and inherited by Exception ) first displays the name of the exception followed \nby a colon, which is then followed by your description. By overriding toString ( ) , you can \nprevent the exception name and colon from being displayed. This makes for a cleaner \noutput, which is desirable in some cases. \nThe following example declares a new subclass of Exception and then uses that subclass to \nsignal an error condition in a method. It overrides the toString ( ) method, allowing a \ncarefully tailored description of the exception to be displayed.",
    "This example defines a subclass of Exception called MyException . This subclass is quite \nsimple: It has only a constructor plus an overridden toString ( ) method that displays the \nvalue of the exception. The ExceptionDemo class defines a method named compute ( ) \nthat throws a MyException object. The exception is thrown when compute ( ) \u2019s integer \nparameter is greater than 10. The main ( ) method sets up an exception handler for \nMyException , then calls compute ( ) with a legal value ( less than 10 ) and an illegal one to \n\n\nshow both paths through the code. Here is the result: \n\nChained Exceptions",
    "Chained Exceptions \n\nBeginning with JDK 1.4, a feature was incorporated into the exception subsystem: chained \nexceptions . The chained exception feature allows you to associate another exception with an \nexception. This second exception describes the cause of the first exception. For example, \nimagine a situation in which a method throws an ArithmeticException because of an \nattempt to divide by zero. However, the actual cause of the problem was that an I/O error \noccurred, which caused the divisor to be set improperly. Although the method must \ncertainly throw an ArithmeticException , since that is the error that occurred, you might \nalso want to let the calling code know that the underlying cause was an I/O error. Chained \nexceptions let you handle this, and any other situation in which layers of exceptions exist. \nTo allow chained exceptions, two constructors and two methods were added to Throwable . \nThe constructors are shown here:",
    "Throwable ( Throwable causeExc ) \nThrowable ( String msg , Throwable causeExc ) \n\nIn the first form, causeExc is the exception that causes the current exception. That \nis, causeExc is the underlying reason that an exception occurred. The second form \nallows you to specify a description at the same time that you specify a cause \nexception. These two constructors have also been added to the Error , Exception , \nand RuntimeException classes. \nThe chained exception methods supported by Throwable are getCause ( ) and \ninitCause ( ) . These methods are shown in Table 10-3 and are repeated here for the sake of \ndiscussion. \n\nThrowable getCause ( ) \n\nThrowable initCause ( Throwable causeExc ) \n\nThe getCause ( ) method returns the exception that underlies the current",
    "Throwable getCause ( ) \n\nThrowable initCause ( Throwable causeExc ) \n\nThe getCause ( ) method returns the exception that underlies the current \n\nexception. If there is no underlying exception, null is returned. The initCause ( ) \nmethod associates causeExc with the invoking exception and returns a reference to \nthe exception. Thus, you can associate a cause with an exception after the \nexception has been created. However, the cause exception can be set only once. \nThus, you can call initCause ( ) only once for each exception object. Furthermore, \nif the cause exception was set by a constructor, then you can\u2019t set it again using \ninitCause ( ) . In general, initCause ( ) is used to set a cause for legacy exception \n\n\nclasses that don\u2019t support the two additional constructors described earlier. \nHere is an example that illustrates the mechanics of handling chained exceptions: \n\nThe output from the program is shown here:",
    "The output from the program is shown here: \n\nIn this example, the top-level exception is NullPointerException . To it is added a cause \n\nexception, ArithmeticException . When the exception is thrown out of demoproc ( ) , it \nis caught by main ( ) . There, the top-level exception is displayed, followed by the underlying \n\nexception, which is obtained by calling getCause ( ) . \nChained exceptions can be carried on to whatever depth is necessary. Thus, the cause \nexception can, itself, have a cause. Be aware that overly long chains of exceptions may \nindicate poor design. \nChained exceptions are not something that every program will need. However, in cases in \nwhich knowledge of an underlying cause is useful, they offer an elegant solution. \n\n\nThree Recently Added Exception Features",
    "Beginning with JDK 7, three interesting and useful features have been added to the \nexception system. The first automates the process of releasing a resource, such as a file, \nwhen it is no longer needed. It is based on an expanded form of the try statement called \ntry -with-resources , and is described in Chapter 13 when files are introduced. The second \nfeature is called multi-catch , and the third is sometimes referred to as final rethrow or \nmore precise rethrow . These two features are described here. \nThe multi-catch feature allows two or more exceptions to be caught by the same catch \nclause. It is not uncommon for two or more exception handlers to use the same code \nsequence even though they respond to different exceptions. Instead of having to catch each \nexception type individually, you can use a single catch clause to handle all of the exceptions \nwithout code duplication. \nTo use a multi-catch, separate each exception type in the catch clause with the OR \noperator",
    ". \nTo use a multi-catch, separate each exception type in the catch clause with the OR \noperator. Each multi-catch parameter is implicitly final . ( You can explicitly specify final , if \ndesired, but it is not necessary.) Because each multi-catch parameter is implicitly final , it \ncan\u2019t be assigned a new value. \nHere is a catch statement that uses the multi-catch feature to catch both \nArithmeticException and ArrayIndexOutOfBoundsException :",
    "The following program shows the multi-catch feature in action: \n\nThe program will generate an ArithmeticException when the division by zero is \nattempted. If you comment out the division statement and remove the comment symbol \nfrom the next line, an ArrayIndexOutOfBoundsException is generated. Both \n\n\nexceptions are caught by the single catch statement. \nThe more precise rethrow feature restricts the type of exceptions that can be rethrown to \nonly those checked exceptions that the associated try block throws, that are not handled by \na preceding catch clause, and that are a subtype or supertype of the parameter. Although \nthis capability might not be needed often, it is now available for use. For the more precise \nrethrow feature to be in force, the catch parameter must be either effectively final , which \nmeans that it must not be assigned a new value inside the catch block, or explicitly \ndeclared final . \n\nUsing Exceptions",
    "Using Exceptions \n\nException handling provides a powerful mechanism for controlling complex programs that \nhave many dynamic run-time characteristics. It is important to think of try , throw , and \ncatch as clean ways to handle errors and unusual boundary conditions in your program\u2019s \nlogic. Unlike some other languages in which error return codes are used to indicate failure, \nJava uses exceptions. Thus, when a method can fail, have it throw an exception. This is a \ncleaner way to handle failure modes. \nOne last point: Java\u2019s exception-handling statements should not be considered a general \nmechanism for nonlocal branching. If you do so, it will only confuse your code and make it \nhard to maintain. \n\n\uf709 \nPREV \nChapter 9: Packages and Interfaces \n\u23ee \n\nNEXT \nChapter 11: Multithreaded Programming \u23ed \n\n\nPREV \nChapter 10: Exception Handling \n\u23ee \n\nNEXT \nChapter 12: Enumerations, Autoboxing, and Ann\u2026 \u23ed \n\nCHAPTER \n\n11 \nMultithreaded Programming",
    "Java provides built-in support for multithreaded programming . A multithreaded program \ncontains two or more parts that can run concurrently. Each part of such a program is called \na thread , and each thread defines a separate path of execution. Thus, multithreading is a \nspecialized form of multitasking. \nYou are almost certainly acquainted with multitasking because it is supported by virtually \nall modern operating systems. However, there are two distinct types of multitasking: \nprocess-based and thread-based. It is important to understand the difference between the \ntwo. For many readers, process-based multitasking is the more familiar form. A process is, \nin essence, a program that is executing. Thus, process-based multitasking is the feature that \nallows your computer to run two or more programs concurrently. For example, processbased multitasking enables you to run the Java compiler at the same time that you are using \na text editor or visiting a web site",
    ". For example, processbased multitasking enables you to run the Java compiler at the same time that you are using \na text editor or visiting a web site. In process-based multitasking, a program is the smallest \nunit of code that can be dispatched by the scheduler. \nIn a thread-based multitasking environment, the thread is the smallest unit of dispatchable \ncode. This means that a single program can perform two or more tasks simultaneously. For \ninstance, a text editor can format text at the same time that it is printing, as long as these \ntwo actions are being performed by two separate threads. Thus, process-based multitasking \ndeals with the \u201cbig picture,\u201d and thread-based multitasking handles the details. \nMultitasking threads require less overhead than multitasking processes. Processes are \nheavyweight tasks that require their own separate address spaces. Interprocess \ncommunication is expensive and limited. Context switching from one process to another is \nalso costly",
    ". Processes are \nheavyweight tasks that require their own separate address spaces. Interprocess \ncommunication is expensive and limited. Context switching from one process to another is \nalso costly. Threads, on the other hand, are lighter weight. They share the same address \nspace and cooperatively share the same heavyweight process. Interthread communication is",
    "inexpensive, and context switching from one thread to the next is lower in cost. While Java \nprograms make use of process-based multitasking environments, process-based \nmultitasking is not under Java\u2019s control. However, multithreaded multitasking is. \nMultithreading enables you to write efficient programs that make maximum use of the \nprocessing power available in the system. One important way multithreading achieves this is \nby keeping idle time to a minimum. This is especially important for the interactive, \n\n\nnetworked environment in which Java operates because idle time is common. For example,",
    "networked environment in which Java operates because idle time is common. For example, \n\nthe transmission rate of data over a network is much slower than the rate at which the \ncomputer can process it. Even local file system resources are read and written at a much \nslower pace than they can be processed by the CPU. And, of course, user input is much \nslower than the computer. In a single-threaded environment, your program has to wait for \neach of these tasks to finish before it can proceed to the next one\u2014even though most of the \ntime the program is idle, waiting for input. Multithreading helps you reduce this idle time \nbecause another thread can run when one is waiting. \nIf you have programmed for operating systems such as Windows, then you are already \nfamiliar with multithreaded programming. However, the fact that Java manages threads \nmakes multithreading especially convenient because many of the details are handled for \nyou. \n\nThe Java Thread Model",
    "The Java run-time system depends on threads for many things, and all the class libraries \nare designed with multithreading in mind. In fact, Java uses threads to enable the entire \nenvironment to be asynchronous. This helps reduce inefficiency by preventing the waste of \nCPU cycles. \nThe value of a multithreaded environment is best understood in contrast to its counterpart. \nSingle-threaded systems use an approach called an event loop with polling . In this model, a \nsingle thread of control runs in an infinite loop, polling a single event queue to decide what \nto do next. Once this polling mechanism returns with, say, a signal that a network file is \nready to be read, then the event loop dispatches control to the appropriate event handler. \nUntil this event handler returns, nothing else can happen in the program. This wastes CPU \ntime. It can also result in one part of a program dominating the system and preventing any \nother events from being processed",
    ". This wastes CPU \ntime. It can also result in one part of a program dominating the system and preventing any \nother events from being processed. In general, in a single-threaded environment, when a \nthread blocks ( that is, suspends execution ) because it is waiting for some resource, the \nentire program stops running. \nThe benefit of Java\u2019s multithreading is that the main loop/polling mechanism is eliminated. \nOne thread can pause without stopping other parts of your program. For example, the idle \ntime created when a thread reads data from a network or waits for user input can be \nutilized elsewhere. Multithreading allows animation loops to sleep for a second between \neach frame without causing the whole system to pause. When a thread blocks in a Java \nprogram, only the single thread that is blocked pauses. All other threads continue to run. \nAs most readers know, over the past few years, multi-core systems have become \ncommonplace",
    ". All other threads continue to run. \nAs most readers know, over the past few years, multi-core systems have become \ncommonplace. Of course, single-core systems are still in widespread use. It is important to \nunderstand that Java\u2019s multithreading features work in both types of systems. In a singlecore system, concurrently executing threads share the CPU, with each thread receiving a \nslice of CPU time. Therefore, in a single-core system, two or more threads do not actually \nrun at the same time, but idle CPU time is utilized. However, in multi-core systems, it is",
    "possible for two or more threads to actually execute simultaneously. In many cases, this can \n\n\nfurther improve program efficiency and increase the speed of certain operations. \n\nNOTE    Recently, the Fork/Join Framework was added to Java. It \nprovides a powerful means of creating multithreaded applications that \nautomatically scale to make best use of multi-core environments. The \nFork/Join Framework is part of Java\u2019s support for parallel \nprogramming , which is the name commonly given to the techniques that \noptimize some types of algorithms for parallel execution in systems that \nhave more than one CPU. For a discussion of the Fork/Join Framework \nand other concurrency utilities, see Chapter 28. Java\u2019s traditional \nmultithreading capabilities are described here.",
    "Threads exist in several states. Here is a general description. A thread can be running . It \ncan be ready to run as soon as it gets CPU time. A running thread can be suspended , which \ntemporarily halts its activity. A suspended thread can then be resumed , allowing it to pick \nup where it left off. A thread can be blocked when waiting for a resource. At any time, a \nthread can be terminated, which halts its execution immediately. Once terminated, a thread \ncannot be resumed. \n\nThread Priorities",
    "Thread Priorities \n\nJava assigns to each thread a priority that determines how that thread should be treated \nwith respect to the others. Thread priorities are integers that specify the relative priority of \none thread to another. As an absolute value, a priority is meaningless ; a higher-priority \nthread doesn\u2019t run any faster than a lower-priority thread if it is the only thread running. \nInstead, a thread\u2019s priority is used to decide when to switch from one running thread to the \nnext. This is called a context switch . The rules that determine when a context switch takes \nplace are simple: \n\n\u2022   A thread can voluntarily relinquish control . This is done by explicitly \nyielding, sleeping, or blocking on pending I/O. In this scenario, all other \nthreads are examined, and the highest-priority thread that is ready to run is \n\ngiven the CPU. \n\n\u2022   A thread can be preempted by a higher-priority thread . In this case, a",
    "given the CPU. \n\n\u2022   A thread can be preempted by a higher-priority thread . In this case, a \n\nlower-priority thread that does not yield the processor is simply preempted \n\u2014no matter what it is doing\u2014 by a higher-priority thread. Basically, as soon \nas a higher-priority thread wants to run, it does. This is called preemptive \nmultitasking . \n\n\nIn cases where two threads with the same priority are competing for CPU cycles, \nthe situation is a bit complicated. For operating systems such as Windows, threads \nof equal priority are time-sliced automatically in round-robin fashion. For other \ntypes of operating systems, threads of equal priority must voluntarily yield control \nto their peers. If they don\u2019t, the other threads will not run. \n\nCAUTION   Portability problems can arise from the differences in the way \nthat operating systems context-switch threads of equal priority. \n\nSynchronization",
    "Because multithreading introduces an asynchronous behavior to your programs, there must \nbe a way for you to enforce synchronicity when you need it. For example, if you want two \nthreads to communicate and share a complicated data structure, such as a linked list, you \nneed some way to ensure that they don\u2019t conflict with each other. That is, you must prevent \none thread from writing data while another thread is in the middle of reading it. For this \npurpose, Java implements an elegant twist on an age-old model of interprocess \nsynchronization: the monitor . The monitor is a control mechanism first defined by C.A.R. \nHoare. You can think of a monitor as a very small box that can hold only one thread. Once a \nthread enters a monitor, all other threads must wait until that thread exits the monitor. In \nthis way, a monitor can be used to protect a shared asset from being manipulated by more \nthan one thread at a time",
    ". In \nthis way, a monitor can be used to protect a shared asset from being manipulated by more \nthan one thread at a time. \nIn Java, there is no class \u201cMonitor\u201d; instead, each object has its own implicit monitor that is \nautomatically entered when one of the object\u2019s synchronized methods is called. Once a \nthread is inside a synchronized method, no other thread can call any other synchronized \nmethod on the same object. This enables you to write very clear and concise multithreaded \ncode, because synchronization support is built into the language.",
    "Messaging \n\nAfter you divide your program into separate threads, you need to define how they will \ncommunicate with each other. When programming with some other languages, you must \n\ndepend on the operating system to establish communication between threads. This, of \ncourse, adds overhead. By contrast, Java provides a clean, low-cost way for two or more \nthreads to talk to each other, via calls to predefined methods that all objects have. Java\u2019s \nmessaging system allows a thread to enter a synchronized method on an object, and then \nwait there until some other thread explicitly notifies it to come out. \n\nThe Thread Class and the Runnable Interface",
    "The Thread Class and the Runnable Interface \n\n\nJava\u2019s multithreading system is built upon the Thread class, its methods, and its \ncompanion interface, Runnable . Thread encapsulates a thread of execution. Since you \ncan\u2019t directly refer to the ethereal state of a running thread, you will deal with it through its \nproxy, the Thread instance that spawned it. To create a new thread, your program will \neither extend Thread or implement the Runnable interface. \nThe Thread class defines several methods that help manage threads. Several of those used \nin this chapter are shown here: \n\nMethod \nMeaning \n\ngetName \nObtain a thread\u2019s name. \n\ngetPriority \nObtain a thread\u2019s priority. \n\nisAlive \nDetermine if a thread is still running. \n\njoin \nWait for a thread to terminate. \n\nrun \nEntry point for the thread. \n\nsleep \nSuspend a thread for a period of time. \n\nstart \nStart a thread by calling its run method.",
    "join \nWait for a thread to terminate. \n\nrun \nEntry point for the thread. \n\nsleep \nSuspend a thread for a period of time. \n\nstart \nStart a thread by calling its run method. \n\nThus far, all the examples in this book have used a single thread of execution. The \nremainder of this chapter explains how to use Thread and Runnable to create and \nmanage threads, beginning with the one thread that all Java programs have: the main \nthread. \n\nThe Main Thread \n\nWhen a Java program starts up, one thread begins running immediately. This is usually \ncalled the main thread of your program, because it is the one that is executed when your \nprogram begins. The main thread is important for two reasons: \n\n\u2022  It is the thread from which other \u201cchild\u201d threads will be spawned. \n\n\u2022  Often, it must be the last thread to finish execution because it performs \nvarious shutdown actions. \n\nAlthough the main thread is created automatically when your program is started, it",
    "\u2022  Often, it must be the last thread to finish execution because it performs \nvarious shutdown actions. \n\nAlthough the main thread is created automatically when your program is started, it \n\ncan be controlled through a Thread object. To do so, you must obtain a reference \nto it by calling the method currentThread ( ) , which is a public static member \n\nof Thread . Its general form is shown here: \n\nstatic Thread currentThread ( ) \n\nThis method returns a reference to the thread in which it is called. Once you have \na reference to the main thread, you can control it just like any other thread. \n\n\nLet\u2019s begin by reviewing the following example:",
    "Let\u2019s begin by reviewing the following example: \n\nIn this program, a reference to the current thread ( the main thread, in this case ) is obtained \nby calling currentThread ( ) , and this reference is stored in the local variable t . Next, the \nprogram displays information about the thread. The program then calls setName ( ) to \nchange the internal name of the thread. Information about the thread is then redisplayed. \nNext, a loop counts down from five, pausing one second between each line. The pause is \naccomplished by the sleep ( ) method. The argument to sleep ( ) specifies the delay period \nin milliseconds. Notice the try/catch block around this loop. The sleep ( ) method in \nThread might throw an InterruptedException . This would happen if some other thread \nwanted to interrupt this sleeping one. This example just prints a message if it gets \ninterrupted. In a real program, you would need to handle this differently. Here is the output \ngenerated by this program:",
    "Notice the output produced when t is used as an argument to println ( ) . This displays, in \norder: the name of the thread, its priority, and the name of its group. By default, the name \nof the main thread is main . Its priority is 5, which is the default value, and main is also the \nname of the group of threads to which this thread belongs. A thread group is a data \nstructure that controls the state of a collection of threads as a whole. After the name of the \nthread is changed, t is again output. This time, the new name of the thread is displayed. \nLet\u2019s look more closely at the methods defined by Thread that are used in the program. \nThe sleep ( ) method causes the thread from which it is called to suspend execution for the \nspecified period of milliseconds. Its general form is shown here: \n\nstatic void sleep ( long milliseconds ) throws InterruptedException",
    "static void sleep ( long milliseconds ) throws InterruptedException \n\nThe number of milliseconds to suspend is specified in milliseconds . This method \nmay throw an InterruptedException . \nThe sleep ( ) method has a second form, shown next, which allows you to specify the period \nin terms of milliseconds and nanoseconds: \n\nstatic void sleep ( long milliseconds , int nanoseconds ) throws InterruptedException \n\nThis second form is useful only in environments that allow timing periods as short \nas nanoseconds. \nAs the preceding program shows, you can set the name of a thread by using setName ( ) . \nYou can obtain the name of a thread by calling getName ( ) ( but note that this is not shown \nin the program ). These methods are members of the Thread class and are declared like \nthis: \n\nfinal void setName ( String threadName ) \nfinal String getName ( ) \n\nHere, threadName specifies the name of the thread. \n\nCreating a Thread",
    "final void setName ( String threadName ) \nfinal String getName ( ) \n\nHere, threadName specifies the name of the thread. \n\nCreating a Thread \n\nIn the most general sense, you create a thread by instantiating an object of type Thread . \nJava defines two ways in which this can be accomplished: \n\n\u2022  You can implement the Runnable interface. \n\n\u2022  You can extend the Thread class, itself. \n\nThe following two sections look at each method, in turn. \n\nImplementing Runnable \n\nThe easiest way to create a thread is to create a class that implements the Runnable \ninterface. Runnable abstracts a unit of executable code. You can construct a thread on any \nobject that implements Runnable . To implement Runnable , a class need only implement \n\na single method called run ( ) , which is declared like this: \n\n\npublic void run ( )",
    "a single method called run ( ) , which is declared like this: \n\n\npublic void run ( ) \n\nInside run ( ) , you will define the code that constitutes the new thread. It is \nimportant to understand that run ( ) can call other methods, use other classes, and \ndeclare variables, just like the main thread can. The only difference is that run ( ) \nestablishes the entry point for another, concurrent thread of execution within your \nprogram. This thread will end when run ( ) returns. \nAfter you create a class that implements Runnable , you will instantiate an object of type \nThread from within that class. Thread defines several constructors. The one that we will \nuse is shown here: \n\nThread ( Runnable threadOb , String threadName )",
    "Thread ( Runnable threadOb , String threadName ) \n\nIn this constructor, threadOb is an instance of a class that implements the \nRunnable interface. This defines where execution of the thread will begin. The \nname of the new thread is specified by threadName . \nAfter the new thread is created, it will not start running until you call its start ( ) method, \nwhich is declared within Thread . In essence, start ( ) executes a call to run ( ) . The start ( \n) method is shown here: \n\nvoid start ( ) \n\nHere is an example that creates a new thread and starts it running: \n\n\nInside NewThread \u2019s constructor, a new Thread object is created by the following \nstatement:",
    "void start ( ) \n\nHere is an example that creates a new thread and starts it running: \n\n\nInside NewThread \u2019s constructor, a new Thread object is created by the following \nstatement: \n\n\nPassing this as the first argument indicates that you want the new thread to call the run ( ) \nmethod on this object. Next, start ( ) is called, which starts the thread of execution \nbeginning at the run ( ) method. This causes the child thread\u2019s for loop to begin. After \ncalling start ( ) , NewThread \u2019s constructor returns to main ( ) . When the main thread \nresumes, it enters its for loop. Both threads continue running, sharing the CPU in singlecore systems, until their loops finish. The output produced by this program is as follows. \n( Your output may vary based upon the specific execution environment.)",
    "As mentioned earlier, in a multithreaded program, often the main thread must be the last \nthread to finish running. In fact, for some older JVMs, if the main thread finishes before a \nchild thread has completed, then the Java run-time system may \u201chang.\u201d The preceding \nprogram ensures that the main thread finishes last, because the main thread sleeps for \n1,000 milliseconds between iterations, but the child thread sleeps for only 500 milliseconds. \nThis causes the child thread to terminate earlier than the main thread. Shortly, you will see \na better way to wait for a thread to finish. \n\nExtending Thread \n\nThe second way to create a thread is to create a new class that extends Thread , and then to \ncreate an instance of that class. The extending class must override the run ( ) method, \nwhich is the entry point for the new thread. It must also call start ( ) to begin execution of \nthe new thread. Here is the preceding program rewritten to extend Thread :",
    "This program generates the same output as the preceding version. As you can see, the child \nthread is created by instantiating an object of NewThread , which is derived from Thread . \nNotice the call to super ( ) inside NewThread . This invokes the following form of the \nThread constructor: \n\npublic Thread ( String threadName ) \n\n\nHere, threadName specifies the name of the thread. \n\nChoosing an Approach",
    "Choosing an Approach \n\nAt this point, you might be wondering why Java has two ways to create child threads, and \nwhich approach is better. The answers to these questions turn on the same point. The \nThread class defines several methods that can be overridden by a derived class. Of these \nmethods, the only one that must be overridden is run ( ) . This is, of course, the same \nmethod required when you implement Runnable . Many Java programmers feel that \nclasses should be extended only when they are being enhanced or modified in some way. So, \nif you will not be overriding any of Thread \u2019s other methods, it is probably best simply to \nimplement Runnable . Also, by implementing Runnable , your thread class does not need \nto inherit Thread , making it free to inherit a different class. Ultimately, which approach to \nuse is up to you. However, throughout the rest of this chapter, we will create threads by \nusing classes that implement Runnable . \n\nCreating Multiple Threads",
    "Creating Multiple Threads \n\nSo far, you have been using only two threads: the main thread and one child thread. \nHowever, your program can spawn as many threads as it needs. For example, the following \nprogram creates three child threads: \n\n\nSample output from this program is shown here. ( Your output may vary based upon the \nspecific execution environment.) \n\n\nAs you can see, once started, all three child threads share the CPU. Notice the call to \nsleep ( 10000 ) in main ( ) . This causes the main thread to sleep for ten seconds and \nensures that it will finish last. \n\nUsing isAlive ( ) and join ( )",
    "Using isAlive ( ) and join ( ) \n\nAs mentioned, often you will want the main thread to finish last. In the preceding examples, \nthis is accomplished by calling sleep ( ) within main ( ) , with a long enough delay to ensure \nthat all child threads terminate prior to the main thread. However, this is hardly a \nsatisfactory solution, and it also raises a larger question: How can one thread know when \nanother thread has ended? Fortunately, Thread provides a means by which you can answer \nthis question. \nTwo ways exist to determine whether a thread has finished. First, you can call isAlive ( ) on \nthe thread. This method is defined by Thread , and its general form is shown here: \n\nfinal boolean isAlive ( ) \n\nThe isAlive ( ) method returns true if the thread upon which it is called is still \nrunning. It returns false otherwise. \nWhile isAlive ( ) is occasionally useful, the method that you will more commonly use to \nwait for a thread to finish is called join ( ) , shown here:",
    "final void join ( ) throws InterruptedException \n\n\nThis method waits until the thread on which it is called terminates. Its name \ncomes from the concept of the calling thread waiting until the specified thread \njoins it. Additional forms of join ( ) allow you to specify a maximum amount of \ntime that you want to wait for the specified thread to terminate. \nHere is an improved version of the preceding example that uses join ( ) to ensure that the \nmain thread is the last to stop. It also demonstrates the isAlive ( ) method. \n\n\nSample output from this program is shown here. ( Your output may vary based upon the \nspecific execution environment.) \n\n\nAs you can see, after the calls to join ( ) return, the threads have stopped executing. \n\nThread Priorities",
    "As you can see, after the calls to join ( ) return, the threads have stopped executing. \n\nThread Priorities \n\nThread priorities are used by the thread scheduler to decide when each thread should be \nallowed to run. In theory, over a given period of time, higher-priority threads get more CPU \ntime than lower-priority threads. In practice, the amount of CPU time that a thread gets \noften depends on several factors besides its priority. ( For example, how an operating system \nimplements multitasking can affect the relative availability of CPU time.) A higher-priority",
    "thread can also preempt a lower-priority one. For instance, when a lower-priority thread is \nrunning and a higher-priority thread resumes ( from sleeping or waiting on I/O, for \nexample ), it will preempt the lower-priority thread. \nIn theory, threads of equal priority should get equal access to the CPU. But you need to be \ncareful. Remember, Java is designed to work in a wide range of environments. Some of \nthose environments implement multitasking fundamentally differently than others. For",
    "safety, threads that share the same priority should yield control once in a while. This \nensures that all threads have a chance to run under a nonpreemptive operating system. In \npractice, even in nonpreemptive environments, most threads still get a chance to run, \nbecause most threads inevitably encounter some blocking situation, such as waiting for I/O. \nWhen this happens, the blocked thread is suspended and other threads can run. But, if you \nwant smooth multithreaded execution, you are better off not relying on this. Also, some \ntypes of tasks are CPU-intensive. Such threads dominate the CPU. For these types of \nthreads, you want to yield control occasionally so that other threads can run. \nTo set a thread\u2019s priority, use the setPriority ( ) method, which is a member of Thread . \nThis is its general form: \n\nfinal void setPriority ( int level )",
    "final void setPriority ( int level ) \n\nHere, level specifies the new priority setting for the calling thread. The value of \nlevel must be within the range MIN_PRIORITY and MAX_PRIORITY . \nCurrently, these values are 1 and 10, respectively. To return a thread to default \npriority, specify NORM_PRIORITY , which is currently 5. These priorities are \ndefined as static final variables within Thread . \nYou can obtain the current priority setting by calling the getPriority ( ) method of Thread , \nshown here: \n\nfinal int getPriority ( ) \n\nImplementations of Java may have radically different behavior when it comes to \nscheduling. Most of the inconsistencies arise when you have threads that are \nrelying on preemptive behavior, instead of cooperatively giving up CPU time. The \nsafest way to obtain predictable, cross-platform behavior with Java is to use \nthreads that voluntarily give up control of the CPU. \n\nSynchronization",
    "Synchronization \n\nWhen two or more threads need access to a shared resource, they need some way to ensure \nthat the resource will be used by only one thread at a time. The process by which this is \nachieved is called synchronization . As you will see, Java provides unique, language-level \nsupport for it. \nKey to synchronization is the concept of the monitor. A monitor is an object that is used as a \nmutually exclusive lock. Only one thread can own a monitor at a given time. When a thread \nacquires a lock, it is said to have entered the monitor. All other threads attempting to enter \n\nthe locked monitor will be suspended until the first thread exits the monitor. These other \nthreads are said to be waiting for the monitor. A thread that owns a monitor can reenter the \nsame monitor if it so desires. \nYou can synchronize your code in either of two ways. Both involve the use of the \nsynchronized keyword, and both are examined here. \n\nUsing Synchronized Methods",
    "Synchronization is easy in Java, because all objects have their own implicit monitor \nassociated with them. To enter an object\u2019s monitor, just call a method that has been \nmodified with the synchronized keyword. While a thread is inside a synchronized method, \nall other threads that try to call it ( or any other synchronized method ) on the same instance \nhave to wait. To exit the monitor and relinquish control of the object to the next waiting \nthread, the owner of the monitor simply returns from the synchronized method. \nTo understand the need for synchronization, let\u2019s begin with a simple example that does not \nuse it\u2014but should. The following program has three simple classes. The first one, Callme , \nhas a single method named call ( ) . The call ( ) method takes a String parameter called \nmsg . This method tries to print the msg string inside of square brackets",
    ". The first one, Callme , \nhas a single method named call ( ) . The call ( ) method takes a String parameter called \nmsg . This method tries to print the msg string inside of square brackets. The interesting \nthing to notice is that after call ( ) prints the opening bracket and the msg string, it calls \nThread.sleep ( 1000 ) , which pauses the current thread for one second. \nThe constructor of the next class, Caller , takes a reference to an instance of the Callme",
    "class and a String , which are stored in target and msg , respectively. The constructor also \ncreates a new thread that will call this object\u2019s run ( ) method. The thread is started \nimmediately. The run ( ) method of Caller calls the call ( ) method on the target instance \nof Callme , passing in the msg string. Finally, the Synch class starts by creating a single \ninstance of Callme , and three instances of Caller , each with a unique message string. The \nsame instance of Callme is passed to each Caller .",
    "As you can see, by calling sleep ( ) , the call ( ) method allows execution to switch to another \nthread. This results in the mixed-up output of the three message strings. In this program, \nnothing exists to stop all three threads from calling the same method, on the same object, at \nthe same time. This is known as a race condition , because the three threads are racing each \nother to complete the method. This example used sleep ( ) to make the effects repeatable \nand obvious. In most situations, a race condition is more subtle and less predictable, \nbecause you can\u2019t be sure when the context switch will occur. This can cause a program to \nrun right one time and wrong the next. \nTo fix the preceding program, you must serialize access to call ( ) . That is, you must restrict \nits access to only one thread at a time. To do this, you simply need to precede call ( ) \u2019s \ndefinition with the keyword synchronized , as shown here:",
    "This prevents other threads from entering call ( ) while another thread is using it. After \nsynchronized has been added to call ( ) , the output of the program is as follows: \n\nAny time that you have a method, or group of methods, that manipulates the internal state \nof an object in a multithreaded situation, you should use the synchronized keyword to \nguard the state from race conditions. Remember, once a thread enters any synchronized \nmethod on an instance, no other thread can enter any other synchronized method on the \nsame instance. However, nonsynchronized methods on that instance will continue to be \ncallable. \n\nThe synchronized Statement \n\nWhile creating synchronized methods within classes that you create is an easy and \neffective means of achieving synchronization, it will not work in all cases. To understand",
    "While creating synchronized methods within classes that you create is an easy and \neffective means of achieving synchronization, it will not work in all cases. To understand \n\nwhy, consider the following. Imagine that you want to synchronize access to objects of a \nclass that was not designed for multithreaded access. That is, the class does not use \nsynchronized methods. Further, this class was not created by you, but by a third party, \nand you do not have access to the source code. Thus, you can\u2019t add synchronized to the \nappropriate methods within the class. How can access to an object of this class be \nsynchronized? Fortunately, the solution to this problem is quite easy: You simply put calls \n\n\nto the methods defined by this class inside a synchronized block. \nThis is the general form of the synchronized statement:",
    "to the methods defined by this class inside a synchronized block. \nThis is the general form of the synchronized statement: \n\nHere, objRef is a reference to the object being synchronized. A synchronized block ensures \nthat a call to a synchronized method that is a member of objRef \u2019s class occurs only after the \ncurrent thread has successfully entered objRef \u2019s monitor. \nHere is an alternative version of the preceding example, using a synchronized block within \nthe run ( ) method: \n\n\nHere, the call ( ) method is not modified by synchronized . Instead, the synchronized \nstatement is used inside Caller \u2019s run ( ) method. This causes the same correct output as the \n\npreceding example, because each thread waits for the prior one to finish before proceeding. \n\nInterthread Communication",
    "The preceding examples unconditionally blocked other threads from asynchronous access to \ncertain methods. This use of the implicit monitors in Java objects is powerful, but you can \nachieve a more subtle level of control through interprocess communication. As you will see, \nthis is especially easy in Java. \nAs discussed earlier, multithreading replaces event loop programming by dividing your tasks \ninto discrete, logical units. Threads also provide a secondary benefit: they do away with \npolling. Polling is usually implemented by a loop that is used to check some condition \nrepeatedly. Once the condition is true, appropriate action is taken. This wastes CPU time. \nFor example, consider the classic queuing problem, where one thread is producing some \ndata and another is consuming it. To make the problem more interesting, suppose that the \nproducer has to wait until the consumer is finished before it generates more data",
    ". To make the problem more interesting, suppose that the \nproducer has to wait until the consumer is finished before it generates more data. In a \npolling system, the consumer would waste many CPU cycles while it waited for the producer \nto produce. Once the producer was finished, it would start polling, wasting more CPU cycles \nwaiting for the consumer to finish, and so on. Clearly, this situation is undesirable. \nTo avoid polling, Java includes an elegant interprocess communication mechanism via the \nwait ( ) , notify ( ) , and notifyAll ( ) methods. These methods are implemented as final \nmethods in Object , so all classes have them. All three methods can be called only from \nwithin a synchronized context. Although conceptually advanced from a computer science \nperspective, the rules for using these methods are actually quite simple:",
    "\u2022   wait ( )     tells the calling thread to give up the monitor and go to sleep \nuntil some other thread enters the same monitor and calls notify ( ) or \nnotifyAll ( ) . \n\n\u2022   notify ( )     wakes up a thread that called wait ( ) on the same object. \n\n\u2022   notifyAll ( )     wakes up all the threads that called wait ( ) on the same \nobject. One of the threads will be granted access. \n\nThese methods are declared within Object , as shown here: \n\nfinal void wait ( ) throws InterruptedException \nfinal void notify ( ) \nfinal void notify All ( )",
    "These methods are declared within Object , as shown here: \n\nfinal void wait ( ) throws InterruptedException \nfinal void notify ( ) \nfinal void notify All ( ) \n\nAdditional forms of wait ( ) exist that allow you to specify a period of time to wait. \nBefore working through an example that illustrates interthread communication, an \nimportant point needs to be made. Although wait ( ) normally waits until notify ( ) or \nnotifyAll ( ) is called, there is a possibility that in very rare cases the waiting thread could \nbe awakened due to a spurious wakeup . In this case, a waiting thread resumes without \nnotify ( ) or notifyAll ( ) having been called. ( In essence, the thread resumes for no \napparent reason.) Because of this remote possibility, Oracle recommends that calls to wait ( \n\n) should take place within a loop that checks the condition on which the thread is waiting. \nThe following example shows this technique.",
    ") should take place within a loop that checks the condition on which the thread is waiting. \nThe following example shows this technique. \n\n\nLet\u2019s now work through an example that uses wait ( ) and notify ( ) . To begin, consider the \nfollowing sample program that incorrectly implements a simple form of the producer/ \nconsumer problem. It consists of four classes: Q , the queue that you\u2019re trying to \nsynchronize ; Producer , the threaded object that is producing queue entries ; Consumer , \nthe threaded object that is consuming queue entries ; and PC , the tiny class that creates the \nsingle Q , Producer , and Consumer . \n\n\nAlthough the put ( ) and get ( ) methods on Q are synchronized, nothing stops the producer \nfrom overrunning the consumer, nor will anything stop the consumer from consuming the \nsame queue value twice. Thus, you get the erroneous output shown here ( the exact output \nwill vary with processor speed and task load ):",
    "As you can see, after the producer put 1, the consumer started and got the same 1 five times \nin a row. Then, the producer resumed and produced 2 through 7 without letting the \nconsumer have a chance to consume them. \nThe proper way to write this program in Java is to use wait ( ) and notify ( ) to signal in \nboth directions, as shown here: \n\n\nInside get ( ) , wait ( ) is called. This causes its execution to suspend until Producer \n\nnotifies you that some data is ready. When this happens, execution inside get ( ) resumes. \nAfter the data has been obtained, get ( ) calls notify ( ) . This tells Producer that it is okay \nto put more data in the queue. Inside put ( ) , wait ( ) suspends execution until Consumer \nhas removed the item from the queue. When execution resumes, the next item of data is put",
    "in the queue, and notify ( ) is called. This tells Consumer that it should now remove it. \nHere is some output from this program, which shows the clean synchronous behavior: \n\nDeadlock \n\nA special type of error that you need to avoid that relates specifically to multitasking is \ndeadlock , which occurs when two threads have a circular dependency on a pair of \nsynchronized objects. For example, suppose one thread enters the monitor on object X and \nanother thread enters the monitor on object Y. If the thread in X tries to call any \nsynchronized method on Y, it will block as expected. However, if the thread in Y, in turn, \ntries to call any synchronized method on X, the thread waits forever, because to access X, it \nwould have to release its own lock on Y so that the first thread could complete. Deadlock is \na difficult error to debug for two reasons: \n\n\u2022  In general, it occurs only rarely, when the two threads time-slice in just \nthe right way.",
    "\u2022  In general, it occurs only rarely, when the two threads time-slice in just \nthe right way. \n\n\u2022  It may involve more than two threads and two synchronized objects. ( That \nis, deadlock can occur through a more convoluted sequence of events than \njust described.) \n\nTo understand deadlock fully, it is useful to see it in action. The next example \n\ncreates two classes, A and B , with methods foo ( ) and bar ( ) , respectively, which \npause briefly before trying to call a method in the other class. The main class, \nnamed Deadlock , creates an A and a B instance, and then starts a second thread \nto set up the deadlock condition. The foo ( ) and bar ( ) methods use sleep ( ) as a \n\nway to force the deadlock condition to occur. \n\n\n\n\nWhen you run this program, you will see the output shown here:",
    "way to force the deadlock condition to occur. \n\n\n\n\nWhen you run this program, you will see the output shown here: \n\n\nBecause the program has deadlocked, you need to press ctrl-c to end the program. You can \nsee a full thread and monitor cache dump by pressing ctrl-break on a PC. You will see that \nRacingThread owns the monitor on b , while it is waiting for the monitor on a . At the \nsame time, MainThread owns a and is waiting to get b . This program will never complete. \nAs this example illustrates, if your multithreaded program locks up occasionally, deadlock is \none of the first conditions that you should check for. \n\nSuspending, Resuming, and Stopping Threads",
    "Sometimes, suspending execution of a thread is useful. For example, a separate thread can \nbe used to display the time of day. If the user doesn\u2019t want a clock, then its thread can be \nsuspended. Whatever the case, suspending a thread is a simple matter. Once suspended, \nrestarting the thread is also a simple matter. \nThe mechanisms to suspend, stop, and resume threads differ between early versions of Java, \nsuch as Java 1.0, and modern versions, beginning with Java 2. Prior to Java 2, a program \nused suspend ( ) , resume ( ) , and stop ( ) , which are methods defined by Thread , to \npause, restart, and stop the execution of a thread. Although these methods seem to be a \nperfectly reasonable and convenient approach to managing the execution of threads, they \nmust not be used for new Java programs. Here\u2019s why. The suspend ( ) method of the \nThread class was deprecated by Java 2 several years ago. This was done because suspend ( \n) can sometimes cause serious system failures",
    ". Here\u2019s why. The suspend ( ) method of the \nThread class was deprecated by Java 2 several years ago. This was done because suspend ( \n) can sometimes cause serious system failures. Assume that a thread has obtained locks on \ncritical data structures. If that thread is suspended at that point, those locks are not \nrelinquished. Other threads that may be waiting for those resources can be deadlocked. \nThe resume ( ) method is also deprecated. It does not cause problems, but cannot be used \nwithout the suspend ( ) method as its counterpart. \nThe stop ( ) method of the Thread class, too, was deprecated by Java 2. This was done \nbecause this method can sometimes cause serious system failures. Assume that a thread is \nwriting to a critically important data structure and has completed only part of its changes. If \nthat thread is stopped at that point, that data structure might be left in a corrupted state. \nThe trouble is that stop ( ) causes any lock the calling thread holds to be released",
    ". If \nthat thread is stopped at that point, that data structure might be left in a corrupted state. \nThe trouble is that stop ( ) causes any lock the calling thread holds to be released. Thus, the \ncorrupted data might be used by another thread that is waiting on the same lock. \nBecause you can\u2019t now use the suspend ( ) , resume ( ) , or stop ( ) methods to control a \nthread, you might be thinking that no way exists to pause, restart, or terminate a thread.",
    "But, fortunately, this is not true. Instead, a thread must be designed so that the run ( ) \nmethod periodically checks to determine whether that thread should suspend, resume, or \nstop its own execution. Typically, this is accomplished by establishing a flag variable that \n\n\nindicates the execution state of the thread. As long as this flag is set to \u201crunning,\u201d the run ( )",
    "method must continue to let the thread execute. If this variable is set to \u201csuspend,\u201d the \nthread must pause. If it is set to \u201cstop,\u201d the thread must terminate. Of course, a variety of \nways exist in which to write such code, but the central theme will be the same for all \nprograms. \nThe following example illustrates how the wait ( ) and notify ( ) methods that are inherited \nfrom Object can be used to control the execution of a thread. Let us consider its operation. \nThe NewThread class contains a boolean instance variable named suspendFlag , which \nis used to control the execution of the thread. It is initialized to false by the constructor. \nThe run ( ) method contains a synchronized statement block that checks suspendFlag . \nIf that variable is true , the wait ( ) method is invoked to suspend the execution of the \nthread. The mysuspend ( ) method sets suspendFlag to true . The myresume ( ) \nmethod sets suspendFlag to false and invokes notify ( ) to wake up the thread",
    ". The mysuspend ( ) method sets suspendFlag to true . The myresume ( ) \nmethod sets suspendFlag to false and invokes notify ( ) to wake up the thread. Finally, \nthe main ( ) method has been modified to invoke the mysuspend ( ) and myresume ( ) \nmethods.",
    "When you run the program, you will see the threads suspend and resume. Later in this \nbook, you will see more examples that use the modern mechanism of thread control. \nAlthough this mechanism isn\u2019t as \u201cclean\u201d as the old way, nevertheless, it is the way required \nto ensure that run-time errors don\u2019t occur. It is the approach that must be used for all new \ncode. \n\nObtaining A Thread\u2019s State \n\nAs mentioned earlier in this chapter, a thread can exist in a number of different states. You \ncan obtain the current state of a thread by calling the getState ( ) method defined by \nThread . It is shown here: \n\nThread.State getState ( ) \n\nIt returns a value of type Thread.State that indicates the state of the thread at the \n\n\ntime at which the call was made. State is an enumeration defined by Thread . ( An \nenumeration is a list of named constants. It is discussed in detail in Chapter 12.) \nHere are the values that can be returned by getState ( ) :",
    "Value \nState \n\nBLOCKED \nA thread that has suspended execution because it is waiting to \nacquire a lock. \n\nNEW \nA thread that has not begun execution. \n\nRUNNABLE \nA thread that either is currently executing or will execute when \nit gains access to the CPU. \n\nTERMINATED \nA thread that has completed execution. \n\nTIMED_WAITING \nA thread that has suspended execution for a specified period of \ntime, such as when it has called sleep ( ) . This state is also \nentered when a timeout version of wait ( ) or join ( ) is called. \n\nWAITING \nA thread that has suspended execution because it is waiting for \nsome action to occur. For example, it is waiting because of a call \nto a non-timeout version of wait ( ) or join ( ) . \n\nFigure 11-1 diagrams how the various thread states relate. \n\n\nFigure 11-1    Thread states",
    "Figure 11-1 diagrams how the various thread states relate. \n\n\nFigure 11-1    Thread states \n\nGiven a Thread instance, you can use getState ( ) to obtain the state of a thread. For \nexample, the following sequence determines if a thread called thrd is in the RUNNABLE \nstate at the time getState ( ) is called: \n\nIt is important to understand that a thread\u2019s state may change after the call to getState ( ) . \nThus, depending on the circumstances, the state obtained by calling getState ( ) may not \nreflect the actual state of the thread only a moment later. For this ( and other ) reasons, \ngetState ( ) is not intended to provide a means of synchronizing threads. It\u2019s primarily used \nfor debugging or for profiling a thread\u2019s run-time characteristics. \n\nUsing Multithreading",
    "Using Multithreading \n\nThe key to utilizing Java\u2019s multithreading features effectively is to think concurrently rather \nthan serially. For example, when you have two subsystems within a program that can \nexecute concurrently, make them individual threads. With the careful use of multithreading, \nyou can create very efficient programs. A word of caution is in order, however: If you create \ntoo many threads, you can actually degrade the performance of your program rather than \nenhance it. Remember, some overhead is associated with context switching. If you create \ntoo many threads, more CPU time will be spent changing contexts than executing your \nprogram! One last point: To create compute-intensive applications that can automatically \nscale to make use of the available processors in a multi-core system, consider using the new \nFork/Join Framework, which is described in Chapter 28. \n\n\uf709 \nPREV \nChapter 10: Exception Handling \n\u23ee \n\nNEXT \nChapter 12: Enumerations, Autoboxing, and Ann\u2026 \u23ed",
    "\uf709 \nPREV \nChapter 10: Exception Handling \n\u23ee \n\nNEXT \nChapter 12: Enumerations, Autoboxing, and Ann\u2026 \u23ed \n\n\nPREV \nChapter 11: Multithreaded Programming \n\u23ee \n\nNEXT \nChapter 13: I/O, Applets, and Other Topics \u23ed \n\nCHAPTER \n\n12 \nEnumerations, Autoboxing, and Annotations \n( Metadata ) \n\nThis chapter examines three relatively recent additions to the Java language: enumerations, \nautoboxing, and annotations ( also referred to as metadata ). Each expands the power of the \nlanguage by offering a streamlined approach to handling common programming tasks. This \nchapter also discusses Java\u2019s type wrappers and introduces reflection. \n\nEnumerations",
    "Versions of Java prior to JDK 5 lacked one feature that many programmers felt was needed: \nenumerations. In its simplest form, an enumeration is a list of named constants. Although \nJava offered other features that provide somewhat similar functionality, such as final \nvariables, many programmers still missed the conceptual purity of enumerations\u2014 \nespecially because enumerations are supported by many other commonly used languages. \nBeginning with JDK 5, enumerations were added to the Java language, and they are now an \nintegral and widely used part of Java. \nIn their simplest form, Java enumerations appear similar to enumerations in other \nlanguages. However, this similarity may be only skin deep because, in Java, an enumeration \ndefines a class type. By making enumerations into classes, the capabilities of the \nenumeration are greatly expanded. For example, in Java, an enumeration can have \nconstructors, methods, and instance variables",
    ". By making enumerations into classes, the capabilities of the \nenumeration are greatly expanded. For example, in Java, an enumeration can have \nconstructors, methods, and instance variables. Therefore, although enumerations were \nseveral years in the making, Java\u2019s rich implementation made them well worth the wait.",
    "Enumeration Fundamentals \n\nAn enumeration is created using the enum keyword. For example, here is a simple \nenumeration that lists various apple varieties: \n\nThe identifiers Jonathan , GoldenDel , and so on, are called enumeration constants . Each \n\n\nis implicitly declared as a public, static final member of Apple . Furthermore, their type is \n\nthe type of the enumeration in which they are declared, which is Apple in this case. Thus, \nin the language of Java, these constants are called self-typed , in which \u201cself\u201d refers to the \nenclosing enumeration. \nOnce you have defined an enumeration, you can create a variable of that type. However, \neven though enumerations define a class type, you do not instantiate an enum using new . \nInstead, you declare and use an enumeration variable in much the same way as you do one \nof the primitive types. For example, this declares ap as a variable of enumeration type \nApple :",
    "Because ap is of type Apple , the only values that it can be assigned ( or can contain ) are \nthose defined by the enumeration. For example, this assigns ap the value RedDel : \n\nNotice that the symbol RedDel is preceded by Apple . \nTwo enumeration constants can be compared for equality by using the = = relational \noperator. For example, this statement compares the value in ap with the GoldenDel \nconstant: \n\nAn enumeration value can also be used to control a switch statement. Of course, all of the \ncase statements must use constants from the same enum as that used by the switch \nexpression. For example, this switch is perfectly valid: \n\nNotice that in the case statements, the names of the enumeration constants are used \nwithout being qualified by their enumeration type name. That is, Winesap , not \nApple.Winesap , is used. This is because the type of the enumeration in the switch \nexpression has already implicitly specified the enum type of the case constants. There is",
    "no need to qualify the constants in the case statements with their enum type name. In \nfact, attempting to do so will cause a compilation error. \nWhen an enumeration constant is displayed, such as in a println ( ) statement, its name is \n\n\noutput. For example, given this statement: \n\nthe name Winesap is displayed. \nThe following program puts together all of the pieces and demonstrates the Apple \nenumeration: \n\n\nThe output from the program is shown here: \n\n\nThe values ( ) and valueOf ( ) Methods \n\nAll enumerations automatically contain two predefined methods: values ( ) and valueOf ( \n) . Their general forms are shown here: \n\npublic static enum-type [ ] values ( ) \npublic static enum-type valueOf ( String str )",
    "public static enum-type [ ] values ( ) \npublic static enum-type valueOf ( String str ) \n\nThe values ( ) method returns an array that contains a list of the enumeration \nconstants. The valueOf ( ) method returns the enumeration constant whose value \ncorresponds to the string passed in str . In both cases, enum-type is the type of the \nenumeration. For example, in the case of the Apple enumeration shown earlier, \nthe return type of Apple.valueOf (\"Winesap\") is Winesap . \nThe following program demonstrates the values ( ) and valueOf ( ) methods: \n\n\nThe output from the program is shown here: \n\nNotice that this program uses a for-each style for loop to cycle through the array of \nconstants obtained by calling values ( ) . For the sake of illustration, the variable allapples \nwas created and assigned a reference to the enumeration array. However, this step is not \nnecessary because the for could have been written as shown here, eliminating the need for \nthe allapples variable:",
    "Now, notice how the value corresponding to the name Winesap was obtained by calling \nvalueOf ( ) . \n\nAs explained, valueOf ( ) returns the enumeration value associated with the name of the \nconstant represented as a string. \n\nJava Enumerations Are Class Types",
    "As explained, valueOf ( ) returns the enumeration value associated with the name of the \nconstant represented as a string. \n\nJava Enumerations Are Class Types \n\nAs explained, a Java enumeration is a class type. Although you don\u2019t instantiate an enum \nusing new , it otherwise has much the same capabilities as other classes. The fact that \nenum defines a class gives the Java enumeration extraordinary power. For example, you \ncan give them constructors, add instance variables and methods, and even implement \ninterfaces. \nIt is important to understand that each enumeration constant is an object of its \nenumeration type. Thus, when you define a constructor for an enum , the constructor is \ncalled when each enumeration constant is created. Also, each enumeration constant has its \nown copy of any instance variables defined by the enumeration. For example, consider the \nfollowing version of Apple : \n\n\nThe output is shown here:",
    "The output is shown here: \n\nThis version of Apple adds three things. The first is the instance variable price , which is \nused to hold the price of each variety of apple. The second is the Apple constructor, which \nis passed the price of an apple. The third is the method getPrice ( ) , which returns the value \nof price . \n\nWhen the variable ap is declared in main ( ) , the constructor for Apple is called once for \neach constant that is specified. Notice how the arguments to the constructor are specified, \nby putting them inside parentheses after each constant, as shown here: \n\n\nThese values are passed to the p parameter of Apple ( ) , which then assigns this value to \nprice . Again, the constructor is called once for each constant. \nBecause each enumeration constant has its own copy of price , you can obtain the price of a \nspecified type of apple by calling getPrice ( ) . For example, in main ( ) the price of a \nWinesap is obtained by the following call:",
    "The prices of all varieties are obtained by cycling through the enumeration using a for loop. \nBecause there is a copy of price for each enumeration constant, the value associated with \none constant is separate and distinct from the value associated with another constant. This \nis a powerful concept, which is only available when enumerations are implemented as \nclasses, as Java does. \nAlthough the preceding example contains only one constructor, an enum can offer two or \nmore overloaded forms, just as can any other class. For example, this version of Apple \nprovides a default constructor that initializes the price to \u20131, to indicate that no price data is \navailable: \n\nNotice that in this version, RedDel is not given an argument. This means that the default \nconstructor is called, and RedDel \u2019s price variable is given the value \u20131.",
    "Notice that in this version, RedDel is not given an argument. This means that the default \nconstructor is called, and RedDel \u2019s price variable is given the value \u20131. \n\nHere are two restrictions that apply to enumerations. First, an enumeration can\u2019t inherit \nanother class. Second, an enum cannot be a superclass. This means that an enum can\u2019t be \nextended. Otherwise, enum acts much like any other class type. The key is to remember \nthat each of the enumeration constants is an object of the class in which it is defined. \n\nEnumerations Inherit Enum \n\nAlthough you can\u2019t inherit a superclass when declaring an enum , all enumerations",
    "Enumerations Inherit Enum \n\nAlthough you can\u2019t inherit a superclass when declaring an enum , all enumerations \n\n\nautomatically inherit one: java.lang.Enum . This class defines several methods that are \navailable for use by all enumerations. The Enum class is described in detail in Part II, but \nthree of its methods warrant a discussion at this time. \nYou can obtain a value that indicates an enumeration constant\u2019s position in the list of \nconstants. This is called its ordinal value , and it is retrieved by calling the ordinal ( ) \nmethod, shown here: \n\nfinal int ordinal ( ) \n\nIt returns the ordinal value of the invoking constant. Ordinal values begin at zero. \nThus, in the Apple enumeration, Jonathan has an ordinal value of zero, \nGoldenDel has an ordinal value of 1, RedDel has an ordinal value of 2, and so \non. \nYou can compare the ordinal value of two constants of the same enumeration by using the \ncompareTo ( ) method. It has this general form:",
    "Here, enum-type is the type of the enumeration, and e is the constant being \ncompared to the invoking constant. Remember, both the invoking constant and e \nmust be of the same enumeration. If the invoking constant has an ordinal value \nless than e \u2019s, then compareTo ( ) returns a negative value. If the two ordinal \nvalues are the same, then zero is returned. If the invoking constant has an ordinal \nvalue greater than e \u2019s, then a positive value is returned. \nYou can compare for equality an enumeration constant with any other object by using \nequals ( ) , which overrides the equals ( ) method defined by Object . Although equals ( ) \ncan compare an enumeration constant to any other object, those two objects will be equal \nonly if they both refer to the same constant, within the same enumeration. Simply having \nordinal values in common will not cause equals ( ) to return true if the two constants are \nfrom different enumerations",
    ". Simply having \nordinal values in common will not cause equals ( ) to return true if the two constants are \nfrom different enumerations. \nRemember, you can compare two enumeration references for equality by using = =. \nThe following program demonstrates the ordinal ( ) , compareTo ( ) , and equals ( ) \nmethods:",
    "The output from the program is shown here: \n\n\nAnother Enumeration Example \n\nBefore moving on, we will look at a different example that uses an enum . In Chapter 9, an \nautomated \u201cdecision maker\u201d program was created. In that version, variables called NO , \nYES , MAYBE , LATER , SOON , and NEVER were declared within an interface and used \nto represent the possible answers. While there is nothing technically wrong with that \napproach, the enumeration is a better choice. Here is an improved version of that program \nthat uses an enum called Answers to define the answers. You should compare this version \nto the original in Chapter 9. \n\n\n\n\nType Wrappers \n\nAs you know, Java uses primitive types ( also called simple types ), such as int or double , to",
    "Type Wrappers \n\nAs you know, Java uses primitive types ( also called simple types ), such as int or double , to \n\nhold the basic data types supported by the language. Primitive types, rather than objects, are \nused for these quantities for the sake of performance. Using objects for these values would \nadd an unacceptable overhead to even the simplest of calculations. Thus, the primitive types \n\nare not part of the object hierarchy, and they do not inherit Object . \nDespite the performance benefit offered by the primitive types, there are times when you \nwill need an object representation. For example, you can\u2019t pass a primitive type by reference \nto a method. Also, many of the standard data structures implemented by Java operate on \nobjects, which means that you can\u2019t use these data structures to store primitive types. To \nhandle these ( and other ) situations, Java provides type wrappers , which are classes that",
    "encapsulate a primitive type within an object. The type wrapper classes are described in \ndetail in Part II, but they are introduced here because they relate directly to Java\u2019s \nautoboxing feature. \nThe type wrappers are Double , Float , Long , Integer , Short , Byte , Character , and \nBoolean . These classes offer a wide array of methods that allow you to fully integrate the \nprimitive types into Java\u2019s object hierarchy. Each is briefly examined next. \n\nCharacter \n\nCharacter is a wrapper around a char . The constructor for Character is \n\nCharacter ( char ch ) \n\nHere, ch specifies the character that will be wrapped by the Character object \nbeing created. \nTo obtain the char value contained in a Character object, call charValue ( ) , shown here: \n\nchar charValue ( ) \n\nIt returns the encapsulated character. \n\nBoolean \n\nBoolean is a wrapper around boolean values. It defines these constructors: \n\nBoolean ( boolean boolValue ) \nBoolean ( String boolString )",
    "It returns the encapsulated character. \n\nBoolean \n\nBoolean is a wrapper around boolean values. It defines these constructors: \n\nBoolean ( boolean boolValue ) \nBoolean ( String boolString ) \n\nIn the first version, boolValue must be either true or false . In the second version, \nif boolString contains the string \"true\" ( in uppercase or lowercase ), then the new \nBoolean object will be true. Otherwise, it will be false. \nTo obtain a boolean value from a Boolean object, use booleanValue ( ) , shown here: \n\nboolean booleanValue ( ) \n\nIt returns the boolean equivalent of the invoking object. \n\nThe Numeric Type Wrappers \n\nBy far, the most commonly used type wrappers are those that represent numeric values. \nThese are Byte , Short , Integer , Long , Float , and Double . All of the numeric type \nwrappers inherit the abstract class Number . Number declares methods that return the \nvalue of an object in each of the different number formats. These methods are shown here:",
    "byte byteValue ( ) \ndouble doubleValue ( ) \nfloat floatValue ( ) \n\nint intValue ( ) \nlong longValue ( ) \nshort shortValue ( ) \n\n\nFor example, doubleValue ( ) returns the value of an object as a double , \nfloatValue ( ) returns the value as a float , and so on. These methods are \nimplemented by each of the numeric type wrappers. \nAll of the numeric type wrappers define constructors that allow an object to be constructed \nfrom a given value, or a string representation of that value. For example, here are the \nconstructors defined for Integer : \n\nInteger ( int num ) \nInteger ( String str )",
    "Integer ( int num ) \nInteger ( String str ) \n\nIf str does not contain a valid numeric value, then a NumberFormatException \nis thrown. \nAll of the type wrappers override toString ( ) . It returns the human-readable form of the \nvalue contained within the wrapper. This allows you to output the value by passing a type \nwrapper object to println ( ) , for example, without having to convert it into its primitive \ntype. \nThe following program demonstrates how to use a numeric type wrapper to encapsulate a \nvalue and then extract that value. \n\nThis program wraps the integer value 100 inside an Integer object called iOb . The \nprogram then obtains this value by calling intValue ( ) and stores the result in i . \nThe process of encapsulating a value within an object is called boxing . Thus, in the program, \nthis line boxes the value 100 into an Integer :",
    "The process of extracting a value from a type wrapper is called unboxing . For example, the \nprogram unboxes the value in iOb with this statement: \n\nThe same general procedure used by the preceding program to box and unbox values has \n\n\nbeen employed since the original version of Java. However, since JDK 5, Java fundamentally \nimproved on this through the addition of autoboxing, described next. \n\nAutoboxing",
    "Beginning with JDK 5, Java added two important features: autoboxing and auto-unboxing . \nAutoboxing is the process by which a primitive type is automatically encapsulated ( boxed ) \ninto its equivalent type wrapper whenever an object of that type is needed. There is no need \nto explicitly construct an object. Auto-unboxing is the process by which the value of a boxed \nobject is automatically extracted ( unboxed ) from a type wrapper when its value is needed. \nThere is no need to call a method such as intValue ( ) or doubleValue ( ) . \nThe addition of autoboxing and auto-unboxing greatly streamlines the coding of several \nalgorithms, removing the tedium of manually boxing and unboxing values. It also helps \nprevent errors. Moreover, it is very important to generics, which operate only on objects. \nFinally, autoboxing makes working with the Collections Framework ( described in Part II ) \nmuch easier",
    ". Moreover, it is very important to generics, which operate only on objects. \nFinally, autoboxing makes working with the Collections Framework ( described in Part II ) \nmuch easier. \nWith autoboxing, it is no longer necessary to manually construct an object in order to wrap \na primitive type. You need only assign that value to a type-wrapper reference. Java \nautomatically constructs the object for you. For example, here is the modern way to \nconstruct an Integer object that has the value 100:",
    "Notice that the object is not explicitly created through the use of new . Java handles this for \nyou, automatically. \nTo unbox an object, simply assign that object reference to a primitive-type variable. For \nexample, to unbox iOb , you can use this line: \n\nJava handles the details for you. \n\nHere is the preceding program rewritten to use autoboxing/unboxing: \n\n\nAutoboxing and Methods \n\nIn addition to the simple case of assignments, autoboxing automatically occurs whenever a \nprimitive type must be converted into an object ; auto-unboxing takes place whenever an \nobject must be converted into a primitive type. Thus, autoboxing/unboxing might occur \nwhen an argument is passed to a method, or when a value is returned by a method. For \nexample, consider this: \n\nThis program displays the following result: \n\nIn the program, notice that m ( ) specifies an Integer parameter and returns an int result.",
    "This program displays the following result: \n\nIn the program, notice that m ( ) specifies an Integer parameter and returns an int result. \n\nInside main ( ) , m ( ) is passed the value 100. Because m ( ) is expecting an Integer , this \nvalue is automatically boxed. Then, m ( ) returns the int equivalent of its argument. This \ncauses v to be auto-unboxed. Next, this int value is assigned to iOb in main ( ) , which \ncauses the int return value to be autoboxed. \n\nAutoboxing/Unboxing Occurs in Expressions \n\nIn general, autoboxing and unboxing take place whenever a conversion into an object or \nfrom an object is required. This applies to expressions. Within an expression, a numeric \nobject is automatically unboxed. The outcome of the expression is reboxed, if necessary. For \nexample, consider the following program: \n\n\nThe output is shown here: \n\nIn the program, pay special attention to this line:",
    "The output is shown here: \n\nIn the program, pay special attention to this line: \n\nThis causes the value in iOb to be incremented. It works like this: iOb is unboxed, the value \nis incremented, and the result is reboxed. \n\nAuto-unboxing also allows you to mix different types of numeric objects in an expression. \n\n\nOnce the values are unboxed, the standard type promotions and conversions are applied. \nFor example, the following program is perfectly valid: \n\nThe output is shown here: \n\nAs you can see, both the Double object dOb and the Integer object iOb participated in \nthe addition, and the result was reboxed and stored in dOb . \nBecause of auto-unboxing, you can use Integer numeric objects to control a switch \nstatement. For example, consider this fragment:",
    "When the switch expression is evaluated, iOb is unboxed and its int value is obtained. \nAs the examples in the program show, because of autoboxing/unboxing, using numeric \nobjects in an expression is both intuitive and easy. In the past, such code would have \n\ninvolved casts and calls to methods such as intValue ( ) . \n\nAutoboxing/Unboxing Boolean and Character Values \n\nAs described earlier, Java also supplies wrappers for boolean and char . These are \nBoolean and Character . Autoboxing/unboxing applies to these wrappers, too. For \n\nexample, consider the following program: \n\n\nThe output is shown here:",
    "example, consider the following program: \n\n\nThe output is shown here: \n\nThe most important thing to notice about this program is the auto-unboxing of b inside the \nif conditional expression. As you should recall, the conditional expression that controls an if \nmust evaluate to type boolean . Because of auto-unboxing, the boolean value contained \nwithin b is automatically unboxed when the conditional expression is evaluated. Thus, with \nthe advent of autoboxing/unboxing, a Boolean object can be used to control an if \nstatement. \nBecause of auto-unboxing, a Boolean object can now also be used to control any of Java\u2019s \nloop statements. When a Boolean is used as the conditional expression of a while , for , or \ndo/while , it is automatically unboxed into its boolean equivalent. For example, this is \nnow perfectly valid code: \n\nAutoboxing/Unboxing Helps Prevent Errors \n\nIn addition to the convenience that it offers, autoboxing/unboxing can also help prevent",
    "Autoboxing/Unboxing Helps Prevent Errors \n\nIn addition to the convenience that it offers, autoboxing/unboxing can also help prevent \n\nerrors. For example, consider the following program:",
    "errors. For example, consider the following program: \n\n\nThis program displays not the expected value of 1000, but \u201324! The reason is that the value \ninside iOb is manually unboxed by calling byteValue ( ) , which causes the truncation of \nthe value stored in iOb , which is 1,000. This results in the garbage value of \u201324 being \nassigned to i . Auto-unboxing prevents this type of error because the value in iOb will \nalways auto-unbox into a value compatible with int . \nIn general, because autoboxing always creates the proper object, and auto-unboxing always \nproduces the proper value, there is no way for the process to produce the wrong type of \nobject or value. In the rare instances where you want a type different than that produced by \nthe automated process, you can still manually box and unbox values. Of course, the benefits \nof autoboxing/unboxing are lost. In general, new code should employ autoboxing/unboxing. \nIt is the way that modern Java code is written.",
    "A Word of Warning \n\nBecause of autoboxing and auto-unboxing, some might be tempted to use objects such as \n\nInteger or Double exclusively, abandoning primitives altogether. For example, with \nautoboxing/unboxing it is possible to write code like this: \n\nIn this example, objects of type Double hold values that are used to calculate the \nhypotenuse of a right triangle. Although this code is technically correct and does, in fact, \nwork properly, it is a very bad use of autoboxing/unboxing. It is far less efficient than the \nequivalent code written using the primitive type double . The reason is that each autobox \n\n\nand auto-unbox adds overhead that is not present if the primitive type is used. \nIn general, you should restrict your use of the type wrappers to only those cases in which an \nobject representation of a primitive type is required. Autoboxing/unboxing was not added to \nJava as a \u201cback door\u201d way of eliminating the primitive types. \n\nAnnotations ( Metadata )",
    "Annotations ( Metadata ) \n\nSince JDK 5, Java has supported a feature that enables you to embed supplemental \ninformation into a source file. This information, called an annotation , does not change the \nactions of a program. Thus, an annotation leaves the semantics of a program unchanged. \nHowever, this information can be used by various tools during both development and \ndeployment. For example, an annotation might be processed by a source-code generator. \nThe term metadata is also used to refer to this feature, but the term annotation is the most \ndescriptive and more commonly used. \n\nAnnotation Basics \n\nAn annotation is created through a mechanism based on the interface . Let\u2019s begin with an \nexample. Here is the declaration for an annotation called MyAnno :",
    "An annotation is created through a mechanism based on the interface . Let\u2019s begin with an \nexample. Here is the declaration for an annotation called MyAnno : \n\nFirst, notice the @ that precedes the keyword interface . This tells the compiler that an \nannotation type is being declared. Next, notice the two members str ( ) and val ( ) . All \nannotations consist solely of method declarations. However, you don\u2019t provide bodies for \nthese methods. Instead, Java implements these methods. Moreover, the methods act much \nlike fields, as you will see. \nAn annotation cannot include an extends clause. However, all annotation types \nautomatically extend the Annotation interface. Thus, Annotation is a super-interface of \nall annotations. It is declared within the java.lang.annotation package. It overrides \nhashCode ( ) , equals ( ) , and toString ( ) , which are defined by Object . It also specifies \nannotationType ( ) , which returns a Class object that represents the invoking annotation.",
    "Once you have declared an annotation, you can use it to annotate something. Prior to JDK \n8, annotations could be used only on declarations, and that is where we will begin. ( JDK 8 \nadds the ability to annotate type use, and this is described later in this chapter. However, \nthe same basic techniques apply to both kinds of annotations.) Any type of declaration can \nhave an annotation associated with it. For example, classes, methods, fields, parameters, \nand enum constants can be annotated. Even an annotation can be annotated. In all cases, \n\nthe annotation precedes the rest of the declaration. \n\n\nWhen you apply an annotation, you give values to its members. For example, here is an \nexample of MyAnno being applied to a method declaration:",
    "When you apply an annotation, you give values to its members. For example, here is an \nexample of MyAnno being applied to a method declaration: \n\nThis annotation is linked with the method myMeth ( ) . Look closely at the annotation \nsyntax. The name of the annotation, preceded by an @, is followed by a parenthesized list of \nmember initializations. To give a member a value, that member\u2019s name is assigned a value. \nTherefore, in the example, the string \"Annotation Example\" is assigned to the str member \nof MyAnno . Notice that no parentheses follow str in this assignment. When an annotation \nmember is given a value, only its name is used. Thus, annotation members look like fields in \nthis context. \n\nSpecifying a Retention Policy",
    "Specifying a Retention Policy \n\nBefore exploring annotations further, it is necessary to discuss annotation retention \npolicies . A retention policy determines at what point an annotation is discarded. Java \ndefines three such policies, which are encapsulated within the \njava.lang.annotation.RetentionPolicy enumeration. They are SOURCE , CLASS , and \nRUNTIME . \nAn annotation with a retention policy of SOURCE is retained only in the source file and is \ndiscarded during compilation. \nAn annotation with a retention policy of CLASS is stored in the .class file during \ncompilation. However, it is not available through the JVM during run time. \nAn annotation with a retention policy of RUNTIME is stored in the .class file during \ncompilation and is available through the JVM during run time. Thus, RUNTIME retention \noffers the greatest annotation persistence. \n\nNOTE    An annotation on a local variable declaration is not retained in \nthe .class file.",
    "NOTE    An annotation on a local variable declaration is not retained in \nthe .class file. \n\nA retention policy is specified for an annotation by using one of Java\u2019s built-in annotations: \n@Retention . Its general form is shown here: \n\n@Retention ( retention-policy ) \n\nHere, retention-policy must be one of the previously discussed enumeration \n\n\nconstants. If no retention policy is specified for an annotation, then the default \npolicy of CLASS is used. \nThe following version of MyAnno uses @Retention to specify the RUNTIME retention \npolicy. Thus, MyAnno will be available to the JVM during program execution. \n\nObtaining Annotations at Run Time by Use of Reflection",
    "Although annotations are designed mostly for use by other development or deployment \ntools, if they specify a retention policy of RUNTIME , then they can be queried at run time \nby any Java program through the use of reflection . Reflection is the feature that enables \ninformation about a class to be obtained at run time. The reflection API is contained in the \njava.lang.reflect package. There are a number of ways to use reflection, and we won\u2019t \nexamine them all here. We will, however, walk through a few examples that apply to \nannotations. \nThe first step to using reflection is to obtain a Class object that represents the class whose \nannotations you want to obtain. Class is one of Java\u2019s built-in classes and is defined in \njava.lang . It is described in detail in Part II. There are various ways to obtain a Class \nobject. One of the easiest is to call getClass ( ) , which is a method defined by Object . Its \ngeneral form is shown here: \n\nfinal Class<?> getClass ( )",
    "final Class<?> getClass ( ) \n\nIt returns the Class object that represents the invoking object. \n\nNOTE    Notice the <?> that follows Class in the declaration of \n\ngetClass ( ) just shown. This is related to Java\u2019s generics feature. \ngetClass ( ) and several other reflection-related methods discussed in \nthis chapter make use of generics. Generics are described in Chapter 14. \nHowever, an understanding of generics is not needed to grasp the \nfundamental principles of reflection. \n\nAfter you have obtained a Class object, you can use its methods to obtain information \nabout the various items declared by the class, including its annotations. If you want to",
    "After you have obtained a Class object, you can use its methods to obtain information \nabout the various items declared by the class, including its annotations. If you want to \n\n\nobtain the annotations associated with a specific item declared within a class, you must first \nobtain an object that represents that item. For example, Class supplies ( among others ) the \ngetMethod ( ) , getField ( ) , and getConstructor ( ) methods, which obtain information \nabout a method, field, and constructor, respectively. These methods return objects of type \nMethod , Field , and Constructor . \nTo understand the process, let\u2019s work through an example that obtains the annotations \nassociated with a method. To do this, you first obtain a Class object that represents the \nclass, and then call getMethod ( ) on that Class object, specifying the name of the method. \ngetMethod ( ) has this general form: \n\nMethod getMethod ( String methName , Class<?> \u2026 paramTypes )",
    "Method getMethod ( String methName , Class<?> \u2026 paramTypes ) \n\nThe name of the method is passed in methName . If the method has arguments, \nthen Class objects representing those types must also be specified by \nparamTypes . Notice that paramTypes is a varargs parameter. This means that you \ncan specify as many parameter types as needed, including zero. getMethod ( ) \nreturns a Method object that represents the method. If the method can\u2019t be found, \nNoSuchMethodException is thrown. \nFrom a Class , Method , Field , or Constructor object, you can obtain a specific \nannotation associated with that object by calling getAnnotation ( ) . Its general form is \nshown here: \n\n<A extends Annotation> getAnnotation ( Class<A> annoType )",
    "<A extends Annotation> getAnnotation ( Class<A> annoType ) \n\nHere, annoType is a Class object that represents the annotation in which you are \ninterested. The method returns a reference to the annotation. Using this reference, \nyou can obtain the values associated with the annotation\u2019s members. The method \nreturns null if the annotation is not found, which will be the case if the annotation \ndoes not have RUNTIME retention. \nHere is a program that assembles all of the pieces shown earlier and uses reflection to \ndisplay the annotation associated with a method: \n\n\nThe output from the program is shown here: \n\nThis program uses reflection as described to obtain and display the values of str and val in \n\n\nthe MyAnno annotation associated with myMeth ( ) in the Meta class. There are two \n\nthings to pay special attention to. First, in this line",
    "the MyAnno annotation associated with myMeth ( ) in the Meta class. There are two \n\nthings to pay special attention to. First, in this line \n\nnotice the expression MyAnno.class . This expression evaluates to a Class object of type \nMyAnno , the annotation. This construct is called a class literal . You can use this type of \nexpression whenever a Class object of a known class is needed. For example, this statement \ncould have been used to obtain the Class object for Meta : \n\nOf course, this approach only works when you know the class name of an object in advance, \nwhich might not always be the case. In general, you can obtain a class literal for classes, \ninterfaces, primitive types, and arrays. ( Remember, the <?> syntax relates to Java\u2019s \ngenerics feature. It is described in Chapter 14.) \nThe second point of interest is the way the values associated with str and val are obtained \nwhen they are output by the following line:",
    "Notice that they are invoked using the method-call syntax. This same approach is used \nwhenever the value of an annotation member is required. \n\nA Second Reflection Example \n\nIn the preceding example, myMeth ( ) has no parameters. Thus, when getMethod ( ) was \n\ncalled, only the name myMeth was passed. However, to obtain a method that has \nparameters, you must specify class objects representing the types of those parameters as \narguments to getMethod ( ) . For example, here is a slightly different version of the \npreceding program: \n\n\nThe output from this version is shown here: \n\nIn this version, myMeth ( ) takes a String and an int parameter. To obtain information \nabout this method, getMethod ( ) must be called as shown here: \n\nHere, the Class objects representing String and int are passed as additional arguments. \n\nObtaining All Annotations",
    "Here, the Class objects representing String and int are passed as additional arguments. \n\nObtaining All Annotations \n\nYou can obtain all annotations that have RUNTIME retention that are associated with an \nitem by calling getAnnotations ( ) on that item. It has this general form: \n\n\nAnnotation[ ] getAnnotations ( ) \n\nIt returns an array of the annotations. getAnnotations ( ) can be called on objects \nof type Class , Method , Constructor , and Field , among others. \nHere is another reflection example that shows how to obtain all annotations associated with \na class and with a method. It declares two annotations. It then uses those annotations to \nannotate a class and a method. \n\n\nThe output is shown here:",
    "The output is shown here: \n\nThe program uses getAnnotations ( ) to obtain an array of all annotations associated with \nthe Meta2 class and with the myMeth ( ) method. As explained, getAnnotations ( ) \nreturns an array of Annotation objects. Recall that Annotation is a super-interface of all \nannotation interfaces and that it overrides toString ( ) in Object . Thus, when a reference \nto an Annotation is output, its toString ( ) method is called to generate a string that \ndescribes the annotation, as the preceding output shows. \n\nThe AnnotatedElement Interface \n\nThe methods getAnnotation ( ) and getAnnotations ( ) used by the preceding examples \nare defined by the AnnotatedElement interface, which is defined in java.lang.reflect .",
    "The methods getAnnotation ( ) and getAnnotations ( ) used by the preceding examples \nare defined by the AnnotatedElement interface, which is defined in java.lang.reflect . \n\nThis interface supports reflection for annotations and is implemented by the classes \nMethod , Field , Constructor , Class , and Package , among others. \nIn addition to getAnnotation ( ) and getAnnotations ( ) , AnnotatedElement defines \nseveral other methods. Two have been available since JDK 5. The first is \ngetDeclaredAnnotations ( ) , which has this general form: \n\nAnnotation[ ] getDeclaredAnnotations ( ) \n\n\nIt returns all non-inherited annotations present in the invoking object. The second \nis isAnnotationPresent ( ) , which has this general form: \n\nboolean isAnnotationPresent ( Class<? extends Annotation> annoType )",
    "boolean isAnnotationPresent ( Class<? extends Annotation> annoType ) \n\nIt returns true if the annotation specified by annoType is associated with the \ninvoking object. It returns false otherwise. To these, JDK 8 adds \ngetDeclaredAnnotation ( ) , getAnnotationsByType ( ) , and \ngetDeclaredAnnotationsByType ( ) . Of these, the last two automatically work \nwith a repeated annotation.( Repeated annotations are discussed at the end of this \nchapter.) \n\nUsing Default Values \n\nYou can give annotation members default values that will be used if no value is specified \nwhen the annotation is applied. A default value is specified by adding a default clause to a \nmember\u2019s declaration. It has this general form: \n\ntype member ( ) default value ; \n\nHere, value must be of a type compatible with type . \nHere is @MyAnno rewritten to include default values: \n\nThis declaration gives a default value of \"Testing\" to str and 9000 to val . This means that",
    "This declaration gives a default value of \"Testing\" to str and 9000 to val . This means that \n\nneither value needs to be specified when @MyAnno is used. However, either or both can \nbe given values if desired. Therefore, following are the four ways that @MyAnno can be \nused: \n\nThe following program demonstrates the use of default values in an annotation. \n\n\nThe output is shown here: \n\nMarker Annotations \n\nA marker annotation is a special kind of annotation that contains no members. Its sole \npurpose is to mark an item. Thus, its presence as an annotation is sufficient. The best way \nto determine if a marker annotation is present is to use the method \nisAnnotationPresent ( ) , which is defined by the AnnotatedElement interface. \n\n\nHere is an example that uses a marker annotation. Because a marker interface contains no \n\nmembers, simply determining whether it is present or absent is sufficient. \n\nThe output, shown here, confirms that @MyMarker is present:",
    "members, simply determining whether it is present or absent is sufficient. \n\nThe output, shown here, confirms that @MyMarker is present: \n\nIn the program, notice that you do not need to follow @MyMarker with parentheses when \n\nit is applied. Thus, @MyMarker is applied simply by using its name, like this: \n\n@MyMarker \n\nIt is not wrong to supply an empty set of parentheses, but they are not needed. \n\nSingle-Member Annotations \n\n\nA single-member annotation contains only one member. It works like a normal annotation \nexcept that it allows a shorthand form of specifying the value of the member. When only one \nmember is present, you can simply specify the value for that member when the annotation \nis applied\u2014you don\u2019t need to specify the name of the member. However, in order to use this \nshorthand, the name of the member must be value . \nHere is an example that creates and uses a single-member annotation:",
    "As expected, this program displays the value 100. In the program, @MySingle is used to \nannotate myMeth ( ) , as shown here: \n\nNotice that value = need not be specified. \n\n\nYou can use the single-value syntax when applying an annotation that has other members, \nbut those other members must all have default values. For example, here the value xyz is \nadded, with a default value of zero: \n\nIn cases in which you want to use the default for xyz , you can apply @SomeAnno , as \nshown next, by simply specifying the value of value by using the single-member syntax. \n\nIn this case, xyz defaults to zero, and value gets the value 88. Of course, to specify a \ndifferent value for xyz requires that both members be explicitly named, as shown here: \n\nRemember, whenever you are using a single-member annotation, the name of that member \nmust be value . \n\nThe Built-In Annotations",
    "Remember, whenever you are using a single-member annotation, the name of that member \nmust be value . \n\nThe Built-In Annotations \n\nJava defines many built-in annotations. Most are specialized, but nine are general purpose. \nOf these, four are imported from java.lang.annotation : @Retention , @Documented , \n@Target , and @Inherited . Five\u2014 @Override , @Deprecated , @FunctionalInterface , \n@SafeVarargs , and @SuppressWarnings \u2014are included in java.lang . Each is \ndescribed here. \n\nNOTE    To java.lang.annotation , JDK 8 adds the annotations \nRepeatable and Native. Repeatable supports repeatable annotations, \nas described later in this chapter. Native annotates a field that can be \naccessed by native code. \n\n@Retention \n\n@Retention is designed to be used only as an annotation to another annotation. It \nspecifies the retention policy as described earlier in this chapter. \n\n\n@Documented",
    "@Retention \n\n@Retention is designed to be used only as an annotation to another annotation. It \nspecifies the retention policy as described earlier in this chapter. \n\n\n@Documented \n\nThe @Documented annotation is a marker interface that tells a tool that an annotation is \nto be documented. It is designed to be used only as an annotation to an annotation \ndeclaration. \n\n@Target \n\nThe @Target annotation specifies the types of items to which an annotation can be applied. \nIt is designed to be used only as an annotation to another annotation. @Target takes one \nargument, which is an array of constants of the ElementType enumeration. This argument \nspecifies the types of declarations to which the annotation can be applied. The constants are \nshown here along with the type of declaration to which they correspond: \n\nTarget Constant \nAnnotation Can Be Applied To \n\nANNOTATION_TYPE \nAnother annotation \n\nCONSTRUCTOR \nConstructor \n\nFIELD \nField \n\nLOCAL_VARIABLE \nLocal variable",
    "Target Constant \nAnnotation Can Be Applied To \n\nANNOTATION_TYPE \nAnother annotation \n\nCONSTRUCTOR \nConstructor \n\nFIELD \nField \n\nLOCAL_VARIABLE \nLocal variable \n\nMETHOD \nMethod \n\nPACKAGE \nPackage \n\nPARAMETER \nParameter \n\nTYPE \nClass, interface, or enumeration \n\nTYPE_PARAMETER \nType parameter ( Added by JDK 8.) \n\nTYPE_USE \nType use ( Added by JDK 8.) \n\nYou can specify one or more of these values in a @Target annotation. To specify multiple \nvalues, you must specify them within a braces-delimited list. For example, to specify that an \nannotation applies only to fields and local variables, you can use this @Target annotation: \n\nIf you don't use @Target , then, except for type parameters, the annotation can be used on \nany declaration. For this reason, it is often a good idea to explicitly specify the target or \ntargets so as to clearly indicate the intended uses of an annotation. \n\n@Inherited",
    "@Inherited \n\n@Inherited is a marker annotation that can be used only on another annotation \ndeclaration. Furthermore, it affects only annotations that will be used on class declarations. \n@Inherited causes the annotation for a superclass to be inherited by a subclass. Therefore, \nwhen a request for a specific annotation is made to the subclass, if that annotation is not \n\n\npresent in the subclass, then its superclass is checked. If that annotation is present in the \nsuperclass, and if it is annotated with @Inherited , then that annotation will be returned. \n\n@Override \n\n@Override is a marker annotation that can be used only on methods. A method annotated \nwith @Override must override a method from a superclass. If it doesn\u2019t, a compile-time \nerror will result. It is used to ensure that a superclass method is actually overridden, and \nnot simply overloaded. \n\n@Deprecated",
    "@Deprecated \n\n@Deprecated is a marker annotation. It indicates that a declaration is obsolete and has \nbeen replaced by a newer form. \n\n@FunctionalInterface \n\n@FunctionalInterface is a marker annotation added by JDK 8 and designed for use on \ninterfaces. It indicates that the annotated interface is a functional interface. A functional \ninterface is an interface that contains one and only one abstract method. Functional \ninterfaces are used by lambda expressions. ( See Chapter 15 for details on functional \ninterfaces and lambda expressions.) If the annotated interface is not a functional interface, a \ncompilation error will be reported. It is important to understand that \n@FunctionalInterface is not needed to create a functional interface. Any interface with \nexactly one abstract method is, by definition, a functional interface. Thus, \n@FunctionalInterface is purely informational. \n\n@SafeVarargs \n\n@SafeVarargs is a marker annotation that can be applied to methods and constructors. It",
    "@SafeVarargs \n\n@SafeVarargs is a marker annotation that can be applied to methods and constructors. It \n\nindicates that no unsafe actions related to a varargs parameter occur. It is used to suppress \nunchecked warnings on otherwise safe code as it relates to non-reifiable vararg types and \nparameterized array instantiation. ( A non-reifiable type is, essentially, a generic type. \nGenerics are described in Chapter 14.) It must be applied only to vararg methods or \nconstructors that are static or final . \n\n@SuppressWarnings \n\n@SuppressWarnings specifies that one or more warnings that might be issued by the \ncompiler are to be suppressed. The warnings to suppress are specified by name, in string \nform. \n\nType Annotations",
    "@SuppressWarnings specifies that one or more warnings that might be issued by the \ncompiler are to be suppressed. The warnings to suppress are specified by name, in string \nform. \n\nType Annotations \n\nBeginning with JDK 8, the places in which annotations can be used has been expanded. As \nmentioned earlier, annotations were originally allowed only on declarations. However, with \nthe advent of JDK 8, annotations can also be specified in most cases in which a type is used. \nThis expanded aspect of annotations is called type annotation . For example, you can \nannotate the return type of a method, the type of this within a method, a cast, array levels, \n\n\nan inherited class, and a throws clause. You can also annotate generic types, including",
    "an inherited class, and a throws clause. You can also annotate generic types, including \n\ngeneric type parameter bounds and generic type arguments. ( See Chapter 14 for a discussion \nof generics.) \nType annotations are important because they enable tools to perform additional checks on \ncode to help prevent errors. Understand that, as a general rule, javac will not perform these \nchecks, itself. A separate tool is used for this purpose, although such a tool might operate as \na compiler plug-in. \nA type annotation must include ElementType.TYPE_USE as a target. ( Recall that valid \nannotation targets are specified using the @Target annotation, as previously described.) A \ntype annotation applies to the type that the annotation precedes. For example, assuming \nsome type annotation called @TypeAnno , the following is legal:",
    "Here, @ TypeAnno annotates NullPointerException in the throws clause. \nYou can also annotate the type of this ( called the receiver ). As you know, this is an implicit \nargument to all instance methods and it refers to the invoking object. To annotate its type \nrequires the use of another new JDK 8 feature. Beginning with JDK 8, you can explicitly \ndeclare this as the first parameter to a method. In this declaration, the type of this must be \nthe type of its class ; for example: \n\nHere, because myMeth ( ) is a method defined by SomeClass , the type of this is \nSomeClass . Using this declaration, you can now annotate the type of this . For example, \nagain assuming that @TypeAnno is a type annotation, the following is legal:",
    "It is important to understand that it is not necessary to declare this unless you are \nannotating it. ( If this is not declared, it is still implicitly passed. JDK 8 does not change this \nfact.) Also, explicitly declaring this does not change any aspect of the method\u2019s signature \nbecause this is implicitly declared, by default. Again, you will declare this only if you want \nto apply a type annotation to it. If you do declare this , it must be the first parameter. \n\nThe following program shows a number of the places that a type annotation can be used. It \ndefines several annotations, of which several are for type annotation. The names and targets \nof the annotations are shown here: \n\nAnnotation \nTarget \n\n@TypeAnno \nElementType.TYPE_USE \n\n\n@MaxLen \nElementType.TYPE_USE \n\n@NotZeroLen \nElementType.TYPE_USE \n\n@Unique \nElementType.TYPE_USE \n\n@What \nElementType.TYPE_PARAMETER \n\n@EmptyOK \nElementType.FIELD \n\n@Recommended \nElementType.METHOD",
    "@NotZeroLen \nElementType.TYPE_USE \n\n@Unique \nElementType.TYPE_USE \n\n@What \nElementType.TYPE_PARAMETER \n\n@EmptyOK \nElementType.FIELD \n\n@Recommended \nElementType.METHOD \n\nNotice that @EmptyOK , @Recommended , and @What are not type annotations. They \nare included for comparison purposes. Of special interest is @What , which is used to \nannotate a generic type parameter declaration and is another new annotation feature added \nby JDK 8. The comments in the program describe each use. \n\n\n\n\nAlthough what most of the annotations in the preceding program refer to is clear, four uses \n\nrequire a bit of discussion. The first is the annotation of a method return type versus the \nannotation of a method declaration. In the program, pay special attention to these two \nmethod declarations:",
    "Notice that in both cases, an annotation precedes the method\u2019s return type ( which is \nInteger ). However, the two annotations annotate two different things. In the first case, the \n@TypeAnno annotation annotates f2 ( ) \u2019s return type. This is because @TypeAnno has \nits target specified as ElementType.TYPE_USE , which means that it can be used to \nannotate type uses. In the second case, @Recommended annotates the method \ndeclaration, itself. This is because @Recommended has its target specified as \nElementType.METHOD . As a result, @Recommended applies to the declaration, not \nthe return type. Therefore, the target specification is used to eliminate what, at first glance, \nappears to be ambiguity between the annotation of a method declaration and the annotation \nof the method\u2019s return type. \nOne other thing about annotating a method return type: You cannot annotate a return type \nof void . \nThe second point of interest are the field annotations, shown here:",
    "Here, @TypeAnno annotates the type String , but @EmptyOK annotates the field test . \nEven though both annotations precede the entire declaration, their targets are different, \nbased on the target element type. If the annotation has the ElementType.TYPE_USE \ntarget, then the type is annotated. If it has ElementType_FIELD as a target, then the \nfield is annotated. Thus, the situation is similar to that just described for methods, and no \n\nambiguity exists. The same mechanism also disambiguates annotations on local variables. \n\nNext, notice how this ( the receiver ) is annotated here: \n\nHere, this is specified as the first parameter and is of type TypeAnnoDemo ( which is the \n\n\nclass of which f ( ) is a member ). As explained, beginning with JDK 8, an instance method \ndeclaration can explicitly specify the this parameter for the sake of applying a type \nannotation. \nFinally, look at how array levels are annotated by the following statement:",
    "In this declaration, @MaxLen annotates the type of the first level and @NotZeroLen \nannotates the type of the second level. In this declaration \n\nthe element type Integer is annotated. \n\nRepeating Annotations",
    "the element type Integer is annotated. \n\nRepeating Annotations \n\nAnother new JDK 8 annotation feature enables an annotation to be repeated on the same \nelement. This is called repeating annotations . For an annotation to be repeatable, it must \nbe annotated with the @Repeatable annotation, defined in java.lang.annotation . Its \nvalue field specifies the container type for the repeatable annotation. The container is \nspecified as an annotation for which the value field is an array of the repeatable annotation \ntype. Thus, to create a repeatable annotation, you must create a container annotation and \nthen specify that annotation type as an argument to the @Repeatable annotation. \nTo access the repeated annotations using a method such as getAnnotation ( ) , you will use \nthe container annotation, not the repeatable annotation. The following program shows this \napproach. It converts the version of MyAnno shown previously into a repeatable \nannotation and demonstrates its use.",
    "The output is shown here: \n\nAs explained, in order for MyAnno to be repeatable, it must be annotated with the \n@Repeatable annotation, which specifies its container annotation. The container \nannotation is called MyRepeatedAnnos . The program accesses the repeated annotations \nby calling getAnnotation ( ) , passing in the class of the container annotation, not the \nrepeatable annotation, itself. As the output shows, the repeated annotations are separated by \na comma. They are not returned individually. \nAnother way to obtain the repeated annotations is to use one of the new methods added to \nAnnotatedElement by JDK 8, which can operate directly on a repeated annotation. These \nare getAnnotationsByType ( ) and getDeclaredAnnotationsByType ( ) . Here, we will \nuse the former. It is shown here:",
    "It returns an array of the annotations of annoType associated with the invoking object. If no \nannotations are present, the array will be of zero length. Here is an example. Assuming the \npreceding program, the following sequence uses getAnnotationsByType ( ) to obtain the \nrepeated MyAnno annotations: \n\nHere, the repeated annotation type, which is MyAnno , is passed to \ngetAnnotationsByType ( ) . The returned array contains all of the instances of MyAnno \nassociated with myMeth ( ) , which, in this example, is two. Each repeated annotation can \nbe accessed via its index in the array. In this case, each MyAnno annotation is displayed \nvia a for-each loop. \n\nSome Restrictions \n\nThere are a number of restrictions that apply to annotation declarations. First, no \nannotation can inherit another. Second, all methods declared by an annotation must be \nwithout parameters. Furthermore, they must return one of the following: \n\n\u2022  A primitive type, such as int or double",
    "\u2022  A primitive type, such as int or double \n\n\u2022  An object of type String or Class \n\n\u2022  An enum type \n\n\n\u2022  Another annotation type \n\n\u2022  An array of one of the preceding types \n\nAnnotations cannot be generic. In other words, they cannot take type parameters. \n( Generics are described in Chapter 14.) Finally, annotation methods cannot specify \na throws clause. \n\n\uf709 \nPREV \nChapter 11: Multithreaded Programming \n\u23ee \n\nNEXT \nChapter 13: I/O, Applets, and Other Topics \u23ed \n\n\nPREV \nChapter 12: Enumerations, Autoboxing, and Ann\u2026 \n\u23ee \n\nNEXT \nChapter 14: Generics \u23ed \n\nCHAPTER \n\n13 \nI/O, Applets, and Other Topics",
    "This chapter introduces two of Java\u2019s most important packages: io and applet . The io \npackage supports Java\u2019s basic I/O ( input/output ) system, including file I/O. The applet \npackage supports applets. Support for both I/O and applets comes from Java\u2019s core API \nlibraries, not from language keywords. For this reason, an in-depth discussion of these \ntopics is found in Part II of this book, which examines Java\u2019s API classes. This chapter \ndiscusses the foundation of these two subsystems so that you can see how they are \nintegrated into the Java language and how they fit into the larger context of the Java \nprogramming and execution environment. This chapter also examines the try -withresources statement and the last of Java\u2019s keywords: transient , volatile , instanceof , \nnative , strictfp , and assert . It concludes by discussing static import, describing another \nuse for the this keyword, and introducing compact profiles ( a feature added by JDK 8 ). \n\nI/O Basics",
    "As you may have noticed while reading the preceding 12 chapters, not much use has been \nmade of I/O in the example programs. In fact, aside from print ( ) and println ( ) , none of \nthe I/O methods have been used significantly. The reason is simple: most real applications \nof Java are not text-based, console programs. Rather, they are either graphically oriented \nprograms that rely on one of Java\u2019s graphical user interface ( GUI ) frameworks, such as \nSwing, the AWT, or JavaFX, for user interaction, or they are Web applications. Although \ntext-based, console programs are excellent as teaching examples, they do not constitute an \nimportant use for Java in the real world. Also, Java\u2019s support for console I/O is limited and \nsomewhat awkward to use\u2014even in simple example programs. Text-based console I/O is \njust not that useful in real-world Java programming. \nThe preceding paragraph notwithstanding, Java does provide strong, flexible support for \nI/O as it relates to files and networks",
    ". \nThe preceding paragraph notwithstanding, Java does provide strong, flexible support for \nI/O as it relates to files and networks. Java\u2019s I/O system is cohesive and consistent. In fact, \nonce you understand its fundamentals, the rest of the I/O system is easy to master. A",
    "general overview of I/O is presented here. A detailed description is found in Chapters 20 \nand 21. \n\nStreams \n\n\nJava programs perform I/O through streams. A stream is an abstraction that either \n\nproduces or consumes information. A stream is linked to a physical device by the Java I/O \nsystem. All streams behave in the same manner, even if the actual physical devices to which \nthey are linked differ. Thus, the same I/O classes and methods can be applied to different \ntypes of devices. This means that an input stream can abstract many different kinds of \ninput: from a disk file, a keyboard, or a network socket. Likewise, an output stream may \nrefer to the console, a disk file, or a network connection. Streams are a clean way to deal \nwith input/ output without having every part of your code understand the difference \nbetween a keyboard and a network, for example. Java implements streams within class \nhierarchies defined in the java.io package.",
    "NOTE In addition to the stream-based I/O defined in java.io , Java also \nprovides buffer- and channel-based I/O, which is defined in java.nio and \nits subpackages. They are described in Chapter 21. \n\nByte Streams and Character Streams",
    "Java defines two types of streams: byte and character. Byte streams provide a convenient \nmeans for handling input and output of bytes. Byte streams are used, for example, when \nreading or writing binary data. Character streams provide a convenient means for handling \ninput and output of characters. They use Unicode and, therefore, can be internationalized. \nAlso, in some cases, character streams are more efficient than byte streams. \nThe original version of Java ( Java 1.0 ) did not include character streams and, thus, all I/O \nwas byte-oriented. Character streams were added by Java 1.1, and certain byte-oriented \nclasses and methods were deprecated. Although old code that doesn\u2019t use character streams \nis becoming increasingly rare, it may still be encountered from time to time. As a general \nrule, old code should be updated to take advantage of character streams where appropriate. \nOne other point: at the lowest level, all I/O is still byte-oriented",
    ". As a general \nrule, old code should be updated to take advantage of character streams where appropriate. \nOne other point: at the lowest level, all I/O is still byte-oriented. The character-based \nstreams simply provide a convenient and efficient means for handling characters. \nAn overview of both byte-oriented streams and character-oriented streams is presented in \nthe following sections.",
    "The Byte Stream Classes \nByte streams are defined by using two class hierarchies. At the top are two abstract classes: \nInputStream and OutputStream . Each of these abstract classes has several concrete \nsubclasses that handle the differences among various devices, such as disk files, network \nconnections, and even memory buffers. The byte stream classes in java.io are shown in \n\nTable 13-1. A few of these classes are discussed later in this section. Others are described in \n\n\nPart II of this book. Remember, to use the stream classes, you must import java.io . \n\nTable 13-1    The Byte Stream Classes in java.io \n\nThe abstract classes InputStream and OutputStream define several key \nmethods that the other stream classes implement. Two of the most important are \nread ( ) and write ( ) , which, respectively, read and write bytes of data. Each has a \nform that is abstract and must be overridden by derived stream classes.",
    "The Character Stream Classes \nCharacter streams are defined by using two class hierarchies. At the top are two abstract \nclasses: Reader and Writer . These abstract classes handle Unicode character streams. \nJava has several concrete subclasses of each of these. The character stream classes in \njava.io are shown in Table 13-2. \n\n\nTable 13-2    The Character Stream I/O Classes in java.io \n\nThe abstract classes Reader and Writer define several key methods that the \nother stream classes implement. Two of the most important methods are read ( ) \nand write ( ) , which read and write characters of data, respectively. Each has a \nform that is abstract and must be overridden by derived stream classes. \n\nThe Predefined Streams",
    "The Predefined Streams \n\nAs you know, all Java programs automatically import the java.lang package. This package \ndefines a class called System , which encapsulates several aspects of the run-time \nenvironment. For example, using some of its methods, you can obtain the current time and \nthe settings of various properties associated with the system. System also contains three \npredefined stream variables: in , out , and err . These fields are declared as public , static , \nand final within System . This means that they can be used by any other part of your \nprogram and without reference to a specific System object. \nSystem.out refers to the standard output stream. By default, this is the console.",
    "System.in refers to standard input, which is the keyboard by default. System.err refers to \nthe standard error stream, which also is the console by default. However, these streams may \nbe redirected to any compatible I/O device. \nSystem.in is an object of type InputStream ; System.out and System.err are objects of \ntype PrintStream . These are byte streams, even though they are typically used to read and \nwrite characters from and to the console. As you will see, you can wrap these within \n\ncharacter-based streams, if desired. \n\n\nThe preceding chapters have been using System.out in their examples. You can use \n\nSystem.err in much the same way. As explained in the next section, use of System.in is a \nlittle more complicated. \n\nReading Console Input",
    "System.err in much the same way. As explained in the next section, use of System.in is a \nlittle more complicated. \n\nReading Console Input \n\nIn Java 1.0, the only way to perform console input was to use a byte stream. Today, using a \nbyte stream to read console input is still acceptable. However, for commercial applications, \nthe preferred method of reading console input is to use a character-oriented stream. This \nmakes your program easier to internationalize and maintain. \nIn Java, console input is accomplished by reading from System.in . To obtain a characterbased stream that is attached to the console, wrap System.in in a BufferedReader \nobject. BufferedReader supports a buffered input stream. A commonly used constructor \nis shown here: \n\nBufferedReader ( Reader inputReader )",
    "BufferedReader ( Reader inputReader ) \n\nHere, inputReader is the stream that is linked to the instance of BufferedReader \nthat is being created. Reader is an abstract class. One of its concrete subclasses is \nInputStreamReader , which converts bytes to characters. To obtain an \nInputStreamReader object that is linked to System.in , use the following \nconstructor: \n\nInputStreamReader ( InputStream inputStream ) \n\nBecause System.in refers to an object of type InputStream , it can be used for \ninputStream . Putting it all together, the following line of code creates a \nBufferedReader that is connected to the keyboard: \n\nAfter this statement executes, br is a character-based stream that is linked to the console \nthrough System.in . \n\nReading Characters \n\nTo read a character from a BufferedReader , use read ( ) . The version of read ( ) that we \nwill be using is \n\nint read ( ) throws IOException",
    "Reading Characters \n\nTo read a character from a BufferedReader , use read ( ) . The version of read ( ) that we \nwill be using is \n\nint read ( ) throws IOException \n\nEach time that read ( ) is called, it reads a character from the input stream and \nreturns it as an integer value. It returns \u20131 when the end of the stream is \nencountered. As you can see, it can throw an IOException . \nThe following program demonstrates read ( ) by reading characters from the console until \nthe user types a \"q.\" Notice that any I/O exceptions that might be generated are simply \nthrown out of main ( ) . Such an approach is common when reading from the console in \n\n\nsimple example programs such as those shown in this book, but in more sophisticated \n\napplications, you can handle the exceptions explicitly. \n\nHere is a sample run:",
    "simple example programs such as those shown in this book, but in more sophisticated \n\napplications, you can handle the exceptions explicitly. \n\nHere is a sample run: \n\nThis output may look a little different from what you expected because System.in is line \nbuffered, by default. This means that no input is actually passed to the program until you \npress ENTER . As you can guess, this does not make read ( ) particularly valuable for \n\ninteractive console input. \n\nReading Strings \n\nTo read a string from the keyboard, use the version of readLine ( ) that is a member of the \n\nBufferedReader class. Its general form is shown here: \n\nString readLine ( ) throws IOException \n\nAs you can see, it returns a String object. \nThe following program demonstrates BufferedReader and the readLine ( ) method ; the \n\n\nprogram reads and displays lines of text until you enter the word \"stop\":",
    "program reads and displays lines of text until you enter the word \"stop\": \n\nThe next example creates a tiny text editor. It creates an array of String objects and then \nreads in lines of text, storing each line in the array. It will read up to 100 lines or until you \nenter \"stop.\" It uses a BufferedReader to read from the console. \n\n\nHere is a sample run: \n\nWriting Console Output \n\nConsole output is most easily accomplished with print ( ) and println ( ) , described earlier, \n\nwhich are used in most of the examples in this book. These methods are defined by the class \nPrintStream ( which is the type of object referenced by System.out ). Even though \nSystem.out is a byte stream, using it for simple program output is still acceptable. \n\nHowever, a character-based alternative is described in the next section.",
    "However, a character-based alternative is described in the next section. \n\n\nBecause PrintStream is an output stream derived from OutputStream , it also \nimplements the low-level method write ( ) . Thus, write ( ) can be used to write to the \nconsole. The simplest form of write ( ) defined by PrintStream is shown here: \n\nvoid write ( int byteval ) \n\nThis method writes the byte specified by byteval . Although byteval is declared as \nan integer, only the low-order eight bits are written. Here is a short example that \nuses write ( ) to output the character \"A\" followed by a newline to the screen: \n\nYou will not often use write ( ) to perform console output ( although doing so might be \nuseful in some situations ) because print ( ) and println ( ) are substantially easier to use. \n\nThe PrintWriter Class",
    "The PrintWriter Class \n\nAlthough using System.out to write to the console is acceptable, its use is probably best for \ndebugging purposes or for sample programs, such as those found in this book. For realworld programs, the recommended method of writing to the console when using Java is \nthrough a PrintWriter stream. PrintWriter is one of the character-based classes. Using a \ncharacter-based class for console output makes internationalizing your program easier. \nPrintWriter defines several constructors. The one we will use is shown here: \n\nPrintWriter ( OutputStream outputStream , boolean flushingOn ) \n\nHere, outputStream is an object of type OutputStream , and flushingOn controls \nwhether Java flushes the output stream every time a println ( ) method ( among \nothers ) is called. If flushingOn is true , flushing automatically takes place. If false , \nflushing is not automatic. \n\nPrintWriter supports the print ( ) and println ( ) methods. Thus, you can use these",
    "PrintWriter supports the print ( ) and println ( ) methods. Thus, you can use these \n\nmethods in the same way as you used them with System.out . If an argument is not a \nsimple type, the PrintWriter methods call the object\u2019s toString ( ) method and then \ndisplay the result. \nTo write to the console by using a PrintWriter , specify System.out for the output stream \nand automatic flushing. For example, this line of code creates a PrintWriter that is \n\n\nconnected to console output: \n\nThe following application illustrates using a PrintWriter to handle console output: \n\nThe output from this program is shown here:",
    "connected to console output: \n\nThe following application illustrates using a PrintWriter to handle console output: \n\nThe output from this program is shown here: \n\nRemember, there is nothing wrong with using System.out to write simple text output to \nthe console when you are learning Java or debugging your programs. However, using a \nPrintWriter makes your real-world applications easier to internationalize. Because no \nadvantage is gained by using a PrintWriter in the sample programs shown in this book, \nwe will continue to use System.out to write to the console. \n\nReading and Writing Files",
    "Reading and Writing Files \n\nJava provides a number of classes and methods that allow you to read and write files. Before \nwe begin, it is important to state that the topic of file I/O is quite large and file I/O is \nexamined in detail in Part II. The purpose of this section is to introduce the basic \ntechniques that read from and write to a file. Although bytes streams are used, these \ntechniques can be adapted to the character-based streams. \nTwo of the most often-used stream classes are FileInputStream and \nFileOutputStream , which create byte streams linked to files. To open a file, you simply \n\ncreate an object of one of these classes, specifying the name of the file as an argument to the \nconstructor. Although both classes support additional constructors, the following are the \n\n\nforms that we will be using: \n\nFileInputStream ( String fileName ) throws FileNotFoundException \nFileOutputStream ( String fileName ) throws FileNotFoundException",
    "forms that we will be using: \n\nFileInputStream ( String fileName ) throws FileNotFoundException \nFileOutputStream ( String fileName ) throws FileNotFoundException \n\nHere, fileName specifies the name of the file that you want to open. When you \ncreate an input stream, if the file does not exist, then FileNotFoundException \nis thrown. For output streams, if the file cannot be opened or created, then \nFileNotFoundException is thrown. FileNotFoundException is a subclass of \nIOException . When an output file is opened, any preexisting file by the same \nname is destroyed.",
    "NOTE In situations in which a security manager is present, several of the \nfile classes, including FileInputStream and FileOutputStream , will \nthrow a SecurityException if a security violation occurs when \nattempting to open a file. By default, applications run via java do not use \na security manager. For that reason, the I/O examples in this book do not \nneed to watch for a possible SecurityException . However, other types \nof applications ( such as applets ) will use the security manager, and file \nI/O performed by such an application could generate a \nSecurityException . In that case, you will need to appropriately handle \nthis exception. \n\nWhen you are done with a file, you must close it. This is done by calling the close ( ) \nmethod, which is implemented by both FileInputStream and FileOutputStream . It is \nshown here: \n\nvoid close ( ) throws IOException",
    "void close ( ) throws IOException \n\nClosing a file releases the system resources allocated to the file, allowing them to \nbe used by another file. Failure to close a file can result in \u201cmemory leaks\u201d because \nof unused resources remaining allocated. \n\nNOTE Beginning with JDK 7, the close ( ) method is specified by the \nAutoCloseable interface in java.lang. AutoCloseable is inherited by \nthe Closeable interface in java.io . Both interfaces are implemented by \nthe stream classes, including FileInputStream and \n\n\nFileOutputStream .",
    "Before moving on, it is important to point out that there are two basic approaches that you \ncan use to close a file when you are done with it. The first is the traditional approach, in \nwhich close ( ) is called explicitly when the file is no longer needed. This is the approach \nused by all versions of Java prior to JDK 7 and is, therefore, found in all pre-JDK 7 legacy \ncode. The second is to use the try -with-resources statement added by JDK 7, which \nautomatically closes a file when it is no longer needed. In this approach, no explicit call to \nclose ( ) is executed. Since there is a large amount of pre-JDK 7 legacy code that is still \nbeing used and maintained, it is important that you know and understand the traditional \napproach. Therefore, we will begin with it. The new automated approach is described in the \nfollowing section. \nTo read from a file, you can use a version of read ( ) that is defined within \nFileInputStream . The one that we will use is shown here:",
    "int read ( ) throws IOException \n\nEach time that it is called, it reads a single byte from the file and returns the byte \nas an integer value. read ( ) returns \u20131 when the end of the file is encountered. It \ncan throw an IOException . \nThe following program uses read ( ) to input and display the contents of a file that contains \nASCII text. The name of the file is specified as a command-line argument. \n\n\nIn the program, notice the try/catch blocks that handle the I/O errors that might occur. \nEach I/O operation is monitored for exceptions, and if an exception occurs, it is handled. Be \naware that in simple programs or example code, it is common to see I/O exceptions simply \nthrown out of main ( ) , as was done in the earlier console I/O examples. Also, in some realworld code, it can be helpful to let an exception propagate to a calling routine to let the",
    "caller know that an I/O operation failed. However, most of the file I/O examples in this \nbook handle all I/O exceptions explicitly, as shown, for the sake of illustration. \nAlthough the preceding example closes the file stream after the file is read, there is a \nvariation that is often useful. The variation is to call close ( ) within a finally block. In this \napproach, all of the methods that access the file are contained within a try block, and the \nfinally block is used to close the file. This way, no matter how the try block terminates, the \nfile is closed. Assuming the preceding example, here is how the try block that reads the file \ncan be recoded:",
    "Although not an issue in this case, one advantage to this approach in general is that if the \ncode that accesses a file terminates because of some non-I/O related exception, the file is \nstill closed by the finally block. \nSometimes it\u2019s easier to wrap the portions of a program that open the file and access the file \nwithin a single try block ( rather than separating the two ) and then use a finally block to \nclose the file. For example, here is another way to write the ShowFile program: \n\n\nIn this approach, notice that fin is initialized to null . Then, in the finally block, the file is \nclosed only if fin is not null . This works because fin will be non- null only if the file is \n\nsuccessfully opened. Thus, close ( ) is not called if an exception occurs while opening the \nfile. \nIt is possible to make the try/catch sequence in the preceding example a bit more compact.",
    "successfully opened. Thus, close ( ) is not called if an exception occurs while opening the \nfile. \nIt is possible to make the try/catch sequence in the preceding example a bit more compact. \n\n\nBecause FileNotFoundException is a subclass of IOException , it need not be caught \nseparately. For example, here is the sequence recoded to eliminate catching \nFileNotFoundException . In this case, the standard exception message, which describes \nthe error, is displayed.",
    "In this approach, any error, including an error opening the file, is simply handled by the \nsingle catch statement. Because of its compactness, this approach is used by many of the \nI/O examples in this book. Be aware, however, that this approach is not appropriate in \ncases in which you want to deal separately with a failure to open a file, such as might be \ncaused if a user mistypes a filename. In such a situation, you might want to prompt for the \ncorrect name, for example, before entering a try block that accesses the file. \nTo write to a file, you can use the write ( ) method defined by FileOutputStream . Its \nsimplest form is shown here: \n\nvoid write ( int byteval ) throws IOException \n\nThis method writes the byte specified by byteval to the file. Although byteval is \ndeclared as an integer, only the low-order eight bits are written to the file. If an \n\nerror occurs during writing, an IOException is thrown. The next example uses \nwrite ( ) to copy a file:",
    "error occurs during writing, an IOException is thrown. The next example uses \nwrite ( ) to copy a file: \n\n\nIn the program, notice that two separate try blocks are used when closing the files. This \nensures that both files are closed, even if the call to fin.close ( ) throws an exception. \nIn general, notice that all potential I/O errors are handled in the preceding two programs by \nthe use of exceptions. This differs from some computer languages that use error codes to \n\nreport file errors. Not only do exceptions make file handling cleaner, but they also enable \n\n\nJava to easily differentiate the end-of-file condition from file errors when input is being \nperformed. \n\nAutomatically Closing a File",
    "Automatically Closing a File \n\nIn the preceding section, the example programs have made explicit calls to close ( ) to close \na file once it is no longer needed. As mentioned, this is the way files were closed when using \nversions of Java prior to JDK 7. Although this approach is still valid and useful, JDK 7 \nadded a new feature that offers another way to manage resources, such as file streams, by \nautomating the closing process. This feature, sometimes referred to as automatic resource \nmanagement , or ARM for short, is based on an expanded version of the try statement. The \nprincipal advantage of automatic resource management is that it prevents situations in \nwhich a file ( or other resource ) is inadvertently not released after it is no longer needed. As \nexplained, forgetting to close a file can result in memory leaks, and could lead to other \nproblems. \nAutomatic resource management is based on an expanded form of the try statement. Here \nis its general form:",
    "Here, resource-specification is a statement that declares and initializes a resource, such as a \nfile stream. It consists of a variable declaration in which the variable is initialized with a \nreference to the object being managed. When the try block ends, the resource is \nautomatically released. In the case of a file, this means that the file is automatically closed. \n( Thus, there is no need to call close ( ) explicitly.) Of course, this form of try can also \ninclude catch and finally clauses. This new form of try is called the try -with-resources \nstatement. \nThe try -with-resources statement can be used only with those resources that implement the \nAutoCloseable interface defined by java.lang . This interface defines the close ( ) \nmethod. AutoCloseable is inherited by the Closeable interface in java.io . Both interfaces \nare implemented by the stream classes. Thus, try -with-resources can be used when working \nwith streams, including file streams.",
    "As a first example of automatically closing a file, here is a reworked version of the \nShowFile program that uses it: \n\n\nIn the program, pay special attention to how the file is opened within the try statement: \n\nNotice how the resource-specification portion of the try declares a FileInputStream \n\ncalled fin , which is then assigned a reference to the file opened by its constructor. Thus, in \nthis version of the program, the variable fin is local to the try block, being created when the \ntry is entered. When the try is left, the stream associated with fin is automatically closed by \nan implicit call to close ( ) . You don\u2019t need to call close ( ) explicitly, which means that you",
    "can\u2019t forget to close the file. This is a key advantage of using try -with-resources. \nIt is important to understand that the resource declared in the try statement is implicitly \nfinal . This means that you can\u2019t assign to the resource after it has been created. Also, the \nscope of the resource is limited to the try -with-resources statement. \nYou can manage more than one resource within a single try statement. To do so, simply \nseparate each resource specification with a semicolon. The following program shows an \nexample. It reworks the CopyFile program shown earlier so that it uses a single try -with- \n\n\nresources statement to manage both fin and fout . \n\nIn this program, notice how the input and output files are opened within the try block:",
    "resources statement to manage both fin and fout . \n\nIn this program, notice how the input and output files are opened within the try block: \n\nAfter this try block ends, both fin and fout will have been closed. If you compare this \nversion of the program to the previous version, you will see that it is much shorter. The \nability to streamline source code is a side-benefit of automatic resource management. \nThere is one other aspect to try -with-resources that needs to be mentioned. In general, \nwhen a try block executes, it is possible that an exception inside the try block will lead to \nanother exception that occurs when the resource is closed in a finally clause. In the case of",
    "a \u201cnormal\u201d try statement, the original exception is lost, being preempted by the second \nexception. However, when using try -with-resources, the second exception is suppressed . It \nis not, however, lost. Instead, it is added to the list of suppressed exceptions associated with \nthe first exception. The list of suppressed exceptions can be obtained by using the \ngetSuppressed ( ) method defined by Throwable . \nBecause of the benefits that the try -with-resources statement offers, it will be used by \nmany, but not all, of the example programs in this edition of this book. Some of the \nexamples will still use the traditional approach to closing a resource. There are several \nreasons for this. First, there is legacy code that still relies on the traditional approach. It is \nimportant that all Java programmers be fully versed in, and comfortable with, the \ntraditional approach when maintaining this older code",
    ". It is \nimportant that all Java programmers be fully versed in, and comfortable with, the \ntraditional approach when maintaining this older code. Second, because not all project \ndevelopment will immediately switch to a new version of the JDK, it is likely that some \nprogrammers will continue to work in a pre-JDK 7 environment for a period of time. In \nsuch situations, the expanded form of try is not available. Finally, there may be cases in \nwhich explicitly closing a resource is more appropriate than the automated approach. For \nthese reasons, some of the examples in this book will continue to use the traditional \napproach, explicitly calling close ( ) . In addition to illustrating the traditional technique, \nthese examples can also be compiled and run by all readers in all environments.",
    "REMEMBER A few examples in this book use the traditional approach \nto closing files as a means of illustrating this technique, which is widely \nused in legacy code. However, for new code, you will usually want to use \nthe new automated approach supported by the try -with-resources \nstatement just described. \n\nApplet Fundamentals \n\nAll of the preceding examples in this book have been Java console-based applications. \nHowever, these types of applications constitute only one class of Java programs. Another \ntype of program is the applet. As mentioned in Chapter 1, applets are small applications \nthat are accessed on an Internet server, transported over the Internet, automatically \ninstalled, and run as part of a web document. After an applet arrives on the client, it has \nlimited access to resources so that it can produce a graphical user interface and run various \ncomputations without introducing the risk of viruses or breaching data integrity.",
    "Many of the issues connected with the creation and use of applets are found in Part II, when \nthe applet package is examined, and also when Swing is described in Part III. However, the \nfundamentals connected to the creation of an applet are presented here, because applets are \n\n\nnot structured in the same way as the programs that have been used thus far. As you will \nsee, applets differ from console-based applications in several key areas. \nLet\u2019s begin with the simple applet shown here:",
    "This applet begins with two import statements. The first imports the Abstract Window \nToolkit ( AWT ) classes. Applets interact with the user through a GUI framework, not through \nthe console-based I/O classes. One of these frameworks is the AWT, and that is the \nframework used here to introduce applet programming. The AWT contains very basic \nsupport for a window-based, graphical user interface. As you might expect, the AWT is quite \nlarge, and a detailed discussion of it is found in Part II of this book. Fortunately, this simple \napplet makes very limited use of the AWT. ( Another commonly used GUI for applets is \nSwing, but this approach is described later in this book.) The second import statement \nimports the applet package, which contains the class Applet . Every AWT-based applet that \nyou create must be a subclass ( either directly or indirectly ) of Applet . \nThe next line in the program declares the class SimpleApplet",
    ". Every AWT-based applet that \nyou create must be a subclass ( either directly or indirectly ) of Applet . \nThe next line in the program declares the class SimpleApplet . This class must be declared \nas public , because it will be accessed by code that is outside the program. \nInside SimpleApplet , paint ( ) is declared. This method is defined by the AWT and must \nbe overridden by the applet. paint ( ) is called each time that the applet must redisplay its \noutput. This situation can occur for several reasons. For example, the window in which the \napplet is running can be overwritten by another window and then uncovered. Or, the applet \nwindow can be minimized and then restored. paint ( ) is also called when the applet begins \nexecution. Whatever the cause, whenever the applet must redraw its output, paint ( ) is \ncalled. The paint ( ) method has one parameter of type Graphics",
    ". Whatever the cause, whenever the applet must redraw its output, paint ( ) is \ncalled. The paint ( ) method has one parameter of type Graphics . This parameter contains \nthe graphics context, which describes the graphics environment in which the applet is \nrunning. This context is used whenever output to the applet is required.",
    "Inside paint ( ) is a call to drawString ( ) , which is a member of the Graphics class. This \nmethod outputs a string beginning at the specified X,Y location. It has the following general \nform: \n\nvoid drawString ( String message , int x , int y ) \n\nHere, message is the string to be output beginning at x , y . In a Java window, the \nupper-left corner is location 0,0. The call to drawString ( ) in the applet causes",
    "Here, message is the string to be output beginning at x , y . In a Java window, the \nupper-left corner is location 0,0. The call to drawString ( ) in the applet causes \n\n\nthe message \"A Simple Applet\" to be displayed beginning at location 20,20. \nNotice that the applet does not have a main ( ) method. Unlike Java programs, applets do \nnot begin execution at main ( ) . In fact, most applets don\u2019t even have a main ( ) method. \nInstead, an applet begins execution when the name of its class is passed to an applet viewer \nor to a network browser. \nAfter you enter the source code for SimpleApplet , compile in the same way that you have \nbeen compiling programs. However, running SimpleApplet involves a different process. In \nfact, there are two ways in which you can run an applet: \n\n\u2022  Executing the applet within a Java-compatible web browser.",
    "\u2022  Executing the applet within a Java-compatible web browser. \n\n\u2022  Using an applet viewer, such as the standard tool, appletviewer . An \napplet viewer executes your applet in a window. This is generally the fastest \nand easiest way to test your applet. \n\nEach of these methods is described next. \nOne way to execute an applet in a web browser is to write a short HTML text file that \ncontains a tag that loads the applet. At the time of this writing, Oracle recommends using \nthe APPLET tag for this purpose. ( The OBJECT tag can also be used. See Chapter 23 for \nfurther information regarding applet deployment strategies.) Using APPLET, here is the \nHTML file that executes SimpleApplet : \n\nThe width and height statements specify the dimensions of the display area used by the \napplet. ( The APPLET tag contains several other options that are examined more closely in \nPart II.) After you create this file, you can use it to execute the applet.",
    "NOTE Beginning with the release of Java 7, update 21, Java applets must \nbe signed to prevent security warnings when run in a browser. In fact, in \nsome cases, the applet may be prevented from running. Applets stored in \nthe local file system, such as you would create when compiling the \nexamples in this book, are especially sensitive to this change. You may \n\nneed to adjust the security settings in the Java Control Panel to run a \nlocal applet in a browser. At the time of this writing, Oracle recommends \n\nagainst the use of local applets, recommending instead that applets be \nexecuted through a web server. Furthermore, it is expected that unsigned \nlocal applets will be blocked from execution in the future. In general, for \napplets that will be distributed via the Internet, such as commercial \n\n\napplications, signing is a virtual necessity. The concepts and techniques",
    "applications, signing is a virtual necessity. The concepts and techniques \n\nrequired to sign applets ( and other types of Java programs ) are beyond \nthe scope of this book. However, extensive information is found on \nOracle\u2019s website. Finally, as mentioned, the easiest way to try the applet \nexamples is to use appletviewer . \n\nTo execute SimpleApplet with an applet viewer, you may also execute the HTML file \nshown earlier. For example, if the preceding HTML file is called RunApp.html , then the \nfollowing command line will run SimpleApplet : \n\nC:\\>appletviewer RunApp.html",
    "C:\\>appletviewer RunApp.html \n\nHowever, a more convenient method exists that you can use to speed up testing. \nSimply include a comment at the head of your Java source code file that contains \nthe APPLET tag. By doing so, your code is documented with a prototype of the \nnecessary HTML statements, and you can test your compiled applet merely by \nstarting the applet viewer with your Java source code file. If you use this method, \nthe SimpleApplet source file looks like this: \n\nWith this approach, you can quickly iterate through applet development by using these three \n\nsteps: \n\n1.  Edit a Java source file. \n\n2.  Compile your program. \n\n3.  Execute the applet viewer, specifying the name of your applet\u2019s source \nfile. The applet viewer will encounter the APPLET tag within the comment \nand execute your applet. \n\nThe window produced by SimpleApplet , as displayed by the applet viewer, is",
    "The window produced by SimpleApplet , as displayed by the applet viewer, is \n\n\nshown in the following illustration. Of course, the precise appearance of the applet \nviewer frame may differ based on your environment. For this reason, the screen \ncaptures in this book reflect a number of different environments. \n\nWhile the subject of applets is more fully discussed later in this book, here are the key \npoints that you should remember now: \n\n\u2022  Applets do not need a main ( ) method. \n\n\u2022  Applets must be run under an applet viewer or a Java-compatible \nbrowser. \n\n\u2022  User I/O is not accomplished with Java\u2019s stream I/O classes. Instead, \napplets use the interface provided by a GUI framework. \n\nThe transient and volatile Modifiers \n\nJava defines two interesting type modifiers: transient and volatile . These modifiers are",
    "The transient and volatile Modifiers \n\nJava defines two interesting type modifiers: transient and volatile . These modifiers are \n\nused to handle somewhat specialized situations. \nWhen an instance variable is declared as transient , then its value need not persist when an \nobject is stored. For example: \n\nHere, if an object of type T is written to a persistent storage area, the contents of a would \nnot be saved, but the contents of b would. \nThe volatile modifier tells the compiler that the variable modified by volatile can be \nchanged unexpectedly by other parts of your program. One of these situations involves \nmultithreaded programs. In a multithreaded program, sometimes two or more threads \nshare the same variable. For efficiency considerations, each thread can keep its own, private \ncopy of such a shared variable. The real ( or master ) copy of the variable is updated at",
    "various times, such as when a synchronized method is entered. While this approach works \nfine, it may be inefficient at times. In some cases, all that really matters is that the master \ncopy of a variable always reflects its current state. To ensure this, simply specify the variable \nas volatile , which tells the compiler that it must always use the master copy of a volatile \nvariable ( or, at least, always keep any private copies up-to-date with the master copy, and \nvice versa ). Also, accesses to the master variable must be executed in the precise order in \nwhich they are executed on any private copy. \n\nUsing instanceof",
    "Sometimes, knowing the type of an object during run time is useful. For example, you might \nhave one thread of execution that generates various types of objects, and another thread \nthat processes these objects. In this situation, it might be useful for the processing thread to \nknow the type of each object when it receives it. Another situation in which knowledge of an \nobject\u2019s type at run time is important involves casting. In Java, an invalid cast causes a runtime error. Many invalid casts can be caught at compile time. However, casts involving class \nhierarchies can produce invalid casts that can be detected only at run time. For example, a \nsuperclass called A can produce two subclasses, called B and C. Thus, casting a B object into \ntype A or casting a C object into type A is legal, but casting a B object into type C ( or vice \nversa ) isn\u2019t legal",
    ". Thus, casting a B object into \ntype A or casting a C object into type A is legal, but casting a B object into type C ( or vice \nversa ) isn\u2019t legal. Because an object of type A can refer to objects of either B or C, how can \nyou know, at run time, what type of object is actually being referred to before attempting the \ncast to type C? It could be an object of type A, B, or C. If it is an object of type B, a run-time \nexception will be thrown. Java provides the run-time operator instanceof to answer this \nquestion. \nThe instanceof operator has this general form:",
    "objref instanceof type \n\nHere, objref is a reference to an instance of a class, and type is a class type. If \nobjref is of the specified type or can be cast into the specified type, then the \ninstanceof operator evaluates to true . Otherwise, its result is false . Thus, \ninstanceof is the means by which your program can obtain run-time type \ninformation about an object. \nThe following program demonstrates instanceof : \n\n\n\n\nThe output from this program is shown here: \n\nThe instanceof operator isn\u2019t needed by most programs, because, generally, you know the \ntype of object with which you are working. However, it can be very useful when you\u2019re \nwriting generalized routines that operate on objects of a complex class hierarchy. \n\nstrictfp",
    "strictfp \n\nWith the creation of Java 2, the floating-point computation model was relaxed slightly. \nSpecifically, the new model does not require the truncation of certain intermediate values \nthat occur during a computation. This prevents overflow or underflow in some cases. By \nmodifying a class, a method, or interface with strictfp , you ensure that floating-point \n\ncalculations ( and thus all truncations ) take place precisely as they did in earlier versions of \nJava. When a class is modified by strictfp , all the methods in the class are also modified by \nstrictfp automatically. \nFor example, the following fragment tells Java to use the original floating-point model for \n\n\ncalculations in all methods defined within MyClass : \n\nFrankly, most programmers never need to use strictfp , because it affects only a very small \nclass of problems. \n\nNative Methods",
    "Although it is rare, occasionally you may want to call a subroutine that is written in a \nlanguage other than Java. Typically, such a subroutine exists as executable code for the CPU \nand environment in which you are working\u2014that is, native code. For example, you may \nwant to call a native code subroutine to achieve faster execution time. Or, you may want to \nuse a specialized, third-party library, such as a statistical package. However, because Java \nprograms are compiled to bytecode, which is then interpreted ( or compiled on-the-fly ) by \nthe Java run-time system, it would seem impossible to call a native code subroutine from \nwithin your Java program. Fortunately, this conclusion is false. Java provides the native \nkeyword, which is used to declare native code methods. Once declared, these methods can \nbe called from inside your Java program just as you call any other Java method",
    ". Java provides the native \nkeyword, which is used to declare native code methods. Once declared, these methods can \nbe called from inside your Java program just as you call any other Java method. \nTo declare a native method, precede the method with the native modifier, but do not define \nany body for the method. For example:",
    "After you declare a native method, you must write the native method and follow a rather \ncomplex series of steps to link it with your Java code. \nMost native methods are written in C. The mechanism used to integrate C code with a Java \nprogram is called the Java Native Interface ( JNI ) . A detailed description of the JNI is \nbeyond the scope of this book, but the approach described here provides sufficient \ninformation for simple applications. \n\nNOTE The precise steps that you need to follow will vary between \ndifferent Java environments. They also depend on the language that you \n\nare using to implement the native method. The following discussion \nassumes a Windows environment. The language used to implement the \nnative method is C. Also, the approach shown here uses a dynamically \nlinked library, but beginning with JDK 8, it is possible to create a \nstatically linked library.",
    "The easiest way to understand the process is to work through an example. To begin, enter \nthe following short program, which uses a native method called test ( ) : \n\nNotice that the test ( ) method is declared as native and has no body. This is the method \nthat we will implement in C shortly. Also notice the static block. As explained earlier in this \nbook, a static block is executed only once, when your program begins execution ( or, more \nprecisely, when its class is first loaded ). In this case, it is used to load the dynamic link \nlibrary that contains the native implementation of test ( ) . ( You will see how to create this \nlibrary soon.) \nThe library is loaded by the loadLibrary ( ) method, which is part of the System class. \nThis is its general form: \n\nstatic void loadLibrary ( String filename )",
    "static void loadLibrary ( String filename ) \n\nHere, filename is a string that specifies the name of the file that holds the library. \nFor the Windows environment, this file is assumed to have the .DLL extension. \nAfter you enter the program, compile it to produce NativeDemo.class . Next, you must use \njavah.exe to produce one file: NativeDemo.h . ( javah.exe is included in the JDK.) You \nwill include NativeDemo.h in your implementation of test ( ) . To produce \n\nNativeDemo.h , use the following command: \n\njavah -jni NativeDemo \n\nThis command produces a header file called NativeDemo.h . This file must be \nincluded in the C file that implements test ( ) . The output produced by this \n\n\ncommand is shown here: \n\nPay special attention to the following line, which defines the prototype for the test ( ) \nfunction that you will create:",
    "command is shown here: \n\nPay special attention to the following line, which defines the prototype for the test ( ) \nfunction that you will create: \n\nNotice that the name of the function is Java_NativeDemo_test ( ) . You must use this as \nthe name of the native function that you implement. That is, instead of creating a C function \ncalled test ( ) , you will create one called Java_NativeDemo_test ( ) . The NativeDemo \ncomponent of the prefix is added because it identifies the test ( ) method as being part of \nthe NativeDemo class. Remember, another class may define its own native test ( ) method \nthat is completely different from the one declared by NativeDemo . Including the class \nname in the prefix provides a way to differentiate between differing versions. As a general \nrule, native functions will be given a name whose prefix includes the name of the class in",
    "which they are declared. \nAfter producing the necessary header file, you can write your implementation of test ( ) and \nstore it in a file named NativeDemo.c :",
    "Notice that this file includes jni.h , which contains interfacing information. This file is \nprovided by your Java compiler. The header file NativeDemo.h was created by javah \nearlier. \nIn this function, the GetObjectClass ( ) method is used to obtain a C structure that has \ninformation about the class NativeDemo . The GetFieldID ( ) method returns a C \nstructure with information about the field named \"i\" for the class. GetIntField ( ) retrieves \nthe original value of that field. SetIntField ( ) stores an updated value in that field. ( See the \nfile jni.h for additional methods that handle other types of data.) \nAfter creating NativeDemo.c , you must compile it and create a DLL. To do this by using \nthe Microsoft C/C++ compiler, use the following command line. ( You might need to specify \nthe path to jni.h and its subordinate file jni_md.h .) \n\nCl /LD NativeDemo.c",
    "Cl /LD NativeDemo.c \n\nThis produces a file called NativeDemo.dll . Once this is done, you can execute \nthe Java program, which will produce the following output: \n\n\nProblems with Native Methods \n\nNative methods seem to offer great promise, because they enable you to gain access to an \nexisting base of library routines, and they offer the possibility of faster run-time execution. \nBut native methods also introduce two significant problems: \n\n\u2022   Potential security risk     Because a native method executes actual \nmachine code, it can gain access to any part of the host system. That is, \nnative code is not confined to the Java execution environment. This could \nallow a virus infection, for example. For this reason, unsigned applets \ncannot use native methods. Also, the loading of DLLs can be restricted, and \ntheir loading is subject to the approval of the security manager.",
    "\u2022   Loss of portability     Because the native code is contained in a DLL, it \nmust be present on the machine that is executing the Java program. \nFurther, because each native method is CPU- and operating system\u2013 \ndependent, each DLL is inherently nonportable. Thus, a Java application \nthat uses native methods will be able to run only on a machine for which a \ncompatible DLL has been installed. \n\nThe use of native methods should be restricted, because they render your Java \n\nprograms nonportable and pose significant security risks. \n\nUsing assert",
    "The use of native methods should be restricted, because they render your Java \n\nprograms nonportable and pose significant security risks. \n\nUsing assert \n\nAnother relatively new addition to Java is the keyword assert . It is used during program \ndevelopment to create an assertion , which is a condition that should be true during the \nexecution of the program. For example, you might have a method that should always return \na positive integer value. You might test this by asserting that the return value is greater than \nzero using an assert statement. At run time, if the condition is true, no other action takes \nplace. However, if the condition is false, then an AssertionError is thrown. Assertions are \noften used during testing to verify that some expected condition is actually met. They are \n\nnot usually used for released code. \n\nThe assert keyword has two forms. The first is shown here: \n\nassert condition ;",
    "not usually used for released code. \n\nThe assert keyword has two forms. The first is shown here: \n\nassert condition ; \n\nHere, condition is an expression that must evaluate to a Boolean result. If the \nresult is true, then the assertion is true and no other action takes place. If the \n\n\ncondition is false, then the assertion fails and a default AssertionError object is \nthrown. \nThe second form of assert is shown here: \n\nassert condition: expr ; \n\nIn this version, expr is a value that is passed to the AssertionError constructor. \nThis value is converted to its string format and displayed if an assertion fails. \nTypically, you will specify a string for expr , but any non- void expression is \nallowed as long as it defines a reasonable string conversion. \nHere is an example that uses assert . It verifies that the return value of getnum ( ) is \npositive.",
    "To enable assertion checking at run time, you must specify the -ea option. For example, to \nenable assertions for AssertDemo , execute it using this line: \n\nAfter compiling and running as just described, the program creates the following output: \n\n\nIn main ( ) , repeated calls are made to the method getnum ( ) , which returns an integer \nvalue. The return value of getnum ( ) is assigned to n and then tested using this assert \nstatement: \n\nThis statement will fail when n equals 0, which it will after the fourth call. When this \nhappens, an exception is thrown. \nAs explained, you can specify the message displayed when an assertion fails. For example, if \nyou substitute \n\nfor the assertion in the preceding program, then the following output will be generated:",
    "for the assertion in the preceding program, then the following output will be generated: \n\nOne important point to understand about assertions is that you must not rely on them to \nperform any action actually required by the program. The reason is that normally, released \ncode will be run with assertions disabled. For example, consider this variation of the \npreceding program:",
    "In this version of the program, the call to getnum ( ) is moved inside the assert statement. \nAlthough this works fine if assertions are enabled, it will cause a malfunction when \nassertions are disabled, because the call to getnum ( ) will never be executed! In fact, n \nmust now be initialized, because the compiler will recognize that it might not be assigned a \nvalue by the assert statement. \nAssertions are a good addition to Java because they streamline the type of error checking \nthat is common during development. For example, prior to assert , if you wanted to verify \nthat n was positive in the preceding program, you had to use a sequence of code similar to \nthis: \n\nWith assert , you need only one line of code. Furthermore, you don\u2019t have to remove the \nassert statements from your released code. \n\nAssertion Enabling and Disabling Options \n\nWhen executing code, you can disable all assertions by using the -da option. You can enable",
    "Assertion Enabling and Disabling Options \n\nWhen executing code, you can disable all assertions by using the -da option. You can enable \n\nor disable a specific package ( and all of its subpackages ) by specifying its name followed by \n\n\nthree periods after the -ea or -da option. For example, to enable assertions in a package \ncalled MyPack , use \n\nTo disable assertions in MyPack , use \n\nYou can also specify a class with the -ea or -da option. For example, this enables \nAssertDemo individually: \n\nStatic Import",
    "Static Import \n\nJava includes a feature called static import that expands the capabilities of the import \nkeyword. By following import with the keyword static , an import statement can be used \nto import the static members of a class or interface. When using static import, it is possible \nto refer to static members directly by their names, without having to qualify them with the \nname of their class. This simplifies and shortens the syntax required to use a static member. \nTo understand the usefulness of static import, let\u2019s begin with an example that does not use \nit. The following program computes the hypotenuse of a right triangle. It uses two static \nmethods from Java\u2019s built-in math class Math , which is part of java.lang . The first is \nMath.pow ( ) , which returns a value raised to a specified power. The second is Math.sqrt ( \n) , which returns the square root of its argument.",
    "Because pow ( ) and sqrt ( ) are static methods, they must be called through the use of their \nclass\u2019 name, Math . This results in a somewhat unwieldy hypotenuse calculation: \n\nAs this simple example illustrates, having to specify the class name each time pow ( ) or \nsqrt ( ) ( or any of Java\u2019s other math methods, such as sin ( ) , cos ( ) , and tan ( ) ) is used \ncan grow tedious. \nYou can eliminate the tedium of specifying the class name through the use of static import, \nas shown in the following version of the preceding program: \n\n\nIn this version, the names sqrt and pow are brought into view by these static import \nstatements: \n\nAfter these statements, it is no longer necessary to qualify sqrt ( ) or pow ( ) with their class \nname. Therefore, the hypotenuse calculation can more conveniently be specified, as shown \nhere:",
    "After these statements, it is no longer necessary to qualify sqrt ( ) or pow ( ) with their class \nname. Therefore, the hypotenuse calculation can more conveniently be specified, as shown \nhere: \n\nAs you can see, this form is considerably more readable. \nThere are two general forms of the import static statement. The first, which is used by the \npreceding example, brings into view a single name. Its general form is shown here: \n\nimport static pkg.type-name.static-member-name ; \n\nHere, type-name is the name of a class or interface that contains the desired static \nmember. Its full package name is specified by pkg . The name of the member is \nspecified by static-member-name . \nThe second form of static import imports all static members of a given class or interface. Its \n\n\ngeneral form is shown here: \n\nimport static pkg.type-name .*;",
    "general form is shown here: \n\nimport static pkg.type-name .*; \n\nIf you will be using many static methods or fields defined by a class, then this form \nlets you bring them into view without having to specify each individually. \nTherefore, the preceding program could have used this single import statement to \nbring both pow ( ) and sqrt ( ) ( and all other static members of Math ) into view: \n\nOf course, static import is not limited just to the Math class or just to methods. For \nexample, this brings the static field System.out into view: \n\nAfter this statement, you can output to the console without having to qualify out with \nSystem , as shown here:",
    "Whether importing System.out as just shown is a good idea is subject to debate. Although \nit does shorten the statement, it is no longer instantly clear to anyone reading the program \nthat the out being referred to is System.out . \nOne other point: in addition to importing the static members of classes and interfaces \ndefined by the Java API, you can also use static import to import the static members of \nclasses and interfaces that you create. \nAs convenient as static import can be, it is important not to abuse it. Remember, the reason \nthat Java organizes its libraries into packages is to avoid namespace collisions. When you \nimport static members, you are bringing those members into the global namespace. Thus, \nyou are increasing the potential for namespace conflicts and for the inadvertent hiding of \nother names. If you are using a static member once or twice in the program, it\u2019s best not to \nimport it",
    ". If you are using a static member once or twice in the program, it\u2019s best not to \nimport it. Also, some static names, such as System.out , are so recognizable that you might \nnot want to import them. Static import is designed for those situations in which you are \nusing a static member repeatedly, such as when performing a series of mathematical \ncomputations. In essence, you should use, but not abuse, this feature.",
    "Invoking Overloaded Constructors Through this ( ) \n\nWhen working with overloaded constructors, it is sometimes useful for one constructor to \ninvoke another. In Java, this is accomplished by using another form of the this keyword. \nThe general form is shown here: \n\nthis ( arg-list ) \n\n\nWhen this ( ) is executed, the overloaded constructor that matches the parameter \nlist specified by arg-list is executed first. Then, if there are any statements inside \nthe original constructor, they are executed. The call to this ( ) must be the first \nstatement within the constructor. \nTo understand how this ( ) can be used, let\u2019s work through a short example. First, consider \nthe following class that does not use this ( ) :",
    "This class contains three constructors, each of which initializes the values of a and b . The \nfirst is passed individual values for a and b . The second is passed just one value, which is \nassigned to both a and b . The third gives a and b default values of zero. \nBy using this ( ) , it is possible to rewrite MyClass as shown here: \n\n\nIn this version of MyClass , the only constructor that actually assigns values to the a and b \nfields is MyClass ( int, int ) . The other two constructors simply invoke that constructor \n( either directly or indirectly ) through this ( ) . For example, consider what happens when \nthis statement executes: \n\nThe call to MyClass ( 8 ) causes this ( 8, 8 ) to be executed, which translates into a call to \n\nMyClass ( 8, 8 ) , because this is the version of the MyClass constructor whose parameter \nlist matches the arguments passed via this ( ) . Now, consider the following statement, which \nuses the default constructor:",
    "In this case, this ( 0 ) is called. This causes MyClass ( 0 ) to be invoked because it is the \nconstructor with the matching parameter list. Of course, MyClass ( 0 ) then calls \nMyClass ( 0,0 ) as just described. \nOne reason why invoking overloaded constructors through this ( ) can be useful is that it \ncan prevent the unnecessary duplication of code. In many cases, reducing duplicate code \n\ndecreases the time it takes to load your class because often the object code is smaller. This is \nespecially important for programs delivered via the Internet in which load times are an \nissue. Using this ( ) can also help structure your code when constructors contain a large",
    "amount of duplicate code. \nHowever, you need to be careful. Constructors that call this ( ) will execute a bit slower than \nthose that contain all of their initialization code inline. This is because the call and return \nmechanism used when the second constructor is invoked adds overhead. If your class will \nbe used to create only a handful of objects, or if the constructors in the class that call this ( ) \nwill be seldom used, then this decrease in run-time performance is probably insignificant. \nHowever, if your class will be used to create a large number of objects ( on the order of \nthousands ) during program execution, then the negative impact of the increased overhead \ncould be meaningful. Because object creation affects all users of your class, there will be \ncases in which you must carefully weigh the benefits of faster load time against the \nincreased time it takes to create an object",
    ". \nHere is another consideration: for very short constructors, such as those used by MyClass , \nthere is often little difference in the size of the object code whether this ( ) is used or not. \n( Actually, there are cases in which no reduction in the size of the object code is achieved.) \nThis is because the bytecode that sets up and returns from the call to this ( ) adds \ninstructions to the object file. Therefore, in these types of situations, even though duplicate \ncode is eliminated, using this ( ) will not obtain significant savings in terms of load time. \nHowever, the added cost in terms of overhead to each object\u2019s construction will still be \nincurred. Therefore, this ( ) is most applicable to constructors that contain large amounts of \ninitialization code, not those that simply set the value of a handful of fields. \nThere are two restrictions you need to keep in mind when using this ( )",
    ". \nThere are two restrictions you need to keep in mind when using this ( ) . First, you cannot \nuse any instance variable of the constructor\u2019s class in a call to this ( ) . Second, you cannot \nuse super ( ) and this ( ) in the same constructor because each must be the first statement \nin the constructor.",
    "Compact API Profiles \n\nJDK 8 adds a feature that organizes subsets of the API library into what are called compact \nprofiles . These are called compact1 , compact2 , and compact3 . Each profile contains a \nsubset of the library. Furthermore, compact2 includes all of compact1 , and compact3 \nincludes all of compact2 . Thus, each profile builds on the previous one. The advantage of \nthe compact profiles is that an application that does not require the full library need not \ndownload it. Using a compact profile reduces the size of the library, thus enabling some \ntypes of Java applications to run on devices that could not otherwise support the entire Java \nAPI. The use of a compact profile can also reduce the time it takes to load a program. The",
    "Java API documentation indicates to which ( if any ) profile each API element belongs. \nWhen compiling a program, you can determine if a program uses only APIs defined by a \ncompact profile by using the -profile option. Here is its general form: \n\njavac -profile profileName programName \n\nHere, profileName specifies the profile, which must be compact1 , compact2 , or \ncompact3 . For example: \n\n\nHere, the compact2 profile is specified. If Test.java contains an API that is not part of \ncompact2 , then a compilation error will result. \n\n\uf709 \nPREV \nChapter 12: Enumerations, Autoboxing, and Ann\u2026 \n\u23ee \n\nNEXT \nChapter 14: Generics \u23ed \n\n\nPREV \nChapter 13: I/O, Applets, and Other Topics \n\u23ee \n\nNEXT \nChapter 15: Lambda Expressions \u23ed \n\nCHAPTER \n\n14 \nGenerics",
    "Since the original 1.0 release in 1995, many new features have been added to Java. One that \nhas had a profound impact is generics . Introduced by JDK 5, generics changed Java in two \nimportant ways. First, it added a new syntactical element to the language. Second, it caused \nchanges to many of the classes and methods in the core API. Today, generics are an integral \npart of Java programming, and a solid understanding of this important feature is required. \nIt is examined here in detail. \nThrough the use of generics, it is possible to create classes, interfaces, and methods that will \nwork in a type-safe manner with various kinds of data. Many algorithms are logically the \nsame no matter what type of data they are being applied to. For example, the mechanism \nthat supports a stack is the same whether that stack is storing items of type Integer , \nString , Object , or Thread",
    ". For example, the mechanism \nthat supports a stack is the same whether that stack is storing items of type Integer , \nString , Object , or Thread . With generics, you can define an algorithm once, \nindependently of any specific type of data, and then apply that algorithm to a wide variety of \ndata types without any additional effort. The expressive power generics added to the \nlanguage fundamentally changed the way that Java code is written. \nPerhaps the one feature of Java that has been most significantly affected by generics is the \nCollections Framework . The Collections Framework is part of the Java API and is described \nin detail in Chapter 18, but a brief mention is useful now. A collection is a group of objects. \nThe Collections Framework defines several classes, such as lists and maps, that manage \ncollections. The collection classes have always been able to work with any type of object",
    ". \nThe Collections Framework defines several classes, such as lists and maps, that manage \ncollections. The collection classes have always been able to work with any type of object. The \nbenefit that generics added is that the collection classes can now be used with complete type \nsafety. Thus, in addition to being a powerful language element on its own, generics also \nenabled an existing feature to be substantially improved. This is another reason why \ngenerics were such an important addition to Java. \nThis chapter describes the syntax, theory, and use of generics. It also shows how generics \nprovide type safety for some previously difficult cases. Once you have completed this \nchapter, you will want to examine Chapter 18, which covers the Collections Framework. \nThere you will find many examples of generics at work.",
    "What Are Generics? \n\nAt its core, the term generics means parameterized types . Parameterized types are",
    "important because they enable you to create classes, interfaces, and methods in which the \ntype of data upon which they operate is specified as a parameter. Using generics, it is \npossible to create a single class, for example, that automatically works with different types \nof data. A class, interface, or method that operates on a parameterized type is called \ngeneric , as in generic class or generic method . \nIt is important to understand that Java has always given you the ability to create generalized \nclasses, interfaces, and methods by operating through references of type Object . Because \nObject is the superclass of all other classes, an Object reference can refer to any type \nobject. Thus, in pre-generics code, generalized classes, interfaces, and methods used Object \nreferences to operate on various types of objects. The problem was that they could not do so \nwith type safety. \nGenerics added the type safety that was lacking",
    ". The problem was that they could not do so \nwith type safety. \nGenerics added the type safety that was lacking. They also streamlined the process, because \nit is no longer necessary to explicitly employ casts to translate between Object and the type \nof data that is actually being operated upon. With generics, all casts are automatic and \nimplicit. Thus, generics expanded your ability to reuse code and let you do so safely and \neasily.",
    "NOTE A Warning to C++ Programmers: Although generics are similar to \ntemplates in C++, they are not the same. There are some fundamental \ndifferences between the two approaches to generic types. If you have a \nbackground in C++, it is important not to jump to conclusions about how \ngenerics work in Java. \n\nA Simple Generics Example \n\nLet\u2019s begin with a simple example of a generic class. The following program defines two \nclasses. The first is the generic class Gen , and the second is GenDemo , which uses Gen . \n\n\nThe output produced by the program is shown here: \n\n\nLet\u2019s examine this program carefully. \nFirst, notice how Gen is declared by the following line:",
    "The output produced by the program is shown here: \n\n\nLet\u2019s examine this program carefully. \nFirst, notice how Gen is declared by the following line: \n\nHere, T is the name of a type parameter . This name is used as a placeholder for the actual \ntype that will be passed to Gen when an object is created. Thus, T is used within Gen \nwhenever the type parameter is needed. Notice that T is contained within < > . This syntax \ncan be generalized. Whenever a type parameter is being declared, it is specified within angle \nbrackets. Because Gen uses a type parameter, Gen is a generic class, which is also called a \nparameterized type . \nNext, T is used to declare an object called ob , as shown here:",
    "As explained, T is a placeholder for the actual type that will be specified when a Gen object \nis created. Thus, ob will be an object of the type passed to T . For example, if type String is \npassed to T , then in that instance, ob will be of type String . \nNow consider Gen \u2019s constructor: \n\nNotice that its parameter, o , is of type T . This means that the actual type of o is determined \nby the type passed to T when a Gen object is created. Also, because both the parameter o \nand the member variable ob are of type T , they will both be of the same actual type when a \nGen object is created. \nThe type parameter T can also be used to specify the return type of a method, as is the case \nwith the getob ( ) method, shown here:",
    "Because ob is also of type T , its type is compatible with the return type specified by getob ( \n) . \nThe showType ( ) method displays the type of T by calling getName ( ) on the Class \nobject returned by the call to getClass ( ) on ob . The getClass ( ) method is defined by \nObject and is thus a member of all class types. It returns a Class object that corresponds to \nthe type of the class of the object on which it is called. Class defines the getName ( ) \nmethod, which returns a string representation of the class name. \nThe GenDemo class demonstrates the generic Gen class. It first creates a version of Gen \nfor integers, as shown here:",
    "Look closely at this declaration. First, notice that the type Integer is specified within the \nangle brackets after Gen . In this case, Integer is a type argument that is passed to Gen \u2019s \ntype parameter, T . This effectively creates a version of Gen in which all references to T are \ntranslated into references to Integer . Thus, for this declaration, ob is of type Integer , and \nthe return type of getob ( ) is of type Integer . \nBefore moving on, it\u2019s necessary to state that the Java compiler does not actually create \ndifferent versions of Gen , or of any other generic class. Although it\u2019s helpful to think in \nthese terms, it is not what actually happens. Instead, the compiler removes all generic type \ninformation, substituting the necessary casts, to make your code behave as if a specific \nversion of Gen were created. Thus, there is really only one version of Gen that actually \nexists in your program",
    ". Thus, there is really only one version of Gen that actually \nexists in your program. The process of removing generic type information is called erasure , \nand we will return to this topic later in this chapter. \nThe next line assigns to iOb a reference to an instance of an Integer version of the Gen \nclass:",
    "Notice that when the Gen constructor is called, the type argument Integer is also specified. \n\nThis is because the type of the object ( in this case iOb ) to which the reference is being \nassigned is of type Gen<Integer> . Thus, the reference returned by new must also be of \ntype Gen<Integer> . If it isn\u2019t, a compile-time error will result. For example, the following \nassignment will cause a compile-time error: \n\nBecause iOb is of type Gen<Integer> , it can\u2019t be used to refer to an object of \nGen<Double> . This type checking is one of the main benefits of generics because it \nensures type safety. \n\n\nNOTE As you will see later in this chapter, beginning with JDK 7, it is \npossible to shorten the syntax used to create an instance of a generic \nclass. In the interest of clarity, we will use the full syntax at this time. \n\nAs the comments in the program state, the assignment",
    "As the comments in the program state, the assignment \n\nmakes use of autoboxing to encapsulate the value 88, which is an int , into an Integer . This \nworks because Gen<Integer> creates a constructor that takes an Integer argument. \nBecause an Integer is expected, Java will automatically box 88 inside one. Of course, the \nassignment could also have been written explicitly, like this: \n\nHowever, there would be no benefit to using this version. \nThe program then displays the type of ob within iOb , which is Integer . Next, the program \nobtains the value of ob by use of the following line:",
    "Because the return type of getob ( ) is T , which was replaced by Integer when iOb was \ndeclared, the return type of getob ( ) is also Integer , which unboxes into int when \nassigned to v ( which is an int ). Thus, there is no need to cast the return type of getob ( ) to \nInteger . \nOf course, it\u2019s not necessary to use the auto-unboxing feature. The preceding line could have \nbeen written like this, too: \n\nHowever, the auto-unboxing feature makes the code more compact. \nNext, GenDemo declares an object of type Gen<String> : \n\nBecause the type argument is String , String is substituted for T inside Gen . This creates \n( conceptually ) a String version of Gen , as the remaining lines in the program demonstrate. \n\nGenerics Work Only with Reference Types \n\nWhen declaring an instance of a generic type, the type argument passed to the type",
    "Generics Work Only with Reference Types \n\nWhen declaring an instance of a generic type, the type argument passed to the type \n\n\nparameter must be a reference type. You cannot use a primitive type, such as int or char . \nFor example, with Gen , it is possible to pass any class type to T , but you cannot pass a \nprimitive type to a type parameter. Therefore, the following declaration is illegal: \n\nOf course, not being able to specify a primitive type is not a serious restriction because you \ncan use the type wrappers ( as the preceding example did ) to encapsulate a primitive type. \nFurther, Java\u2019s autoboxing and auto-unboxing mechanism makes the use of the type \nwrapper transparent. \n\nGeneric Types Differ Based on Their Type Arguments",
    "Generic Types Differ Based on Their Type Arguments \n\nA key point to understand about generic types is that a reference of one specific version of a \ngeneric type is not type compatible with another version of the same generic type. For \nexample, assuming the program just shown, the following line of code is in error and will \nnot compile: \n\nEven though both iOb and strOb are of type Gen<T> , they are references to different \ntypes because their type parameters differ. This is part of the way that generics add type \nsafety and prevent errors. \n\nHow Generics Improve Type Safety",
    "How Generics Improve Type Safety \n\nAt this point, you might be asking yourself the following question: Given that the same \nfunctionality found in the generic Gen class can be achieved without generics, by simply \nspecifying Object as the data type and employing the proper casts, what is the benefit of \nmaking Gen generic? The answer is that generics automatically ensure the type safety of all \noperations involving Gen . In the process, they eliminate the need for you to enter casts and \nto type-check code by hand. \nTo understand the benefits of generics, first consider the following program that creates a \nnon-generic equivalent of Gen :",
    "There are several things of interest in this version. First, notice that NonGen replaces all \nuses of T with Object . This makes NonGen able to store any type of object, as can the \ngeneric version. However, it also prevents the Java compiler from having any real \nknowledge about the type of data actually stored in NonGen , which is bad for two reasons. \nFirst, explicit casts must be employed to retrieve the stored data. Second, many kinds of \ntype mismatch errors cannot be found until run time. Let\u2019s look closely at each problem. \nNotice this line:",
    "Because the return type of getob ( ) is Object , the cast to Integer is necessary to enable \nthat value to be auto-unboxed and stored in v . If you remove the cast, the program will not \ncompile. With the generic version, this cast was implicit. In the non-generic version, the cast \nmust be explicit. This is not only an inconvenience, but also a potential source of error. \nNow, consider the following sequence from near the end of the program: \n\nHere, strOb is assigned to iOb . However, strOb refers to an object that contains a string, \n\nnot an integer. This assignment is syntactically valid because all NonGen references are the \nsame, and any NonGen reference can refer to any other NonGen object. However, the \nstatement is semantically wrong, as the next line shows. Here, the return type of getob ( ) is \ncast to Integer , and then an attempt is made to assign this value to v . The trouble is that",
    "iOb now refers to an object that stores a String , not an Integer . Unfortunately, without \nthe use of generics, the Java compiler has no way to know this. Instead, a run-time \nexception occurs when the cast to Integer is attempted. As you know, it is extremely bad to \nhave run-time exceptions occur in your code! \nThe preceding sequence can\u2019t occur when generics are used. If this sequence were attempted \nin the generic version of the program, the compiler would catch it and report an error, thus \n\npreventing a serious bug that results in a run-time exception. The ability to create type-safe \n\n\ncode in which type-mismatch errors are caught at compile time is a key advantage of",
    "preventing a serious bug that results in a run-time exception. The ability to create type-safe \n\n\ncode in which type-mismatch errors are caught at compile time is a key advantage of \n\ngenerics. Although using Object references to create \u201cgeneric\u201d code has always been \npossible, that code was not type safe, and its misuse could result in run-time exceptions. \nGenerics prevent this from occurring. In essence, through generics, run-time errors are \nconverted into compile-time errors. This is a major advantage. \n\nA Generic Class with Two Type Parameters \n\nYou can declare more than one type parameter in a generic type. To specify two or more \ntype parameters, simply use a comma-separated list. For example, the following TwoGen \nclass is a variation of the Gen class that has two type parameters: \n\n\nThe output from this program is shown here: \n\n\nNotice how TwoGen is declared:",
    "The output from this program is shown here: \n\n\nNotice how TwoGen is declared: \n\nIt specifies two type parameters: T and V , separated by a comma. Because it has two type \nparameters, two type arguments must be passed to TwoGen when an object is created, as \nshown next: \n\nIn this case, Integer is substituted for T , and String is substituted for V . \nAlthough the two type arguments differ in this example, it is possible for both types to be \nthe same. For example, the following line of code is valid: \n\nIn this case, both T and V would be of type String . Of course, if the type arguments were \nalways the same, then two type parameters would be unnecessary. \n\nThe General Form of a Generic Class \n\nThe generics syntax shown in the preceding examples can be generalized. Here is the syntax \nfor declaring a generic class: \n\nHere is the full syntax for declaring a reference to a generic class and instance creation: \n\nBounded Types",
    "Here is the full syntax for declaring a reference to a generic class and instance creation: \n\nBounded Types \n\nIn the preceding examples, the type parameters could be replaced by any class type. This is \n\nfine for many purposes, but sometimes it is useful to limit the types that can be passed to a \ntype parameter. For example, assume that you want to create a generic class that contains a \nmethod that returns the average of an array of numbers. Furthermore, you want to use the \nclass to obtain the average of an array of any type of number, including integers, float s, and \n\ndouble s. Thus, you want to specify the type of the numbers generically, using a type \n\n\nparameter. To create such a class, you might try something like this:",
    "parameter. To create such a class, you might try something like this: \n\nIn Stats , the average ( ) method attempts to obtain the double version of each number in \nthe nums array by calling doubleValue ( ) . Because all numeric classes, such as Integer \nand Double , are subclasses of Number , and Number defines the doubleValue ( ) \nmethod, this method is available to all numeric wrapper classes. The trouble is that the \ncompiler has no way to know that you are intending to create Stats objects using only \nnumeric types. Thus, when you try to compile Stats , an error is reported that indicates that \nthe doubleValue ( ) method is unknown. To solve this problem, you need some way to tell \nthe compiler that you intend to pass only numeric types to T . Furthermore, you need some \nway to ensure that only numeric types are actually passed. \nTo handle such situations, Java provides bounded types . When specifying a type parameter,",
    "you can create an upper bound that declares the superclass from which all type arguments \nmust be derived. This is accomplished through the use of an extends clause when \nspecifying the type parameter, as shown here: \n\n< T extends superclass > \n\nThis specifies that T can only be replaced by superclass , or subclasses of \nsuperclass . Thus, superclass defines an inclusive, upper limit. \n\n\nYou can use an upper bound to fix the Stats class shown earlier by specifying Number as \nan upper bound, as shown here: \n\nThe output is shown here: \n\n\nNotice how Stats is now declared by this line:",
    "Because the type T is now bounded by Number , the Java compiler knows that all objects of \ntype T can call doubleValue ( ) because it is a method declared by Number . This is, by \nitself, a major advantage. However, as an added bonus, the bounding of T also prevents \nnonnumeric Stats objects from being created. For example, if you try removing the \ncomments from the lines at the end of the program, and then try recompiling, you will \nreceive compile-time errors because String is not a subclass of Number . \nIn addition to using a class type as a bound, you can also use an interface type. In fact, you \ncan specify multiple interfaces as bounds. Furthermore, a bound can include both a class \ntype and one or more interfaces. In this case, the class type must be specified first. When a \nbound includes an interface type, only type arguments that implement that interface are \nlegal",
    ". In this case, the class type must be specified first. When a \nbound includes an interface type, only type arguments that implement that interface are \nlegal. When specifying a bound that has a class and an interface, or multiple interfaces, use \nthe & operator to connect them. For example,",
    "Here, T is bounded by a class called MyClass and an interface called MyInterface . Thus, \nany type argument passed to T must be a subclass of MyClass and implement \nMyInterface . \n\nUsing Wildcard Arguments \n\nAs useful as type safety is, sometimes it can get in the way of perfectly acceptable constructs. \nFor example, given the Stats class shown at the end of the preceding section, assume that \nyou want to add a method called sameAvg ( ) that determines if two Stats objects contain \narrays that yield the same average, no matter what type of numeric data each object holds. \nFor example, if one object contains the double values 1.0, 2.0, and 3.0, and the other object \ncontains the integer values 2, 1, and 3, then the averages will be the same. One way to \nimplement sameAvg ( ) is to pass it a Stats argument, and then compare the average of \nthat argument against the invoking object, returning true only if the averages are the same.",
    "For example, you want to be able to call sameAvg ( ) , as shown here: \n\n\nAt first, creating sameAvg ( ) seems like an easy problem. Because Stats is generic and its \naverage ( ) method can work on any type of Stats object, it seems that creating sameAvg ( \n) would be straightforward. Unfortunately, trouble starts as soon as you try to declare a \nparameter of type Stats . Because Stats is a parameterized type, what do you specify for \nStats \u2019 type parameter when you declare a parameter of that type? \nAt first, you might think of a solution like this, in which T is used as the type parameter: \n\nThe trouble with this attempt is that it will work only with other Stats objects whose type is",
    "The trouble with this attempt is that it will work only with other Stats objects whose type is \n\nthe same as the invoking object. For example, if the invoking object is of type \nStats<Integer> , then the parameter ob must also be of type Stats<Integer> . It can\u2019t be \nused to compare the average of an object of type Stats<Double> with the average of an \nobject of type Stats<Short> , for example. Therefore, this approach won\u2019t work except in a \nvery narrow context and does not yield a general ( that is, generic ) solution. \nTo create a generic sameAvg ( ) method, you must use another feature of Java generics: the \nwildcard argument. The wildcard argument is specified by the ? , and it represents an \n\nunknown type. Using a wildcard, here is one way to write the sameAvg ( ) method: \n\n\nHere, Stats<?> matches any Stats object, allowing any two Stats objects to have their \naverages compared. The following program demonstrates this: \n\n\nThe output is shown here:",
    "Here, Stats<?> matches any Stats object, allowing any two Stats objects to have their \naverages compared. The following program demonstrates this: \n\n\nThe output is shown here: \n\n\nOne last point: It is important to understand that the wildcard does not affect what type of \nStats objects can be created. This is governed by the extends clause in the Stats \ndeclaration. The wildcard simply matches any valid Stats object. \n\nBounded Wildcards \n\nWildcard arguments can be bounded in much the same way that a type parameter can be \nbounded. A bounded wildcard is especially important when you are creating a generic type \nthat will operate on a class hierarchy. To understand why, let\u2019s work through an example. \nConsider the following hierarchy of classes that encapsulate coordinates:",
    "At the top of the hierarchy is TwoD , which encapsulates a two-dimensional, XY coordinate. \nTwoD is inherited by ThreeD , which adds a third dimension, creating an XYZ coordinate. \nThreeD is inherited by FourD , which adds a fourth dimension ( time ), yielding a fourdimensional coordinate. \nShown next is a generic class called Coords , which stores an array of coordinates: \n\nNotice that Coords specifies a type parameter bounded by TwoD . This means that any \narray stored in a Coords object will contain objects of type TwoD or one of its subclasses. \nNow, assume that you want to write a method that displays the X and Y coordinates for \neach element in the coords array of a Coords object. Because all types of Coords objects \nhave at least two coordinates ( X and Y ), this is easy to do using a wildcard, as shown here:",
    "Because Coords is a bounded generic type that specifies TwoD as an upper bound, all \nobjects that can be used to create a Coords object will be arrays of type TwoD , or of \nclasses derived from TwoD . Thus, showXY ( ) can display the contents of any Coords \nobject. \nHowever, what if you want to create a method that displays the X, Y, and Z coordinates of a \nThreeD or FourD object? The trouble is that not all Coords objects will have three \n\ncoordinates, because a Coords<TwoD> object will only have X and Y. Therefore, how do \nyou write a method that displays the X, Y, and Z coordinates for Coords<ThreeD> and \nCoords<FourD> objects, while preventing that method from being used with \nCoords<TwoD> objects? The answer is the bounded wildcard argument . \nA bounded wildcard specifies either an upper bound or a lower bound for the type \nargument. This enables you to restrict the types of objects upon which a method will",
    "operate. The most common bounded wildcard is the upper bound, which is created using an \n\n\nextends clause in much the same way it is used to create a bounded type. \n\nUsing a bounded wildcard, it is easy to create a method that displays the X, Y, and Z \ncoordinates of a Coords object, if that object actually has those three coordinates. For \nexample, the following showXYZ ( ) method shows the X, Y, and Z coordinates of the \nelements stored in a Coords object, if those elements are actually of type ThreeD ( or are \nderived from ThreeD ):",
    "Notice that an extends clause has been added to the wildcard in the declaration of \nparameter c . It states that the ? can match any type as long as it is ThreeD , or a class \nderived from ThreeD . Thus, the extends clause establishes an upper bound that the ? can \nmatch. Because of this bound, showXYZ ( ) can be called with references to objects of type \nCoords<ThreeD> or Coords<FourD> , but not with a reference of type \nCoords<TwoD> . Attempting to call showXZY ( ) with a Coords<TwoD> reference \nresults in a compile-time error, thus ensuring type safety. \nHere is an entire program that demonstrates the actions of a bounded wildcard argument: \n\n\n\n\nThe output from the program is shown here: \n\n\nNotice these commented-out lines: \n\nBecause tdlocs is a Coords ( TwoD ) object, it cannot be used to call showXYZ ( ) or",
    "The output from the program is shown here: \n\n\nNotice these commented-out lines: \n\nBecause tdlocs is a Coords ( TwoD ) object, it cannot be used to call showXYZ ( ) or \n\nshowAll ( ) because bounded wildcard arguments in their declarations prevent it. To prove \nthis to yourself, try removing the comment symbols, and then attempt to compile the \nprogram. You will receive compilation errors because of the type mismatches. \nIn general, to establish an upper bound for a wildcard, use the following type of wildcard \nexpression: \n\n<? extends superclass > \n\nwhere superclass is the name of the class that serves as the upper bound. \nRemember, this is an inclusive clause because the class forming the upper bound \n( that is, specified by superclass ) is also within bounds. \nYou can also specify a lower bound for a wildcard by adding a super clause to a wildcard \ndeclaration. Here is its general form: \n\n\n<? super subclass >",
    "<? super subclass > \n\nIn this case, only classes that are superclasses of subclass are acceptable \narguments. This is an inclusive clause. \n\nCreating a Generic Method \n\nAs the preceding examples have shown, methods inside a generic class can make use of a \nclass\u2019 type parameter and are, therefore, automatically generic relative to the type \nparameter. However, it is possible to declare a generic method that uses one or more type \nparameters of its own. Furthermore, it is possible to create a generic method that is \nenclosed within a non-generic class. \nLet\u2019s begin with an example. The following program declares a non-generic class called \nGenMethDemo and a static generic method within that class called isIn ( ) . The isIn ( ) \nmethod determines if an object is a member of an array. It can be used with any type of \nobject and array as long as the array contains objects that are compatible with the type of \nthe object being sought.",
    "The output from the program is shown here: \n\nLet\u2019s examine isIn ( ) closely. First, notice how it is declared by this line: \n\nThe type parameters are declared before the return type of the method. Also note that T \nextends Comparable<T> . Comparable is an interface declared in java.lang. A class \nthat implements Comparable defines objects that can be ordered. Thus, requiring an upper",
    "bound of Comparable ensures that isIn ( ) can be used only with objects that are capable \nof being compared. Comparable is generic, and its type parameter specifies the type of \nobjects that it compares. ( Shortly, you will see how to create a generic interface.) Next, \nnotice that the type V is upper-bounded by T . Thus, V must either be the same as type T , or \na subclass of T . This relationship enforces that isIn ( ) can be called only with arguments \nthat are compatible with each other. Also notice that isIn ( ) is static, enabling it to be \ncalled independently of any object. Understand, though, that generic methods can be either \nstatic or non-static. There is no restriction in this regard. \nNow, notice how isIn ( ) is called within main ( ) by use of the normal call syntax, without \nthe need to specify type arguments. This is because the types of the arguments are \nautomatically discerned, and the types of T and V are adjusted accordingly",
    ". This is because the types of the arguments are \nautomatically discerned, and the types of T and V are adjusted accordingly. For example, in \nthe first call:",
    "the type of the first argument is Integer ( due to autoboxing ), which causes Integer to be \nsubstituted for T . The base type of the second argument is also Integer , which makes \nInteger a substitute for V , too. In the second call, String types are used, and the types of \nT and V are replaced by String . \nAlthough type inference will be sufficient for most generic method calls, you can explicitly \nspecify the type argument if needed. For example, here is how the first call to isIn ( ) looks \nwhen the type arguments are specified: \n\nOf course, in this case, there is nothing gained by specifying the type arguments. \nFurthermore, JDK 8 has improved type inference as it relates to methods. As a result, there \nare fewer cases in which explicit type arguments are needed. \nNow, notice the commented-out code, shown here:",
    "If you remove the comments and then try to compile the program, you will receive an error. \nThe reason is that the type parameter V is bounded by T in the extends clause in V \u2019s \ndeclaration. This means that V must be either type T , or a subclass of T . In this case, the \nfirst argument is of type String , making T into String , but the second argument is of type \nInteger , which is not a subclass of String . This causes a compile-time type-mismatch \n\nerror. This ability to enforce type safety is one of the most important advantages of generic \nmethods. \nThe syntax used to create isIn ( ) can be generalized. Here is the syntax for a generic \nmethod: \n\n\nIn all cases, type-param-list is a comma-separated list of type parameters. Notice that for a \ngeneric method, the type parameter list precedes the return type. \n\nGeneric Constructors \n\nIt is possible for constructors to be generic, even if their class is not. For example, consider \nthe following short program:",
    "Generic Constructors \n\nIt is possible for constructors to be generic, even if their class is not. For example, consider \nthe following short program: \n\nThe output is shown here: \n\nBecause GenCons ( ) specifies a parameter of a generic type, which must be a subclass of \nNumber , GenCons ( ) can be called with any numeric type, including Integer , Float , or \nDouble . Therefore, even though GenCons is not a generic class, its constructor is generic. \n\nGeneric Interfaces \n\nIn addition to generic classes and methods, you can also have generic interfaces. Generic \n\n\ninterfaces are specified just like generic classes. Here is an example. It creates an interface \ncalled MinMax that declares the methods min ( ) and max ( ) , which are expected to \nreturn the minimum and maximum value of some set of objects. \n\nThe output is shown here:",
    "The output is shown here: \n\n\nAlthough most aspects of this program should be easy to understand, a couple of key points \nneed to be made. First, notice that MinMax is declared like this: \n\nIn general, a generic interface is declared in the same way as is a generic class. In this case, \nthe type parameter is T , and its upper bound is Comparable . As explained earlier, \nComparable is an interface defined by java.lang that specifies how objects are compared. \nIts type parameter specifies the type of the objects being compared. \nNext, MinMax is implemented by MyClass . Notice the declaration of MyClass , shown \nhere:",
    "Pay special attention to the way that the type parameter T is declared by MyClass and then \npassed to MinMax . Because MinMax requires a type that implements Comparable , the \nimplementing class ( MyClass in this case ) must specify the same bound. Furthermore, once \nthis bound has been established, there is no need to specify it again in the implements \nclause. In fact, it would be wrong to do so. For example, this line is incorrect and won\u2019t \ncompile: \n\nOnce the type parameter has been established, it is simply passed to the interface without \n\nfurther modification. \nIn general, if a class implements a generic interface, then that class must also be generic, at \nleast to the extent that it takes a type parameter that is passed to the interface. For example, \n\nthe following attempt to declare MyClass is in error:",
    "the following attempt to declare MyClass is in error: \n\nBecause MyClass does not declare a type parameter, there is no way to pass one to \nMinMax . In this case, the identifier T is simply unknown, and the compiler reports an \nerror. Of course, if a class implements a specific type of generic interface, such as shown \n\n\nhere: \n\nthen the implementing class does not need to be generic. \nThe generic interface offers two benefits. First, it can be implemented for different types of \ndata. Second, it allows you to put constraints ( that is, bounds ) on the types of data for which \nthe interface can be implemented. In the MinMax example, only types that implement the \nComparable interface can be passed to T . \nHere is the generalized syntax for a generic interface: \n\nHere, type-param-list is a comma-separated list of type parameters. When a generic \ninterface is implemented, you must specify the type arguments, as shown here: \n\nRaw Types and Legacy Code",
    "Here, type-param-list is a comma-separated list of type parameters. When a generic \ninterface is implemented, you must specify the type arguments, as shown here: \n\nRaw Types and Legacy Code \n\nBecause support for generics did not exist prior to JDK 5, it was necessary to provide some \ntransition path from old, pre-generics code. At the time of this writing, there is still pregenerics legacy code that must remain both functional and compatible with generics. Pregenerics code must be able to work with generics, and generic code must be able to work \nwith pre-generics code. \nTo handle the transition to generics, Java allows a generic class to be used without any type \narguments. This creates a raw type for the class. This raw type is compatible with legacy \ncode, which has no knowledge of generics. The main drawback to using the raw type is that \nthe type safety of generics is lost. \nHere is an example that shows a raw type in action:",
    "This program contains several interesting things. First, a raw type of the generic Gen class \nis created by the following declaration: \n\n\nNotice that no type arguments are specified. In essence, this creates a Gen object whose \ntype T is replaced by Object . \nA raw type is not type safe. Thus, a variable of a raw type can be assigned a reference to any \ntype of Gen object. The reverse is also allowed ; a variable of a specific Gen type can be \nassigned a reference to a raw Gen object. However, both operations are potentially unsafe \nbecause the type checking mechanism of generics is circumvented. \nThis lack of type safety is illustrated by the commented-out lines at the end of the program. \nLet\u2019s examine each case. First, consider the following situation:",
    "In this statement, the value of ob inside raw is obtained, and this value is cast to Integer . \nThe trouble is that raw contains a Double value, not an integer value. However, this \ncannot be detected at compile time because the type of raw is unknown. Thus, this \nstatement fails at run time. \nThe next sequence assigns to a strOb ( a reference of type Gen<String> ) a reference to a \nraw Gen object: \n\nThe assignment, itself, is syntactically correct, but questionable. Because strOb is of type \nGen<String> , it is assumed to contain a String . However, after the assignment, the \nobject referred to by strOb contains a Double . Thus, at run time, when an attempt is made \nto assign the contents of strOb to str , a run-time error results because strOb now contains \na Double . Thus, the assignment of a raw reference to a generic reference bypasses the typesafety mechanism. \nThe following sequence inverts the preceding case:",
    "Here, a generic reference is assigned to a raw reference variable. Although this is \nsyntactically correct, it can lead to problems, as illustrated by the second line. In this case, \nraw now refers to an object that contains an Integer object, but the cast assumes that it \n\ncontains a Double . This error cannot be prevented at compile time. Rather, it causes a runtime error. \nBecause of the potential for danger inherent in raw types, javac displays unchecked \nwarnings when a raw type is used in a way that might jeopardize type safety. In the \npreceding program, these lines generate unchecked warnings: \n\n\nIn the first line, it is the call to the Gen constructor without a type argument that causes the \nwarning. In the second line, it is the assignment of a raw reference to a generic variable that \ngenerates the warning. \nAt first, you might think that this line should also generate an unchecked warning, but it \ndoes not:",
    "No compiler warning is issued because the assignment does not cause any further loss of \ntype safety than had already occurred when raw was created. \nOne final point: You should limit the use of raw types to those cases in which you must mix \nlegacy code with newer, generic code. Raw types are simply a transitional feature and not \nsomething that should be used for new code. \n\nGeneric Class Hierarchies \n\nGeneric classes can be part of a class hierarchy in just the same way as a non-generic class. \nThus, a generic class can act as a superclass or be a subclass. The key difference between \ngeneric and non-generic hierarchies is that in a generic hierarchy, any type arguments \nneeded by a generic superclass must be passed up the hierarchy by all subclasses. This is \nsimilar to the way that constructor arguments must be passed up a hierarchy. \n\nUsing a Generic Superclass \n\nHere is a simple example of a hierarchy that uses a generic superclass:",
    "Using a Generic Superclass \n\nHere is a simple example of a hierarchy that uses a generic superclass: \n\n\nIn this hierarchy, Gen2 extends the generic class Gen . Notice how Gen2 is declared by the \nfollowing line: \n\nThe type parameter T is specified by Gen2 and is also passed to Gen in the extends \n\nclause. This means that whatever type is passed to Gen2 will also be passed to Gen . For \nexample, this declaration, \n\npasses Integer as the type parameter to Gen . Thus, the ob inside the Gen portion of \nGen2 will be of type Integer . \nNotice also that Gen2 does not use the type parameter T except to support the Gen \nsuperclass. Thus, even if a subclass of a generic superclass would otherwise not need to be \ngeneric, it still must specify the type parameter ( s ) required by its generic superclass. \nOf course, a subclass is free to add its own type parameters, if needed. For example, here is \na variation on the preceding hierarchy in which Gen2 adds a type parameter of its own:",
    "Notice the declaration of this version of Gen2 , which is shown here: \n\nHere, T is the type passed to Gen , and V is the type that is specific to Gen2 . V is used to \n\n\ndeclare an object called ob2 , and as a return type for the method getob2 ( ) . In main ( ) , a \nGen2 object is created in which type parameter T is String , and type parameter V is \nInteger . The program displays the following, expected, result: \n\nA Generic Subclass \n\nIt is perfectly acceptable for a non-generic class to be the superclass of a generic subclass. \nFor example, consider this program: \n\n\nThe output from the program is shown here: \n\nIn the program, notice how Gen inherits NonGen in the following declaration: \n\n\nBecause NonGen is not generic, no type argument is specified. Thus, even though Gen \ndeclares the type parameter T , it is not needed by ( nor can it be used by ) NonGen . Thus, \nNonGen is inherited by Gen in the normal way. No special conditions apply.",
    "Run-Time Type Comparisons Within a Generic Hierarchy \n\nRecall the run-time type information operator instanceof that was described in Chapter \n13. As explained, instanceof determines if an object is an instance of a class. It returns true \nif an object is of the specified type or can be cast to the specified type. The instanceof \noperator can be applied to objects of generic classes. The following class demonstrates some \nof the type compatibility implications of a generic hierarchy: \n\n\nThe output from the program is shown here: \n\nIn this program, Gen2 is a subclass of Gen , which is generic on type parameter T . In \nmain ( ) , three objects are created. The first is iOb , which is an object of type \n\n\nGen<Integer> . The second is iOb2 , which is an instance of Gen2<Integer> . Finally, \nstrOb2 is an object of type Gen2<String> . \nThen, the program performs these instanceof tests on the type of iOb2 :",
    "As the output shows, both succeed. In the first test, iOb2 is checked against Gen2<?> . \nThis test succeeds because it simply confirms that iOb2 is an object of some type of Gen2 \nobject. The use of the wildcard enables instanceof to determine if iOb2 is an object of any \ntype of Gen2 . Next, iOb2 is tested against Gen<?> , the superclass type. This is also true \nbecause iOb2 is some form of Gen , the superclass. The next few lines in main ( ) show the \nsame sequence ( and same results ) for strOb2 . \nNext, iOb , which is an instance of Gen<Integer> ( the superclass ), is tested by these lines: \n\nThe first if fails because iOb is not some type of Gen2 object. The second test succeeds \nbecause iOb is some type of Gen object. \nNow, look closely at these commented-out lines:",
    "The first if fails because iOb is not some type of Gen2 object. The second test succeeds \nbecause iOb is some type of Gen object. \nNow, look closely at these commented-out lines: \n\nAs the comments indicate, these lines can\u2019t be compiled because they attempt to compare \niOb2 with a specific type of Gen2 , in this case, Gen2<Integer> . Remember, there is no \ngeneric type information available at run time. Therefore, there is no way for instanceof to \nknow if iOb2 is an instance of Gen2<Integer> or not. \n\n\nCasting \n\nYou can cast one instance of a generic class into another only if the two are otherwise \ncompatible and their type arguments are the same. For example, assuming the foregoing \nprogram, this cast is legal: \n\nbecause iOb2 includes an instance of Gen<Integer> . But, this cast: \n\nis not legal because iOb2 is not an instance of Gen<Long> . \n\nOverriding Methods in a Generic Class",
    "because iOb2 includes an instance of Gen<Integer> . But, this cast: \n\nis not legal because iOb2 is not an instance of Gen<Long> . \n\nOverriding Methods in a Generic Class \n\nA method in a generic class can be overridden just like any other method. For example, \nconsider this program in which the method getob ( ) is overridden: \n\n\nThe output is shown here: \n\n\nAs the output confirms, the overridden version of getob ( ) is called for objects of type \nGen2 , but the superclass version is called for objects of type Gen . \n\nType Inference with Generics \n\nBeginning with JDK 7, it is possible to shorten the syntax used to create an instance of a \ngeneric type. To begin, consider the following generic class: \n\nPrior to JDK 7, to create an instance of MyClass , you would have needed to use a \nstatement similar to the following:",
    "Prior to JDK 7, to create an instance of MyClass , you would have needed to use a \nstatement similar to the following: \n\nHere, the type arguments ( which are Integer and String ) are specified twice: first, when \nmcOb is declared, and second, when a MyClass instance is created via new . Since \ngenerics were introduced by JDK 5, this is the form required by all versions of Java prior to \nJDK 7. Although there is nothing wrong, per se, with this form, it is a bit more verbose than \nit needs to be. In the new clause, the type of the type arguments can be readily inferred \nfrom the type of mcOb ; therefore, there is really no reason that they need to be specified a \nsecond time. To address this situation, JDK 7 added a syntactic element that lets you avoid \nthe second specification. \nToday the preceding declaration can be rewritten as shown here:",
    "Notice that the instance creation portion simply uses <>, which is an empty type argument \nlist. This is referred to as the diamond operator. It tells the compiler to infer the type \narguments needed by the constructor in the new expression. The principal advantage of this \ntype-inference syntax is that it shortens what are sometimes quite long declaration \n\nstatements. \n\n\nThe preceding can be generalized. When type inference is used, the declaration syntax for a \ngeneric reference and instance creation has this general form: \n\nclass-name < type-arg-list > var-name = new class-name <>( cons-arg-list ); \n\nHere, the type argument list of the constructor in the new clause is empty. \nType inference can also be applied to parameter passing. For example, if the following \nmethod is added to MyClass , \n\nthen the following call is legal:",
    "then the following call is legal: \n\nIn this case, the type arguments for the argument passed to isSame ( ) can be inferred from \nthe parameter\u2019s type. \nBecause the type-inference syntax was added by JDK 7 and won\u2019t work with older \ncompilers, most of the examples in this book will continue to use the full syntax when \ndeclaring instances of generic classes. This way, the examples will work with any Java \ncompiler that supports generics. Using the full-length syntax also makes it very clear \nprecisely what is being created, which is important in example code shown in a book. \nHowever, in your own code, the use of the type-inference syntax will streamline your \ndeclarations. \n\nErasure",
    "Erasure \n\nUsually, it is not necessary to know the details about how the Java compiler transforms your \nsource code into object code. However, in the case of generics, some general understanding \nof the process is important because it explains why the generic features work as they do\u2014 \nand why their behavior is sometimes a bit surprising. For this reason, a brief discussion of \nhow generics are implemented in Java is in order. \nAn important constraint that governed the way that generics were added to Java was the \nneed for compatibility with previous versions of Java. Simply put, generic code had to be \ncompatible with preexisting, non-generic code. Thus, any changes to the syntax of the Java \nlanguage, or to the JVM, had to avoid breaking older code. The way Java implements",
    "generics while satisfying this constraint is through the use of erasure . \nIn general, here is how erasure works. When your Java code is compiled, all generic type \ninformation is removed ( erased ). This means replacing type parameters with their bound \ntype, which is Object if no explicit bound is specified, and then applying the appropriate \n\n\ncasts ( as determined by the type arguments ) to maintain type compatibility with the types \nspecified by the type arguments. The compiler also enforces this type compatibility. This \napproach to generics means that no type parameters exist at run time. They are simply a \nsource-code mechanism. \n\nBridge Methods",
    "Bridge Methods \n\nOccasionally, the compiler will need to add a bridge method to a class to handle situations \nin which the type erasure of an overriding method in a subclass does not produce the same \nerasure as the method in the superclass. In this case, a method is generated that uses the \ntype erasure of the superclass, and this method calls the method that has the type erasure \nspecified by the subclass. Of course, bridge methods only occur at the bytecode level, are not \nseen by you, and are not available for your use. \nAlthough bridge methods are not something that you will normally need to be concerned \nwith, it is still instructive to see a situation in which one is generated. Consider the following \nprogram: \n\n\nIn the program, the subclass Gen2 extends Gen , but does so using a String -specific \nversion of Gen , as its declaration shows: \n\nFurthermore, inside Gen2 , getob ( ) is overridden with String specified as the return type:",
    "Furthermore, inside Gen2 , getob ( ) is overridden with String specified as the return type: \n\n\nAll of this is perfectly acceptable. The only trouble is that because of type erasure, the \nexpected form of getob ( ) will be \n\nTo handle this problem, the compiler generates a bridge method with the preceding \nsignature that calls the String version. Thus, if you examine the class file for Gen2 by using \njavap , you will see the following methods: \n\nAs you can see, the bridge method has been included. ( The comment was added by the \nauthor and not by javap , and the precise output you see may vary based on the version of \nJava that you are using.) \nThere is one last point to make about this example. Notice that the only difference between \nthe two getob ( ) methods is their return type. Normally, this would cause an error, but \nbecause this does not occur in your source code, it does not cause a problem and is handled \ncorrectly by the JVM. \n\nAmbiguity Errors",
    "Ambiguity Errors \n\nThe inclusion of generics gives rise to a new type of error that you must guard against: \nambiguity . Ambiguity errors occur when erasure causes two seemingly distinct generic \ndeclarations to resolve to the same erased type, causing a conflict. Here is an example that \n\ninvolves method overloading: \n\n\nNotice that MyGenClass declares two generic types: T and V . Inside MyGenClass , an \nattempt is made to overload set ( ) based on parameters of type T and V . This looks \nreasonable because T and V appear to be different types. However, there are two ambiguity \nproblems here. \nFirst, as MyGenClass is written, there is no requirement that T and V actually be different \ntypes. For example, it is perfectly correct ( in principle ) to construct a MyGenClass object \nas shown here:",
    "In this case, both T and V will be replaced by String . This makes both versions of set ( ) \nidentical, which is, of course, an error. \nThe second and more fundamental problem is that the type erasure of set ( ) reduces both \nversions to the following: \n\nThus, the overloading of set ( ) as attempted in MyGenClass is inherently ambiguous. \nAmbiguity errors can be tricky to fix. For example, if you know that V will always be some \n\ntype of Number , you might try to fix MyGenClass by rewriting its declaration as shown \nhere: \n\nThis change causes MyGenClass to compile, and you can even instantiate objects like the \n\n\none shown here: \n\nThis works because Java can accurately determine which method to call. However, \nambiguity returns when you try this line:",
    "one shown here: \n\nThis works because Java can accurately determine which method to call. However, \nambiguity returns when you try this line: \n\nIn this case, since both T and V are Number , which version of set ( ) is to be called? The \ncall to set ( ) is now ambiguous. \nFrankly, in the preceding example, it would be much better to use two separate method \nnames, rather than trying to overload set ( ) . Often, the solution to ambiguity involves the \nrestructuring of the code, because ambiguity frequently means that you have a conceptual \nerror in your design. \n\nSome Generic Restrictions \n\nThere are a few restrictions that you need to keep in mind when using generics. They \ninvolve creating objects of a type parameter, static members, exceptions, and arrays. Each is \nexamined here. \n\nType Parameters Can\u2019t Be Instantiated \n\nIt is not possible to create an instance of a type parameter. For example, consider this class:",
    "Type Parameters Can\u2019t Be Instantiated \n\nIt is not possible to create an instance of a type parameter. For example, consider this class: \n\nHere, it is illegal to attempt to create an instance of T . The reason should be easy to \n\nunderstand: the compiler does not know what type of object to create. T is simply a \nplaceholder. \n\nRestrictions on Static Members \n\nNo static member can use a type parameter declared by the enclosing class. For example, \nboth of the static members of this class are illegal: \n\n\nAlthough you can\u2019t declare static members that use a type parameter declared by the \nenclosing class, you can declare static generic methods, which define their own type \nparameters, as was done earlier in this chapter. \n\nGeneric Array Restrictions",
    "Generic Array Restrictions \n\nThere are two important generics restrictions that apply to arrays. First, you cannot \ninstantiate an array whose element type is a type parameter. Second, you cannot create an \narray of type-specific generic references. The following short program shows both situations: \n\n\nAs the program shows, it\u2019s valid to declare a reference to an array of type T , as this line \ndoes: \n\nBut, you cannot instantiate an array of T , as this commented-out line attempts: \n\nThe reason you can\u2019t create an array of T is that there is no way for the compiler to know \nwhat type of array to actually create. \nHowever, you can pass a reference to a type-compatible array to Gen ( ) when an object is \ncreated and assign that reference to vals , as the program does in this line:",
    "This works because the array passed to Gen has a known type, which will be the same type \nas T at the time of object creation. \nInside main ( ) , notice that you can\u2019t declare an array of references to a specific generic \ntype. That is, this line \n\nwon\u2019t compile. \nYou can create an array of references to a generic type if you use a wildcard, however, as \nshown here: \n\nThis approach is better than using an array of raw types, because at least some type \n\nchecking will still be enforced. \n\nGeneric Exception Restriction \n\nA generic class cannot extend Throwable . This means that you cannot create generic \nexception classes. \n\n\uf709 \nPREV \nChapter 13: I/O, Applets, and Other Topics \n\u23ee \n\nNEXT \nChapter 15: Lambda Expressions \u23ed \n\n\nPREV \nChapter 14: Generics \n\u23ee \n\nNEXT \nPart II: The Java Library \n\u23ed \n\nCHAPTER \n\n15 \nLambda Expressions",
    "During Java\u2019s ongoing development and evolution, many features have been added since its \noriginal 1.0 release. However, two stand out because they have profoundly reshaped the \nlanguage, fundamentally changing the way that code is written. The first was the addition of \ngenerics, added by JDK 5. ( See Chapter 14.) The second is the lambda expression , which is \nthe subject of this chapter. \nAdded by JDK 8, lambda expressions ( and their related features ) significantly enhance Java \nbecause of two primary reasons. First, they add new syntax elements that increase the \nexpressive power of the language. In the process, they streamline the way that certain \ncommon constructs are implemented. Second, the addition of lambda expressions resulted \nin new capabilities being incorporated into the API library",
    ". Second, the addition of lambda expressions resulted \nin new capabilities being incorporated into the API library. Among these new capabilities \nare the ability to more easily take advantage of the parallel processing capabilities of multicore environments, especially as it relates to the handling of for-each style operations, and \nthe new stream API, which supports pipeline operations on data. The addition of lambda \nexpressions also provided the catalyst for other new Java features, including the default \nmethod ( described in Chapter 9 ), which lets you define default behavior for an interface",
    "method, and the method reference ( described here ), which lets you refer to a method \nwithout executing it. \nBeyond the benefits that lambda expressions bring to the language, there is another reason \nwhy they constitute an important addition to Java. Over the past few years, lambda \nexpressions have become a major focus of computer language design. For example, they \nhave been added to languages such as C# and C++. Their inclusion in JDK 8 helps Java \nremain the vibrant, innovative language that programmers have come to expect. \nIn the final analysis, in much the same way that generics reshaped Java several years ago, \n\nlambda expressions are reshaping Java today. Simply put, lambda expressions will impact \nvirtually all Java programmers. They truly are that important. \n\nIntroducing Lambda Expressions",
    "lambda expressions are reshaping Java today. Simply put, lambda expressions will impact \nvirtually all Java programmers. They truly are that important. \n\nIntroducing Lambda Expressions \n\nKey to understanding Java\u2019s implementation of lambda expressions are two constructs. The \nfirst is the lambda expression, itself. The second is the functional interface. Let\u2019s begin with \n\na simple definition of each.",
    "A lambda expression is, essentially, an anonymous ( that is, unnamed ) method. However, \nthis method is not executed on its own. Instead, it is used to implement a method defined \nby a functional interface. Thus, a lambda expression results in a form of anonymous class. \nLambda expressions are also commonly referred to as closures . \nA functional interface is an interface that contains one and only one abstract method. \nNormally, this method specifies the intended purpose of the interface. Thus, a functional",
    "interface typically represents a single action. For example, the standard interface Runnable \nis a functional interface because it defines only one method: run ( ) . Therefore, run ( ) \ndefines the action of Runnable . Furthermore, a functional interface defines the target type \nof a lambda expression. Here is a key point: a lambda expression can be used only in a \ncontext in which its target type is specified. One other thing: a functional interface is \nsometimes referred to as a SAM type , where SAM stands for Single Abstract Method.",
    "NOTE    A functional interface may specify any public method defined by \nObject , such as equals ( ) , without affecting its \u201cfunctional interface\u201d \nstatus. The public Object methods are considered implicit members of a \nfunctional interface because they are automatically implemented by an \ninstance of a functional interface. \n\nLet\u2019s now look more closely at both lambda expressions and functional interfaces. \n\nLambda Expression Fundamentals",
    "Let\u2019s now look more closely at both lambda expressions and functional interfaces. \n\nLambda Expression Fundamentals \n\nThe lambda expression introduces a new syntax element and operator into the Java \nlanguage. The new operator, sometimes referred to as the lambda operator or the arrow \noperator , is \u2013> . It divides a lambda expression into two parts. The left side specifies any \nparameters required by the lambda expression. ( If no parameters are needed, an empty \nparameter list is used.) On the right side is the lambda body , which specifies the actions of \nthe lambda expression. The \u2013> can be verbalized as \u201cbecomes\u201d or \u201cgoes to.\u201d \nJava defines two types of lambda bodies. One consists of a single expression, and the other \ntype consists of a block of code. We will begin with lambdas that define a single expression. \nLambdas with block bodies are discussed later in this chapter. \n\nAt this point, it will be helpful to look a few examples of lambda expressions before",
    "At this point, it will be helpful to look a few examples of lambda expressions before \n\ncontinuing. Let\u2019s begin with what is probably the simplest type of lambda expression you can \nwrite. It evaluates to a constant value and is shown here: \n\n\nThis lambda expression takes no parameters, thus the parameter list is empty. It returns the \nconstant value 123.45. Therefore, it is similar to the following method: \n\nOf course, the method defined by a lambda expression does not have a name. \nA slightly more interesting lambda expression is shown here: \n\nThis lambda expression obtains a pseudo-random value from Math.random ( ) , multiplies \nit by 100, and returns the result. It, too, does not require a parameter. \nWhen a lambda expression requires a parameter, it is specified in the parameter list on the \nleft side of the lambda operator. Here is a simple example:",
    "This lambda expression returns true if the value of parameter n is even. Although it is \npossible to explicitly specify the type of a parameter, such as n in this case, often you won\u2019t \nneed to do so because in many cases its type can be inferred. Like a named method, a \nlambda expression can specify as many parameters as needed. \n\nFunctional Interfaces",
    "Functional Interfaces \n\nAs stated, a functional interface is an interface that specifies only one abstract method. If \nyou have been programming in Java for some time, you might at first think that all interface \nmethods are implicitly abstract. Although this was true prior to JDK 8, the situation has \nchanged. As explained in Chapter 9, beginning with JDK 8, it is possible to specify default \nbehavior for a method declared in an interface. This is called a default method . Today, an \ninterface method is abstract only if it does not specify a default implementation. Because \nnondefault interface methods are implicitly abstract, there is no need to use the abstract \nmodifier ( although you can specify it, if you like ). \nHere is an example of a functional interface:",
    "In this case, the method getValue ( ) is implicitly abstract, and it is the only method \ndefined by MyNumber . Thus, MyNumber is a functional interface, and its function is \ndefined by getValue ( ) . \nAs mentioned earlier, a lambda expression is not executed on its own. Rather, it forms the \nimplementation of the abstract method defined by the functional interface that specifies its \n\n\ntarget type. As a result, a lambda expression can be specified only in a context in which a \ntarget type is defined. One of these contexts is created when a lambda expression is \nassigned to a functional interface reference. Other target type contexts include variable \ninitialization, return statements, and method arguments, to name a few. \nLet\u2019s work through an example that shows how a lambda expression can be used in an \nassignment context. First, a reference to the functional interface MyNumber is declared: \n\nNext, a lambda expression is assigned to that interface reference:",
    "Next, a lambda expression is assigned to that interface reference: \n\nWhen a lambda expression occurs in a target type context, an instance of a class is \nautomatically created that implements the functional interface, with the lambda expression \ndefining the behavior of the abstract method declared by the functional interface. When that \nmethod is called through the target, the lambda expression is executed. Thus, a lambda \nexpression gives us a way to transform a code segment into an object. \nIn the preceding example, the lambda expression becomes the implementation for the \ngetValue ( ) method. As a result, the following displays the value 123.45:",
    "Because the lambda expression assigned to myNum returns the value 123.45, that is the \nvalue obtained when getValue ( ) is called. \nIn order for a lambda expression to be used in a target type context, the type of the abstract \nmethod and the type of the lambda expression must be compatible. For example, if the \nabstract method specifies two int parameters, then the lambda must specify two parameters \nwhose type either is explicitly int or can be implicitly inferred as int by the context. In \ngeneral, the type and number of the lambda expression\u2019s parameters must be compatible \nwith the method\u2019s parameters ; the return types must be compatible ; and any exceptions \nthrown by the lambda expression must be acceptable to the method. \n\nSome Lambda Expression Examples \n\nWith the preceding discussion in mind, let\u2019s look at some simple examples that illustrate the \n\nbasic lambda expression concepts. The first example puts together the pieces shown in the \nforegoing section.",
    "basic lambda expression concepts. The first example puts together the pieces shown in the \nforegoing section. \n\n\nSample output from the program is shown here: \n\nAs mentioned, the lambda expression must be compatible with the abstract method that it is \n\nintended to implement. For this reason, the commented-out line at the end of the preceding \nprogram is illegal because a value of type String is not compatible with double , which is \nthe return type required by getValue ( ) . \n\nThe next example shows the use of a parameter with a lambda expression: \n\n\nThe output from this program is shown here: \n\nThis program demonstrates a key fact about lambda expressions that warrants close \nexamination. Pay special attention to the lambda expression that performs the test for \nevenness. It is shown again here: \n\nNotice that the type of n is not specified. Rather, its type is inferred from the context. In",
    "Notice that the type of n is not specified. Rather, its type is inferred from the context. In \n\nthis case, its type is inferred from the parameter type of test ( ) as defined by the \nNumericTest interface, which is int . It is also possible to explicitly specify the type of a \n\nparameter in a lambda expression. For example, this is also a valid way to write the \npreceding: \n\nHere, n is explicitly specified as int . Usually it is not necessary to explicitly specify the type, \n\n\nbut you can in those situations that require it.",
    "This program demonstrates another important point about lambda expressions: A \nfunctional interface reference can be used to execute any lambda expression that is \ncompatible with it. Notice that the program defines two different lambda expressions that \nare compatible with the test ( ) method of the functional interface NumericTest . The first, \ncalled isEven , determines if a value is even. The second, called isNonNeg , checks if a \nvalue is non-negative. In each case, the value of the parameter n is tested. Because each \nlambda expression is compatible with test ( ) , each can be executed through a \nNumericTest reference. \nOne other point before moving on. When a lambda expression has only one parameter, it is \nnot necessary to surround the parameter name with parentheses when it is specified on the \nleft side of the lambda operator. For example, this is also a valid way to write the lambda \nexpression used in the program:",
    "For consistency, this book will surround all lambda expression parameter lists with \nparentheses, even those containing only one parameter. Of course, you are free to adopt a \ndifferent style. \nThe next program demonstrates a lambda expression that takes two parameters. In this \ncase, the lambda expression tests if one number is a factor of another. \n\nThe output is shown here: \n\n\nIn this program, the functional interface NumericTest2 defines the test ( ) method: \n\nIn this version, test ( ) specifies two parameters. Thus, for a lambda expression to be \ncompatible with test ( ) , the lambda expression must also specify two parameters. Notice \nhow they are specified:",
    "The two parameters, n and d , are specified in the parameter list, separated by commas. This \nexample can be generalized. Whenever more than one parameter is required, the \nparameters are specified, separated by commas, in a parenthesized list on the left side of the \nlambda operator. \nHere is an important point about multiple parameters in a lambda expression: If you need \nto explicitly declare the type of a parameter, then all of the parameters must have declared \ntypes. For example, this is legal: \n\nBut this is not: \n\nBlock Lambda Expressions",
    "But this is not: \n\nBlock Lambda Expressions \n\nThe body of the lambdas shown in the preceding examples consist of a single expression. \nThese types of lambda bodies are referred to as expression bodies , and lambdas that have \nexpression bodies are sometimes called expression lambdas . In an expression body, the \ncode on the right side of the lambda operator must consist of a single expression. While \nexpression lambdas are quite useful, sometimes the situation will require more than a single \nexpression. To handle such cases, Java supports a second type of lambda expression in \nwhich the code on the right side of the lambda operator consists of a block of code that can \ncontain more than one statement. This type of lambda body is called a block body . Lambdas",
    "that have block bodies are sometimes referred to as block lambdas . \nA block lambda expands the types of operations that can be handled within a lambda \nexpression because it allows the body of the lambda to contain multiple statements. For \nexample, in a block lambda you can declare variables, use loops, specify if and switch \nstatements, create nested blocks, and so on. A block lambda is easy to create. Simply enclose \nthe body within braces as you would any other block of statements. \n\n\nAside from allowing multiple statements, block lambdas are used much like the expression \nlambdas just discussed. One key difference, however, is that you must explicitly use a \nreturn statement to return a value. This is necessary because a block lambda body does not \nrepresent a single expression. \nHere is an example that uses a block lambda to compute and return the factorial of an int \nvalue: \n\nThe output is shown here:",
    "The output is shown here: \n\nIn the program, notice that the block lambda declares a variable called result , uses a for \n\nloop, and has a return statement. These are legal inside a block lambda body. In essence, \nthe block body of a lambda is similar to a method body. One other point. When a return \nstatement occurs within a lambda expression, it simply causes a return from the lambda. It \n\ndoes not cause an enclosing method to return. \nAnother example of a block lambda is shown in the following program. It reverses the \ncharacters in a string. \n\n\nThe output is shown here: \n\nIn this example, the functional interface StringFunc declares the func ( ) method. This \nmethod takes a parameter of type String and has a return type of String . Thus, in the \nreverse lambda expression, the type of str is inferred to be String . Notice that the \ncharAt ( ) method is called on str . This is legal because of the inference that str is of type \nString . \n\nGeneric Functional Interfaces",
    "Generic Functional Interfaces \n\nA lambda expression, itself, cannot specify type parameters. Thus, a lambda expression \n\ncannot be generic. ( Of course, because of type inference, all lambda expressions exhibit \nsome \u201cgeneric-like\u201d qualities.) However, the functional interface associated with a lambda \nexpression can be generic. In this case, the target type of the lambda expression is \ndetermined, in part, by the type argument or arguments specified when a functional \ninterface reference is declared. \n\n\nTo understand the value of generic functional interfaces, consider this. The two examples in",
    "To understand the value of generic functional interfaces, consider this. The two examples in \n\nthe previous section used two different functional interfaces, one called NumericFunc and \nthe other called StringFunc . However, both defined a method called func ( ) that took one \nparameter and returned a result. In the first case, the type of the parameter and return type \nwas int . In the second case, the parameter and return type was String . Thus, the only \ndifference between the two methods was the type of data they required. Instead of having \ntwo functional interfaces whose methods differ only in their data types, it is possible to \ndeclare one generic interface that can be used to handle both circumstances. The following \nprogram shows this approach: \n\n\nThe output is shown here: \n\nIn the program, the generic functional interface SomeFunc is declared as shown here:",
    "The output is shown here: \n\nIn the program, the generic functional interface SomeFunc is declared as shown here: \n\nHere, T specifies both the return type and the parameter type of func ( ) . This means that it \nis compatible with any lambda expression that takes one parameter and returns a value of \nthe same type. \nThe SomeFunc interface is used to provide a reference to two different types of lambdas. \nThe first uses type String . The second uses type Integer . Thus, the same functional \ninterface can be used to refer to the reverse lambda and the factorial lambda. Only the \ntype argument passed to SomeFunc differs. \n\nPassing Lambda Expressions as Arguments",
    "Passing Lambda Expressions as Arguments \n\nAs explained earlier, a lambda expression can be used in any context that provides a target \ntype. One of these is when a lambda expression is passed as an argument. In fact, passing a \nlambda expression as an argument is a common use of lambdas. Moreover, it is a very \npowerful use because it gives you a way to pass executable code as an argument to a \nmethod. This greatly enhances the expressive power of Java. \nTo pass a lambda expression as an argument, the type of the parameter receiving the \nlambda expression argument must be of a functional interface type compatible with the \nlambda. Although using a lambda expression as an argument is straightforward, it is still \nhelpful to see it in action. The following program demonstrates the process: \n\n\n\n\nThe output is shown here: \n\n\nIn the program, first notice the stringOp ( ) method. It has two parameters. The first is of",
    "The output is shown here: \n\n\nIn the program, first notice the stringOp ( ) method. It has two parameters. The first is of \n\ntype StringFunc , which is a functional interface. Thus, this parameter can receive a \nreference to any instance of StringFunc , including one created by a lambda expression. \nThe second argument of stringOp ( ) is of type String , and this is the string operated on. \nNext, notice the first call to stringOp ( ) , shown again here:",
    "Here, a simple expression lambda is passed as an argument. When this occurs, an instance \nof the functional interface StringFunc is created and a reference to that object is passed to \nthe first parameter of stringOp ( ) . Thus, the lambda code, embedded in a class instance, is \npassed to the method. The target type context is determined by the type of parameter. \nBecause the lambda expression is compatible with that type, the call is valid. Embedding \nsimple lambdas, such as the one just shown, inside a method call is often a convenient \ntechnique\u2014especially when the lambda expression is intended for a single use. \nNext, the program passes a block lambda to stringOp ( ) . This lambda removes spaces from \na string. It is shown again here:",
    "Although this uses a block lambda, the process of passing the lambda expression is the same \nas just described for the simple expression lambda. In this case, however, some \nprogrammers will find the syntax a bit awkward. \nWhen a block lambda seems overly long to embed in a method call, it is an easy matter to \nassign that lambda to a functional interface variable, as the previous examples have done. \nThen, you can simply pass that reference to the method. This technique is shown at the end \nof the program. There, a block lambda is defined that reverses a string. This lambda is \nassigned to reverse , which is a reference to a StringFunc instance. Thus, reverse can be \nused as an argument to the first parameter of stringOp ( ) . The program then calls",
    "stringOp ( ) , passing in reverse and the string on which to operate. Because the instance \nobtained by the evaluation of each lambda expression is an implementation of StringFunc , \neach can be used as the first parameter to stringOp ( ) . \nOne last point: In addition to variable initialization, assignment, and argument passing, the \n\n\nfollowing also constitute target type contexts: casts, the ? operator, array initializers, \nreturn statements, and lambda expressions, themselves. \n\nLambda Expressions and Exceptions",
    "following also constitute target type contexts: casts, the ? operator, array initializers, \nreturn statements, and lambda expressions, themselves. \n\nLambda Expressions and Exceptions \n\nA lambda expression can throw an exception. However, it if throws a checked exception, \nthen that exception must be compatible with the exception ( s ) listed in the throws clause of \nthe abstract method in the functional interface. Here is an example that illustrates this fact. \nIt computes the average of an array of double values. If a zero-length array is passed, \nhowever, it throws the custom exception EmptyArrayException . As the example shows, \nthis exception is listed in the throws clause of func ( ) declared inside the \nDoubleNumericArrayFunc functional interface.",
    "The first call to average.func ( ) returns the value 2.5. The second call, which passes a \nzero-length array, causes an EmptyArrayException to be thrown. Remember, the \ninclusion of the throws clause in func ( ) is necessary. Without it, the program will not \n\n\ncompile because the lambda expression will no longer be compatible with func ( ) . \nThis example demonstrates another important point about lambda expressions. Notice that \nthe parameter specified by func ( ) in the functional interface \nDoubleNumericArrayFunc is an array. However, the parameter to the lambda \nexpression is simply n , rather than n[ ] . Remember, the type of a lambda expression \nparameter will be inferred from the target context. In this case, the target context is \ndouble[ ] , thus the type of n will be double[ ] . It is not necessary ( or legal ) to specify it as \nn[ ] . It would be legal to explicitly declare it as double[ ] n , but doing so gains nothing in \nthis case.",
    "Variables defined by the enclosing scope of a lambda expression are accessible within the \nlambda expression. For example, a lambda expression can use an instance or static variable \ndefined by its enclosing class. A lambda expression also has access to this ( both explicitly \nand implicitly ), which refers to the invoking instance of the lambda expression\u2019s enclosing \nclass. Thus, a lambda expression can obtain or set the value of an instance or static variable \nand call a method defined by its enclosing class. \nHowever, when a lambda expression uses a local variable from its enclosing scope, a special \nsituation is created that is referred to as a variable capture . In this case, a lambda \nexpression may only use local variables that are effectively final . An effectively final variable \nis one whose value does not change after it is first assigned. There is no need to explicitly \ndeclare such a variable as final , although doing so would not be an error",
    ". There is no need to explicitly \ndeclare such a variable as final , although doing so would not be an error. ( The this \nparameter of an enclosing scope is automatically effectively final, and lambda expressions do \nnot have a this of their own.) \nIt is important to understand that a local variable of the enclosing scope cannot be modified \nby the lambda expression. Doing so would remove its effectively final status, thus rendering \nit illegal for capture. \nThe following program illustrates the difference between effectively final and mutable local \nvariables:",
    "As the comments indicate, num is effectively final and can, therefore, be used inside \nmyLambda . However, if num were to be modified, either inside the lambda or outside of \nit, num would lose its effectively final status. This would cause an error, and the program \nwould not compile. \nIt is important to emphasize that a lambda expression can use and modify an instance \nvariable from its invoking class. It just can\u2019t use a local variable of its enclosing scope unless \nthat variable is effectively final. \n\nMethod References \n\nThere is an important feature related to lambda expressions called the method reference . A \nmethod reference provides a way to refer to a method without executing it. It relates to \nlambda expressions because it, too, requires a target type context that consists of a \ncompatible functional interface. When evaluated, a method reference also creates an \ninstance of the functional interface.",
    "There are different types of method references. We will begin with method references to \nstatic methods. \n\nMethod References to static Methods \n\nTo create a static method reference, use this general syntax: \n\nClassName :: methodName \n\n\nNotice that the class name is separated from the method name by a double colon. \nThe :: is a new separator that has been added to Java by JDK 8 expressly for this \npurpose. This method reference can be used anywhere in which it is compatible \nwith its target type. \nThe following program demonstrates a static method reference: \n\nThe output is shown here: \n\n\nIn the program, pay special attention to this line:",
    "The output is shown here: \n\n\nIn the program, pay special attention to this line: \n\nHere, a reference to the static method strReverse ( ) , declared inside MyStringOps , is \npassed as the first argument to stringOp ( ) . This works because strReverse is compatible \nwith the StringFunc functional interface. Thus, the expression \nMyStringOps::strReverse evaluates to a reference to an object in which strReverse \nprovides the implementation of func ( ) in StringFunc . \n\nMethod References to Instance Methods \n\nTo pass a reference to an instance method on a specific object, use this basic syntax: \n\nobjRef :: methodName \n\nAs you can see, the syntax is similar to that used for a static method, except that \nan object reference is used instead of a class name. Here is the previous program \nrewritten to use an instance method reference: \n\n\nThis program produces the same output as the previous version.",
    "This program produces the same output as the previous version. \n\nIn the program, notice that strReverse ( ) is now an instance method of MyStringOps . \nInside main ( ) , an instance of MyStringOps called strOps is created. This instance is \nused to create the method reference to strReverse in the call to stringOp , as shown \nagain, here: \n\n\nIn this example, strReverse ( ) is called on the strOps object. \nIt is also possible to handle a situation in which you want to specify an instance method that \ncan be used with any object of a given class\u2014not just a specified object. In this case, you will \ncreate a method reference as shown here: \n\nClassName :: instanceMethodName",
    "ClassName :: instanceMethodName \n\nHere, the name of the class is used instead of a specific object, even though an \ninstance method is specified. With this form, the first parameter of the functional \ninterface matches the invoking object and the second parameter matches the \nparameter specified by the method. Here is an example. It defines a method called \ncounter ( ) that counts the number of objects in an array that satisfy the condition \ndefined by the func ( ) method of the MyFunc functional interface. In this case, it \ncounts instances of the HighTemp class. \n\n\nThe output is shown here:",
    "The output is shown here: \n\n\nIn the program, notice that HighTemp has two instance methods: sameTemp ( ) and \nlessThanTemp ( ) . The first returns true if two HighTemp objects contain the same \ntemperature. The second returns true if the temperature of the invoking object is less than \nthat of the passed object. Each method has a parameter of type HighTemp and each \nmethod returns a boolean result. Thus, each is compatible with the MyFunc functional \ninterface because the invoking object type can be mapped to the first parameter of func ( ) \nand the argument mapped to func ( ) \u2019s second parameter. Thus, when the expression",
    "is passed to the counter ( ) method, an instance of the functional interface MyFunc is \ncreated in which the parameter type of the first parameter is that of the invoking object of \nthe instance method, which is HighTemp . The type of the second parameter is also \nHighTemp because that is the type of the parameter to sameTemp ( ) . The same is true \nfor the lessThanTemp ( ) method. \nOne other point: you can refer to the superclass version of a method by use of super , as \nshown here: \n\nsuper:: name \n\nThe name of the method is specified by name . \n\nMethod References with Generics \n\nYou can use method references with generic classes and/or generic methods. For example, \nconsider the following program: \n\n\nThe output is shown here:",
    "Method References with Generics \n\nYou can use method references with generic classes and/or generic methods. For example, \nconsider the following program: \n\n\nThe output is shown here: \n\n\nIn the program, MyArrayOps is a non-generic class that contains a generic method called \ncountMatching ( ) . The method returns a count of the elements in an array that match a \nspecified value. Notice how the generic type argument is specified. For example, its first call \nin main ( ) , shown here:",
    "passes the type argument Integer . Notice that it occurs after the :: . This syntax can be \ngeneralized: When a generic method is specified as a method reference, its type argument \ncomes after the :: and before the method name. It is important to point out, however, that \nexplicitly specifying the type argument is not required in this situation ( and many others ) \nbecause the type argument would have been automatically inferred. In cases in which a \ngeneric class is specified, the type argument follows the class name and precedes the :: . \nAlthough the preceding examples show the mechanics of using method references, they \ndon\u2019t show their real benefits. One place method references can be quite useful is in \nconjunction with the Collections Framework, which is described later in Chapter 18. \nHowever, for completeness, a short, but effective, example that uses a method reference to \nhelp determine the largest element in a collection is included here",
    ". \nHowever, for completeness, a short, but effective, example that uses a method reference to \nhelp determine the largest element in a collection is included here. ( If you are unfamiliar \nwith the Collections Framework, return to this example after you have worked through \nChapter 18.) \nOne way to find the largest element in a collection is to use the max ( ) method defined by \nthe Collections class. For the version of max ( ) used here, you must pass a reference to \nthe collection and an instance of an object that implements the Comparator<T> interface. \nThis interface specifies how two objects are compared. It defines only one abstract method, \ncalled compare ( ) , that takes two arguments, each the type of the objects being compared. \nIt must return greater than zero if the first argument is greater than the second, zero if the \ntwo arguments are equal, and less than zero if the first object is less than the second",
    ". \nIt must return greater than zero if the first argument is greater than the second, zero if the \ntwo arguments are equal, and less than zero if the first object is less than the second. \nIn the past, to use max ( ) with user-defined objects, an instance of Comparator<T> had \nto be obtained by first explicitly implementing it by a class, and then creating an instance of \nthat class. This instance was then passed as the comparator to max ( ) . With JDK 8, it is \nnow possible to simply pass a reference to a comparison method to max ( ) because doing \nso automatically implements the comparator. The following simple example shows the \nprocess by creating an ArrayList of MyClass objects and then finding the one in the list \nthat has the highest value ( as defined by the comparison method ).",
    "The output is shown here: \n\nIn the program, notice that MyClass neither defines any comparison method of its own, \n\nnor does it implement Comparator . However, the maximum value of a list of MyClass \nitems can still be obtained by calling max ( ) because UseMethodRef defines the static \nmethod compareMC ( ) , which is compatible with the compare ( ) method defined by \nComparator . Therefore, there is no need to explicitly implement and create an instance of \nComparator . \n\nConstructor References \n\nSimilar to the way that you can create references to methods, you can create references to \nconstructors. Here is the general form of the syntax that you will use: \n\nclassname ::new \n\nThis reference can be assigned to any functional interface reference that defines a \n\n\nmethod compatible with the constructor. Here is a simple example: \n\nThe output is shown here:",
    "This reference can be assigned to any functional interface reference that defines a \n\n\nmethod compatible with the constructor. Here is a simple example: \n\nThe output is shown here: \n\nIn the program, notice that the func ( ) method of MyFunc returns a reference of type \nMyClass and has an int parameter. Next, notice that MyClass defines two constructors. \nThe first specifies a parameter of type int . The second is the default, parameterless \nconstructor. Now, examine the following line: \n\n\nHere, the expression MyClass::new creates a constructor reference to a MyClass \nconstructor. In this case, because MyFunc \u2019s func ( ) method takes an int parameter, the \nconstructor being referred to is MyClass ( int v ) because it is the one that matches. Also \nnotice that the reference to this constructor is assigned to a MyFunc reference called \nmyClassCons . After this statement executes, myClassCons can be used to create an \ninstance of MyClass , as this line shows:",
    "In essence, myClassCons has become another way to call MyClass ( int v ) . \nConstructor references to generic classes are created in the same fashion. The only \ndifference is that the type argument can be specified. This works the same as it does for \nusing a generic class to create a method reference: simply specify the type argument after \nthe class name. The following illustrates this by modifying the previous example so that \nMyFunc and MyClass are generic. \n\n\nThis program produces the same output as the previous version. The difference is that now \nboth MyFunc and MyClass are generic. Thus, the sequence that creates a constructor \nreference can include a type argument ( although one is not always needed ), as shown here: \n\nBecause the type argument Integer has already been specified when myClassCons is \ncreated, it can be used to create a MyClass<Integer> object, as the next line shows:",
    "Because the type argument Integer has already been specified when myClassCons is \ncreated, it can be used to create a MyClass<Integer> object, as the next line shows: \n\nAlthough the preceding examples demonstrate the mechanics of using a constructor \nreference, no one would use a constructor reference as just shown because nothing is \ngained. Furthermore, having what amounts to two names for the same constructor creates a \nconfusing situation ( to say the least ). However, to give you the flavor of a more practical \nusage, the following program uses a static method, called myClassFactory ( ) , that is a \nfactory for objects of any type of MyFunc objects. It can be used to create any type of object \nthat has a constructor compatible with its first parameter. \n\n\n\n\nThe output is shown here:",
    "As you can see, myClassFactory ( ) is used to create objects of type MyClass<Double> \nand MyClass2 . Although both classes differ, for example MyClass is generic and \nMyClass2 is not, both can be created by myClassFactory ( ) because they both have \nconstructors that are compatible with func ( ) in MyFunc . This works because \nmyClassFactory ( ) is passed the constructor for the object that it builds. You might want \nto experiment with this program a bit, trying different classes that you create. Also try \ncreating instances of different types of MyClass objects. As you will see, myClassFactory ( \n) can create any type of object whose class has a constructor that is compatible with func ( ) \nin MyFunc . Although this example is quite simple, it hints at the power that constructor \nreferences bring to Java. \nBefore moving on, it is important to mention a second form of the constructor reference \nsyntax that is used for arrays",
    ". \nBefore moving on, it is important to mention a second form of the constructor reference \nsyntax that is used for arrays. To create a constructor reference for an array, use this \nconstruct:",
    "type []::new \n\nHere, type specifies the type of object being created. For example, assuming the \nform of MyClass as shown in the first constructor reference example \n( ConstructorRefDemo ) and given the MyArrayCreator interface shown here: \n\nthe following creates a two-element array of MyClass objects and gives each element an \ninitial value: \n\nHere, the call to func ( 2 ) causes a two-element array to be created. In general, a functional \ninterface must contain a method that takes a single int parameter if it is to be used to refer \nto an array constructor. \n\nPredefined Functional Interfaces",
    "Predefined Functional Interfaces \n\n\nUp to this point, the examples in this chapter have defined their own functional interfaces \nso that the fundamental concepts behind lambda expressions and functional interfaces could \nbe clearly illustrated. However, in many cases, you won\u2019t need to define your own functional \ninterface because JDK 8 adds a new package called java.util.function that provides \nseveral predefined ones. Although we will look at them more closely in Part II, here is a \nsampling: \n\nInterface \nPurpose \n\nUnaryOperator<T> \nApply a unary operation to an object of type T and return the \nresult, which is also of type T . Its method is called apply ( ). \n\nBinaryOperator<T> \nApply an operation to two objects of type T and return the \nresult, which is also of type T . Its method is called apply ( ) . \n\nConsumer<T> \nApply an operation on an object of type T . Its method is called \naccept ( ) . \n\nSupplier<T> \nReturn an object of type T . Its method is called get ( ) .",
    "Consumer<T> \nApply an operation on an object of type T . Its method is called \naccept ( ) . \n\nSupplier<T> \nReturn an object of type T . Its method is called get ( ) . \n\nFunction<T, R> \nApply an operation to an object of type T and return the result \nas an object of type R . Its method is called apply ( ) . \n\nPredicate<T> \nDetermine if an object of type T fulfills some constraint. Return \na boolean value that indicates the outcome. Its method is \ncalled test ( ) . \n\nThe following program shows the Function interface in action by using it to rework the \nearlier example called BlockLambdaDemo that demonstrated block lambdas by \nimplementing a factorial example. That example created its own functional interface called \nNumericFunc , but the built-in Function interface could have been used, as this version \nof the program illustrates: \n\n\nIt produces the same output as previous versions of the program. \n\n\uf709 \nPREV \nChapter 14: Generics \n\u23ee \n\nNEXT \nPart II: The Java Library \n\u23ed",
    "It produces the same output as previous versions of the program. \n\n\uf709 \nPREV \nChapter 14: Generics \n\u23ee \n\nNEXT \nPart II: The Java Library \n\u23ed \n\n\nPREV \nChapter 15: Lambda Expressions \n\u23ee \n\nNEXT \nChapter 16: String Handling \u23ed \n\nPART \n\nII \nThe Java Library \n\nCHAPTER 16 \n\nString Handling \n\nCHAPTER 17 \n\nExploring \njava.lang \n\nCHAPTER 18 \n\njava.util Part 1: \nThe Collections \nFramework \n\nCHAPTER 19 \n\njava.util Part 2: \nMore Utility \nClasses \n\nCHAPTER 20 \n\nInput/Output: \nExploring java.io \n\nCHAPTER 21 \n\nExploring NIO \n\nCHAPTER 22 \n\nNetworking \n\nCHAPTER 23 \n\nThe Applet Class \n\nCHAPTER 24 \n\nEvent Handling \n\n\nCHAPTER 25 \n\nIntroducing the \nAWT: Working \n\nwith Windows, \nGraphics, and \nText \n\nCHAPTER 26 \n\nUsing AWT \nControls, Layout \nManagers, and \nMenus \n\nCHAPTER 27 \n\nImages \n\nCHAPTER 28 \n\nThe Concurrency \nUtilities \n\nCHAPTER 29 \n\nThe Stream API \n\nCHAPTER 30 \n\nRegular \nExpressions and \nOther Packages \n\n\uf709 \nPREV \nChapter 15: Lambda Expressions \n\u23ee",
    "CHAPTER 27 \n\nImages \n\nCHAPTER 28 \n\nThe Concurrency \nUtilities \n\nCHAPTER 29 \n\nThe Stream API \n\nCHAPTER 30 \n\nRegular \nExpressions and \nOther Packages \n\n\uf709 \nPREV \nChapter 15: Lambda Expressions \n\u23ee \n\nNEXT \nChapter 16: String Handling \u23ed \n\n\nPREV \nPart II: The Java Library \n\u23ee \n\nNEXT \nChapter 17: Exploring java.lang \u23ed \n\nCHAPTER \n\n16 \nString Handling",
    "A brief overview of Java\u2019s string handling was presented in Chapter 7. In this chapter, it is \ndescribed in detail. As is the case in most other programming languages, in Java a string is \na sequence of characters. But, unlike some other languages that implement strings as \ncharacter arrays, Java implements strings as objects of type String . \nImplementing strings as built-in objects allows Java to provide a full complement of \nfeatures that make string handling convenient. For example, Java has methods to compare \ntwo strings, search for a substring, concatenate two strings, and change the case of letters \nwithin a string. Also, String objects can be constructed a number of ways, making it easy to \nobtain a string when needed. \nSomewhat unexpectedly, when you create a String object, you are creating a string that \ncannot be changed. That is, once a String object has been created, you cannot change the \ncharacters that comprise that string",
    ". That is, once a String object has been created, you cannot change the \ncharacters that comprise that string. At first, this may seem to be a serious restriction. \nHowever, such is not the case. You can still perform all types of string operations. The \ndifference is that each time you need an altered version of an existing string, a new String \nobject is created that contains the modifications. The original string is left unchanged. This \napproach is used because fixed, immutable strings can be implemented more efficiently than \nchangeable ones. For those cases in which a modifiable string is desired, Java provides two \noptions: StringBuffer and StringBuilder . Both hold strings that can be modified after \nthey are created. \nThe String , StringBuffer , and StringBuilder classes are defined in java.lang . Thus, \nthey are available to all programs automatically. All are declared final , which means that \nnone of these classes may be subclassed",
    ". Thus, \nthey are available to all programs automatically. All are declared final , which means that \nnone of these classes may be subclassed. This allows certain optimizations that increase \nperformance to take place on common string operations. All three implement the",
    "CharSequence interface. \nOne last point: To say that the strings within objects of type String are unchangeable \nmeans that the contents of the String instance cannot be changed after it has been created. \nHowever, a variable declared as a String reference can be changed to point at some other \nString object at any time. \n\nThe String Constructors \n\n\nThe String class supports several constructors. To create an empty String , call the default \nconstructor. For example, \n\nwill create an instance of String with no characters in it. \nFrequently, you will want to create strings that have initial values. The String class provides \na variety of constructors to handle this. To create a String initialized by an array of \ncharacters, use the constructor shown here: \n\nString ( char chars [ ]) \n\nHere is an example: \n\nThis constructor initializes s with the string \"abc\". \nYou can specify a subrange of a character array as an initializer using the following \nconstructor:",
    "Here is an example: \n\nThis constructor initializes s with the string \"abc\". \nYou can specify a subrange of a character array as an initializer using the following \nconstructor: \n\nString ( char chars [ ], int startIndex , int numChars ) \n\nHere, startIndex specifies the index at which the subrange begins, and numChars \nspecifies the number of characters to use. Here is an example: \n\nThis initializes s with the characters cde . \n\nYou can construct a String object that contains the same character sequence as another \nString object using this constructor: \n\nString ( String strObj ) \n\nHere, strObj is a String object. Consider this example: \n\n\nThe output from this program is as follows:",
    "String ( String strObj ) \n\nHere, strObj is a String object. Consider this example: \n\n\nThe output from this program is as follows: \n\nAs you can see, s1 and s2 contain the same string. \nEven though Java\u2019s char type uses 16 bits to represent the basic Unicode character set, the \ntypical format for strings on the Internet uses arrays of 8-bit bytes constructed from the \nASCII character set. Because 8-bit ASCII strings are common, the String class provides \nconstructors that initialize a string when given a byte array. Two forms are shown here: \n\nString ( byte chrs [ ]) \nString ( byte chrs [ ], int startIndex , int numChars ) \n\nHere, chrs specifies the array of bytes. The second form allows you to specify a \nsubrange. In each of these constructors, the byte-to-character conversion is done \nby using the default character encoding of the platform. The following program \nillustrates these constructors: \n\nThis program generates the following output:",
    "This program generates the following output: \n\n\nExtended versions of the byte-to-string constructors are also defined in which you can \nspecify the character encoding that determines how bytes are converted to characters. \nHowever, you will often want to use the default encoding provided by the platform. \n\nNOTE    The contents of the array are copied whenever you create a \nString object from an array. If you modify the contents of the array after \nyou have created the string, the String will be unchanged. \n\nYou can construct a String from a StringBuffer by using the constructor shown here: \n\nString ( StringBuffer strBufObj ) \n\nYou can construct a String from a StringBuilder by using this constructor: \n\nString ( StringBuilder strBuildObj ) \n\nThe following constructor supports the extended Unicode character set: \n\nString ( int codePoints [ ], int startIndex , int numChars )",
    "String ( StringBuilder strBuildObj ) \n\nThe following constructor supports the extended Unicode character set: \n\nString ( int codePoints [ ], int startIndex , int numChars ) \n\nHere, codePoints is an array that contains Unicode code points. The resulting \nstring is constructed from the range that begins at startIndex and runs for \nnumChars . \nThere are also constructors that let you specify a Charset . \n\nNOTE    A discussion of Unicode code points and how they are handled by \nJava is found in Chapter 17. \n\nString Length \n\nThe length of a string is the number of characters that it contains. To obtain this value, call \nthe length ( ) method, shown here: \n\nint length ( ) \n\nThe following fragment prints \"3\", since there are three characters in the string s : \n\n\nSpecial String Operations",
    "int length ( ) \n\nThe following fragment prints \"3\", since there are three characters in the string s : \n\n\nSpecial String Operations \n\nBecause strings are a common and important part of programming, Java has added special \nsupport for several string operations within the syntax of the language. These operations \ninclude the automatic creation of new String instances from string literals, concatenation of \nmultiple String objects by use of the + operator, and the conversion of other data types to a \nstring representation. There are explicit methods available to perform all of these functions, \nbut Java does them automatically as a convenience for the programmer and to add clarity. \n\nString Literals",
    "String Literals \n\nThe earlier examples showed how to explicitly create a String instance from an array of \ncharacters by using the new operator. However, there is an easier way to do this using a \nstring literal. For each string literal in your program, Java automatically constructs a \nString object. Thus, you can use a string literal to initialize a String object. For example, \nthe following code fragment creates two equivalent strings: \n\nBecause a String object is created for every string literal, you can use a string literal any \n\nplace you can use a String object. For example, you can call methods directly on a quoted \nstring as if it were an object reference, as the following statement shows. It calls the length ( \n) method on the string \"abc\". As expected, it prints \"3\". \n\nString Concatenation",
    "String Concatenation \n\nIn general, Java does not allow operators to be applied to String objects. The one exception \nto this rule is the + operator, which concatenates two strings, producing a String object as \nthe result. This allows you to chain together a series of + operations. For example, the \nfollowing fragment concatenates three strings: \n\n\nThis displays the string \"He is 9 years old.\" \nOne practical use of string concatenation is found when you are creating very long strings. \nInstead of letting long strings wrap around within your source code, you can break them \ninto smaller pieces, using the + to concatenate them. Here is an example: \n\nString Concatenation with Other Data Types \n\nYou can concatenate strings with other types of data. For example, consider this slightly \ndifferent version of the earlier example:",
    "String Concatenation with Other Data Types \n\nYou can concatenate strings with other types of data. For example, consider this slightly \ndifferent version of the earlier example: \n\nIn this case, age is an int rather than another String , but the output produced is the same \nas before. This is because the int value in age is automatically converted into its string \nrepresentation within a String object. This string is then concatenated as before. The \ncompiler will convert an operand to its string equivalent whenever the other operand of the \n+ is an instance of String . \nBe careful when you mix other types of operations with string concatenation expressions, \nhowever. You might get surprising results. Consider the following: \n\nThis fragment displays \n\nrather than the",
    "This fragment displays \n\nrather than the \n\n\nthat you probably expected. Here\u2019s why. Operator precedence causes the concatenation of \n\"four\" with the string equivalent of 2 to take place first. This result is then concatenated with \nthe string equivalent of 2 a second time. To complete the integer addition first, you must use \nparentheses, like this: \n\nNow s contains the string \"four: 4\". \n\nString Conversion and toString ( )",
    "When Java converts data into its string representation during concatenation, it does so by \ncalling one of the overloaded versions of the string conversion method valueOf ( ) defined \nby String . valueOf ( ) is overloaded for all the primitive types and for type Object . For the \nprimitive types, valueOf ( ) returns a string that contains the human-readable equivalent of \nthe value with which it is called. For objects, valueOf ( ) calls the toString ( ) method on \nthe object. We will look more closely at valueOf ( ) later in this chapter. Here, let\u2019s examine \nthe toString ( ) method, because it is the means by which you can determine the string \nrepresentation for objects of classes that you create. \nEvery class implements toString ( ) because it is defined by Object . However, the default \nimplementation of toString ( ) is seldom sufficient. For most important classes that you \ncreate, you will want to override toString ( ) and provide your own string representations",
    ". For most important classes that you \ncreate, you will want to override toString ( ) and provide your own string representations. \nFortunately, this is easy to do. The toString ( ) method has this general form:",
    "String toString ( ) \n\nTo implement toString ( ) , simply return a String object that contains the \nhuman-readable string that appropriately describes an object of your class. \nBy overriding toString ( ) for classes that you create, you allow them to be fully integrated \ninto Java\u2019s programming environment. For example, they can be used in print ( ) and \nprintln ( ) statements and in concatenation expressions. The following program \ndemonstrates this by overriding toString ( ) for the Box class: \n\n\nThe output of this program is shown here: \n\nAs you can see, Box \u2019s toString ( ) method is automatically invoked when a Box object is \nused in a concatenation expression or in a call to println ( ) . \n\nCharacter Extraction \n\nThe String class provides a number of ways in which characters can be extracted from a \nString object. Several are examined here. Although the characters that comprise a string",
    "The String class provides a number of ways in which characters can be extracted from a \nString object. Several are examined here. Although the characters that comprise a string \n\nwithin a String object cannot be indexed as if they were a character array, many of the \nString methods employ an index ( or offset ) into the string for their operation. Like arrays, \nthe string indexes begin at zero. \n\ncharAt ( ) \n\nTo extract a single character from a String , you can refer directly to an individual character \n\n\nvia the charAt ( ) method. It has this general form: \n\nchar charAt ( int where ) \n\nHere, where is the index of the character that you want to obtain. The value of \nwhere must be nonnegative and specify a location within the string. charAt ( ) \nreturns the character at the specified location. For example, \n\nassigns the value b to ch . \n\ngetChars ( ) \n\nIf you need to extract more than one character at a time, you can use the getChars ( ) \nmethod. It has this general form:",
    "assigns the value b to ch . \n\ngetChars ( ) \n\nIf you need to extract more than one character at a time, you can use the getChars ( ) \nmethod. It has this general form: \n\nvoid getChars ( int sourceStart , int sourceEnd , char target [ ], int targetStart ) \n\nHere, sourceStart specifies the index of the beginning of the substring, and \nsourceEnd specifies an index that is one past the end of the desired substring. \nThus, the substring contains the characters from sourceStart through sourceEnd \u2013 \n1. The array that will receive the characters is specified by target . The index within \ntarget at which the substring will be copied is passed in targetStart . Care must be \ntaken to assure that the target array is large enough to hold the number of \ncharacters in the specified substring. \nThe following program demonstrates getChars ( ) : \n\nHere is the output of this program: \n\ngetBytes ( )",
    "Here is the output of this program: \n\ngetBytes ( ) \n\n\nThere is an alternative to getChars ( ) that stores the characters in an array of bytes. This \nmethod is called getBytes ( ) , and it uses the default character-to-byte conversions \nprovided by the platform. Here is its simplest form: \n\nbyte[ ] getBytes ( ) \n\nOther forms of getBytes ( ) are also available. getBytes ( ) is most useful when \nyou are exporting a String value into an environment that does not support 16-bit \nUnicode characters. For example, most Internet protocols and text file formats use \n8-bit ASCII for all text interchange. \n\ntoCharArray ( ) \n\nIf you want to convert all the characters in a String object into a character array, the \neasiest way is to call toCharArray ( ) . It returns an array of characters for the entire string. \nIt has this general form: \n\nchar[ ] toCharArray ( ) \n\nThis function is provided as a convenience, since it is possible to use getChars ( ) \nto achieve the same result.",
    "char[ ] toCharArray ( ) \n\nThis function is provided as a convenience, since it is possible to use getChars ( ) \nto achieve the same result. \n\nString Comparison \n\nThe String class includes a number of methods that compare strings or substrings within \nstrings. Several are examined here. \n\nequals ( ) and equalsIgnoreCase ( ) \n\nTo compare two strings for equality, use equals ( ) . It has this general form: \n\nboolean equals ( Object str ) \n\nHere, str is the String object being compared with the invoking String object. It \nreturns true if the strings contain the same characters in the same order, and \nfalse otherwise. The comparison is case-sensitive. \nTo perform a comparison that ignores case differences, call equalsIgnoreCase ( ) . When it \ncompares two strings, it considers A-Z to be the same as a-z . It has this general form: \n\nboolean equalsIgnoreCase ( String str )",
    "boolean equalsIgnoreCase ( String str ) \n\nHere, str is the String object being compared with the invoking String object. It, \ntoo, returns true if the strings contain the same characters in the same order, and \nfalse otherwise. \nHere is an example that demonstrates equals ( ) and equalsIgnoreCase ( ) : \n\n\nThe output from the program is shown here: \n\nregionMatches ( ) \n\nThe regionMatches ( ) method compares a specific region inside a string with another \nspecific region in another string. There is an overloaded form that allows you to ignore case \nin such comparisons. Here are the general forms for these two methods:",
    "For both versions, startIndex specifies the index at which the region begins within the \ninvoking String object. The String being compared is specified by str2 . The index at which \nthe comparison will start within str2 is specified by str2StartIndex . The length of the \nsubstring being compared is passed in numChars . In the second version, if ignoreCase is \ntrue , the case of the characters is ignored. Otherwise, case is significant. \n\nstartsWith ( ) and endsWith ( ) \n\n\nString defines two methods that are, more or less, specialized forms of regionMatches ( ) . \nThe startsWith ( ) method determines whether a given String begins with a specified \nstring. Conversely, endsWith ( ) determines whether the String in question ends with a \nspecified string. They have the following general forms: \n\nboolean startsWith ( String str ) \nboolean endsWith ( String str )",
    "boolean startsWith ( String str ) \nboolean endsWith ( String str ) \n\nHere, str is the String being tested. If the string matches, true is returned. \nOtherwise, false is returned. For example, \n\nand \n\nare both true . \nA second form of startsWith ( ) , shown here, lets you specify a starting point: \n\nboolean startsWith ( String str , int startIndex ) \n\nHere, startIndex specifies the index into the invoking string at which point the \nsearch will begin. For example, \n\nreturns true . \n\nequals ( ) Versus == \n\nIt is important to understand that the equals ( ) method and the == operator perform two \ndifferent operations. As just explained, the equals ( ) method compares the characters \ninside a String object. The == operator compares two object references to see whether they \nrefer to the same instance. The following program shows how two different String objects \ncan contain the same characters, but references to these objects will not compare as equal:",
    "The variable s1 refers to the String instance created by \"Hello\" . The object referred to by \ns2 is created with s1 as an initializer. Thus, the contents of the two String objects are \nidentical, but they are distinct objects. This means that s1 and s2 do not refer to the same \nobjects and are, therefore, not ==, as is shown here by the output of the preceding example: \n\ncompareTo ( ) \n\nOften, it is not enough to simply know whether two strings are identical. For sorting \napplications, you need to know which is less than , equal to , or greater than the next. A \nstring is less than another if it comes before the other in dictionary order. A string is greater \nthan another if it comes after the other in dictionary order. The method compareTo ( ) \nserves this purpose. It is specified by the Comparable<T> interface, which String \nimplements. It has this general form: \n\nint compareTo ( String str )",
    "int compareTo ( String str ) \n\nHere, str is the String being compared with the invoking String . The result of the \ncomparison is returned and is interpreted as shown here: \n\nValue \nMeaning \n\nLess than zero \nThe invoking string is less than str . \n\nGreater than zero \nThe invoking string is greater than str . \n\nZero \nThe two strings are equal. \n\nHere is a sample program that sorts an array of strings. The program uses compareTo ( ) \nto determine sort ordering for a bubble sort: \n\n\nThe output of this program is the list of words: \n\nAs you can see from the output of this example, compareTo ( ) takes into account \nuppercase and lowercase letters. The word \"Now\" came out before all the others because it \n\nbegins with an uppercase letter, which means it has a lower value in the ASCII character set. \nIf you want to ignore case differences when comparing two strings, use \ncompareToIgnoreCase ( ) , as shown here: \n\nint compareToIgnoreCase ( String str )",
    "int compareToIgnoreCase ( String str ) \n\n\nThis method returns the same results as compareTo ( ) , except that case \ndifferences are ignored. You might want to try substituting it into the previous \nprogram. After doing so, \"Now\" will no longer be first. \n\nSearching Strings \n\nThe String class provides two methods that allow you to search a string for a specified \ncharacter or substring: \n\n\u2022   indexOf ( )     Searches for the first occurrence of a character or substring. \n\n\u2022   lastIndexOf ( )     Searches for the last occurrence of a character or \nsubstring. \n\nThese two methods are overloaded in several different ways. In all cases, the \nmethods return the index at which the character or substring was found, or \u20131 on \nfailure. \nTo search for the first occurrence of a character, use \n\nint indexOf ( int ch ) \n\nTo search for the last occurrence of a character, use \n\nint lastIndexOf ( int ch )",
    "int indexOf ( int ch ) \n\nTo search for the last occurrence of a character, use \n\nint lastIndexOf ( int ch ) \n\nHere, ch is the character being sought. \nTo search for the first or last occurrence of a substring, use \n\nint indexOf ( String str ) \nint lastIndexOf ( String str ) \n\nHere, str specifies the substring. \nYou can specify a starting point for the search using these forms: \n\nint indexOf ( int ch , int startIndex ) \n\nint lastIndexOf ( int ch , int startIndex ) \n\nint indexOf ( String str , int startIndex ) \nint lastIndexOf ( String str , int startIndex ) \n\nHere, startIndex specifies the index at which point the search begins. For \n\nindexOf ( ) , the search runs from startIndex to the end of the string. For \nlastIndexOf ( ) , the search runs from startIndex to zero. \nThe following example shows how to use the various index methods to search inside of a \n\nString : \n\n\nHere is the output of this program: \n\nModifying a String",
    "String : \n\n\nHere is the output of this program: \n\nModifying a String \n\nBecause String objects are immutable, whenever you want to modify a String , you must \neither copy it into a StringBuffer or StringBuilder , or use a String method that \n\nconstructs a new copy of the string with your modifications complete. A sampling of these \nmethods are described here. \n\nsubstring ( ) \n\nYou can extract a substring using substring ( ) . It has two forms. The first is \n\n\nString substring ( int startIndex ) \n\nHere, startIndex specifies the index at which the substring will begin. This form \nreturns a copy of the substring that begins at startIndex and runs to the end of the \ninvoking string. \nThe second form of substring ( ) allows you to specify both the beginning and ending index \nof the substring: \n\nString substring ( int startIndex , int endIndex )",
    "String substring ( int startIndex , int endIndex ) \n\nHere, startIndex specifies the beginning index, and endIndex specifies the stopping \npoint. The string returned contains all the characters from the beginning index, up \nto, but not including, the ending index. \nThe following program uses substring ( ) to replace all instances of one substring with \nanother within a string: \n\nThe output from this program is shown here: \n\n\nconcat ( ) \n\nYou can concatenate two strings using concat ( ) , shown here: \n\nString concat ( String str ) \n\nThis method creates a new object that contains the invoking string with the \ncontents of str appended to the end. concat ( ) performs the same function as + . \nFor example, \n\nputs the string \"onetwo\" into s2 . It generates the same result as the following sequence: \n\nreplace ( )",
    "puts the string \"onetwo\" into s2 . It generates the same result as the following sequence: \n\nreplace ( ) \n\nThe replace ( ) method has two forms. The first replaces all occurrences of one character in \nthe invoking string with another character. It has the following general form: \n\nString replace ( char original , char replacement ) \n\nHere, original specifies the character to be replaced by the character specified by \nreplacement . The resulting string is returned. For example, \n\nputs the string \"Hewwo\" into s . \nThe second form of replace ( ) replaces one character sequence with another. It has this \ngeneral form: \n\nString replace ( CharSequence original , CharSequence replacement ) \n\ntrim ( ) \n\nThe trim ( ) method returns a copy of the invoking string from which any leading and \ntrailing whitespace has been removed. It has this general form: \n\nString trim ( ) \n\nHere is an example:",
    "The trim ( ) method returns a copy of the invoking string from which any leading and \ntrailing whitespace has been removed. It has this general form: \n\nString trim ( ) \n\nHere is an example: \n\nThis puts the string \"Hello World\" into s . \nThe trim ( ) method is quite useful when you process user commands. For example, the \nfollowing program prompts the user for the name of a state and then displays that state\u2019s \n\n\ncapital. It uses trim ( ) to remove any leading or trailing whitespace that may have \ninadvertently been entered by the user. \n\nData Conversion Using valueOf ( ) \n\nThe valueOf ( ) method converts data from its internal format into a human-readable form. \n\nIt is a static method that is overloaded within String for all of Java\u2019s built-in types so that \neach type can be converted properly into a string. valueOf ( ) is also overloaded for type",
    "It is a static method that is overloaded within String for all of Java\u2019s built-in types so that \neach type can be converted properly into a string. valueOf ( ) is also overloaded for type \n\nObject , so an object of any class type you create can also be used as an argument. ( Recall \nthat Object is a superclass for all classes.) Here are a few of its forms: \n\nstatic String valueOf ( double num ) \nstatic String valueOf ( long num ) \nstatic String valueOf ( Object ob ) \nstatic String valueOf ( char chars [ ])",
    "As discussed earlier, valueOf ( ) is called when a string representation of some \nother type of data is needed\u2014for example, during concatenation operations. You \ncan call this method directly with any data type and get a reasonable String \nrepresentation. All of the simple types are converted to their common String \nrepresentation. Any object that you pass to valueOf ( ) will return the result of a \ncall to the object\u2019s toString ( ) method. In fact, you could just call toString ( ) \ndirectly and get the same result. \nFor most arrays, valueOf ( ) returns a rather cryptic string, which indicates that it is an \narray of some type. For arrays of char , however, a String object is created that contains \nthe characters in the char array. There is a special version of valueOf ( ) that allows you to \nspecify a subset of a char array. It has this general form: \n\nstatic String valueOf ( char chars [ ], int startIndex , int numChars )",
    "static String valueOf ( char chars [ ], int startIndex , int numChars ) \n\nHere, chars is the array that holds the characters, startIndex is the index into the \narray of characters at which the desired substring begins, and numChars specifies \nthe length of the substring. \n\nChanging the Case of Characters Within a String \n\nThe method toLowerCase ( ) converts all the characters in a string from uppercase to \nlowercase. The toUpperCase ( ) method converts all the characters in a string from \nlowercase to uppercase. Nonalphabetical characters, such as digits, are unaffected. Here are \nthe simplest forms of these methods: \n\nString toLowerCase ( ) \nString toUpperCase ( ) \n\nBoth methods return a String object that contains the uppercase or lowercase \n\nequivalent of the invoking String . The default locale governs the conversion in \nboth cases. \nHere is an example that uses toLowerCase ( ) and toUpperCase ( ) : \n\n\nThe output produced by the program is shown here:",
    "The output produced by the program is shown here: \n\nOne other point: Overloaded versions of toLowerCase ( ) and toUpperCase ( ) that let \nyou specify a Locale object to govern the conversion are also supplied. Specifying the locale \ncan be quite important in some cases and can help internationalize your application. \n\nJoining Strings \n\nJDK 8 adds a new method to String called join ( ) . It is used to concatenate two or more \nstrings, separating each string with a delimiter, such as a space or a comma. It has two \nforms. Its first is shown here: \n\nstatic String join ( CharSequence delim , CharSequence \u2026 strs ) \n\nHere, delim specifies the delimiter used to separate the character sequences \nspecified by strs . Because String implements the CharSequence interface, strs \ncan be a list of strings. ( See Chapter 17 for information on CharSequence .) The \n\nfollowing program demonstrates this version of join ( ) : \n\n\nThe output is shown here:",
    "following program demonstrates this version of join ( ) : \n\n\nThe output is shown here: \n\nIn the first call to join ( ) , a space is inserted between each string. In the second call, the \ndelimiter is a comma followed by a space. This illustrates that the delimiter need not be just \na single character. \nThe second form of join ( ) lets you join a list of strings obtained from an object that \nimplements the Iterable interface. Iterable is implemented by the Collections Framework \nclasses described in Chapter 18, among others. See Chapter 17 for information on Iterable . \n\nAdditional String Methods \n\nIn addition to those methods discussed earlier, String has many other methods, including \nthose summarized in the following table: \n\nMethod \nDescription \n\nint codePointAt ( int i ) \nReturns the Unicode code point at the location specified by i . \n\nint codePointBefore ( int \ni ) \nReturns the Unicode code point at the location that precedes \nthat specified by i .",
    "int codePointBefore ( int \ni ) \nReturns the Unicode code point at the location that precedes \nthat specified by i . \n\nint codePointCount ( int \nstart , int end ) \nReturns the number of code points in the portion of the \ninvoking String that are between start and end \u20131. \n\nboolean \ncontains ( CharSequence \nstr ) \n\nReturns true if the invoking object contains the string \nspecified by str . Returns false otherwise. \n\nboolean contentEquals \n\n( CharSequence str ) \n\nReturns true if the invoking string contains the same string \n\nas str . Otherwise, returns false . \n\nboolean contentEquals \n( StringBuffer str ) \nReturns true if the invoking string contains the same string \nas str . Otherwise, returns false . \n\n\nstatic String \nformat ( String fmtstr , \nObject \u2026 args ) \n\nReturns a string formatted as specified by fmtstr . ( See \nChapter 19 for details on formatting.) \n\nstatic String \nformat ( Locale loc , \nString fmtstr , Object \u2026 \nargs )",
    "Returns a string formatted as specified by fmtstr . ( See \nChapter 19 for details on formatting.) \n\nstatic String \nformat ( Locale loc , \nString fmtstr , Object \u2026 \nargs ) \n\nReturns a string formatted as specified by fmtstr . Formatting \nis governed by the locale specified by loc . ( See Chapter 19 for \ndetails on formatting.) \n\nboolean isEmpty ( ) \nReturns true if the invoking string contains no characters \nand has a length of zero. \n\nboolean matches ( string \nregExp ) \nReturns true if the invoking string matches the regular \nexpression passed in regExp . Otherwise, returns false . \n\nint offsetBy \nCodePoints ( int start , \nint num ) \n\nReturns the index within the invoking string that is num code \npoints beyond the starting index specified by start . \n\nString \nreplaceFirst ( String \nregExp , String newStr ) \n\nReturns a string in which the first substring that matches the \nregular expression specified by regExp is replaced by newStr .",
    "String \nreplaceFirst ( String \nregExp , String newStr ) \n\nReturns a string in which the first substring that matches the \nregular expression specified by regExp is replaced by newStr . \n\nString \nreplaceAll ( String \nregExp , String newStr ) \n\nReturns a string in which all substrings that match the \nregular expression specified by regExp are replaced by \nnewStr . \n\nString[ ] split ( String \nregExp ) \n\nDecomposes the invoking string into parts and returns an \narray that contains the result. Each part is delimited by the \nregular expression passed in regExp . \n\nString[ ] split ( String \nregExp , int max )",
    "String[ ] split ( String \nregExp , int max ) \n\nDecomposes the invoking string into parts and returns an \narray that contains the result. Each part is delimited by the \nregular expression passed in regExp . The number of pieces is \nspecified by max . If max is negative, then the invoking string \nis fully decomposed. Otherwise, if max contains a nonzero \nvalue, the last entry in the returned array contains the \nremainder of the invoking string. If max is zero, the invoking \nstring is fully decomposed, but no trailing empty strings will \nbe included. \n\nCharSequence \nsubSequence ( int \nstartIndex , int \n\nstopIndex ) \n\nReturns a substring of the invoking string, beginning at \nstartIndex and stopping at stopIndex . This method is \nrequired by the CharSequence interface, which is \n\nimplemented by String . \n\nNotice that several of these methods work with regular expressions. Regular expressions are \n\n\ndescribed in Chapter 30. \n\nStringBuffer",
    "implemented by String . \n\nNotice that several of these methods work with regular expressions. Regular expressions are \n\n\ndescribed in Chapter 30. \n\nStringBuffer \n\nStringBuffer supports a modifiable string. As you know, String represents fixed-length, \nimmutable character sequences. In contrast, StringBuffer represents growable and \nwritable character sequences. StringBuffer may have characters and substrings inserted in \nthe middle or appended to the end. StringBuffer will automatically grow to make room for \nsuch additions and often has more characters preallocated than are actually needed, to \nallow room for growth. \n\nStringBuffer Constructors \n\nStringBuffer defines these four constructors: \n\nStringBuffer ( ) \nStringBuffer ( int size ) \nStringBuffer ( String str ) \nStringBuffer ( CharSequence chars )",
    "StringBuffer ( ) \nStringBuffer ( int size ) \nStringBuffer ( String str ) \nStringBuffer ( CharSequence chars ) \n\nThe default constructor ( the one with no parameters ) reserves room for 16 \ncharacters without reallocation. The second version accepts an integer argument \nthat explicitly sets the size of the buffer. The third version accepts a String \nargument that sets the initial contents of the StringBuffer object and reserves \nroom for 16 more characters without reallocation. StringBuffer allocates room \nfor 16 additional characters when no specific buffer length is requested, because \nreallocation is a costly process in terms of time. Also, frequent reallocations can \nfragment memory. By allocating room for a few extra characters, StringBuffer \nreduces the number of reallocations that take place. The fourth constructor creates \nan object that contains the character sequence contained in chars and reserves \nroom for 16 more characters. \n\nlength ( ) and capacity ( )",
    "length ( ) and capacity ( ) \n\nThe current length of a StringBuffer can be found via the length ( ) method, while the \ntotal allocated capacity can be found through the capacity ( ) method. They have the \nfollowing general forms: \n\nint length ( ) \nint capacity ( ) \n\nHere is an example: \n\n\nHere is the output of this program, which shows how StringBuffer reserves extra space for \nadditional manipulations: \n\nSince sb is initialized with the string \"Hello\" when it is created, its length is 5. Its capacity is \n21 because room for 16 additional characters is automatically added. \n\nensureCapacity ( ) \n\nIf you want to preallocate room for a certain number of characters after a StringBuffer has \nbeen constructed, you can use ensureCapacity ( ) to set the size of the buffer. This is \nuseful if you know in advance that you will be appending a large number of small strings to \na StringBuffer . ensureCapacity ( ) has this general form: \n\nvoid ensureCapacity ( int minCapacity )",
    "void ensureCapacity ( int minCapacity ) \n\nHere, minCapacity specifies the minimum size of the buffer. ( A buffer larger than \nminCapacity may be allocated for reasons of efficiency.) \n\nsetLength ( ) \n\nTo set the length of the string within a StringBuffer object, use setLength ( ) . Its general \nform is shown here: \n\nvoid setLength ( int len ) \n\nHere, len specifies the length of the string. This value must be nonnegative. \nWhen you increase the size of the string, null characters are added to the end. If you call \nsetLength ( ) with a value less than the current value returned by length ( ) , then the \ncharacters stored beyond the new length will be lost. The setCharAtDemo sample \nprogram in the following section uses setLength ( ) to shorten a StringBuffer . \n\ncharAt ( ) and setCharAt ( )",
    "charAt ( ) and setCharAt ( ) \n\n\nThe value of a single character can be obtained from a StringBuffer via the charAt ( ) \nmethod. You can set the value of a character within a StringBuffer using setCharAt ( ) . \nTheir general forms are shown here: \n\nchar charAt ( int where ) \nvoid setCharAt ( int where , char ch ) \n\nFor charAt ( ) , where specifies the index of the character being obtained. For \nsetCharAt ( ) , where specifies the index of the character being set, and ch \nspecifies the new value of that character. For both methods, where must be \nnonnegative and must not specify a location beyond the end of the string. \nThe following example demonstrates charAt ( ) and setCharAt ( ) : \n\nHere is the output generated by this program: \n\ngetChars ( ) \n\nTo copy a substring of a StringBuffer into an array, use the getChars ( ) method. It has \n\nthis general form: \n\nvoid getChars ( int sourceStart , int sourceEnd , char target [ ], int targetStart )",
    "To copy a substring of a StringBuffer into an array, use the getChars ( ) method. It has \n\nthis general form: \n\nvoid getChars ( int sourceStart , int sourceEnd , char target [ ], int targetStart ) \n\nHere, sourceStart specifies the index of the beginning of the substring, and \nsourceEnd specifies an index that is one past the end of the desired substring. This \nmeans that the substring contains the characters from sourceStart through \nsourceEnd \u20131. The array that will receive the characters is specified by target . The \nindex within target at which the substring will be copied is passed in targetStart . \n\n\nCare must be taken to assure that the target array is large enough to hold the \n\nnumber of characters in the specified substring. \n\nappend ( ) \n\nThe append ( ) method concatenates the string representation of any other type of data to \nthe end of the invoking StringBuffer object. It has several overloaded versions. Here are a \nfew of its forms:",
    "StringBuffer append ( String str ) \nStringBuffer append ( int num ) \nStringBuffer append ( Object obj ) \n\nThe string representation of each parameter is obtained, often by calling \nString.valueOf ( ) . The result is appended to the current StringBuffer object. \nThe buffer itself is returned by each version of append ( ) . This allows subsequent \ncalls to be chained together, as shown in the following example: \n\nThe output of this example is shown here: \n\ninsert ( ) \n\nThe insert ( ) method inserts one string into another. It is overloaded to accept values of all \nthe primitive types, plus String s, Object s, and CharSequence s. Like append ( ) , it \nobtains the string representation of the value it is called with. This string is then inserted \n\ninto the invoking StringBuffer object. These are a few of its forms: \n\nStringBuffer insert ( int index , String str ) \nStringBuffer insert ( int index , char ch ) \nStringBuffer insert ( int index , Object obj )",
    "StringBuffer insert ( int index , String str ) \nStringBuffer insert ( int index , char ch ) \nStringBuffer insert ( int index , Object obj ) \n\nHere, index specifies the index at which point the string will be inserted into the \ninvoking StringBuffer object. \n\n\nThe following sample program inserts \"like\" between \"I\" and \"Java\": \n\nThe output of this example is shown here: \n\nreverse ( ) \n\nYou can reverse the characters within a StringBuffer object using reverse ( ) , shown \nhere: \n\nStringBuffer reverse ( ) \n\nThis method returns the reverse of the object on which it was called. The following \nprogram demonstrates reverse ( ) : \n\nHere is the output produced by the program: \n\ndelete ( ) and deleteCharAt ( ) \n\nYou can delete characters within a StringBuffer by using the methods delete ( ) and \ndeleteCharAt ( ) . These methods are shown here: \n\nStringBuffer delete ( int startIndex , int endIndex ) \n\n\nStringBuffer deleteCharAt ( int loc )",
    "StringBuffer delete ( int startIndex , int endIndex ) \n\n\nStringBuffer deleteCharAt ( int loc ) \n\nThe delete ( ) method deletes a sequence of characters from the invoking object. \nHere, startIndex specifies the index of the first character to remove, and endIndex \nspecifies an index one past the last character to remove. Thus, the substring \ndeleted runs from startIndex to endIndex \u20131. The resulting StringBuffer object is \nreturned. \nThe deleteCharAt ( ) method deletes the character at the index specified by loc . It returns \nthe resulting StringBuffer object. \nHere is a program that demonstrates the delete ( ) and deleteCharAt ( ) methods: \n\nThe following output is produced: \n\nreplace ( ) \n\nYou can replace one set of characters with another set inside a StringBuffer object by \n\ncalling replace ( ) . Its signature is shown here: \n\nStringBuffer replace ( int startIndex , int endIndex , String str )",
    "calling replace ( ) . Its signature is shown here: \n\nStringBuffer replace ( int startIndex , int endIndex , String str ) \n\nThe substring being replaced is specified by the indexes startIndex and endIndex . \nThus, the substring at startIndex through endIndex \u20131 is replaced. The replacement \nstring is passed in str . The resulting StringBuffer object is returned. \nThe following program demonstrates replace ( ) : \n\n\nHere is the output: \n\nsubstring ( ) \n\nYou can obtain a portion of a StringBuffer by calling substring ( ) . It has the following \ntwo forms: \n\nString substring ( int startIndex ) \nString substring ( int startIndex , int endIndex ) \n\nThe first form returns the substring that starts at startIndex and runs to the end of \nthe invoking StringBuffer object. The second form returns the substring that \nstarts at startIndex and runs through endIndex \u20131. These methods work just like \nthose defined for String that were described earlier. \n\nAdditional StringBuffer Methods",
    "Additional StringBuffer Methods \n\nIn addition to those methods just described, StringBuffer supplies several others, \nincluding those summarized in the following table: \n\nMethod \nDescription \n\nStringBuffer \nappendCodePoint ( int \nch ) \n\nAppends a Unicode code point to the end of the invoking \n\nobject. A reference to the object is returned. \n\nint codePointAt ( int i ) \nReturns the Unicode code point at the location specified by i . \n\nint \ncodePointBefore ( int i ) \nReturns the Unicode code point at the location that precedes \nthat specified by i . \n\nint codePointCount ( int \nstart , int end ) \nReturns the number of code points in the portion of the \ninvoking String that are between start and end \u20131. \n\nint indexOf ( String str ) \nSearches the invoking StringBuffer for the first occurrence \nof str . Returns the index of the match, or \u20131 if no match is \n\nfound. \n\n\nint indexOf ( String str , \nint startIndex )",
    "found. \n\n\nint indexOf ( String str , \nint startIndex ) \n\nSearches the invoking StringBuffer for the first occurrence \nof str , beginning at startIndex . Returns the index of the \nmatch, or \u20131 if no match is found. \n\nint lastIndexOf ( String \nstr ) \n\nSearches the invoking StringBuffer for the last occurrence \nof str . Returns the index of the match, or \u20131 if no match is \nfound. \n\nint lastIndexOf ( String \nstr , int startIndex ) \n\nSearches the invoking StringBuffer for the last occurrence \nof str , beginning at startIndex . Returns the index of the \nmatch, or \u20131 if no match is found. \n\nint \noffsetByCodePoints ( int \nstart , int num ) \n\nReturns the index within the invoking string that is num code \npoints beyond the starting index specified by start . \n\nCharSequence \nsubSequence ( int \nstartIndex , int \nstopIndex )",
    "Returns the index within the invoking string that is num code \npoints beyond the starting index specified by start . \n\nCharSequence \nsubSequence ( int \nstartIndex , int \nstopIndex ) \n\nReturns a substring of the invoking string, beginning at \nstartIndex and stopping at stopIndex . This method is \nrequired by the CharSequence interface, which is \nimplemented by StringBuffer . \n\nvoid trimToSize ( ) \nRequests that the size of the character buffer for the invoking \nobject be reduced to better fit the current contents. \n\nThe following program demonstrates indexOf ( ) and lastIndexOf ( ) : \n\nThe output is shown here: \n\nStringBuilder \n\nIntroduced by JDK 5, StringBuilder is a relatively recent addition to Java\u2019s string",
    "The output is shown here: \n\nStringBuilder \n\nIntroduced by JDK 5, StringBuilder is a relatively recent addition to Java\u2019s string \n\n\nhandling capabilities. StringBuilder is similar to StringBuffer except for one important \ndifference: it is not synchronized, which means that it is not thread-safe. The advantage of \nStringBuilder is faster performance. However, in cases in which a mutable string will be \naccessed by multiple threads, and no external synchronization is employed, you must use \nStringBuffer rather than StringBuilder . \n\n\uf709 \nPREV \nPart II: The Java Library \n\u23ee \n\nNEXT \nChapter 17: Exploring java.lang \u23ed \n\n\nPREV \nChapter 16: String Handling \n\u23ee \n\nNEXT \nChapter 18: java.util Part 1: The Collections Fra\u2026 \u23ed \n\nCHAPTER \n\n17 \nExploring java.lang",
    "NEXT \nChapter 17: Exploring java.lang \u23ed \n\n\nPREV \nChapter 16: String Handling \n\u23ee \n\nNEXT \nChapter 18: java.util Part 1: The Collections Fra\u2026 \u23ed \n\nCHAPTER \n\n17 \nExploring java.lang \n\nThis chapter discusses those classes and interfaces defined by java.lang . As you know, \njava.lang is automatically imported into all programs. It contains classes and interfaces \nthat are fundamental to virtually all of Java programming. It is Java\u2019s most widely used \npackage. \njava.lang includes the following classes: \n\njava.lang defines the following interfaces: \n\nSeveral of the classes contained in java.lang contain deprecated methods, most dating back \nto Java 1.0. These deprecated methods are still provided by Java to support an evershrinking pool of legacy code and are not recommended for new code. Because of this, the \ndeprecated methods are not discussed here. \n\nPrimitive Type Wrappers",
    "Primitive Type Wrappers \n\nAs mentioned in Part I of this book, Java uses primitive types, such as int and char , for \nperformance reasons. These data types are not part of the object hierarchy. They are passed \n\n\nby value to methods and cannot be directly passed by reference. Also, there is no way for \ntwo methods to refer to the same instance of an int . At times, you will need to create an \nobject representation for one of these primitive types. For example, there are collection \nclasses discussed in Chapter 18 that deal only with objects ; to store a primitive type in one \nof these classes, you need to wrap the primitive type in a class. To address this need, Java \nprovides classes that correspond to each of the primitive types. In essence, these classes \nencapsulate, or wrap , the primitive types within a class. Thus, they are commonly referred \nto as type wrappers . The type wrappers were introduced in Chapter 12. They are examined \nin detail here. \n\nNumber",
    "Number \n\nThe abstract class Number defines a superclass that is implemented by the classes that \nwrap the numeric types byte , short , int , long , float , and double . Number has abstract \nmethods that return the value of the object in each of the different number formats. For \nexample, doubleValue ( ) returns the value as a double , floatValue ( ) returns the value \nas a float , and so on. These methods are shown here: \n\nbyte byteValue ( ) \ndouble doubleValue ( ) \nfloat floatValue ( ) \nint intValue ( ) \nlong longValue ( ) \nshort shortValue ( ) \n\nThe values returned by these methods might be rounded, truncated, or result in a \n\u201cgarbage\u201d value due to the effects of a narrowing conversion. \nNumber has concrete subclasses that hold explicit values of each primitive numeric type: \nDouble , Float , Byte , Short , Integer , and Long . \n\nDouble and Float",
    "Double and Float \n\nDouble and Float are wrappers for floating-point values of type double and float , \nrespectively. The constructors for Float are shown here: \n\nFloat ( double num ) \n\nFloat ( float num ) \nFloat ( String str ) throws NumberFormatException \n\nAs you can see, Float objects can be constructed with values of type float or \n\ndouble . They can also be constructed from the string representation of a floatingpoint number. \nThe constructors for Double are shown here: \n\nDouble ( double num ) \nDouble ( String str ) throws NumberFormatException \n\n\nDouble objects can be constructed with a double value or a string containing a \nfloatingpoint value. \nThe methods defined by Float include those shown in Table 17-1. The methods defined by \nDouble include those shown in Table 17-2. Both Float and Double define the following \nconstants: \n\nBYTES \nThe width of a float or double in bytes ( Added \nby JDK 8.) \n\nMAX_EXPONENT \nMaximum exponent \n\nMAX_VALUE \nMaximum positive value",
    "BYTES \nThe width of a float or double in bytes ( Added \nby JDK 8.) \n\nMAX_EXPONENT \nMaximum exponent \n\nMAX_VALUE \nMaximum positive value \n\nMIN_EXPONENT \nMinimum exponent \n\nMIN_NORMAL \nMinimum positive normal value \n\nMIN_VALUE \nMinimum positive value \n\nNaN \nNot a number \n\nPOSITIVE_INFINITY \nPositive infinity \n\nNEGATIVE_INFINITY \nNegative infinity \n\nSIZE \nThe bit width of the wrapped value \n\nTYPE \nThe Class object for float or double \n\n\nTable 17-1    The Methods Defined by Float \n\n\n\n\nTable 17-2    The Methods Defined by Double \n\nThe following example creates two Double objects\u2014one by using a double value \nand the other by passing a string that can be parsed as a double : \n\nAs you can see from the following output, both constructors created identical Double \ninstances, as shown by the equals ( ) method returning true : \n\nUnderstanding isInfinite ( ) and isNaN ( )",
    "As you can see from the following output, both constructors created identical Double \ninstances, as shown by the equals ( ) method returning true : \n\nUnderstanding isInfinite ( ) and isNaN ( ) \n\nFloat and Double provide the methods isInfinite ( ) and isNaN ( ) , which help when \nmanipulating two special double and float values. These methods test for two unique \nvalues defined by the IEEE floating-point specification: infinity and NaN ( not a number ). \nisInfinite ( ) returns true if the value being tested is infinitely large or small in magnitude. \nisNaN ( ) returns true if the value being tested is not a number. \nThe following example creates two Double objects ; one is infinite, and the other is not a \nnumber: \n\n\nThis program generates the following output: \n\nByte, Short, Integer, and Long \n\nThe Byte , Short , Integer , and Long classes are wrappers for byte , short , int , and long \ninteger types, respectively. Their constructors are shown here:",
    "Byte, Short, Integer, and Long \n\nThe Byte , Short , Integer , and Long classes are wrappers for byte , short , int , and long \ninteger types, respectively. Their constructors are shown here: \n\nByte ( byte num ) \nByte ( String str ) throws NumberFormatException \n\nShort ( short num ) \nShort ( String str ) throws NumberFormatException \n\nInteger ( int num ) \nInteger ( String str ) throws NumberFormatException \n\nLong ( long num ) \nLong ( String str ) throws NumberFormatException \n\nAs you can see, these objects can be constructed from numeric values or from",
    "Long ( long num ) \nLong ( String str ) throws NumberFormatException \n\nAs you can see, these objects can be constructed from numeric values or from \n\nstrings that contain valid whole number values. \nThe methods defined by these classes are shown in Tables 17-3 through 17-6. As you can \nsee, they define methods for parsing integers from strings and converting strings back into \nintegers. Variants of these methods allow you to specify the radix , or numeric base, for \nconversion. Common radixes are 2 for binary, 8 for octal, 10 for decimal, and 16 for \nhexadecimal. \nThe following constants are defined: \n\nBYTES \nThe width of the integer type in bytes ( Added by JDK 8.) \n\nMIN_VALUE \nMinimum value \n\nMAX_VALUE \nMaximum value \n\nSIZE \nThe bit width of the wrapped value \n\n\nTYPE \nThe Class object for byte , short , int , or long \n\nTable 17-3    The Methods Defined by Byte \n\n\nTable 17-4    The Methods Defined by Short",
    "TYPE \nThe Class object for byte , short , int , or long \n\nTable 17-3    The Methods Defined by Byte \n\n\nTable 17-4    The Methods Defined by Short \n\n\n\n\nTable 17-5    The Methods Defined by Integer \n\n\n\n\nTable 17-6    The Methods Defined by Long \n\nConverting Numbers to and from Strings \nOne of the most common programming chores is converting the string representation of a \nnumber into its internal, binary format. Fortunately, Java provides an easy way to \naccomplish this. The Byte , Short , Integer , and Long classes provide the parseByte ( ) , \nparseShort ( ) , parseInt ( ) , and parseLong ( ) methods, respectively. These methods \nreturn the byte , short , int , or long equivalent of the numeric string with which they are \ncalled. ( Similar methods also exist for the Float and Double classes.)",
    "The following program demonstrates parseInt ( ) . It sums a list of integers entered by the \nuser. It reads the integers using readLine ( ) and uses parseInt ( ) to convert these strings \ninto their int equivalents. \n\n\nTo convert a whole number into a decimal string, use the versions of toString ( ) defined in \nthe Byte , Short , Integer , or Long classes. The Integer and Long classes also provide \nthe methods toBinaryString ( ) , toHexString ( ) , and toOctalString ( ) , which convert a \nvalue into a binary, hexadecimal, or octal string, respectively. \nThe following program demonstrates binary, hexadecimal, and octal conversion: \n\n\nThe output of this program is shown here: \n\nCharacter \n\nCharacter is a simple wrapper around a char . The constructor for Character is \n\nCharacter ( char ch ) \n\nHere, ch specifies the character that will be wrapped by the Character object",
    "Character \n\nCharacter is a simple wrapper around a char . The constructor for Character is \n\nCharacter ( char ch ) \n\nHere, ch specifies the character that will be wrapped by the Character object \n\nbeing created. \nTo obtain the char value contained in a Character object, call charValue ( ) , shown here: \n\nchar charValue ( ) \n\nIt returns the character. \nThe Character class defines several constants, including the following: \n\nBYTES \nThe width of a char in bytes ( Added by JDK 8.) \n\nMAX_RADIX \nThe largest radix \n\nMIN_RADIX \nThe smallest radix \n\nMAX_VALUE \nThe largest character value \n\n\nMIN_VALUE \nThe smallest character value \n\nTYPE \nThe Class object for char \n\nCharacter includes several static methods that categorize characters and alter their case. A \nsampling is shown in Table 17-7. The following example demonstrates several of these \nmethods: \n\nThe output from this program is shown here:",
    "The output from this program is shown here: \n\nCharacter defines two methods, forDigit ( ) and digit ( ) , that enable you to convert \nbetween integer values and the digits they represent. They are shown here: \n\nstatic char forDigit ( int num , int radix ) \n\n\nstatic int digit ( char digit , int radix ) \n\nforDigit ( ) returns the digit character associated with the value of num . The radix \nof the conversion is specified by radix . digit ( ) returns the integer value associated \nwith the specified character ( which is presumably a digit ) according to the \nspecified radix. ( There is a second form of digit ( ) that takes a code point. See the \nfollowing section for a discussion of code points.) \nAnother method defined by Character is compareTo ( ) , which has the following form: \n\nint compareTo ( Character c )",
    "int compareTo ( Character c ) \n\nIt returns zero if the invoking object and c have the same value. It returns a \nnegative value if the invoking object has a lower value. Otherwise, it returns a \npositive value. \n\nTable 17-7    Various Character Methods \n\n\nCharacter includes a method called getDirectionality ( ) which can be used to \ndetermine the direction of a character. Several constants are defined that describe \ndirectionality. Most programs will not need to use character directionality. \nCharacter also overrides the equals ( ) and hashCode ( ) methods. \nTwo other character-related classes are Character.Subset , used to describe a subset of \nUnicode, and Character.UnicodeBlock , which contains Unicode character blocks. \n\nAdditions to Character for Unicode Code Point Support",
    "Relatively recently, major additions were made to Character . Beginning with JDK 5, the \nCharacter class has included support for 32-bit Unicode characters. In the past, all \nUnicode characters could be held by 16 bits, which is the size of a char ( and the size of the \nvalue encapsulated within a Character ), because those values ranged from 0 to FFFF. \nHowever, the Unicode character set has been expanded, and more than 16 bits are required. \nCharacters can now range from 0 to 10FFFF. \nHere are three important terms. A code point is a character in the range 0 to 10FFFF. \nCharacters that have values greater than FFFF are called supplemental characters . The \nbasic multilingual plane ( BMP ) are those characters between 0 and FFFF. \nThe expansion of the Unicode character set caused a fundamental problem for Java. \nBecause a supplemental character has a value greater than a char can hold, some means of \nhandling the supplemental characters was needed",
    ". \nBecause a supplemental character has a value greater than a char can hold, some means of \nhandling the supplemental characters was needed. Java addressed this problem in two ways. \nFirst, Java uses two chars to represent a supplemental character. The first char is called \nthe high surrogate , and the second is called the low surrogate . New methods, such as \ncodePointAt ( ) , were provided to translate between code points and supplemental \ncharacters. \nSecondly, Java overloaded several preexisting methods in the Character class. The \noverloaded forms use int rather than char data. Because an int is large enough to hold any \ncharacter as a single value, it can be used to store any character. For example, all of the \nmethods in Table 17-7 have overloaded forms that operate on int . Here is a sampling:",
    "static boolean isDigit ( int cp ) \nstatic boolean isLetter ( int cp ) \nstatic int toLowerCase ( int cp ) \n\nIn addition to the methods overloaded to accept code points, Character adds \n\nmethods that provide additional support for code points. A sampling is shown in \nTable 17-8. \n\nBoolean \n\nBoolean is a very thin wrapper around boolean values, which is useful mostly when you \nwant to pass a boolean variable by reference. It contains the constants TRUE and FALSE , \nwhich define true and false Boolean objects. Boolean also defines the TYPE field, which \nis the Class object for boolean . Boolean defines these constructors: \n\n\nBoolean ( boolean boolValue ) \nBoolean ( String boolString ) \n\nTable 17-8    A Sampling of Methods That Provide Support for 32-Bit \nUnicode Code Points",
    "Boolean ( boolean boolValue ) \nBoolean ( String boolString ) \n\nTable 17-8    A Sampling of Methods That Provide Support for 32-Bit \nUnicode Code Points \n\nIn the first version, boolValue must be either true or false . In the second version, \nif boolString contains the string \"true\" ( in uppercase or lowercase ), then the new \nBoolean object will be true . Otherwise, it will be false . \nBoolean defines the methods shown in Table 17-9. \n\n\nTable 17-9    The Methods Defined by Boolean \n\nVoid \n\nThe Void class has one field, TYPE , which holds a reference to the Class object for type \nvoid . You do not create instances of this class. \n\nProcess \n\nThe abstract Process class encapsulates a process \u2014that is, an executing program. It is used \nprimarily as a superclass for the type of objects created by exec ( ) in the Runtime class, or \nby start ( ) in the ProcessBuilder class. Process contains the methods shown in Table \n17-10.",
    "Table 17-10    The Methods Defined by Process \n\nRuntime \n\nThe Runtime class encapsulates the run-time environment. You cannot instantiate a \nRuntime object. However, you can get a reference to the current Runtime object by \ncalling the static method Runtime.getRuntime ( ) . Once you obtain a reference to the \ncurrent Runtime object, you can call several methods that control the state and behavior of \nthe Java Virtual Machine. Applets and other untrusted code typically cannot call any of the \nRuntime methods without raising a SecurityException . Several commonly used \nmethods defined by Runtime are shown in Table 17-11. \n\n\nTable 17-11    A Sampling of Methods Defined by Runtime \n\nLet\u2019s look at two of the most common uses of the Runtime class: memory \nmanagement and executing additional processes. \n\nMemory Management",
    "Let\u2019s look at two of the most common uses of the Runtime class: memory \nmanagement and executing additional processes. \n\nMemory Management \n\nAlthough Java provides automatic garbage collection, sometimes you will want to know how \nlarge the object heap is and how much of it is left. You can use this information, for \nexample, to check your code for efficiency or to approximate how many more objects of a \ncertain type can be instantiated. To obtain these values, use the totalMemory ( ) and \nfreeMemory ( ) methods. \nAs mentioned in Part I, Java\u2019s garbage collector runs periodically to recycle unused objects.",
    "However, sometimes you will want to collect discarded objects prior to the collector\u2019s next \nappointed rounds. You can run the garbage collector on demand by calling the gc ( ) \nmethod. A good thing to try is to call gc ( ) and then call freeMemory ( ) to get a baseline \nmemory usage. Next, execute your code and call freeMemory ( ) again to see how much \nmemory it is allocating. The following program illustrates this idea: \n\n\nSample output from this program is shown here ( of course, your actual results may vary ): \n\nExecuting Other Programs \n\nIn safe environments, you can use Java to execute other heavyweight processes ( that is,",
    "Executing Other Programs \n\nIn safe environments, you can use Java to execute other heavyweight processes ( that is, \n\n\nprograms ) on your multitasking operating system. Several forms of the exec ( ) method \nallow you to name the program you want to run as well as its input parameters. The exec ( ) \nmethod returns a Process object, which can then be used to control how your Java \nprogram interacts with this new running process. Because Java can run on a variety of \nplatforms and under a variety of operating systems, exec ( ) is inherently environmentdependent. \nThe following example uses exec ( ) to launch notepad , Windows\u2019 simple text editor. \nObviously, this example must be run under the Windows operating system.",
    "There are several alternative forms of exec ( ) , but the one shown in the example is the \nmost common. The Process object returned by exec ( ) can be manipulated by Process \u2019 \nmethods after the new program starts running. You can kill the subprocess with the \ndestroy ( ) method. The waitFor ( ) method causes your program to wait until the \nsubprocess finishes. The exitValue ( ) method returns the value returned by the subprocess \nwhen it is finished. This is typically 0 if no problems occur. Here is the preceding exec ( ) \nexample modified to wait for the running process to exit: \n\n\nWhile a subprocess is running, you can write to and read from its standard input and \noutput. The getOutputStream ( ) and getInputStream ( ) methods return the handles to \nstandard in and out of the subprocess. ( I/O is examined in detail in Chapter 20.) \n\nProcessBuilder",
    "ProcessBuilder \n\nProcessBuilder provides another way to start and manage processes ( that is, programs ). \nAs explained earlier, all processes are represented by the Process class, and a process can \nbe started by Runtime.exec ( ) . ProcessBuilder offers more control over the processes. \nFor example, you can set the current working directory. \nProcessBuilder defines these constructors: \n\nProcessBuilder ( List<String> args ) \nProccessBuilder ( String \u2026 args ) \n\nHere, args is a list of arguments that specify the name of the program to be",
    "ProcessBuilder ( List<String> args ) \nProccessBuilder ( String \u2026 args ) \n\nHere, args is a list of arguments that specify the name of the program to be \n\nexecuted along with any required command-line arguments. In the first \nconstructor, the arguments are passed in a List . In the second, they are specified \nthrough a varargs parameter. Table 17-12 describes the methods defined by \nProcessBuilder . \nIn Table 17-12, notice the methods that use the ProcessBuilder.Redirect class. This \nabstract class encapsulates an I/O source or target linked to a subprocess. Among other \nthings, these methods enable you to redirect the source or target of I/O operations. For \nexample, you can redirect to a file by calling to ( ) , redirect from a file by calling from ( ) , \nand append to a file by calling appendTo ( ) . A File object linked to the file can be \nobtained by calling file ( ) . These methods are shown here:",
    "static ProcessBuilder.Redirect to ( File f ) \nstatic ProcessBuilder.Redirect from ( File f ) \nstatic ProcessBuilder.Redirect appendTo ( File f ) \n\n\nFile file ( ) \n\nAnother method supported by ProcessBuilder.Redirect is type ( ) , which \nreturns a value of the enumeration type ProcessBuilder.Redirect.Type . This \nenumeration describes the type of the redirection. It defines these values: \nAPPEND , INHERIT , PIPE , READ , or WRITE . ProcessBuilder.Redirect \nalso defines the constants INHERIT and PIPE . \n\n\nTable 17-12    The Methods Defined by ProcessBuilder \n\nTo create a process using ProcessBuilder , simply create an instance of \nProcessBuilder , specifying the name of the program and any needed arguments. \nTo begin execution of the program, call start ( ) on that instance. Here is an \nexample that executes the Windows text editor notepad . Notice that it specifies \nthe name of the file to edit as an argument. \n\n\nSystem",
    "System \n\nThe System class holds a collection of static methods and variables. The standard input, \noutput, and error output of the Java run time are stored in the in , out , and err variables. \nThe methods defined by System are shown in Table 17-13. Many of the methods throw a \nSecurityException if the operation is not permitted by the security manager. \nLet\u2019s look at some common uses of System . \n\n\nTable 17-13    The Methods Defined by System \n\nUsing currentTimeMillis ( ) to Time Program Execution",
    "Table 17-13    The Methods Defined by System \n\nUsing currentTimeMillis ( ) to Time Program Execution \n\nOne use of the System class that you might find particularly interesting is to use the \ncurrentTimeMillis ( ) method to time how long various parts of your program take to \nexecute. The currentTimeMillis ( ) method returns the current time in terms of \nmilliseconds since midnight, January 1, 1970. To time a section of your program, store this \nvalue just before beginning the section in question. Immediately upon completion, call \ncurrentTimeMillis ( ) again. The elapsed time will be the ending time minus the starting \n\ntime. The following program demonstrates this: \n\n\nHere is a sample run ( remember that your results probably will differ ):",
    "time. The following program demonstrates this: \n\n\nHere is a sample run ( remember that your results probably will differ ): \n\nIf your system has a timer that offers nanosecond precision, then you could rewrite the \npreceding program to use nanoTime ( ) rather than currentTimeMillis ( ) . For example, \nhere is the key portion of the program rewritten to use nanoTime ( ) : \n\nUsing arraycopy ( ) \n\nThe arraycopy ( ) method can be used to copy quickly an array of any type from one place \nto another. This is much faster than the equivalent loop written out longhand in Java. Here \nis an example of two arrays being copied by the arraycopy ( ) method. First, a is copied to \nb . Next, all of a \u2019s elements are shifted down by one. Then, b is shifted up by one. \n\n\nAs you can see from the following output, you can copy using the same source and \ndestination in either direction: \n\nEnvironment Properties \n\nThe following properties are available in all cases:",
    "Environment Properties \n\nThe following properties are available in all cases: \n\nYou can obtain the values of various environment variables by calling the \nSystem.getProperty ( ) method. For example, the following program displays the path to \nthe current user directory: \n\n\nObject \n\nAs mentioned in Part I, Object is a superclass of all other classes. Object defines the \nmethods shown in Table 17-14, which are available to every object. \n\nUsing clone ( ) and the Cloneable Interface",
    "Most of the methods defined by Object are discussed elsewhere in this book. However, one \ndeserves special attention: clone ( ) . The clone ( ) method generates a duplicate copy of the \nobject on which it is called. Only classes that implement the Cloneable interface can be \ncloned. \nThe Cloneable interface defines no members. It is used to indicate that a class allows a \nbitwise copy of an object ( that is, a clone ) to be made. If you try to call clone ( ) on a class \nthat does not implement Cloneable , a CloneNotSupportedException is thrown. When \na clone is made, the constructor for the object being cloned is not called. As implemented by \nObject , a clone is simply an exact copy of the original. \nCloning is a potentially dangerous action, because it can cause unintended side effects. For \nexample, if the object being cloned contains a reference variable called obRef , then when the \nclone is made, obRef in the clone will refer to the same object as does obRef in the original",
    ". For \nexample, if the object being cloned contains a reference variable called obRef , then when the \nclone is made, obRef in the clone will refer to the same object as does obRef in the original. \nIf the clone makes a change to the contents of the object referred to by obRef , then it will be \nchanged for the original object, too. Here is another example: If an object opens an I/O \nstream and is then cloned, two objects will be capable of operating on the same stream. \nFurther, if one of these objects closes the stream, the other object might still attempt to \nwrite to it, causing an error. In some cases, you will need to override the clone ( ) method \ndefined by Object to handle these types of problems.",
    "Table 17-14    The Methods Defined by Object \n\nBecause cloning can cause problems, clone ( ) is declared as protected inside \nObject . This means that it must either be called from within a method defined by \nthe class that implements Cloneable , or it must be explicitly overridden by that \nclass so that it is public. Let\u2019s look at an example of each approach. \nThe following program implements Cloneable and defines the method cloneTest ( ) , \nwhich calls clone ( ) in Object : \n\n\nHere, the method cloneTest ( ) calls clone ( ) in Object and returns the result. Notice that \n\nthe object returned by clone ( ) must be cast into its appropriate type ( TestClone ). \nThe following example overrides clone ( ) so that it can be called from code outside of its \nclass. To do this, its access specifier must be public , as shown here:",
    "The side effects caused by cloning are sometimes difficult to see at first. It is easy to think \nthat a class is safe for cloning when it actually is not. In general, you should not implement \nCloneable for any class without good reason. \n\nClass \n\nClass encapsulates the run-time state of a class or interface. Objects of type Class are \n\ncreated automatically, when classes are loaded. You cannot explicitly declare a Class object. \nGenerally, you obtain a Class object by calling the getClass ( ) method defined by Object . \nClass is a generic type that is declared as shown here: \n\nclass Class<T> \n\n\nHere, T is the type of the class or interface represented. A sampling of methods \ndefined by Class is shown in Table 17-15. \n\n\nTable 17-15    A Sampling of Methods Defined by Class",
    "Table 17-15    A Sampling of Methods Defined by Class \n\nThe methods defined by Class are often useful in situations where run-time type \ninformation about an object is required. As Table 17-15 shows, methods are \nprovided that allow you to determine additional information about a particular \nclass, such as its public constructors, fields, and methods. Among other things, this \nis important for the Java Beans functionality, which is discussed later in this book. \nThe following program demonstrates getClass ( ) ( inherited from Object ) and \n\ngetSuperclass ( ) ( from Class ): \n\n\nThe output from this program is shown here: \n\nClassLoader \n\nThe abstract class ClassLoader defines how classes are loaded. Your application can create",
    "getSuperclass ( ) ( from Class ): \n\n\nThe output from this program is shown here: \n\nClassLoader \n\nThe abstract class ClassLoader defines how classes are loaded. Your application can create \n\nsubclasses that extend ClassLoader , implementing its methods. Doing so allows you to \nload classes in some way other than the way they are normally loaded by the Java run-time \nsystem. However, this is not something that you will normally need to do. \n\nMath \n\nThe Math class contains all the floating-point functions that are used for geometry and \n\n\ntrigonometry, as well as several general-purpose methods. Math defines two double \nconstants: E ( approximately 2.72 ) and PI ( approximately 3.14 ). \n\nTrigonometric Functions \n\nThe following methods accept a double parameter for an angle in radians and return the \nresult of their respective trigonometric function: \n\nMethod \nDescription \n\nstatic double \nsin ( double arg ) \nReturns the sine of the angle specified by arg in \nradians.",
    "Method \nDescription \n\nstatic double \nsin ( double arg ) \nReturns the sine of the angle specified by arg in \nradians. \n\nstatic double \ncos ( double arg ) \nReturns the cosine of the angle specified by arg in \nradians. \n\nstatic double \ntan ( double arg ) \nReturns the tangent of the angle specified by arg in \nradians. \n\nThe next methods take as a parameter the result of a trigonometric function and return, in \nradians, the angle that would produce that result. They are the inverse of their non-arc \ncompanions. \n\nMethod \nDescription \n\nstatic double \nasin ( double arg ) \nReturns the angle whose sine is specified by arg . \n\nstatic double \n\nacos ( double arg ) \nReturns the angle whose cosine is specified by arg . \n\nstatic double \n\natan ( double arg ) \nReturns the angle whose tangent is specified by arg . \n\nstatic double \n\natan2 ( double x , \ndouble y ) \nReturns the angle whose tangent is x / y . \n\nThe next methods compute the hyperbolic sine, cosine, and tangent of an angle:",
    "static double \n\natan2 ( double x , \ndouble y ) \nReturns the angle whose tangent is x / y . \n\nThe next methods compute the hyperbolic sine, cosine, and tangent of an angle: \n\nMethod \nDescription \n\nstatic double \n\nsinh ( double arg ) \n\nReturns the hyperbolic sine of the angle specified by \n\narg . \n\n\nstatic double \ncosh ( double arg ) \nReturns the hyperbolic cosine of the angle specified \nby arg . \n\nstatic double \ntanh ( double arg ) \nReturns the hyperbolic tangent of the angle specified \nby arg . \n\nExponential Functions \n\nMath defines the following exponential methods: \n\nMethod \nDescription \n\nstatic double cbrt ( double arg ) \nReturns the cube root of arg . \n\nstatic double exp ( double arg ) \nReturns e to the arg . \n\nstatic double expm1 ( double \narg ) \nReturns e to the arg \u20131. \n\nstatic double log ( double arg ) \nReturns the natural logarithm of arg . \n\nstatic double log10 ( double arg ) \nReturns the base 10 logarithm for arg .",
    "static double log ( double arg ) \nReturns the natural logarithm of arg . \n\nstatic double log10 ( double arg ) \nReturns the base 10 logarithm for arg . \n\nstatic double log1p ( double arg ) \nReturns the natural logarithm for arg + \n1. \n\nstatic double pow ( double y , \ndouble x ) \nReturns y raised to the x ; for example, \npow ( 2.0, 3.0 ) returns 8.0. \n\nstatic double scalb ( double arg , \n\nint factor ) \nReturns arg \u00d7 2 \n. \n\nstatic float scalb ( float arg , int \n\nfactor ) \nReturns arg \u00d7 2 \n. \n\nstatic double sqrt ( double arg ) \nReturns the square root of arg . \n\nRounding Functions \n\nThe Math class defines several methods that provide various types of rounding operations. \n\nThey are shown in Table 17-16. Notice the two ulp ( ) methods at the end of the table. In \nthis context, ulp stands for units in the last place . It indicates the distance between a value \nand the next higher value. It can be used to help assess the accuracy of a result. \n\nfactor \n\nfactor",
    "factor \n\nfactor \n\n\nTable 17-16    The Rounding Methods Defined by Math \n\nMiscellaneous Math Methods \n\nIn addition to the methods just shown, Math defines several other methods, which are \nshown in Table 17-17. Notice that several of the methods use the suffix Exact . These were \n\n\nadded by JDK 8. They throw an ArithmeticException if overflow occurs. Thus, these \nmethods give you an easy way to watch various operations for overflow. \n\nTable 17-17    Other Methods Defined by Math \n\nThe following program demonstrates toRadians ( ) and toDegrees ( ) : \n\n\nThe output is shown here: \n\nStrictMath \n\nThe StrictMath class defines a complete set of mathematical methods that parallel those in \nMath . The difference is that the StrictMath version is guaranteed to generate precisely \nidentical results across all Java implementations, whereas the methods in Math are given \nmore latitude in order to improve performance. \n\nCompiler",
    "Compiler \n\nThe Compiler class supports the creation of Java environments in which Java bytecode is \n\ncompiled into executable code rather than interpreted. It is not for normal programming \nuse. \n\nThread, ThreadGroup, and Runnable \n\nThe Runnable interface and the Thread and ThreadGroup classes support \nmultithreaded programming. Each is examined next. \n\nNOTE An overview of the techniques used to manage threads, implement \nthe Runnable interface, and create multithreaded programs is presented \n\nin Chapter 11. \n\nThe Runnable Interface \n\nThe Runnable interface must be implemented by any class that will initiate a separate \n\n\nthread of execution. Runnable only defines one abstract method, called run ( ) , which is \nthe entry point to the thread. It is defined like this: \n\nvoid run ( ) \n\nThreads that you create must implement this method. \n\nThread \n\nThread creates a new thread of execution. It implements Runnable and defines the \nfollowing commonly used constructors:",
    "void run ( ) \n\nThreads that you create must implement this method. \n\nThread \n\nThread creates a new thread of execution. It implements Runnable and defines the \nfollowing commonly used constructors: \n\nThread ( ) \nThread ( Runnable threadOb ) \nThread ( Runnable threadOb , String threadName ) \nThread ( String threadName ) \nThread ( ThreadGroup groupOb , Runnable threadOb ) \nThread ( ThreadGroup groupOb , Runnable threadOb , String threadName ) \nThread ( ThreadGroup groupOb , String threadName ) \n\nthreadOb is an instance of a class that implements the Runnable interface and \ndefines where execution of the thread will begin. The name of the thread is \nspecified by threadName . When a name is not specified, one is created by the Java \nVirtual Machine. groupOb specifies the thread group to which the new thread will \nbelong. When no thread group is specified, the new thread belongs to the same \ngroup as the parent thread. \nThe following constants are defined by Thread : \n\nMAX_PRIORITY",
    "MAX_PRIORITY \n\nMIN_PRIORITY \nNORM_PRIORITY \n\nAs expected, these constants specify the maximum, minimum, and default thread \npriorities. \nThe methods defined by Thread are shown in Table 17-18. In early versions of Java, \nThread also included the methods stop ( ) , suspend ( ) , and resume ( ) . However, as \nexplained in Chapter 11, these were deprecated because they were inherently unstable. Also \ndeprecated are countStackFrames ( ) , because it calls suspend ( ) , and destroy ( ) , \nbecause it can cause deadlock. \n\n\n\n\nTable 17-18    The Methods Defined by Thread \n\nThreadGroup \n\nThreadGroup creates a group of threads. It defines these two constructors: \n\nThreadGroup ( String groupName ) \nThreadGroup ( ThreadGroup parentOb , String groupName )",
    "ThreadGroup \n\nThreadGroup creates a group of threads. It defines these two constructors: \n\nThreadGroup ( String groupName ) \nThreadGroup ( ThreadGroup parentOb , String groupName ) \n\nFor both forms, groupName specifies the name of the thread group. The first \nversion creates a new group that has the current thread as its parent. In the second \nform, the parent is specified by parentOb . The non-deprecated methods defined by \nThreadGroup are shown in Table 17-19. \n\n\nTable 17-19    The Methods Defined by ThreadGroup",
    "Table 17-19    The Methods Defined by ThreadGroup \n\nThread groups offer a convenient way to manage groups of threads as a unit. This \nis particularly valuable in situations in which you want to suspend and resume a \nnumber of related threads. For example, imagine a program in which one set of \nthreads is used for printing a document, another set is used to display the \ndocument on the screen, and another set saves the document to a disk file. If \nprinting is aborted, you will want an easy way to stop all threads related to \nprinting. Thread groups offer this convenience. The following program, which \ncreates two thread groups of two threads each, illustrates this usage: \n\n\n\n\nSample output from this program is shown here ( the precise output you see may differ ):",
    "Sample output from this program is shown here ( the precise output you see may differ ): \n\n\nInside the program, notice that thread group A is suspended for four seconds. As the output \nconfirms, this causes threads One and Two to pause, but threads Three and Four continue \nrunning. After the four seconds, threads One and Two are resumed. Notice how thread \n\ngroup A is suspended and resumed. First, the threads in group A are obtained by calling \n\n\nenumerate ( ) on group A. Then, each thread is suspended by iterating through the \nresulting array. To resume the threads in A, the list is again traversed and each thread is \nresumed. One last point: This example uses the recommended approach to suspending and \nresuming threads. It does not rely upon the deprecated methods suspend ( ) and resume ( \n) . \n\nThreadLocal and InheritableThreadLocal \n\nJava defines two additional thread-related classes in java.lang :",
    "ThreadLocal and InheritableThreadLocal \n\nJava defines two additional thread-related classes in java.lang : \n\n\u2022   ThreadLocal     Used to create thread local variables. Each thread will \nhave its own copy of a thread local variable. \n\n\u2022   InheritableThreadLocal     Creates thread local variables that may be \ninherited. \n\nPackage \n\nPackage encapsulates version data associated with a package. Package version \ninformation is becoming more important because of the proliferation of packages and \nbecause a Java program may need to know what version of a package is available. The \nmethods defined by Package are shown in Table 17-20. The following program \ndemonstrates Package , displaying the packages about which the program currently is \naware: \n\n\nTable 17-20    The Methods Defined by Package \n\nRuntimePermission \n\nRuntimePermission relates to Java\u2019s security mechanism and is not examined further \nhere. \n\nThrowable",
    "Table 17-20    The Methods Defined by Package \n\nRuntimePermission \n\nRuntimePermission relates to Java\u2019s security mechanism and is not examined further \nhere. \n\nThrowable \n\n\nThe Throwable class supports Java\u2019s exception-handling system and is the class from \nwhich all exception classes are derived. It is discussed in Chapter 10. \n\nSecurityManager \n\nSecurityManager supports Java\u2019s security system. A reference to the current security \nmanager can be obtained by calling getSecurityManager ( ) defined by the System class. \n\nStackTraceElement",
    "SecurityManager supports Java\u2019s security system. A reference to the current security \nmanager can be obtained by calling getSecurityManager ( ) defined by the System class. \n\nStackTraceElement \n\nThe StackTraceElement class describes a single stack frame , which is an individual \nelement of a stack trace when an exception occurs. Each stack frame represents an \nexecution point , which includes such things as the name of the class, the name of the \nmethod, the name of the file, and the source-code line number. An array of \nStackTraceElement s is returned by the getStackTrace ( ) method of the Throwable \nclass. \nStackTraceElement has one constructor: \n\nStackTraceElement ( String className , String methName , string fileName , int line )",
    "StackTraceElement ( String className , String methName , string fileName , int line ) \n\nHere, the name of the class is specified by className , the name of the method is \nspecified in methName , the name of the file is specified by fileName , and the line \nnumber is passed in line . If there is no valid line number, use a negative value for \nline . Furthermore, a value of \u20132 for line indicates that this frame refers to a native \nmethod. \nThe methods supported by StackTraceElement are shown in Table 17-21. These methods \ngive you programmatic access to a stack trace. \n\nTable 17-21    The Methods Defined by StackTraceElement \n\n\nEnum \n\nAs described in Chapter 12, an enumeration is a list of named constants. ( Recall that an \nenumeration is created by using the keyword enum .) All enumerations automatically \ninherit Enum . Enum is a generic class that is declared as shown here: \n\nclass Enum<E extends Enum<E>>",
    "class Enum<E extends Enum<E>> \n\nHere, E stands for the enumeration type. Enum has no public constructors. \nEnum defines several methods that are available for use by all enumerations, which are \nshown in Table 17-22. \n\nTable 17-212    The Methods Defined by Enum \n\nClassValue \n\nClassValue can be used to associate a value with a type. It is a generic type defined like \nthis: \n\nClass ClassValue<T> \n\nIt is designed for highly specialized uses, not for normal programming. \n\nThe CharSequence Interface \n\nThe CharSequence interface defines methods that grant read-only access to a sequence of \ncharacters. These methods are shown in Table 17-23. This interface is implemented by \nString , StringBuffer , and StringBuilder , among others. \n\nThe Comparable Interface",
    "The Comparable Interface \n\n\nObjects of classes that implement Comparable can be ordered. In other words, classes that \nimplement Comparable contain objects that can be compared in some meaningful \nmanner. Comparable is generic and is declared like this: \n\ninterface Comparable<T> \n\nHere, T represents the type of objects being compared. \n\nTable 17-23    The Methods Defined by CharSequence \n\nThe Comparable interface declares one method that is used to determine what Java calls \nthe natural ordering of instances of a class. The signature of the method is shown here: \n\nint compareTo ( T obj )",
    "int compareTo ( T obj ) \n\nThis method compares the invoking object with obj . It returns 0 if the values are \nequal. A negative value is returned if the invoking object has a lower value. \nOtherwise, a positive value is returned. \nThis interface is implemented by several of the classes already reviewed in this book. \nSpecifically, the Byte , Character , Double , Float , Long , Short , String , and Integer \nclasses define a compareTo ( ) method. So does Enum . \n\nThe Appendable Interface \n\nObjects of a class that implements Appendable can have a character or character \nsequences appended to it. Appendable defines these three methods: \n\nAppendable append ( char ch ) throws IOException \n\nAppendable append ( CharSequence chars ) throws IOException \nAppendable append ( CharSequence chars , int begin , int end ) throws IOException",
    "Appendable append ( char ch ) throws IOException \n\nAppendable append ( CharSequence chars ) throws IOException \nAppendable append ( CharSequence chars , int begin , int end ) throws IOException \n\nIn the first form, the character ch is appended to the invoking object. In the second \nform, the character sequence chars is appended to the invoking object. The third \nform allows you to indicate a portion ( the characters running from begin through \nend \u20131 ) of the sequence specified by chars . In all cases, a reference to the invoking \n\nobject is returned. \n\n\nThe Iterable Interface \n\nIterable must be implemented by any class whose objects will be used by the for-each \nversion of the for loop. In other words, in order for an object to be used within a for-each \nstyle for loop, its class must implement Iterable . Iterable is a generic interface that has \nthis declaration: \n\ninterface Iterable<T>",
    "interface Iterable<T> \n\nHere, T is the type of the object being iterated. It defines one abstract method, \niterator ( ) , which is shown here: \n\nIterator<T> iterator ( ) \n\nIt returns an iterator to the elements contained in the invoking object. \nBeginning with JDK 8, Iterable also defines two default methods. The first is called \nforEach ( ) : \n\ndefault void forEach ( Consumer<? super T> action ) \n\nFor each element being iterated, forEach ( ) executes the code specified by action . \n( Consumer is a functional interface added by JDK 8 and defined in \njava.util.function . See Chapter 19.) \nThe second default method is spliterator ( ) , shown next: \n\ndefault Spliterator<T> spliterator ( ) \n\nIt returns a Spliterator to the sequence being iterated. ( See Chapters 18 and 29 \nfor details on spliterators.) \n\nNOTE Iterators are described in detail in Chapter 18. \n\nThe Readable Interface",
    "It returns a Spliterator to the sequence being iterated. ( See Chapters 18 and 29 \nfor details on spliterators.) \n\nNOTE Iterators are described in detail in Chapter 18. \n\nThe Readable Interface \n\nThe Readable interface indicates that an object can be used as a source for characters. It \ndefines one method called read ( ) , which is shown here: \n\nint read ( CharBuffer buf ) throws IOException \n\nThis method reads characters into buf . It returns the number of characters read, or \n\u20131 if an EOF is encountered. \n\nThe AutoCloseable Interface \n\nAutoCloseable provides support for the try -with-resources statement, which implements \nwhat is sometimes referred to as automatic resource management ( ARM ). The try -with-",
    "AutoCloseable provides support for the try -with-resources statement, which implements \nwhat is sometimes referred to as automatic resource management ( ARM ). The try -with- \n\n\nresources statement automates the process of releasing a resource ( such as a stream ) when \nit is no longer needed. ( See Chapter 13 for details.) Only objects of classes that implement \nAutoCloseable can be used with try -with-resources. The AutoCloseable interface \ndefines only the close ( ) method, which is shown here: \n\nvoid close ( ) throws Exception \n\nThis method closes the invoking object, releasing any resources that it may hold. It \nis automatically called at the end of a try -with-resources statement, thus \neliminating the need to explicitly invoke close ( ) . AutoCloseable is \nimplemented by several classes, including all of the I/O classes that open a stream \nthat can be closed. \n\nThe Thread.UncaughtExceptionHandler Interface",
    "The Thread.UncaughtExceptionHandler Interface \n\nThe static Thread.UncaughtExceptionHandler interface is implemented by classes that \nwant to handle uncaught exceptions. It is implemented by ThreadGroup . It declares only \none method, which is shown here: \n\nvoid uncaughtException ( Thread thrd , Throwable exc ) \n\nHere, thrd is a reference to the thread that generated the exception and exc is a \nreference to the exception. \n\nThe java.lang Subpackages \n\nJava defines several subpackages of java.lang : \n\n\u2022  java.lang.annotation \n\n\u2022  java.lang.instrument \n\n\u2022  java.lang.invoke \n\n\u2022  java.lang.management \n\n\u2022  java.lang.ref \n\n\u2022  java.lang.reflect \n\nEach is briefly described here. \n\njava.lang.annotation \n\nJava\u2019s annotation facility is supported by java.lang.annotation . It defines the \nAnnotation interface, the ElementType and RetentionPolicy enumerations, and \nseveral predefined annotations. Annotations are described in Chapter 12. \n\njava.lang.instrument",
    "java.lang.instrument \n\njava.lang.instrument defines features that can be used to add instrumentation to various \naspects of program execution. It defines the Instrumentation and \n\nClassFileTransformer interfaces, and the ClassDefinition class. \n\n\njava.lang.invoke \n\njava.lang.invoke supports dynamic languages. It includes classes such as CallSite , \nMethodHandle , and MethodType . \n\njava.lang.management \n\nThe java.lang.management package provides management support for the JVM and the \nexecution environment. Using the features in java.lang.management , you can observe \nand manage various aspects of program execution. \n\njava.lang.ref \n\nYou learned earlier that the garbage collection facilities in Java automatically determine \nwhen no references exist to an object. The object is then assumed to be no longer needed \nand its memory is reclaimed. The classes in the java.lang.ref package provide more \nflexible control over the garbage collection process. \n\njava.lang.reflect",
    "java.lang.reflect \n\nReflection is the ability of a program to analyze code at run time. The java.lang.reflect \npackage provides the ability to obtain information about the fields, constructors, methods, \nand modifiers of a class. Among other reasons, you need this information to build software \ntools that enable you to work with Java Beans components. The tools use reflection to \ndetermine dynamically the characteristics of a component. Reflection was introduced in \n\nChapter 12 and is also examined in Chapter 30. \njava.lang.reflect defines several classes, including Method , Field , and Constructor . It \nalso defines several interfaces, including AnnotatedElement , Member , and Type . In \naddition, the java.lang.reflect package includes the Array class that enables you to create \nand access arrays dynamically. \n\n\uf709 \nPREV \nChapter 16: String Handling \n\u23ee \n\nNEXT \nChapter 18: java.util Part 1: The Collections Fra\u2026 \u23ed \n\n\nPREV \nChapter 17: Exploring java.lang \n\u23ee",
    "\uf709 \nPREV \nChapter 16: String Handling \n\u23ee \n\nNEXT \nChapter 18: java.util Part 1: The Collections Fra\u2026 \u23ed \n\n\nPREV \nChapter 17: Exploring java.lang \n\u23ee \n\nNEXT \nChapter 19: java.util Part 2: More Utility Classes \n\u23ed \n\nCHAPTER \n\n18 \njava.util Part 1: The Collections Framework",
    "PREV \nChapter 17: Exploring java.lang \n\u23ee \n\nNEXT \nChapter 19: java.util Part 2: More Utility Classes \n\u23ed \n\nCHAPTER \n\n18 \njava.util Part 1: The Collections Framework \n\nThis chapter begins our examination of java.util . This important package contains a large \nassortment of classes and interfaces that support a broad range of functionality. For \nexample, java.util has classes that generate pseudorandom numbers, manage date and \ntime, observe events, manipulate sets of bits, tokenize strings, and handle formatted data. \nThe java.util package also contains one of Java\u2019s most powerful subsystems: the Collections \nFramework . The Collections Framework is a sophisticated hierarchy of interfaces and \nclasses that provide state-of-the-art technology for managing groups of objects. It merits \nclose attention by all programmers. \nBecause java.util contains a wide array of functionality, it is quite large. Here is a list of its \ntop-level classes:",
    "The interfaces defined by java.util are shown next: \n\n\nBecause of its size, the description of java.util is broken into two chapters. This chapter \nexamines those members of java.util that are part of the Collections Framework. Chapter \n18 discusses its other classes and interfaces. \n\nCollections Overview",
    "The Java Collections Framework standardizes the way in which groups of objects are \nhandled by your programs. Collections were not part of the original Java release, but were \nadded by J2SE 1.2. Prior to the Collections Framework, Java provided ad hoc classes such \nas Dictionary , Vector , Stack , and Properties to store and manipulate groups of objects. \nAlthough these classes were quite useful, they lacked a central, unifying theme. The way that \nyou used Vector was different from the way that you used Properties , for example. Also, \nthis early, ad hoc approach was not designed to be easily extended or adapted. Collections \nare an answer to these ( and other ) problems. \nThe Collections Framework was designed to meet several goals. First, the framework had to \nbe high-performance. The implementations for the fundamental collections ( dynamic \narrays, linked lists, trees, and hash tables ) are highly efficient. You seldom, if ever, need to \ncode one of these \u201cdata engines\u201d manually",
    ". You seldom, if ever, need to \ncode one of these \u201cdata engines\u201d manually. Second, the framework had to allow different \ntypes of collections to work in a similar manner and with a high degree of interoperability. \nThird, extending and/or adapting a collection had to be easy. Toward this end, the entire",
    "Collections Framework is built upon a set of standard interfaces. Several standard \nimplementations ( such as LinkedList , HashSet , and TreeSet ) of these interfaces are \nprovided that you may use as-is. You may also implement your own collection, if you \nchoose. Various special-purpose implementations are created for your convenience, and \nsome partial implementations are provided that make creating your own collection class \neasier. Finally, mechanisms were added that allow the integration of standard arrays into \n\nthe Collections Framework.",
    "Algorithms are another important part of the collection mechanism. Algorithms operate on \ncollections and are defined as static methods within the Collections class. Thus, they are \navailable for all collections. Each collection class need not implement its own versions. The \nalgorithms provide a standard means of manipulating collections. \nAnother item closely associated with the Collections Framework is the Iterator interface. \nAn iterator offers a general-purpose, standardized way of accessing the elements within a \ncollection, one at a time. Thus, an iterator provides a means of enumerating the contents of \na collection . Because each collection provides an iterator, the elements of any collection",
    "class can be accessed through the methods defined by Iterator . Thus, with only small \nchanges, the code that cycles through a set can also be used to cycle through a list, for \nexample. \nJDK 8 adds another type of iterator called a spliterator . In brief, spliterators are iterators \nthat provide support for parallel iteration. The interfaces that support spliterators are \nSpliterator and several nested interfaces that support primitive types. JDK 8 also adds \niterator interfaces designed for use with primitive types, such as PrimitiveIterator and \nPrimitiveIterator.OfDouble . \nIn addition to collections, the framework defines several map interfaces and classes. Maps \nstore key/value pairs. Although maps are part of the Collections Framework, they are not \n\u201ccollections\u201d in the strict use of the term. You can, however, obtain a collection-view of a \nmap. Such a view contains the elements from the map stored in a collection",
    ". You can, however, obtain a collection-view of a \nmap. Such a view contains the elements from the map stored in a collection. Thus, you can \nprocess the contents of a map as a collection, if you choose. \nThe collection mechanism was retrofitted to some of the original classes defined by \njava.util so that they too could be integrated into the new system. It is important to \nunderstand that although the addition of collections altered the architecture of many of the \noriginal utility classes, it did not cause the deprecation of any. Collections simply provide a \nbetter way of doing several things.",
    "NOTE If you are familiar with C++, then you will find it helpful to know \nthat the Java collections technology is similar in spirit to the Standard \nTemplate Library ( STL ) defined by C++. What C++ calls a container, Java \ncalls a collection. However, there are significant differences between the \nCollections Framework and the STL. It is important to not jump to \nconclusions. \n\nJDK 5 Changed the Collections Framework \n\nWhen JDK 5 was released, some fundamental changes were made to the Collections \n\nFramework that significantly increased its power and streamlined its use. These changes",
    "When JDK 5 was released, some fundamental changes were made to the Collections \n\nFramework that significantly increased its power and streamlined its use. These changes \n\n\ninclude the addition of generics, autoboxing/unboxing, and the for-each style for loop. \nAlthough JDK 8 is three major Java releases after JDK 5, the effects of the JDK 5 features \nwere so profound that they still warrant special attention. The main reason is that you may \nencounter pre-JDK 5 code. Understanding the effects and reasons for the changes is \nimportant if you will be maintaining or updating older code. \n\nGenerics Fundamentally Changed the Collections Framework",
    "The addition of generics caused a significant change to the Collections Framework because \nthe entire Collections Framework was reengineered for it. All collections are now generic, \nand many of the methods that operate on collections take generic type parameters. Simply \nput, the addition of generics affected every part of the Collections Framework. \nGenerics added the one feature that collections had been missing: type safety. Prior to \ngenerics, all collections stored Object references, which meant that any collection could \nstore any type of object. Thus, it was possible to accidentally store incompatible types in a \ncollection. Doing so could result in run-time type mismatch errors. With generics, it is \npossible to explicitly state the type of data being stored, and run-time type mismatch errors \ncan be avoided",
    ". Doing so could result in run-time type mismatch errors. With generics, it is \npossible to explicitly state the type of data being stored, and run-time type mismatch errors \ncan be avoided. \nAlthough the addition of generics changed the declarations of most of its classes and \ninterfaces, and several of their methods, overall, the Collections Framework still works the \nsame as it did prior to generics. Of course, to gain the advantages that generics bring \ncollections, older code will need to be rewritten. This is also important because pre-generics \ncode will generate warning messages when compiled by a modern Java compiler. To \neliminate these warnings, you will need to add type information to all your collections code.",
    "Autoboxing Facilitates the Use of Primitive Types \n\nAutoboxing/unboxing facilitates the storing of primitive types in collections. As you will see, \na collection can store only references, not primitive values. In the past, if you wanted to \nstore a primitive value, such as an int , in a collection, you had to manually box it into its \ntype wrapper. When the value was retrieved, it needed to be manually unboxed ( by using an \nexplicit cast ) into its proper primitive type. Because of autoboxing/unboxing, Java can \nautomatically perform the proper boxing and unboxing needed when storing or retrieving \nprimitive types. There is no need to manually perform these operations. \n\nThe For-Each Style for Loop",
    "The For-Each Style for Loop \n\nAll collection classes in the Collections Framework were retrofitted to implement the \nIterable interface, which means that a collection can be cycled through by use of the foreach style for loop. In the past, cycling through a collection required the use of an iterator \n( described later in this chapter ), with the programmer manually constructing the loop. \n\nAlthough iterators are still needed for some uses, in many cases, iterator-based loops can be \nreplaced by for loops. \n\nThe Collection Interfaces \n\n\nThe Collections Framework defines several core interfaces. This section provides an \n\noverview of each interface. Beginning with the collection interfaces is necessary because \nthey determine the fundamental nature of the collection classes. Put differently, the concrete \nclasses simply provide different implementations of the standard interfaces. The interfaces \nthat underpin collections are summarized in the following table:",
    "Interface \nDescription \n\nCollection \nEnables you to work with groups of objects ; it is at the top of the \ncollections hierarchy. \n\nDeque \nExtends Queue to handle a double-ended queue. \n\nList \nExtends Collection to handle sequences ( lists of objects ). \n\nNavigableSet \nExtends SortedSet to handle retrieval of elements based on \nclosest-match searches. \n\nQueue \nExtends Collection to handle special types of lists in which \nelements are removed only from the head. \n\nSet \nExtends Collection to handle sets, which must contain unique \nelements. \n\nSortedSet \nExtends Set to handle sorted sets.",
    "In addition to the collection interfaces, collections also use the Comparator , \nRandomAccess , Iterator , and ListIterator interfaces, which are described in depth \nlater in this chapter. Beginning with JDK 8, Spliterator can also be used. Briefly, \nComparator defines how two objects are compared ; Iterator , ListIterator , and \nSpliterator enumerate the objects within a collection. By implementing RandomAccess , \na list indicates that it supports efficient, random access to its elements. \nTo provide the greatest flexibility in their use, the collection interfaces allow some methods \nto be optional. The optional methods enable you to modify the contents of a collection. \nCollections that support these methods are called modifiable . Collections that do not allow \ntheir contents to be changed are called unmodifiable . If an attempt is made to use one of \nthese methods on an unmodifiable collection, an UnsupportedOperationException is \nthrown",
    ". If an attempt is made to use one of \nthese methods on an unmodifiable collection, an UnsupportedOperationException is \nthrown. All the built-in collections are modifiable. \nThe following sections examine the collection interfaces.",
    "The Collection Interface \n\nThe Collection interface is the foundation upon which the Collections Framework is built \n\nbecause it must be implemented by any class that defines a collection. Collection is a \ngeneric interface that has this declaration: \n\ninterface Collection<E> \n\n\nHere, E specifies the type of objects that the collection will hold. Collection",
    "extends the Iterable interface. This means that all collections can be cycled \nthrough by use of the for-each style for loop. ( Recall that only classes that \nimplement Iterable can be cycled through by the for .) \nCollection declares the core methods that all collections will have. These methods are \nsummarized in Table 18-1. Because all collections implement Collection , familiarity with \nits methods is necessary for a clear understanding of the framework. Several of these \nmethods can throw an UnsupportedOperationException . As explained, this occurs if a \ncollection cannot be modified. A ClassCastException is generated when one object is \nincompatible with another, such as when an attempt is made to add an incompatible object \nto a collection. A NullPointerException is thrown if an attempt is made to store a null \nobject and null elements are not allowed in the collection. An \nIllegalArgumentException is thrown if an invalid argument is used",
    ". An \nIllegalArgumentException is thrown if an invalid argument is used. An \nIllegalStateException is thrown if an attempt is made to add an element to a fixed-length \ncollection that is full.",
    "Objects are added to a collection by calling add ( ) . Notice that add ( ) takes an argument of \ntype E , which means that objects added to a collection must be compatible with the type of \ndata expected by the collection. You can add the entire contents of one collection to another \nby calling addAll ( ) . \nYou can remove an object by using remove ( ) . To remove a group of objects, call \nremoveAll ( ) . You can remove all elements except those of a specified group by calling \nretainAll ( ) . Beginning with JDK 8, to remove an element only if it statisfies some \ncondition, you can use removeIf ( ) . ( Predicate is a functional interface added by JDK 8. \nSee Chapter 19.) To empty a collection, call clear ( ) . \nYou can determine whether a collection contains a specific object by calling contains ( ) . To \ndetermine whether one collection contains all the members of another, call containsAll ( ) . \nYou can determine when a collection is empty by calling isEmpty ( )",
    ". To \ndetermine whether one collection contains all the members of another, call containsAll ( ) . \nYou can determine when a collection is empty by calling isEmpty ( ) . The number of \nelements currently held in a collection can be determined by calling size ( ) . \nThe toArray ( ) methods return an array that contains the elements stored in the invoking \ncollection. The first returns an array of Object . The second returns an array of elements \nthat have the same type as the array specified as a parameter. Normally, the second form is",
    "more convenient because it returns the desired array type. These methods are more \n\nimportant than it might at first seem. Often, processing the contents of a collection by using \narray-like syntax is advantageous. By providing a pathway between collections and arrays, \nyou can have the best of both worlds. \nTwo collections can be compared for equality by calling equals ( ) . The precise meaning of \n\u201cequality\u201d may differ from collection to collection. For example, you can implement equals (",
    ") so that it compares the values of elements stored in the collection. Alternatively, equals ( ) \ncan compare references to those elements. \nAnother important method is iterator ( ) , which returns an iterator to a collection. The new \nspliterator ( ) method returns a spliterator to the collection. Iterators are frequently used \nwhen working with collections. Finally, the stream ( ) and parallelStream ( ) methods \nreturn a Stream that uses the collection as a source of elements. ( See Chapter 29 for a \ndetailed discussion of the new Stream interface.) \n\nThe List Interface \n\nThe List interface extends Collection and declares the behavior of a collection that stores \na sequence of elements. Elements can be inserted or accessed by their position in the list, \nusing a zero-based index. A list may contain duplicate elements. List is a generic interface \nthat has this declaration: \n\ninterface List<E>",
    "Here, E specifies the type of objects that the list will hold. \nIn addition to the methods defined by Collection , List defines some of its own, which are \nsummarized in Table 18-2. Note again that several of these methods will throw an \nUnsupportedOperationException if the list cannot be modified, and a \nClassCastException is generated when one object is incompatible with another, such as \nwhen an attempt is made to add an incompatible object to a list. Also, several methods will \nthrow an IndexOutOfBoundsException if an invalid index is used. A \nNullPointerException is thrown if an attempt is made to store a null object and null \nelements are not allowed in the list. An IllegalArgumentException is thrown if an \ninvalid argument is used. \nTo the versions of add ( ) and addAll ( ) defined by Collection , List adds the methods \nadd ( int, E ) and addAll ( int, Collection ) . These methods insert elements at the specified \nindex",
    ". \nTo the versions of add ( ) and addAll ( ) defined by Collection , List adds the methods \nadd ( int, E ) and addAll ( int, Collection ) . These methods insert elements at the specified \nindex. Also, the semantics of add ( E ) and addAll ( Collection ) defined by Collection are \nchanged by List so that they add elements to the end of the list. You can modify each \nelement in the collection by using replaceAll ( ) . ( UnaryOperator is a functional",
    "To obtain the object stored at a specific location, call get ( ) with the index of the object. To \nassign a value to an element in the list, call set ( ) , specifying the index of the object to be \nchanged. To find the index of an object, use indexOf ( ) or lastIndexOf ( ) . \n\nYou can obtain a sublist of a list by calling subList ( ) , specifying the beginning and ending \nindexes of the sublist. As you can imagine, subList ( ) makes list processing quite \nconvenient. One way to sort a list is with the sort ( ) method defined by List . \n\nThe Set Interface \n\nThe Set interface defines a set. It extends Collection and specifies the behavior of a \n\ncollection that does not allow duplicate elements. Therefore, the add ( ) method returns \n\nfalse if an attempt is made to add duplicate elements to a set. It does not specify any \n\n\nadditional methods of its own. Set is a generic interface that has this declaration: \n\nTable 18-2    The Methods Declared by List \n\ninterface Set<E>",
    "additional methods of its own. Set is a generic interface that has this declaration: \n\nTable 18-2    The Methods Declared by List \n\ninterface Set<E> \n\nHere, E specifies the type of objects that the set will hold. \n\nThe SortedSet Interface \n\nThe SortedSet interface extends Set and declares the behavior of a set sorted in ascending \norder. SortedSet is a generic interface that has this declaration: \n\ninterface SortedSet<E> \n\nHere, E specifies the type of objects that the set will hold. \nIn addition to those methods provided by Set , the SortedSet interface declares the \nmethods summarized in Table 18-3. Several methods throw a NoSuchElementException \nwhen no items are contained in the invoking set. A ClassCastException is thrown when \nan object is incompatible with the elements in a set. A NullPointerException is thrown if",
    "an attempt is made to use a null object and null is not allowed in the set. An \nIllegalArgumentException is thrown if an invalid argument is used. \nSortedSet defines several methods that make set processing more convenient. To obtain \nthe first object in the set, call first ( ) . To get the last element, use last ( ) . You can obtain a \nsubset of a sorted set by calling subSet ( ) , specifying the first and last object in the set. If \nyou need the subset that starts with the first element in the set, use headSet ( ) . If you want \nthe subset that ends the set, use tailSet ( ) . \n\nTable 18-3    The Methods Declared by SortedSet \n\nThe NavigableSet Interface \n\nThe NavigableSet interface extends SortedSet and declares the behavior of a collection \nthat supports the retrieval of elements based on the closest match to a given value or values. \nNavigableSet is a generic interface that has this declaration: \n\ninterface NavigableSet<E>",
    "interface NavigableSet<E> \n\nHere, E specifies the type of objects that the set will hold. In addition to the \nmethods that it inherits from SortedSet , NavigableSet adds those summarized \nin Table 18-4. A ClassCastException is thrown when an object is incompatible \nwith the elements in the set. A NullPointerException is thrown if an attempt is \nmade to use a null object and null is not allowed in the set. An \nIllegalArgumentException is thrown if an invalid argument is used. \n\n\nTable 18-4    The Methods Declared by NavigableSet \n\nThe Queue Interface \n\nThe Queue interface extends Collection and declares the behavior of a queue, which is \noften a first-in, first-out list. However, there are types of queues in which the ordering is \nbased upon other criteria. Queue is a generic interface that has this declaration: \n\ninterface Queue<E>",
    "interface Queue<E> \n\nHere, E specifies the type of objects that the queue will hold. The methods \ndeclared by Queue are shown in Table 18-5. \nSeveral methods throw a ClassCastException when an object is incompatible with the \nelements in the queue. A NullPointerException is thrown if an attempt is made to store \na null object and null elements are not allowed in the queue. An \n\nIllegalArgumentException is thrown if an invalid argument is used. An \nIllegalStateException is thrown if an attempt is made to add an element to a fixed-length \nqueue that is full. A NoSuchElementException is thrown if an attempt is made to",
    "remove an element from an empty queue. \nDespite its simplicity, Queue offers several points of interest. First, elements can only be \nremoved from the head of the queue. Second, there are two methods that obtain and remove \nelements: poll ( ) and remove ( ) . The difference between them is that poll ( ) returns null \nif the queue is empty, but remove ( ) throws an exception. Third, there are two methods, \nelement ( ) and peek ( ) , that obtain but don\u2019t remove the element at the head of the \nqueue. They differ only in that element ( ) throws an exception if the queue is empty, but \npeek ( ) returns null . Finally, notice that offer ( ) only attempts to add an element to a \nqueue. Because some queues have a fixed length and might be full, offer ( ) can fail. \n\nTable 18-5    The Methods Declared by Queue \n\nThe Deque Interface",
    "Table 18-5    The Methods Declared by Queue \n\nThe Deque Interface \n\nThe Deque interface extends Queue and declares the behavior of a double-ended queue. \nDouble-ended queues can function as standard, first-in, first-out queues or as last-in, firstout stacks. Deque is a generic interface that has this declaration: \n\ninterface Deque<E> \n\nHere, E specifies the type of objects that the deque will hold. In addition to the \nmethods that it inherits from Queue , Deque adds those methods summarized in \n\nTable 18-6. Several methods throw a ClassCastException when an object is \n\nincompatible with the elements in the deque. A NullPointerException is thrown \nif an attempt is made to store a null object and null elements are not allowed in \nthe deque. An IllegalArgumentException is thrown if an invalid argument is \nused. An IllegalStateException is thrown if an attempt is made to add an",
    "element to a fixed-length deque that is full. A NoSuchElementException is \nthrown if an attempt is made to remove an element from an empty deque. \n\n\nTable 18-6    The Methods Declared by Deque \n\nNotice that Deque includes the methods push ( ) and pop ( ) . These methods enable a \n\nDeque to function as a stack. Also, notice the descendingIterator ( ) method. It returns \nan iterator that returns elements in reverse order. In other words, it returns an iterator that \nmoves from the end of the collection to the start. A Deque implementation can be capacityrestricted , which means that only a limited number of elements can be added to the deque. \nWhen this is the case, an attempt to add an element to the deque can fail. Deque allows you",
    "to handle such a failure in two ways. First, methods such as addFirst ( ) and addLast ( ) \nthrow an IllegalStateException if a capacity-restricted deque is full. Second, methods \nsuch as offerFirst ( ) and offerLast ( ) return false if the element cannot be added. \n\nThe Collection Classes \n\nNow that you are familiar with the collection interfaces, you are ready to examine the \nstandard classes that implement them. Some of the classes provide full implementations \nthat can be used as-is. Others are abstract, providing skeletal implementations that are used \nas starting points for creating concrete collections. As a general rule, the collection classes \nare not synchronized, but as you will see later in this chapter, it is possible to obtain \nsynchronized versions. \nThe core collection classes are summarized in the following table: \n\nClass \nDescription \n\nAbstractCollection \nImplements most of the Collection interface.",
    "Class \nDescription \n\nAbstractCollection \nImplements most of the Collection interface. \n\nAbstractList \nExtends AbstractCollection and implements most of the \nList interface. \n\nAbstractQueue \nExtends AbstractCollection and implements parts of the \nQueue interface. \n\nAbstractSequentialList \nExtends AbstractList for use by a collection that uses \nsequential rather than random access of its elements. \n\nLinkedList \nImplements a linked list by extending \nAbstractSequentialList . \n\nArrayList \nImplements a dynamic array by extending AbstractList . \n\nArrayDeque \nImplements a dynamic double-ended queue by extending \n\nAbstractCollection and implementing the Deque interface. \n\nAbstractSet \nExtends AbstractCollection and implements most of the \nSet interface. \n\nEnumSet \nExtends AbstractSet for use with enum elements. \n\nHashSet \nExtends AbstractSet for use with a hash table. \n\nLinkedHashSet \nExtends HashSet to allow insertion-order iterations.",
    "EnumSet \nExtends AbstractSet for use with enum elements. \n\nHashSet \nExtends AbstractSet for use with a hash table. \n\nLinkedHashSet \nExtends HashSet to allow insertion-order iterations. \n\nPriorityQueue \nExtends AbstractQueue to support a priority-based queue. \n\nTreeSet \nImplements a set stored in a tree. Extends AbstractSet . \n\nThe following sections examine the concrete collection classes and illustrate their use. \n\n\nNOTE In addition to the collection classes, several legacy classes, such as \nVector , Stack , and Hashtable , have been reengineered to support \ncollections. These are examined later in this chapter. \n\nThe ArrayList Class \n\nThe ArrayList class extends AbstractList and implements the List interface. ArrayList \nis a generic class that has this declaration: \n\nclass ArrayList<E>",
    "The ArrayList Class \n\nThe ArrayList class extends AbstractList and implements the List interface. ArrayList \nis a generic class that has this declaration: \n\nclass ArrayList<E> \n\nHere, E specifies the type of objects that the list will hold. \nArrayList supports dynamic arrays that can grow as needed. In Java, standard arrays are \nof a fixed length. After arrays are created, they cannot grow or shrink, which means that you \nmust know in advance how many elements an array will hold. But, sometimes, you may not \nknow until run time precisely how large an array you need. To handle this situation, the \nCollections Framework defines ArrayList . In essence, an ArrayList is a variable-length \narray of object references. That is, an ArrayList can dynamically increase or decrease in \nsize. Array lists are created with an initial size. When this size is exceeded, the collection is \nautomatically enlarged. When objects are removed, the array can be shrunk.",
    "NOTE Dynamic arrays are also supported by the legacy class Vector , \nwhich is described later in this chapter. \n\nArrayList has the constructors shown here: \n\nArrayList ( ) \n\nArrayList ( Collection<? extends E> c ) \nArrayList ( int capacity ) \n\nThe first constructor builds an empty array list. The second constructor builds an \narray list that is initialized with the elements of the collection c. The third \nconstructor builds an array list that has the specified initial capacity . The capacity \nis the size of the underlying array that is used to store the elements. The capacity \ngrows automatically as elements are added to an array list. \nThe following program shows a simple use of ArrayList . An array list is created for objects \nof type String , and then several strings are added to it. ( Recall that a quoted string is \n\ntranslated into a String object.) The list is then displayed. Some of the elements are \n\nremoved and the list is displayed again.",
    "translated into a String object.) The list is then displayed. Some of the elements are \n\nremoved and the list is displayed again. \n\n\nThe output from this program is shown here:",
    "Notice that a1 starts out empty and grows as elements are added to it. When elements are \nremoved, its size is reduced. \nIn the preceding example, the contents of a collection are displayed using the default \nconversion provided by toString ( ) , which was inherited from AbstractCollection . \nAlthough it is sufficient for short, sample programs, you seldom use this method to display \nthe contents of a real-world collection. Usually, you provide your own output routines. But, \nfor the next few examples, the default output created by toString ( ) is sufficient. \nAlthough the capacity of an ArrayList object increases automatically as objects are stored \nin it, you can increase the capacity of an ArrayList object manually by calling \nensureCapacity ( ) . You might want to do this if you know in advance that you will be \nstoring many more items in the collection than it can currently hold",
    ". You might want to do this if you know in advance that you will be \nstoring many more items in the collection than it can currently hold. By increasing its \ncapacity once, at the start, you can prevent several reallocations later. Because reallocations \nare costly in terms of time, preventing unnecessary ones improves performance. The \nsignature for ensureCapacity ( ) is shown here:",
    "void ensureCapacity ( int cap ) \n\nHere, cap specifies the new minimum capacity of the collection. \nConversely, if you want to reduce the size of the array that underlies an ArrayList object so \nthat it is precisely as large as the number of items that it is currently holding, call \ntrimToSize ( ) , shown here: \n\nvoid trimToSize ( ) \n\nObtaining an Array from an ArrayList \n\nWhen working with ArrayList , you will sometimes want to obtain an actual array that \ncontains the contents of the list. You can do this by calling toArray ( ) , which is defined by \nCollection . Several reasons exist why you might want to convert a collection into an array, \nsuch as: \n\n\u2022  To obtain faster processing times for certain operations \n\n\u2022  To pass an array to a method that is not overloaded to accept a collection \n\n\u2022  To integrate collection-based code with legacy code that does not \nunderstand collections \n\nWhatever the reason, converting an ArrayList to an array is a trivial matter.",
    "\u2022  To integrate collection-based code with legacy code that does not \nunderstand collections \n\nWhatever the reason, converting an ArrayList to an array is a trivial matter. \n\nAs explained earlier, there are two versions of toArray ( ) , which are shown again here for \nyour convenience: \n\nobject[ ] toArray ( ) \n<T> T[ ] toArray ( T array [ ]) \n\nThe first returns an array of Object . The second returns an array of elements that \nhave the same type as T . Normally, the second form is more convenient because it \n\n\nreturns the proper type of array. The following program demonstrates its use: \n\nThe output from the program is shown here: \n\nThe program begins by creating a collection of integers. Next, toArray ( ) is called and it \nobtains an array of Integer s. Then, the contents of that array are summed by use of a foreach style for loop.",
    "There is something else of interest in this program. As you know, collections can store only \nreferences, not values of primitive types. However, autoboxing makes it possible to pass \nvalues of type int to add ( ) without having to manually wrap them within an Integer , as \nthe program shows. Autoboxing causes them to be automatically wrapped. In this way, \nautoboxing significantly improves the ease with which collections can be used to store \nprimitive values. \n\n\nThe LinkedList Class \n\nThe LinkedList class extends AbstractSequentialList and implements the List , Deque , \nand Queue interfaces. It provides a linked-list data structure. LinkedList is a generic class \nthat has this declaration: \n\nclass LinkedList<E> \n\nHere, E specifies the type of objects that the list will hold. LinkedList has the two \nconstructors shown here: \n\nLinkedList ( ) \nLinkedList ( Collection<? extends E> c )",
    "class LinkedList<E> \n\nHere, E specifies the type of objects that the list will hold. LinkedList has the two \nconstructors shown here: \n\nLinkedList ( ) \nLinkedList ( Collection<? extends E> c ) \n\nThe first constructor builds an empty linked list. The second constructor builds a \nlinked list that is initialized with the elements of the collection c . \nBecause LinkedList implements the Deque interface, you have access to the methods \ndefined by Deque . For example, to add elements to the start of a list, you can use \naddFirst ( ) or offerFirst ( ) . To add elements to the end of the list, use addLast ( ) or \nofferLast ( ) . To obtain the first element, you can use getFirst ( ) or peekFirst ( ) . To \nobtain the last element, use getLast ( ) or peekLast ( ) . To remove the first element, use \nremoveFirst ( ) or pollFirst ( ) . To remove the last element, use removeLast ( ) or \npollLast ( ) . \nThe following program illustrates LinkedList :",
    "The output from this program is shown here: \n\n\nBecause LinkedList implements the List interface, calls to add ( E ) append items to the \nend of the list, as do calls to addLast ( ) . To insert items at a specific location, use the \nadd ( int, E ) form of add ( ) , as illustrated by the call to add ( 1, \"A2\") in the example. \nNotice how the third element in ll is changed by employing calls to get ( ) and set ( ) . To \nobtain the current value of an element, pass get ( ) the index at which the element is stored. \nTo assign a new value to that index, pass set ( ) the index and its new value. \n\nThe HashSet Class \n\nHashSet extends AbstractSet and implements the Set interface. It creates a collection \nthat uses a hash table for storage. HashSet is a generic class that has this declaration: \n\nclass HashSet<E>",
    "HashSet extends AbstractSet and implements the Set interface. It creates a collection \nthat uses a hash table for storage. HashSet is a generic class that has this declaration: \n\nclass HashSet<E> \n\nHere, E specifies the type of objects that the set will hold. \nAs most readers likely know, a hash table stores information by using a mechanism called \nhashing. In hashing , the informational content of a key is used to determine a unique value, \ncalled its hash code . The hash code is then used as the index at which the data associated \nwith the key is stored. The transformation of the key into its hash code is performed \nautomatically\u2014you never see the hash code itself. Also, your code can\u2019t directly index the \nhash table. The advantage of hashing is that it allows the execution time of add ( ) , \ncontains ( ) , remove ( ) , and size ( ) to remain constant even for large sets. \nThe following constructors are defined: \n\nHashSet ( )",
    "HashSet ( ) \n\nHashSet ( Collection<? extends E> c ) \nHashSet ( int capacity ) \nHashSet ( int capacity , float fillRatio ) \n\nThe first form constructs a default hash set. The second form initializes the hash \nset by using the elements of c . The third form initializes the capacity of the hash \nset to capacity . ( The default capacity is 16.) The fourth form initializes both the \ncapacity and the fill ratio ( also called load capacity ) of the hash set from its \narguments. The fill ratio must be between 0.0 and 1.0, and it determines how full \nthe hash set can be before it is resized upward. Specifically, when the number of \nelements is greater than the capacity of the hash set multiplied by its fill ratio, the \n\nhash set is expanded. For constructors that do not take a fill ratio, 0.75 is used. \nHashSet does not define any additional methods beyond those provided by its superclasses \nand interfaces.",
    "hash set is expanded. For constructors that do not take a fill ratio, 0.75 is used. \nHashSet does not define any additional methods beyond those provided by its superclasses \nand interfaces. \n\n\nIt is important to note that HashSet does not guarantee the order of its elements, because \nthe process of hashing doesn\u2019t usually lend itself to the creation of sorted sets. If you need \nsorted storage, then another collection, such as TreeSet , is a better choice. \nHere is an example that demonstrates HashSet : \n\nThe following is the output from this program: \n\nAs explained, the elements are not stored in sorted order, and the precise output may vary. \n\nThe LinkedHashSet Class \n\nThe LinkedHashSet class extends HashSet and adds no members of its own. It is a \ngeneric class that has this declaration: \n\nclass LinkedHashSet<E> \n\nHere, E specifies the type of objects that the set will hold. Its constructors parallel \nthose in HashSet .",
    "class LinkedHashSet<E> \n\nHere, E specifies the type of objects that the set will hold. Its constructors parallel \nthose in HashSet . \n\nLinkedHashSet maintains a linked list of the entries in the set, in the order in which they \nwere inserted. This allows insertion-order iteration over the set. That is, when cycling \nthrough a LinkedHashSet using an iterator, the elements will be returned in the order in \nwhich they were inserted. This is also the order in which they are contained in the string \nreturned by toString ( ) when called on a LinkedHashSet object. To see the effect of \nLinkedHashSet , try substituting LinkedHashSet for HashSet in the preceding \n\nprogram. The output will be \n\n\nwhich is the order in which the elements were inserted. \n\nThe TreeSet Class",
    "program. The output will be \n\n\nwhich is the order in which the elements were inserted. \n\nThe TreeSet Class \n\nTreeSet extends AbstractSet and implements the NavigableSet interface. It creates a \ncollection that uses a tree for storage. Objects are stored in sorted, ascending order. Access \nand retrieval times are quite fast, which makes TreeSet an excellent choice when storing \nlarge amounts of sorted information that must be found quickly. \nTreeSet is a generic class that has this declaration: \n\nclass TreeSet<E> \n\nHere, E specifies the type of objects that the set will hold. \nTreeSet has the following constructors: \n\nTreeSet ( ) \nTreeSet ( Collection<? extends E> c ) \nTreeSet ( Comparator<? super E> comp ) \nTreeSet ( SortedSet<E> ss )",
    "TreeSet ( ) \nTreeSet ( Collection<? extends E> c ) \nTreeSet ( Comparator<? super E> comp ) \nTreeSet ( SortedSet<E> ss ) \n\nThe first form constructs an empty tree set that will be sorted in ascending order \naccording to the natural order of its elements. The second form builds a tree set \nthat contains the elements of c . The third form constructs an empty tree set that \nwill be sorted according to the comparator specified by comp . ( Comparators are \ndescribed later in this chapter.) The fourth form builds a tree set that contains the \nelements of ss . \nHere is an example that demonstrates a TreeSet : \n\n\nThe output from this program is shown here:",
    "The output from this program is shown here: \n\nAs explained, because TreeSet stores its elements in a tree, they are automatically arranged \nin sorted order, as the output confirms. \nBecause TreeSet implements the NavigableSet interface, you can use the methods \ndefined by NavigableSet to retrieve elements of a TreeSet . For example, assuming the \npreceding program, the following statement uses subSet ( ) to obtain a subset of ts that \ncontains the elements between C ( inclusive ) and F ( exclusive ). It then displays the resulting \nset. \n\nThe output from this statement is shown here: \n\nYou might want to experiment with the other methods defined by NavigableSet . \n\nThe PriorityQueue Class \n\nPriorityQueue extends AbstractQueue and implements the Queue interface. It creates \na queue that is prioritized based on the queue\u2019s comparator. PriorityQueue is a generic \nclass that has this declaration: \n\nclass PriorityQueue<E>",
    "class PriorityQueue<E> \n\n\nHere, E specifies the type of objects stored in the queue. PriorityQueue s are \ndynamic, growing as necessary. \nPriorityQueue defines the six constructors shown here: \n\nPriorityQueue ( ) \nPriorityQueue ( int capacity ) \nPriorityQueue ( Comparator<? super E> comp ) ( Added by JDK 8.) \nPriorityQueue ( int capacity , Comparator<? super E> comp ) \nPriorityQueue ( Collection<? extends E> c ) \nPriorityQueue ( PriorityQueue<? extends E> c ) \nPriorityQueue ( SortedSet<? extends E> c )",
    "The first constructor builds an empty queue. Its starting capacity is 11. The second \nconstructor builds a queue that has the specified initial capacity. The third \nconstructor specifies a comparator, and the fourth builds a queue with the \nspecified capacity and comparator. The last three constructors create queues that \nare initialized with the elements of the collection passed in c . In all cases, the \ncapacity grows automatically as elements are added. \nIf no comparator is specified when a PriorityQueue is constructed, then the default \ncomparator for the type of data stored in the queue is used. The default comparator will \norder the queue in ascending order. Thus, the head of the queue will be the smallest value. \nHowever, by providing a custom comparator, you can specify a different ordering scheme. \nFor example, when storing items that include a time stamp, you could prioritize the queue \nsuch that the oldest items are first in the queue",
    ". \nFor example, when storing items that include a time stamp, you could prioritize the queue \nsuch that the oldest items are first in the queue. \nYou can obtain a reference to the comparator used by a PriorityQueue by calling its \ncomparator ( ) method, shown here:",
    "Comparator<? super E> comparator ( ) \n\nIt returns the comparator. If natural ordering is used for the invoking queue, null \nis returned. \nOne word of caution: Although you can iterate through a PriorityQueue using an iterator, \nthe order of that iteration is undefined. To properly use a PriorityQueue , you must call \nmethods such as offer ( ) and poll ( ) , which are defined by the Queue interface. \n\nThe ArrayDeque Class \n\nThe ArrayDeque class extends AbstractCollection and implements the Deque \ninterface. It adds no methods of its own. ArrayDeque creates a dynamic array and has no \ncapacity restrictions. ( The Deque interface supports implementations that restrict capacity, \nbut does not require such restrictions.) ArrayDeque is a generic class that has this \ndeclaration: \n\nclass ArrayDeque<E> \n\nHere, E specifies the type of objects stored in the collection. \n\n\nArrayDeque defines the following constructors:",
    "class ArrayDeque<E> \n\nHere, E specifies the type of objects stored in the collection. \n\n\nArrayDeque defines the following constructors: \n\nArrayDeque ( ) \nArrayDeque ( int size ) \nArrayDeque ( Collection<? extends E> c ) \n\nThe first constructor builds an empty deque. Its starting capacity is 16. The second \nconstructor builds a deque that has the specified initial capacity. The third \nconstructor creates a deque that is initialized with the elements of the collection \npassed in c . In all cases, the capacity grows as needed to handle the elements \nadded to the deque. \nThe following program demonstrates ArrayDeque by using it to create a stack: \n\nThe output is shown here: \n\nThe EnumSet Class \n\nEnumSet extends AbstractSet and implements Set . It is specifically for use with elements \nof an enum type. It is a generic class that has this declaration: \n\nclass EnumSet<E extends Enum<E>>",
    "EnumSet extends AbstractSet and implements Set . It is specifically for use with elements \nof an enum type. It is a generic class that has this declaration: \n\nclass EnumSet<E extends Enum<E>> \n\n\nHere, E specifies the elements. Notice that E must extend Enum<E> , which \nenforces the requirement that the elements must be of the specified enum type. \nEnumSet defines no constructors. Instead, it uses the factory methods shown in Table 18-7 \nto create objects. All methods can throw NullPointerException . The copyOf ( ) and \nrange ( ) methods can also throw IllegalArgumentException . Notice that the of ( ) \nmethod is overloaded a number of times. This is in the interest of efficiency. Passing a \nknown number of arguments can be faster than using a vararg parameter when the number \nof arguments is small. \n\nAccessing a Collection via an Iterator",
    "Accessing a Collection via an Iterator \n\nOften, you will want to cycle through the elements in a collection. For example, you might \nwant to display each element. One way to do this is to employ an iterator , which is an \nobject that implements either the Iterator or the ListIterator interface. Iterator enables \nyou to cycle through a collection, obtaining or removing elements. ListIterator extends \nIterator to allow bidirectional traversal of a list, and the modification of elements. \nIterator and ListIterator are generic interfaces which are declared as shown here: \n\ninterface Iterator<E> \ninterface ListIterator<E>",
    "interface Iterator<E> \ninterface ListIterator<E> \n\nHere, E specifies the type of objects being iterated. The Iterator interface declares \nthe methods shown in Table 18-8. The methods declared by ListIterator ( along \nwith those inherited from Iterator ) are shown in Table 18-9. In both cases, \noperations that modify the underlying collection are optional. For example, \nremove ( ) will throw UnsupportedOperationException when used with a \nread-only collection. Various other exceptions are possible. \n\n\nTable 18-7    The Methods Declared by EnumSet \n\nTable 18-8    The Methods Declared by Iterator \n\n\nTable 18-9    The Methods Provided by ListIterator \n\nNOTE Beginning with JDK 8, you can also use a Spliterator to cycle \nthrough a collection. Spliterator works differently than does Iterator , \nand it is described later in this chapter. \n\nUsing an Iterator \n\nBefore you can access a collection through an iterator, you must obtain one. Each of the",
    "Using an Iterator \n\nBefore you can access a collection through an iterator, you must obtain one. Each of the \n\ncollection classes provides an iterator ( ) method that returns an iterator to the start of the \ncollection. By using this iterator object, you can access each element in the collection, one \nelement at a time. In general, to use an iterator to cycle through the contents of a collection, \nfollow these steps: \n\n1.  Obtain an iterator to the start of the collection by calling the collection\u2019s \niterator ( ) method. \n\n2.  Set up a loop that makes a call to hasNext ( ) . Have the loop iterate as \n\nlong as hasNext ( ) returns true . \n\n3.  Within the loop, obtain each element by calling next ( ) . \n\nFor collections that implement List , you can also obtain an iterator by calling",
    "long as hasNext ( ) returns true . \n\n3.  Within the loop, obtain each element by calling next ( ) . \n\nFor collections that implement List , you can also obtain an iterator by calling \n\n\nlistIterator ( ) . As explained, a list iterator gives you the ability to access the \ncollection in either the forward or backward direction and lets you modify an \nelement. Otherwise, ListIterator is used just like Iterator . \nThe following example implements these steps, demonstrating both the Iterator and \nListIterator interfaces. It uses an ArrayList object, but the general principles apply to \nany type of collection. Of course, ListIterator is available only to those collections that \nimplement the List interface. \n\n\nThe output is shown here:",
    "The output is shown here: \n\n\nPay special attention to how the list is displayed in reverse. After the list is modified, litr \npoints to the end of the list. ( Remember, litr.hasNext ( ) returns false when the end of the \nlist has been reached.) To traverse the list in reverse, the program continues to use litr , but \nthis time it checks to see whether it has a previous element. As long as it does, that element \nis obtained and displayed. \n\nThe For-Each Alternative to Iterators",
    "The For-Each Alternative to Iterators \n\nIf you won\u2019t be modifying the contents of a collection or obtaining elements in reverse \norder, then the for-each version of the for loop is often a more convenient alternative to \ncycling through a collection than is using an iterator. Recall that the for can cycle through \nany collection of objects that implement the Iterable interface. Because all of the collection \nclasses implement this interface, they can all be operated upon by the for . \nThe following example uses a for loop to sum the contents of a collection: \n\nThe output from the program is shown here: \n\n\nAs you can see, the for loop is substantially shorter and simpler to use than the iteratorbased approach. However, it can only be used to cycle through a collection in the forward \ndirection, and you can\u2019t modify the contents of the collection. \n\nSpliterators",
    "Spliterators \n\nJDK 8 adds a new type of iterator called a spliterator that is defined by the Spliterator \ninterface. A spliterator cycles through a sequence of elements, and in this regard, it is \nsimilar to the iterators just described. However, the techniques required to use it differ. \nFurthermore, it offers substantially more functionality than does either Iterator or \nListIterator . Perhaps the most important aspect of Spliterator is its ability to provide \nsupport for parallel iteration of portions of the sequence. Thus, Spliterator supports \nparallel programming. ( See Chapter 28 for information on concurrency and parallel \nprogramming.) However, you can use Spliterator even if you won\u2019t be using parallel \nexecution. One reason you might want to do so is because it offers a streamlined approach \nthat combines the hasNext and next operations into one method. \nSpliterator is a generic interface that is declared like this: \n\ninterface Spliterator<T>",
    "interface Spliterator<T> \n\nHere, T is the type of elements being iterated. Spliterator declares the methods \nshown in Table 18-10. \nUsing Spliterator for basic iteration tasks is quite easy: simply call tryAdvance ( ) until it \nreturns false . If you will be applying the same action to each element in the sequence, \nforEachRemaining ( ) offers a streamlined alternative. In both cases, the action that will \noccur with each iteration is defined by what the Consumer object does with each element. \nConsumer is a functional interface that applies an action to an object. It is a generic \nfunctional interface declared in java.util.function . ( See Chapter 19 for information on \njava.util.function .) Consumer specifies only one abstract method, accept ( ) , which is \nshown here: \n\nvoid accept ( T objRef ) \n\nIn the case of tryAdvance ( ) , each iteration passes the next element in the \nsequence to objRef . Often, the easiest way to implement Consumer is by use of a \n\nlambda expression.",
    "In the case of tryAdvance ( ) , each iteration passes the next element in the \nsequence to objRef . Often, the easiest way to implement Consumer is by use of a \n\nlambda expression. \n\n\nTable 18-10    The Methods Declared by Spliterator \n\nThe following program provides a simple example of Spliterator . Notice that the program \ndemonstrates both tryAdvance ( ) and forEachRemaining ( ) . Also notice how these \nmethods combine the actions of Iterator \u2019s next ( ) and hasNext ( ) methods into a single \ncall. \n\n\nThe output is shown here:",
    "The output is shown here: \n\n\nAlthough this program demonstrates the mechanics of using Spliterator , it does not reveal \nits full power. As mentioned, Spliterator \u2019s maximum benefit is found in situations that \ninvolve parallel processing. \nIn Table 18-10, notice the methods characteristics ( ) and hasCharacteristics ( ) . Each \nSpliterator has a set of attributes, called characteristics , associated with it. These are \ndefined by static int fields in Spliterator , such as SORTED , DISTINCT , SIZED , and \nIMMUTABLE , to name a few. You can obtain the characteristics by calling \ncharacteristics ( ) . You can determine if a characteristic is present by calling \nhasCharacteristics ( ) . Often, you won\u2019t need to access a Spliterator \u2019s characteristics, \nbut in some cases, they can aid in creating efficient, resilient code. \n\nNOTE For a further discussion of Spliterator , see Chapter 29, where it",
    "NOTE For a further discussion of Spliterator , see Chapter 29, where it \n\nis used in the context of the new stream API. For a discussion of lambda \nexpressions, see Chapter 15. See Chapter 28 for a discussion of parallel \nprogramming and concurrency. \n\nThere are several nested subinterfaces of Spliterator designed for use with the primitive \ntypes double , int , and long . These are called Spliterator.OfDouble , \nSpliterator.OfInt , and Spliterator.OfLong . There is also a generalized version called \nSpliterator.OfPrimitive ( ) , which offers additional flexibility and serves as a \nsuperinterface of the aforementioned ones. \n\nStoring User-Defined Classes in Collections \n\nFor the sake of simplicity, the foregoing examples have stored built-in objects, such as",
    "Storing User-Defined Classes in Collections \n\nFor the sake of simplicity, the foregoing examples have stored built-in objects, such as \n\n\nString or Integer , in a collection. Of course, collections are not limited to the storage of \nbuilt-in objects. Quite the contrary. The power of collections is that they can store any type \nof object, including objects of classes that you create. For example, consider the following \nexample that uses a LinkedList to store mailing addresses: \n\n\nThe output from the program is shown here:",
    "The output from the program is shown here: \n\nAside from storing a user-defined class in a collection, another important thing to notice \nabout the preceding program is that it is quite short. When you consider that it sets up a \nlinked list that can store, retrieve, and process mailing addresses in about 50 lines of code, \nthe power of the Collections Framework begins to become apparent. As most readers know, \nif all of this functionality had to be coded manually, the program would be several times \nlonger. Collections offer off-the-shelf solutions to a wide variety of programming problems. \nYou should use them whenever the situation presents itself. \n\nThe RandomAccess Interface",
    "The RandomAccess Interface \n\nThe RandomAccess interface contains no members. However, by implementing this \ninterface, a collection signals that it supports efficient random access to its elements. \nAlthough a collection might support random access, it might not do so efficiently. By \nchecking for the RandomAccess interface, client code can determine at run time whether \na collection is suitable for certain types of random access operations\u2014especially as they \napply to large collections. ( You can use instanceof to determine if a class implements an \ninterface.) RandomAccess is implemented by ArrayList and by the legacy Vector class, \namong others. \n\nWorking with Maps \n\nA map is an object that stores associations between keys and values, or key/value pairs . \nGiven a key, you can find its value. Both keys and values are objects. The keys must be \nunique, but the values may be duplicated. Some maps can accept a null key and null",
    "values, others cannot. \nThere is one key point about maps that is important to mention at the outset: they don\u2019t \nimplement the Iterable interface. This means that you cannot cycle through a map using a \nfor-each style for loop. Furthermore, you can\u2019t obtain an iterator to a map. However, as you \nwill soon see, you can obtain a collection-view of a map, which does allow the use of either \nthe for loop or an iterator. \n\n\nThe Map Interfaces \n\nBecause the map interfaces define the character and nature of maps, this discussion of maps \nbegins with them. The following interfaces support maps: \n\nInterface \nDescription \n\nMap \nMaps unique keys to values. \n\nMap.Entry \nDescribes an element ( a key/value pair ) in a map. This is an \ninner class of Map . \n\nNavigableMap \nExtends SortedMap to handle the retrieval of entries based on \nclosest-match searches. \n\nSortedMap \nExtends Map so that the keys are maintained in ascending \norder. \n\nEach interface is examined next, in turn.",
    "SortedMap \nExtends Map so that the keys are maintained in ascending \norder. \n\nEach interface is examined next, in turn. \n\nThe Map Interface \nThe Map interface maps unique keys to values. A key is an object that you use to retrieve a \nvalue at a later date. Given a key and a value, you can store the value in a Map object. After \nthe value is stored, you can retrieve it by using its key. Map is generic and is declared as \nshown here: \n\ninterface Map<K, V>",
    "Here, K specifies the type of keys, and V specifies the type of values. \nThe methods declared by Map are summarized in Table 18-11. Several methods throw a \nClassCastException when an object is incompatible with the elements in a map. A \nNullPointerException is thrown if an attempt is made to use a null object and null is \nnot allowed in the map. An UnsupportedOperationException is thrown when an \nattempt is made to change an unmodifiable map. An IllegalArgumentException is \nthrown if an invalid argument is used. \nMaps revolve around two basic operations: get ( ) and put ( ) . To put a value into a map, \nuse put ( ) , specifying the key and the value. To obtain a value, call get ( ) , passing the key \nas an argument. The value is returned. \nAs mentioned earlier, although part of the Collections Framework, maps are not, \nthemselves, collections because they do not implement the Collection interface. However, \nyou can obtain a collection-view of a map",
    ". However, \nyou can obtain a collection-view of a map. To do this, you can use the entrySet ( ) method. \nIt returns a Set that contains the elements in the map. To obtain a collection-view of the",
    "keys, use keySet ( ) . To get a collection-view of the values, use values ( ) . For all three \ncollection-views, the collection is backed by the map. Changing one affects the other. \nCollection-views are the means by which maps are integrated into the larger Collections \n\n\nFramework. \n\n\nTable 18-11    The Methods Declared by Map \n\nThe SortedMap Interface \n\nThe SortedMap interface extends Map . It ensures that the entries are maintained in \nascending order based on the keys. SortedMap is generic and is declared as shown here: \n\ninterface SortedMap<K, V>",
    "interface SortedMap<K, V> \n\nHere, K specifies the type of keys, and V specifies the type of values. \nThe methods declared by SortedMap are summarized in Table 18-12. Several methods \nthrow a NoSuchElementException when no items are in the invoking map. A \nClassCastException is thrown when an object is incompatible with the elements in a \nmap. A NullPointerException is thrown if an attempt is made to use a null object when \nnull is not allowed in the map. An IllegalArgumentException is thrown if an invalid \n\nargument is used. \nSorted maps allow very efficient manipulations of submaps ( in other words, subsets of a \n\n\nmap ). To obtain a submap, use headMap ( ) , tailMap ( ) , or subMap ( ) . The submap \nreturned by these methods is backed by the invoking map. Changing one changes the other. \nTo get the first key in the set, call firstKey ( ) . To get the last key, use lastKey ( ) .",
    "The NavigableMap Interface \nThe NavigableMap interface extends SortedMap and declares the behavior of a map that \nsupports the retrieval of entries based on the closest match to a given key or keys. \nNavigableMap is a generic interface that has this declaration: \n\ninterface NavigableMap<K,V> \n\nHere, K specifies the type of the keys, and V specifies the type of the values \nassociated with the keys. In addition to the methods that it inherits from \nSortedMap , NavigableMap adds those summarized in Table 18-13. Several \nmethods throw a ClassCastException when an object is incompatible with the \nkeys in the map. A NullPointerException is thrown if an attempt is made to use \na null object and null keys are not allowed in the set. An \nIllegalArgumentException is thrown if an invalid argument is used. \n\nTable 18-12    The Methods Declared by SortedMap \n\n\n\n\nTable 18-13    The Methods Declared by NavigableMap",
    "Table 18-12    The Methods Declared by SortedMap \n\n\n\n\nTable 18-13    The Methods Declared by NavigableMap \n\nThe Map.Entry Interface \nThe Map.Entry interface enables you to work with a map entry. Recall that the entrySet ( \n) method declared by the Map interface returns a Set containing the map entries. Each of \nthese set elements is a Map.Entry object. Map.Entry is generic and is declared like this: \n\ninterface Map.Entry<K, V> \n\nHere, K specifies the type of keys, and V specifies the type of values. Table 18-14 \nsummarizes the non-static methods declared by Map.Entry . JDK 8 adds two \nstatic methods. The first is comparingByKey ( ) , which returns a Comparator \nthat compares entries by key. The second is comparingByValue ( ) , which \nreturns a Comparator that compares entries by value. \n\nTable 18-14    The Non-Static Methods Declared by Map.Entry \n\n\nThe Map Classes",
    "Table 18-14    The Non-Static Methods Declared by Map.Entry \n\n\nThe Map Classes \n\nSeveral classes provide implementations of the map interfaces. The classes that can be used \nfor maps are summarized here: \n\nClass \nDescription \n\nAbstractMap \nImplements most of the Map interface. \n\nEnumMap \nExtends AbstractMap for use with enum keys. \n\nHashMap \nExtends AbstractMap to use a hash table. \n\nTreeMap \nExtends AbstractMap to use a tree. \n\nWeakHashMap \nExtends AbstractMap to use a hash table with weak keys. \n\nLinkedHashMap \nExtends HashMap to allow insertion-order iterations. \n\nIdentityHashMap \nExtends AbstractMap and uses reference equality when \ncomparing documents. \n\nNotice that AbstractMap is a superclass for all concrete map implementations. \nWeakHashMap implements a map that uses \u201cweak keys,\u201d which allows an element in a \nmap to be garbage-collected when its key is otherwise unused. This class is not discussed \nfurther here. The other map classes are described next.",
    "The HashMap Class \nThe HashMap class extends AbstractMap and implements the Map interface. It uses a \nhash table to store the map. This allows the execution time of get ( ) and put ( ) to remain \nconstant even for large sets. HashMap is a generic class that has this declaration: \n\nclass HashMap<K, V> \n\nHere, K specifies the type of keys, and V specifies the type of values. \nThe following constructors are defined: \n\nHashMap ( ) \nHashMap ( Map<? extends K, ? extends V> m ) \nHashMap ( int capacity ) \nHashMap ( int capacity , float fillRatio ) \n\nThe first form constructs a default hash map. The second form initializes the hash \nmap by using the elements of m . The third form initializes the capacity of the hash \nmap to capacity . The fourth form initializes both the capacity and fill ratio of the \nhash map by using its arguments. The meaning of capacity and fill ratio is the same",
    "as for HashSet , described earlier. The default capacity is 16. The default fill ratio \nis 0.75. \nHashMap implements Map and extends AbstractMap . It does not add any methods of \n\n\nits own. \nYou should note that a hash map does not guarantee the order of its elements. Therefore, \nthe order in which elements are added to a hash map is not necessarily the order in which \nthey are read by an iterator. \nThe following program illustrates HashMap . It maps names to account balances. Notice \nhow a set-view is obtained and used. \n\nOutput from this program is shown here ( the precise order may vary ):",
    "Output from this program is shown here ( the precise order may vary ): \n\n\nThe program begins by creating a hash map and then adds the mapping of names to \nbalances. Next, the contents of the map are displayed by using a set-view, obtained by \ncalling entrySet ( ) . The keys and values are displayed by calling the getKey ( ) and \ngetValue ( ) methods that are defined by Map.Entry . Pay close attention to how the \ndeposit is made into John Doe\u2019s account. The put ( ) method automatically replaces any \npreexisting value that is associated with the specified key with the new value. Thus, after \nJohn Doe\u2019s account is updated, the hash map will still contain just one \"John Doe\" account.",
    "The TreeMap Class \nThe TreeMap class extends AbstractMap and implements the NavigableMap interface. \nIt creates maps stored in a tree structure. A TreeMap provides an efficient means of storing \nkey/value pairs in sorted order and allows rapid retrieval. You should note that, unlike a \nhash map, a tree map guarantees that its elements will be sorted in ascending key order. \nTreeMap is a generic class that has this declaration: \n\nclass TreeMap<K, V> \n\nHere, K specifies the type of keys, and V specifies the type of values. \nThe following TreeMap constructors are defined: \n\nTreeMap ( ) \n\nTreeMap ( Comparator<? super K> comp ) \nTreeMap ( Map<? extends K, ? extends V> m ) \nTreeMap ( SortedMap<K, ? extends V> sm )",
    "TreeMap ( ) \n\nTreeMap ( Comparator<? super K> comp ) \nTreeMap ( Map<? extends K, ? extends V> m ) \nTreeMap ( SortedMap<K, ? extends V> sm ) \n\nThe first form constructs an empty tree map that will be sorted by using the \nnatural order of its keys. The second form constructs an empty tree-based map \nthat will be sorted by using the Comparator comp . ( Comparators are discussed \nlater in this chapter.) The third form initializes a tree map with the entries from m , \nwhich will be sorted by using the natural order of the keys. The fourth form \ninitializes a tree map with the entries from sm , which will be sorted in the same \norder as sm . \n\nTreeMap has no map methods beyond those specified by the NavigableMap interface \nand the AbstractMap class. \nThe following program reworks the preceding example so that it uses TreeMap : \n\n\nThe following is the output from this program:",
    "The following is the output from this program: \n\nNotice that TreeMap sorts the keys. However, in this case, they are sorted by first name \ninstead of last name. You can alter this behavior by specifying a comparator when the map \nis created, as described shortly. \n\nThe LinkedHashMap Class \n\n\nLinkedHashMap extends HashMap . It maintains a linked list of the entries in the map, \nin the order in which they were inserted. This allows insertion-order iteration over the map. \nThat is, when iterating through a collection-view of a LinkedHashMap , the elements will \nbe returned in the order in which they were inserted. You can also create a \nLinkedHashMap that returns its elements in the order in which they were last accessed. \nLinkedHashMap is a generic class that has this declaration: \n\nclass LinkedHashMap<K, V> \n\nHere, K specifies the type of keys, and V specifies the type of values.",
    "class LinkedHashMap<K, V> \n\nHere, K specifies the type of keys, and V specifies the type of values. \n\nLinkedHashMap defines the following constructors: \nLinkedHashMap ( ) \nLinkedHashMap ( Map<? extends K, ? extends V> m ) \nLinkedHashMap ( int capacity ) \nLinkedHashMap ( int capacity , float fillRatio ) \nLinkedHashMap ( int capacity , float fillRatio , boolean Order )",
    "The first form constructs a default LinkedHashMap . The second form initializes \nthe LinkedHashMap with the elements from m . The third form initializes the \ncapacity. The fourth form initializes both capacity and fill ratio. The meaning of \ncapacity and fill ratio are the same as for HashMap . The default capacity is 16. \nThe default ratio is 0.75. The last form allows you to specify whether the elements \nwill be stored in the linked list by insertion order, or by order of last access. If \nOrder is true , then access order is used. If Order is false , then insertion order is \nused. \nLinkedHashMap adds only one method to those defined by HashMap . This method is \nremoveEldestEntry ( ) , and it is shown here: \n\nprotected boolean removeEldestEntry ( Map.Entry<K, V> e )",
    "protected boolean removeEldestEntry ( Map.Entry<K, V> e ) \n\nThis method is called by put ( ) and putAll ( ) . The oldest entry is passed in e . By \ndefault, this method returns false and does nothing. However, if you override this \nmethod, then you can have the LinkedHashMap remove the oldest entry in the \nmap. To do this, have your override return true . To keep the oldest entry, return \nfalse . \n\nThe IdentityHashMap Class \nIdentityHashMap extends AbstractMap and implements the Map interface. It is similar \nto HashMap except that it uses reference equality when comparing elements. \nIdentityHashMap is a generic class that has this declaration: \n\nclass IdentityHashMap<K, V> \n\nHere, K specifies the type of key, and V specifies the type of value. The API \n\ndocumentation explicitly states that IdentityHashMap is not for general use.",
    "class IdentityHashMap<K, V> \n\nHere, K specifies the type of key, and V specifies the type of value. The API \n\ndocumentation explicitly states that IdentityHashMap is not for general use. \n\n\nThe EnumMap Class \nEnumMap extends AbstractMap and implements Map . It is specifically for use with \nkeys of an enum type. It is a generic class that has this declaration: \n\nclass EnumMap<K extends Enum<K>, V> \n\nHere, K specifies the type of key, and V specifies the type of value. Notice that K \nmust extend Enum<K> , which enforces the requirement that the keys must be of \nan enum type. \nEnumMap defines the following constructors: \n\nEnumMap ( Class<K> kType ) \nEnumMap ( Map<K, ? extends V> m ) \nEnumMap ( EnumMap<K, ? extends V> em ) \n\nThe first constructor creates an empty EnumMap of type kType . The second \ncreates an EnumMap map that contains the same entries as m . The third creates \nan EnumMap initialized with the values in em . \nEnumMap defines no methods of its own. \n\nComparators",
    "Comparators \n\nBoth TreeSet and TreeMap store elements in sorted order. However, it is the comparator \nthat defines precisely what \u201csorted order\u201d means. By default, these classes store their \nelements by using what Java refers to as \u201cnatural ordering,\u201d which is usually the ordering \nthat you would expect ( A before B, 1 before 2, and so forth ). If you want to order elements a \ndifferent way, then specify a Comparator when you construct the set or map. Doing so \ngives you the ability to govern precisely how elements are stored within sorted collections \nand maps. \nComparator is a generic interface that has this declaration: \n\ninterface Comparator<T> \n\nHere, T specifies the type of objects being compared. \nPrior to JDK 8, the Comparator interface defined only two methods: compare ( ) and \nequals ( ) . The compare ( ) method, shown here, compares two elements for order: \n\nint compare ( T obj1 , T obj2 )",
    "int compare ( T obj1 , T obj2 ) \n\nobj1 and obj2 are the objects to be compared. Normally, this method returns zero if \nthe objects are equal. It returns a positive value if obj1 is greater than obj2 . \nOtherwise, a negative value is returned. The method can throw a \nClassCastException if the types of the objects are not compatible for \ncomparison. By implementing compare ( ) , you can alter the way that objects are \nordered. For example, to sort in reverse order, you can create a comparator that \n\nreverses the outcome of a comparison. \n\n\nThe equals ( ) method, shown here, tests whether an object equals the invoking \ncomparator: \n\nboolean equals ( object obj )",
    "reverses the outcome of a comparison. \n\n\nThe equals ( ) method, shown here, tests whether an object equals the invoking \ncomparator: \n\nboolean equals ( object obj ) \n\nHere, obj is the object to be tested for equality. The method returns true if obj and \nthe invoking object are both Comparator objects and use the same ordering. \nOtherwise, it returns false . Overriding equals ( ) is not necessary, and most \nsimple comparators will not do so. \nFor many years, the preceding two methods were the only methods defined by \nComparator . With the release of JDK 8, the situation has dramatically changed. JDK 8 \nadds significant new functionality to Comparator through the use of default and static \ninterface methods. Each is described here. \nYou can obtain a comparator that reverses the ordering of the comparator on which it is \ncalled by using reversed ( ) , shown here: \n\ndefault Comparator<T> reversed ( )",
    "default Comparator<T> reversed ( ) \n\nIt returns the reverse comparator. For example, assuming a comparator that uses \nnatural ordering for the characters A through Z, a reverse order comparator would \nput B before A, C before B, and so on. \nA method related to reversed ( ) is reverseOrder ( ) , shown next: \n\nstatic <T extends Comparable<? super T>> Comparator<T> reverseOrder ( ) \n\nIt returns a comparator that reverses the natural order of the elements. Conversely, \nyou can obtain a comparator that uses natural ordering by calling the static method \nnaturalOrder ( ) , shown next: \n\nstatic <T extends Comparable<? super T>> Comparator<T> naturalOrder ( ) \n\nIf you want a comparator that can handle null values, use nullsFirst ( ) or \nnullsLast ( ) , shown here: \n\nstatic <T> Comparator<T> nullsFirst ( Comparator<? super T> comp ) \nstatic <T> Comparator<T> nullsLast ( Comparator<? super T> comp ) \n\nThe nullsFirst ( ) method returns a comparator that views null values as less",
    "The nullsFirst ( ) method returns a comparator that views null values as less \n\nthan other values. The nullsLast ( ) method returns a comparator that views null \nvalues as greater than other values. In both cases, if the two values being compared \n\nare non- null , comp performs the comparison. If comp is passed null , then all \nnon- null values are viewed as equivalent. \nAnother default method added by JDK 8 is thenComparing ( ) . It returns a comparator \nthat performs a second comparison when the outcome of the first comparison indicates that \nthe objects being compared are equal. Thus, it can be used to create a \u201ccompare by X then \ncompare by Y\u201d sequence. For example, when comparing cities, the first comparison might \ncompare names, with the second comparison comparing states. ( Therefore, Springfield,",
    "Illinois, would come before Springfield, Missouri, assuming normal, alphabetical order.) The \nthenComparing ( ) method has three forms. The first, shown here, lets you specify the \nsecond comparator by passing an instance of Comparator : \n\ndefault Comparator<T> thenComparing ( Comparator<? super T> thenByComp ) \n\nHere, thenByComp specifies the comparator that is called if the first comparison \nreturns equal. \nThe next versions of thenComparing ( ) let you specify the standard functional interface \nFunction ( defined by java.util.function ) . They are shown here: \n\nIn both, getKey refers to function that obtains the next comparison key, which is used if the \nfirst comparison returns equal. In the second version, keyComp specifies the comparator \nused to compare keys. ( Here, and in subsequent uses, U specifies the type of the key.) \nComparator also adds the following specialized versions of \u201cthen comparing\u201d methods for \nthe primitive types: \n\ndefault Comparator<T>",
    "default Comparator<T> \n\n    thenComparingDouble ( ToDoubleFunction<? super T> getKey ) \n\ndefault Comparator<T> \n    thenComparingInt ( ToIntFunction<? super T> getKey ) \n\ndefault Comparator<T> \n\n    thenComparingLong ( ToLongFunction<? super T> getKey ) \n\nIn all methods, getKey refers to a function that obtains the next comparison key. \nFinally, JDK 8 adds to Comparator a method called comparing ( ) . It returns a \ncomparator that obtains its comparison key from a function passed to the method. There \nare two versions of comparing ( ) , shown here: \n\n\nIn both, getKey refers to a function that obtains the next comparison key. In the second \nversion, keyComp specifies the comparator used to compare keys. Comparator also adds \nthe following specialized versions of these methods for the primitive types: \n\nstatic <T> Comparator<T> \n\n    ComparingDouble ( ToDoubleFunction<? super T> getKey ) \n\nstatic <T> Comparator<T> \n\n    ComparingInt ( ToIntFunction<? super T> getKey )",
    "static <T> Comparator<T> \n\n    ComparingDouble ( ToDoubleFunction<? super T> getKey ) \n\nstatic <T> Comparator<T> \n\n    ComparingInt ( ToIntFunction<? super T> getKey ) \n\nstatic <T> Comparator<T> \n\n    ComparingLong ( ToLongFunction<? super T> getKey ) \nIn all methods, getKey refers to a function that obtains the next comparison key. \n\nUsing a Comparator \n\nThe following is an example that demonstrates the power of a custom comparator. It \nimplements the compare ( ) method for strings that operates in reverse of normal. Thus, it \ncauses a tree set to be sorted in reverse order. \n\n\nAs the following output shows, the tree is now sorted in reverse order: \n\nLook closely at the MyComp class, which implements Comparator by implementing \n\ncompare ( ) . ( As explained earlier, overriding equals ( ) is neither necessary nor common. \nIt is also not necessary to override the default methods added by JDK 8.) Inside compare (",
    "compare ( ) . ( As explained earlier, overriding equals ( ) is neither necessary nor common. \nIt is also not necessary to override the default methods added by JDK 8.) Inside compare ( \n\n) , the String method compareTo ( ) compares the two strings. However, bStr \u2014not \naStr \u2014 invokes compareTo ( ) . This causes the outcome of the comparison to be reversed. \nAlthough the way in which the reverse order comparator is implemented by the preceding \nprogram is perfectly adequate, beginning with JDK 8, there is another way to approach a \nsolution. It is now possible to simply call reversed ( ) on a natural-order comparator. It will \n\n\nreturn an equivalent comparator, except that it runs in reverse. For example, assuming the \npreceding program, you can rewrite MyComp as a natural-order comparator, as shown \nhere: \n\nNext, you can use the following sequence to create a TreeSet that orders its string elements \nin reverse:",
    "Next, you can use the following sequence to create a TreeSet that orders its string elements \nin reverse: \n\nIf you plug this new code into the preceding program, it will produce the same results as \nbefore. In this case, there is no advantage gained by using reversed ( ) . However, in cases \nin which you need to create both a natural-order comparator and a reversed comparator, \nthen using reversed ( ) gives you an easy way to obtain the reverse-order comparator \nwithout having to code it explicitly. \nBeginning with JDK 8, it is not actually necessary to create the MyComp class in the \npreceding examples because a lambda expression can be easily used instead. For example, \nyou can remove the MyComp class entirely and create the string comparator by using this \nstatement: \n\nOne other point: in this simple example, it would also be possible to specify a reverse \ncomparator via a lambda expression directly in the call to the TreeSet ( ) constructor, as \nshown here:",
    "One other point: in this simple example, it would also be possible to specify a reverse \ncomparator via a lambda expression directly in the call to the TreeSet ( ) constructor, as \nshown here: \n\nBy making these changes, the program is substantially shortened, as its final version shown \nhere illustrates: \n\n\nFor a more practical example that uses a custom comparator, the following program is an \nupdated version of the TreeMap program shown earlier that stores account balances. In \nthe previous version, the accounts were sorted by name, but the sorting began with the first \nname. The following program sorts the accounts by last name. To do so, it uses a \ncomparator that compares the last name of each account. This results in the map being \nsorted by last name. \n\n\nHere is the output ; notice that the accounts are now sorted by last name:",
    "The comparator class TComp compares two strings that hold first and last names. It does \nso by first comparing last names. To do this, it finds the index of the last space in each \nstring and then compares the substrings of each element that begin at that point. In cases \nwhere last names are equivalent, the first names are then compared. This yields a tree map \nthat is sorted by last name, and within last name by first name. You can see this because \nRalph Smith comes before Tom Smith in the output. \nIf you are using JDK 8 or later, then there is another way that you could code the preceding \nprogram so the map is sorted by last name and then by first name. This approach uses the \nthenComparing ( ) method. Recall that thenComparing ( ) lets you specify a second \ncomparator that will be used if the invoking comparator returns equal. This approach is put \ninto action by the following program, which reworks the preceding example to use \nthenComparing ( ) :",
    "This version produces the same output as before. It differs only in how it accomplishes its \njob. To begin, notice that a comparator called CompLastNames is created. This \ncomparator compares only the last names. A second comparator, called \nCompThenByFirstName , compares the entire name, starting with the first name. Next, \nthe TreeMap is then created by the following sequence: \n\n\nHere, the primary comparator is compLN . It is an instance of CompLastNames . On it is \ncalled thenComparing ( ) , passing in an instance of CompThenByFirstName . The \nresult is assigned to the comparator called compLastThenFirst . This comparator is used \nto construct the TreeMap , as shown here:",
    "Now, whenever the last names of the items being compared are equal, the entire name, \nbeginning with the first name, is used to order the two. This means that names are ordered \nbased on last name, and within last names, by first names. \nOne last point: in the interest of clarity, this example explicitly creates two comparator \nclasses called CompLastNames and ThenByFirstNames , but lambda expressions could \nhave been used instead. You might want to try this on your own. Just follow the same \ngeneral approach described for the CompDemo2 example shown earlier. \n\nThe Collection Algorithms",
    "The Collections Framework defines several algorithms that can be applied to collections and \nmaps. These algorithms are defined as static methods within the Collections class. They \nare summarized in Table 18-15. As explained earlier, beginning with JDK 5 all of the \nalgorithms were retrofitted for generics. \nSeveral of the methods can throw a ClassCastException , which occurs when an attempt is \nmade to compare incompatible types, or an UnsupportedOperationException , which \noccurs when an attempt is made to modify an unmodifiable collection. Other exceptions are \npossible, depending on the method. \nOne thing to pay special attention to is the set of checked methods, such as \ncheckedCollection ( ) , which returns what the API documentation refers to as a \n\u201cdynamically typesafe view\u201d of a collection. This view is a reference to the collection that \nmonitors insertions into the collection for type compatibility at run time",
    ". This view is a reference to the collection that \nmonitors insertions into the collection for type compatibility at run time. An attempt to \ninsert an incompatible element will cause a ClassCastException . Using such a view is \nespecially helpful during debugging because it ensures that the collection always contains \nvalid elements. Related methods include checkedSet ( ) , checkedList ( ) , checkedMap ( \n) , and so on. They obtain a type-safe view for the indicated collection.",
    "Notice that several methods, such as synchronizedList ( ) and synchronizedSet ( ) , are \nused to obtain synchronized ( thread-safe ) copies of the various collections. As a general \nrule, the standard collections implementations are not synchronized. You must use the \nsynchronization algorithms to provide synchronization. One other point: iterators to \nsynchronized collections must be used within synchronized blocks. \n\n\n\n\n\n\n\n\nTable 18-15    The Algorithms Defined by Collections \n\nThe set of methods that begins with unmodifiable returns views of the various collections \nthat cannot be modified. These will be useful when you want to grant some process read\u2014",
    "The set of methods that begins with unmodifiable returns views of the various collections \nthat cannot be modified. These will be useful when you want to grant some process read\u2014 \n\n\nbut not write\u2014capabilities on a collection. \nCollections defines three static variables: EMPTY_SET, EMPTY_LIST, and \nEMPTY_MAP . All are immutable. \nThe following program demonstrates some of the algorithms. It creates and initializes a \nlinked list. The reverseOrder ( ) method returns a Comparator that reverses the \ncomparison of Integer objects. The list elements are sorted according to this comparator \nand then are displayed. Next, the list is randomized by calling shuffle ( ) , and then its \nminimum and maximum values are displayed. \n\n\nOutput from this program is shown here: \n\nNotice that min ( ) and max ( ) operate on the list after it has been shuffled. Neither \nrequires a sorted list for its operation. \n\nArrays",
    "Output from this program is shown here: \n\nNotice that min ( ) and max ( ) operate on the list after it has been shuffled. Neither \nrequires a sorted list for its operation. \n\nArrays \n\nThe Arrays class provides various methods that are useful when working with arrays. These \nmethods help bridge the gap between collections and arrays. Each method defined by \nArrays is examined in this section. \nThe asList ( ) method returns a List that is backed by a specified array. In other words, \nboth the list and the array refer to the same location. It has the following signature: \n\nstatic <T> List asList ( T\u2026 array ) \n\nHere, array is the array that contains the data. \nThe binarySearch ( ) method uses a binary search to find a specified value. This method \nmust be applied to sorted arrays. Here are some of its forms. ( Additional forms let you \nsearch a subrange ):",
    "static int binarySearch ( byte array [ ], byte value ) \nstatic int binarySearch ( char array [ ], char value ) \nstatic int binarySearch ( double array [ ], double value ) \nstatic int binarySearch ( float array [ ], float value ) \nstatic int binarySearch ( int array [ ], int value ) \nstatic int binarySearch ( long array [ ], long value ) \nstatic int binarySearch ( short array [ ], short value ) \nstatic int binarySearch ( Object array [ ], Object value ) \nstatic <T> int binarySearch ( T[ ] array , T value , Comparator<? super T> c ) \n\nHere, array is the array to be searched, and value is the value to be located. The \nlast two forms throw a ClassCastException if array contains elements that \ncannot be compared ( for example, Double and StringBuffer ) or if value is not \ncompatible with the types in array . In the last form, the Comparator c is used to \ndetermine the order of the elements in array . In all cases, if value exists in array ,",
    "the index of the element is returned. Otherwise, a negative value is returned. \nThe copyOf ( ) method returns a copy of an array and has the following forms: \n\nstatic boolean[ ] copyOf ( boolean[ ] source , int len ) \nstatic byte[ ] copyOf ( byte[ ] source , int len ) \n\n\nstatic char[ ] copyOf ( char[ ] source , int len ) \nstatic double[ ] copyOf ( double[ ] source , int len ) \nstatic float[ ] copyOf ( float[ ] source , int len ) \nstatic int[ ] copyOf ( int[ ] source , int len ) \nstatic long[ ] copyOf ( long[ ] source , int len ) \nstatic short[ ] copyOf ( short[ ] source , int len ) \nstatic <T> T[ ] copyOf ( T[ ] source , int len ) \nstatic <T,U> T[ ] copyOf ( U[ ] source , int len , Class<? extends T[ ]> resultT )",
    "The original array is specified by source , and the length of the copy is specified by \nlen . If the copy is longer than source , then the copy is padded with zeros ( for \nnumeric arrays ), null s ( for object arrays ), or false ( for boolean arrays ). If the copy \nis shorter than source , then the copy is truncated. In the last form, the type of \nresultT becomes the type of the array returned. If len is negative, a \nNegativeArraySizeException is thrown. If source is null , a \nNullPointerException is thrown. If resultT is incompatible with the type of \nsource , an ArrayStoreException is thrown. \nThe copyOfRange ( ) method returns a copy of a range within an array and has the \nfollowing forms:",
    "static boolean[ ] copyOfRange ( boolean[ ] source , int start , int end ) \nstatic byte[ ] copyOfRange ( byte[ ] source , int start , int end ) \nstatic char[ ] copyOfRange ( char[ ] source , int start , int end ) \nstatic double[ ] copyOfRange ( double[ ] source , int start , int end ) \nstatic float[ ] copyOfRange ( float[ ] source , int start , int end ) \nstatic int[ ] copyOfRange ( int[ ] source , int start , int end ) \nstatic long[ ] copyOfRange ( long[ ] source , int start , int end ) \nstatic short[ ] copyOfRange ( short[ ] source , int start , int end ) \nstatic <T> T[ ] copyOfRange ( T[ ] source , int start , int end ) \nstatic <T,U> T[ ] copyOfRange ( U[ ] source , int start , int end , Class<? extends T[ ]> resultT ) \n\nThe original array is specified by source . The range to copy is specified by the",
    "The original array is specified by source . The range to copy is specified by the \n\nindices passed via start and end . The range runs from start to end \u2013 1. If the range \nis longer than source , then the copy is padded with zeros ( for numeric arrays ), \nnull s ( for object arrays ), or false ( for boolean arrays ). In the last form, the type of \nresultT becomes the type of the array returned. If start is negative or greater than \n\nthe length of source , an ArrayIndexOutOfBoundsException is thrown. If start \nis greater than end , an IllegalArgumentException is thrown. If source is null , \na NullPointerException is thrown. If resultT is incompatible with the type of \nsource , an ArrayStoreException is thrown. \nThe equals ( ) method returns true if two arrays are equivalent. Otherwise, it returns \nfalse . The equals ( ) method has the following forms:",
    "static boolean equals ( boolean array1 [ ], boolean array2 [ ]) \nstatic boolean equals ( byte array1 [ ], byte array2 [ ]) \nstatic boolean equals ( char array1 [ ], char array2 [ ]) \nstatic boolean equals ( double array1 [ ], double array2 [ ]) \nstatic boolean equals ( float array1 [ ], float array2 [ ]) \nstatic boolean equals ( int array1 [ ], int array2 [ ]) \nstatic boolean equals ( long array1 [ ], long array2 [ ]) \nstatic boolean equals ( short array1 [ ], short array2 [ ]) \nstatic boolean equals ( Object array1 [ ], Object array2 [ ]) \n\nHere, array1 and array2 are the two arrays that are compared for equality. \nThe deepEquals ( ) method can be used to determine if two arrays, which might contain \nnested arrays, are equal. It has this declaration: \n\nstatic boolean deepEquals ( Object[ ] a , Object[ ] b )",
    "static boolean deepEquals ( Object[ ] a , Object[ ] b ) \n\nIt returns true if the arrays passed in a and b contain the same elements. If a and \nb contain nested arrays, then the contents of those nested arrays are also checked. \nIt returns false if the arrays, or any nested arrays, differ. \nThe fill ( ) method assigns a value to all elements in an array. In other words, it fills an \narray with a specified value. The fill ( ) method has two versions. The first version, which \nhas the following forms, fills an entire array: \n\nstatic void fill ( boolean array [ ], boolean value ) \nstatic void fill ( byte array [ ], byte value ) \nstatic void fill ( char array [ ], char value ) \nstatic void fill ( double array [ ], double value ) \nstatic void fill ( float array [ ], float value ) \nstatic void fill ( int array [ ], int value ) \nstatic void fill ( long array [ ], long value ) \nstatic void fill ( short array [ ], short value ) \nstatic void fill ( Object array [ ], Object value )",
    "Here, value is assigned to all elements in array . The second version of the fill ( ) \n\nmethod assigns a value to a subset of an array. \nThe sort ( ) method sorts an array so that it is arranged in ascending order. The sort ( ) \nmethod has two versions. The first version, shown here, sorts the entire array: \n\nstatic void sort ( byte array [ ]) \nstatic void sort ( char array [ ]) \nstatic void sort ( double array [ ]) \nstatic void sort ( float array [ ]) \nstatic void sort ( int array [ ]) \nstatic void sort ( long array [ ]) \n\n\nstatic void sort ( short array [ ]) \nstatic void sort ( Object array [ ]) \nstatic <T> void sort ( T array [ ], Comparator<? super T> c )",
    "static void sort ( short array [ ]) \nstatic void sort ( Object array [ ]) \nstatic <T> void sort ( T array [ ], Comparator<? super T> c ) \n\nHere, array is the array to be sorted. In the last form, c is a Comparator that is \nused to order the elements of array . The last two forms can throw a \nClassCastException if elements of the array being sorted are not comparable. \nThe second version of sort ( ) enables you to specify a range within an array that \nyou want to sort. \nJDK 8 adds several new methods to Arrays . Perhaps the most important is parallelSort ( \n) because it sorts, into ascending order, portions of an array in parallel and then merges the \nresults. This approach can greatly speed up sorting times. Like sort ( ) , there are two basic \ntypes of parallelSort ( ) , each with several overloads. The first type sorts the entire array. It \nis shown here:",
    "static void parallelSort ( byte array [ ]) \nstatic void parallelSort ( char array [ ]) \nstatic void parallelSort ( double array [ ]) \nstatic void parallelSort ( float array [ ]) \nstatic void parallelSort ( int array [ ]) \nstatic void parallelSort ( long array [ ]) \nstatic void parallelSort ( short array [ ]) \nstatic <T extends Comparable<? super T>> void parallelSort ( T array [ ]) \nstatic <T> void parallelSort ( T array [ ], Comparator<? super T> c ) \n\nHere, array is the array to be sorted. In the last form, c is a comparator that is \nused to order the elements in the array. The last two forms can throw a \nClassCastException if the elements of the array being sorted are not \ncomparable. The second version of parallelSort ( ) enables you to specify a range \nwithin the array that you want to sort. \nJDK 8 gives Arrays support for spliterators by including the spliterator ( ) method. It has \ntwo basic forms. The first type returns a spliterator to an entire array. It is shown here:",
    "static Spliterator.OfDouble spliterator ( double array [ ]) \n\nstatic Spliterator.OfInt spliterator ( int array [ ]) \nstatic Spliterator.OfLong spliterator ( long array [ ]) \n\nstatic <T> Spliterator spliterator ( T array [ ]) \n\nHere, array is the array that the spliterator will cycle through. The second version \nof spliterator ( ) enables you to specify a range to iterate within the array. \nBeginning with JDK 8, Arrays supports the new Stream interface ( see Chapter 29 ) by \n\nincluding the stream ( ) method. It has two forms. The first is shown here: \n\nstatic DoubleStream stream ( double array [ ]) \n\n\nstatic IntStream stream ( int array [ ]) \nstatic LongStream stream ( long array [ ]) \nstatic <T> Stream stream ( T array [ ])",
    "static DoubleStream stream ( double array [ ]) \n\n\nstatic IntStream stream ( int array [ ]) \nstatic LongStream stream ( long array [ ]) \nstatic <T> Stream stream ( T array [ ]) \n\nHere, array is the array to which the stream will refer. The second version of \nstream ( ) enables you to specify a range within the array. \nIn addition to those just discussed, JDK 8 adds three other new methods. Two are related: \nsetAll ( ) and parallelSetAll ( ) . Both assign values to all of the elements, but \nparallelSetAll ( ) works in parallel. Here is an example of each:",
    "Several overloads exist for each of these that handle types int , long , and generic. \nFinally, JDK 8 includes one of the more intriguing additions to Arrays . It is called \nparallelPrefix ( ) , and it modifies an array so that each element contains the cumulative \nresult of an operation applied to all previous elements. For example, if the operation is \nmultiplication, then on return, the array elements will contain the values associated with the \nrunning product of the original values. It has several overloads. Here is one example: \n\nstatic void parallelPrefix ( double array [ ], DoubleBinaryOperator func )",
    "static void parallelPrefix ( double array [ ], DoubleBinaryOperator func ) \n\nHere, array is the array being acted upon, and func specifies the operation \napplied. ( DoubleBinaryOperator is a functional interface defined in \njava.util.function .) Many other versions are provided, including those that \noperate on types int , long , and generic, and those that let you specify a range \nwithin the array on which to operate. \nArrays also provides toString ( ) and hashCode ( ) for the various types of arrays. In \naddition, deepToString ( ) and deepHashCode ( ) are provided, which operate effectively \non arrays that contain nested arrays. \nThe following program illustrates how to use some of the methods of the Arrays class: \n\n\nThe following is the output from this program: \n\n\nThe Legacy Classes and Interfaces",
    "As explained at the start of this chapter, early versions of java.util did not include the \nCollections Framework. Instead, it defined several classes and an interface that provided an \nad hoc method of storing objects. When collections were added ( by J2SE 1.2 ), several of the \noriginal classes were reengineered to support the collection interfaces. Thus, they are now \ntechnically part of the Collections Framework. However, where a modern collection \nduplicates the functionality of a legacy class, you will usually want to use the newer \ncollection class. In general, the legacy classes are supported because there is still code that \nuses them. \nOne other point: none of the modern collection classes described in this chapter are \nsynchronized, but all the legacy classes are synchronized. This distinction may be important \nin some situations. Of course, you can easily synchronize collections by using one of the \nalgorithms provided by Collections",
    ". This distinction may be important \nin some situations. Of course, you can easily synchronize collections by using one of the \nalgorithms provided by Collections . \nThe legacy classes defined by java.util are shown here:",
    "There is one legacy interface called Enumeration . The following sections examine \nEnumeration and each of the legacy classes, in turn. \n\nThe Enumeration Interface \n\nThe Enumeration interface defines the methods by which you can enumerate ( obtain one \nat a time ) the elements in a collection of objects. This legacy interface has been superseded \nby Iterator . Although not deprecated, Enumeration is considered obsolete for new code. \nHowever, it is used by several methods defined by the legacy classes ( such as Vector and \nProperties ) and is used by several other API classes. Because it is still in use, it was \nretrofitted for generics by JDK 5. It has this declaration: \n\ninterface Enumeration<E> \n\nwhere E specifies the type of element being enumerated. \nEnumeration specifies the following two methods: \n\nboolean hasMoreElements ( ) \nE nextElement ( ) \n\nWhen implemented, hasMoreElements ( ) must return true while there are still",
    "boolean hasMoreElements ( ) \nE nextElement ( ) \n\nWhen implemented, hasMoreElements ( ) must return true while there are still \n\n\nmore elements to extract, and false when all the elements have been enumerated. \nnextElement ( ) returns the next object in the enumeration. That is, each call to \nnextElement ( ) obtains the next object in the enumeration. It throws \nNoSuchElementException when the enumeration is complete. \n\nVector",
    "Vector \n\nVector implements a dynamic array. It is similar to ArrayList , but with two differences: \nVector is synchronized, and it contains many legacy methods that duplicate the \nfunctionality of methods defined by the Collections Framework. With the advent of \ncollections, Vector was reengineered to extend AbstractList and to implement the List \ninterface. With the release of JDK 5, it was retrofitted for generics and reengineered to \nimplement Iterable . This means that Vector is fully compatible with collections, and a \nVector can have its contents iterated by the enhanced for loop. \nVector is declared like this: \n\nclass Vector<E> \n\nHere, E specifies the type of element that will be stored. \nHere are the Vector constructors: \n\nVector ( ) \nVector ( int size ) \nVector ( int size , int incr ) \nVector ( Collection<? extends E> c )",
    "The first form creates a default vector, which has an initial size of 10. The second \nform creates a vector whose initial capacity is specified by size . The third form \ncreates a vector whose initial capacity is specified by size and whose increment is \nspecified by incr . The increment specifies the number of elements to allocate each \ntime that a vector is resized upward. The fourth form creates a vector that contains \nthe elements of collection c . \nAll vectors start with an initial capacity. After this initial capacity is reached, the next time \nthat you attempt to store an object in the vector, the vector automatically allocates space for \nthat object plus extra room for additional objects. By allocating more than just the required \nmemory, the vector reduces the number of allocations that must take place as the vector \ngrows. This reduction is important, because allocations are costly in terms of time",
    ". This reduction is important, because allocations are costly in terms of time. The \namount of extra space allocated during each reallocation is determined by the increment \nthat you specify when you create the vector. If you don\u2019t specify an increment, the vector\u2019s \nsize is doubled by each allocation cycle. \nVector defines these protected data members:",
    "The increment value is stored in capacityIncrement . The number of elements \ncurrently in the vector is stored in elementCount . The array that holds the vector \nis stored in elementData . \nIn addition to the collections methods specified by List , Vector defines several legacy \nmethods, which are summarized in Table 18-16. \nBecause Vector implements List , you can use a vector just like you use an ArrayList \ninstance. You can also manipulate one using its legacy methods. For example, after you \ninstantiate a Vector , you can add an element to it by calling addElement ( ) . To obtain the \nelement at a specific location, call elementAt ( ) . To obtain the first element in the vector, \ncall firstElement ( ) . To retrieve the last element, call lastElement ( ) . You can obtain the \nindex of an element by using indexOf ( ) and lastIndexOf ( ) . To remove an element, call \nremoveElement ( ) or removeElementAt ( ) .",
    "Table 18-16    The Legacy Methods Defined by Vector \n\nThe following program uses a vector to store various types of numeric objects. It \ndemonstrates several of the legacy methods defined by Vector . It also \ndemonstrates the Enumeration interface. \n\n\nThe output from this program is shown here: \n\n\nInstead of relying on an enumeration to cycle through the objects ( as the preceding program \ndoes ), you can use an iterator. For example, the following iterator-based code can be \nsubstituted into the program: \n\nYou can also use a for-each for loop to cycle through a Vector , as the following version of \nthe preceding code shows: \n\nBecause the Enumeration interface is not recommended for new code, you will usually use \nan iterator or a for-each for loop to enumerate the contents of a vector. Of course, legacy \n\ncode will employ Enumeration . Fortunately, enumerations and iterators work in nearly \nthe same manner. \n\nStack",
    "code will employ Enumeration . Fortunately, enumerations and iterators work in nearly \nthe same manner. \n\nStack \n\nStack is a subclass of Vector that implements a standard last-in, first-out stack. Stack \nonly defines the default constructor, which creates an empty stack. With the release of JDK \n\n\n5, Stack was retrofitted for generics and is declared as shown here: \n\nclass Stack<E> \n\nHere, E specifies the type of element stored in the stack. \nStack includes all the methods defined by Vector and adds several of its own, shown in \nTable 18-17. \n\nTable 18-17    The Methods Defined by Stack",
    "Table 18-17    The Methods Defined by Stack \n\nTo put an object on the top of the stack, call push ( ) . To remove and return the \ntop element, call pop ( ) . You can use peek ( ) to return, but not remove, the top \nobject. An EmptyStackException is thrown if you call pop ( ) or peek ( ) when \nthe invoking stack is empty. The empty ( ) method returns true if nothing is on \nthe stack. The search ( ) method determines whether an object exists on the stack \nand returns the number of pops that are required to bring it to the top of the stack. \nHere is an example that creates a stack, pushes several Integer objects onto it, \nand then pops them off again: \n\n\nThe following is the output produced by the program ; notice how the exception handler for \nEmptyStackException is caught so that you can gracefully handle a stack underflow: \n\n\nOne other point: although Stack is not deprecated, ArrayDeque is a better choice. \n\nDictionary",
    "One other point: although Stack is not deprecated, ArrayDeque is a better choice. \n\nDictionary \n\nDictionary is an abstract class that represents a key/value storage repository and operates \nmuch like Map . Given a key and value, you can store the value in a Dictionary object. \nOnce the value is stored, you can retrieve it by using its key. Thus, like a map, a dictionary \ncan be thought of as a list of key/value pairs. Although not currently deprecated, \nDictionary is classified as obsolete, because it is fully superseded by Map . However, \nDictionary is still in use and thus is discussed here. \nWith the advent of JDK 5, Dictionary was made generic. It is declared as shown here: \n\nclass Dictionary<K, V>",
    "class Dictionary<K, V> \n\nHere, K specifies the type of keys, and V specifies the type of values. The abstract \nmethods defined by Dictionary are listed in Table 18-18. \nTo add a key and a value, use the put ( ) method. Use get ( ) to retrieve the value of a given \nkey. The keys and values can each be returned as an Enumeration by the keys ( ) and \nelements ( ) methods, respectively. The size ( ) method returns the number of key/value \npairs stored in a dictionary, and isEmpty ( ) returns true when the dictionary is empty. \nYou can use the remove ( ) method to delete a key/value pair. \n\nREMEMBER   The Dictionary class is obsolete. You should implement \nthe Map interface to obtain key/value storage functionality. \n\n\nTable 18-18    The Abstract Methods Defined by Dictionary \n\nHashtable",
    "Table 18-18    The Abstract Methods Defined by Dictionary \n\nHashtable \n\nHashtable was part of the original java.util and is a concrete implementation of a \nDictionary . However, with the advent of collections, Hashtable was reengineered to also \nimplement the Map interface. Thus, Hashtable is integrated into the Collections \nFramework. It is similar to HashMap , but is synchronized. \nLike HashMap , Hashtable stores key/value pairs in a hash table. However, neither keys \nnor values can be null . When using a Hashtable , you specify an object that is used as a \nkey, and the value that you want linked to that key. The key is then hashed, and the \nresulting hash code is used as the index at which the value is stored within the table. \nHashtable was made generic by JDK 5. It is declared like this: \n\nclass Hashtable<K, V>",
    "class Hashtable<K, V> \n\nHere, K specifies the type of keys, and V specifies the type of values. \nA hash table can only store objects that override the hashCode ( ) and equals ( ) methods \nthat are defined by Object . The hashCode ( ) method must compute and return the hash \ncode for the object. Of course, equals ( ) compares two objects. Fortunately, many of Java\u2019s \nbuilt-in classes already implement the hashCode ( ) method. For example, the most \ncommon type of Hashtable uses a String object as the key. String implements both \nhashCode ( ) and equals ( ) . \n\nThe Hashtable constructors are shown here: \n\nHashtable ( ) \nHashtable ( int size ) \nHashtable ( int size , float fillRatio ) \nHashtable ( Map<? extends K, ? extends V> m ) \n\nThe first version is the default constructor. The second version creates a hash table",
    "that has an initial size specified by size . ( The default size is 11.) The third version \ncreates a hash table that has an initial size specified by size and a fill ratio specified \nby fillRatio . This ratio must be between 0.0 and 1.0, and it determines how full the \nhash table can be before it is resized upward. Specifically, when the number of \nelements is greater than the capacity of the hash table multiplied by its fill ratio, \nthe hash table is expanded. If you do not specify a fill ratio, then 0.75 is used. \nFinally, the fourth version creates a hash table that is initialized with the elements \nin m . The default load factor of 0.75 is used. \nIn addition to the methods defined by the Map interface, which Hashtable now \nimplements, Hashtable defines the legacy methods listed in Table 18-19. Several methods \nthrow NullPointerException if an attempt is made to use a null key or value. \n\nTable 18-19    The Legacy Methods Defined by Hashtable",
    "Table 18-19    The Legacy Methods Defined by Hashtable \n\nThe following example reworks the bank account program, shown earlier, so that it \nuses a Hashtable to store the names of bank depositors and their current \n\nbalances: \n\n\nThe output from this program is shown here: \n\n\nOne important point: Like the map classes, Hashtable does not directly support iterators. \nThus, the preceding program uses an enumeration to display the contents of balance . \nHowever, you can obtain set-views of the hash table, which permits the use of iterators. To \ndo so, you simply use one of the collection-view methods defined by Map , such as \nentrySet ( ) or keySet ( ) . For example, you can obtain a set-view of the keys and cycle \nthrough them using either an iterator or an enhanced for loop. Here is a reworked version \nof the program that shows this technique: \n\n\nProperties",
    "Properties \n\nProperties is a subclass of Hashtable . It is used to maintain lists of values in which the \nkey is a String and the value is also a String . The Properties class is used by some other \nJava classes. For example, it is the type of object returned by System.getProperties ( ) \nwhen obtaining environmental values. Although the Properties class, itself, is not generic, \nseveral of its methods are. \n\n\nProperties defines the following instance variable: \n\nProperties defaults ; \n\nThis variable holds a default property list associated with a Properties object. \nProperties defines these constructors: \n\nProperties ( ) \nProperties ( Properties propDefault )",
    "This variable holds a default property list associated with a Properties object. \nProperties defines these constructors: \n\nProperties ( ) \nProperties ( Properties propDefault ) \n\nThe first version creates a Properties object that has no default values. The \nsecond creates an object that uses propDefault for its default values. In both cases, \nthe property list is empty. \nIn addition to the methods that Properties inherits from Hashtable , Properties defines \nthe methods listed in Table 18-20. Properties also contains one deprecated method: save ( \n) . This was replaced by store ( ) because save ( ) did not handle errors correctly. \n\n\nTable 18-20    The Methods Defined by Properties",
    "One useful capability of the Properties class is that you can specify a default \nproperty that will be returned if no value is associated with a certain key. For \nexample, a default value can be specified along with the key in the getProperty ( ) \nmethod\u2014such as getProperty ( \"name\",\"default value\") . If the \"name\" value \nis not found, then \u201cdefault value\u201d is returned. When you construct a Properties \nobject, you can pass another instance of Properties to be used as the default \nproperties for the new instance. In this case, if you call getProperty (\"foo\") on a \ngiven Properties object, and \"foo\" does not exist, Java looks for \"foo\" in the \ndefault Properties object. This allows for arbitrary nesting of levels of default \nproperties. \nThe following example demonstrates Properties . It creates a property list in which the \nkeys are the names of states and the values are the names of their capitals. Notice that the \nattempt to find the capital for Florida includes a default value.",
    "The output from this program is shown here: \n\n\nSince Florida is not in the list, the default value is used. \nAlthough it is perfectly valid to use a default value when you call getProperty ( ) , as the \npreceding example shows, there is a better way of handling default values for most \napplications of property lists. For greater flexibility, specify a default property list when \nconstructing a Properties object. The default list will be searched if the desired key is not \nfound in the main list. For example, the following is a slightly reworked version of the \npreceding program, with a default list of states specified. Now, when Florida is sought, it \nwill be found in the default list: \n\n\nUsing store ( ) and load ( )",
    "Using store ( ) and load ( ) \n\nOne of the most useful aspects of Properties is that the information contained in a \nProperties object can be easily stored to or loaded from disk with the store ( ) and load ( \n) methods. At any time, you can write a Properties object to a stream or read it back. This \n\nmakes property lists especially convenient for implementing simple databases. For example, \nthe following program uses a property list to create a simple computerized telephone book \nthat stores names and phone numbers. To find a person\u2019s number, you enter his or her \nname. The program uses the store ( ) and load ( ) methods to store and retrieve the list. \nWhen the program executes, it first tries to load the list from a file called phonebook.dat . \nIf this file exists, the list is loaded. You can then add to the list. If you do, the new list is",
    "saved when you terminate the program. Notice how little code is required to implement a \nsmall, but functional, computerized phone book. \n\n\nParting Thoughts on Collections \n\nThe Collections Framework gives you, the programmer, a powerful set of well-engineered",
    "Parting Thoughts on Collections \n\nThe Collections Framework gives you, the programmer, a powerful set of well-engineered \n\nsolutions to some of programming\u2019s most common tasks. Consider using a collection the \nnext time that you need to store and retrieve information. Remember, collections need not \nbe reserved for only the \u201clarge jobs,\u201d such as corporate databases, mailing lists, or inventory \nsystems. They are also effective when applied to smaller jobs. For example, a TreeMap \nmight make an excellent collection to hold the directory structure of a set of files. A \nTreeSet could be quite useful for storing project-management information. Frankly, the \ntypes of problems that will benefit from a collections-based solution are limited only by your \nimagination. One last point: In Chapter 29, the new stream API is discussed. Because \nstreams are now integrated with collections, consider using a stream when operating on a \n\ncollection.",
    "collection. \n\n\uf709 \nPREV \nChapter 17: Exploring java.lang \n\u23ee \n\nNEXT \nChapter 19: java.util Part 2: More Utility Classes \n\u23ed \n\n\n\n\nPREV \nChapter 18: java.util Part 1: The Collections Fra\u2026 \n\u23ee \n\nNEXT \nChapter 20: Input/Output: Exploring java.io \u23ed \n\nCHAPTER \n\n19 \njava.util Part 2: More Utility Classes \n\nThis chapter continues our discussion of java.util by examining those classes and interfaces \nthat are not part of the Collections Framework. These include classes that tokenize strings, \nwork with dates, compute random numbers, bundle resources, and observe events. Also \ncovered are the Formatter and Scanner classes which make it easy to write and read \nformatted data, and the new Optional class, which makes it easier to handle situations in \nwhich a value may be absent. Finally, the subpackages of java.util are summarized at the \nend of this chapter. Of particular interest is java.util.function , which defines several \nstandard functional interfaces. \n\nStringTokenizer",
    "StringTokenizer \n\nThe processing of text often consists of parsing a formatted input string. Parsing is the \ndivision of text into a set of discrete parts, or tokens , which in a certain sequence can convey \na semantic meaning. The StringTokenizer class provides the first step in this parsing \nprocess, often called the lexer ( lexical analyzer ) or scanner . StringTokenizer implements \nthe Enumeration interface. Therefore, given an input string, you can enumerate the \nindividual tokens contained in it using StringTokenizer . \nTo use StringTokenizer , you specify an input string and a string that contains delimiters. \nDelimiters are characters that separate tokens. Each character in the delimiters string is \nconsidered a valid delimiter\u2014for example, \",;:\" sets the delimiters to a comma, semicolon, \nand colon. The default set of delimiters consists of the whitespace characters: space, tab, \nform feed, newline, and carriage return. \nThe StringTokenizer constructors are shown here:",
    "StringTokenizer ( String str ) \n\nStringTokenizer ( String str , String delimiters ) \nStringTokenizer ( String str , String delimiters , boolean delimAsToken ) \n\nIn all versions, str is the string that will be tokenized. In the first version, the \ndefault delimiters are used. In the second and third versions, delimiters is a string \nthat specifies the delimiters. In the third version, if delimAsToken is true , then the \ndelimiters are also returned as tokens when the string is parsed. Otherwise, the",
    "delimiters are not returned. Delimiters are not returned as tokens by the first two \nforms. \nOnce you have created a StringTokenizer object, the nextToken ( ) method is used to \nextract consecutive tokens. The hasMoreTokens ( ) method returns true while there are \nmore tokens to be extracted. Since StringTokenizer implements Enumeration , the \nhasMoreElements ( ) and nextElement ( ) methods are also implemented, and they act \nthe same as hasMoreTokens ( ) and nextToken ( ) , respectively. The StringTokenizer \nmethods are shown in Table 19-1. \nHere is an example that creates a StringTokenizer to parse \"key=value\" pairs. \nConsecutive sets of \"key=value\" pairs are separated by a semicolon. \n\nThe output from this program is shown here: \n\n\nTable 19-1    The Methods Defined by StringTokenizer \n\nBitSet",
    "The output from this program is shown here: \n\n\nTable 19-1    The Methods Defined by StringTokenizer \n\nBitSet \n\nA BitSet class creates a special type of array that holds bit values in the form of boolean \nvalues. This array can increase in size as needed. This makes it similar to a vector of bits. \nThe BitSet constructors are shown here: \n\nBitSet ( ) \nBitSet ( int size ) \n\nThe first version creates a default object. The second version allows you to specify \nits initial size ( that is, the number of bits that it can hold ). All bits are initialized to \nfalse . \nBitSet defines the methods listed in Table 19-2. \n\n\n\n\nTable 19-2    The Methods Defined by BitSet \n\nHere is an example that demonstrates BitSet : \n\n\nThe output from this program is shown here. When toString ( ) converts a BitSet object to \nits string equivalent, each set bit is represented by its bit position. Cleared bits are not \nshown.",
    "Optional, OptionalDouble, OptionalInt, and OptionalLong \n\nJDK 8 adds classes called Optional , OptionalDouble , OptionalInt , and OptionalLong \nthat offer a way to handle situations in which a value may or may not be present. In the \npast, you would normally use the value null to indicate that no value is present. However, \nthis can lead to null pointer exceptions if an attempt is made to dereference a null reference. \nAs a result, frequent checks for a null value were necessary to avoid generating an \nexception. These classes provide a better way to handle such situations. \nThe first and most general of these classes is Optional . For this reason, it is the primary \nfocus of this discussion. It is shown here: \n\nclass Optional<T> \n\nHere, T specifies the type of value stored. It is important to understand that an",
    "class Optional<T> \n\nHere, T specifies the type of value stored. It is important to understand that an \n\nOptional instance can either contain a value of type T or be empty. In other \nwords, an Optional object does not necessarily contain a value. Optional does \nnot define any constructors, but it does define several methods that let you work \nwith Optional objects. For example, you can determine if a value is present, \nobtain the value if it is present, obtain a default value when no value is present, \nand construct an Optional value. The Optional methods are shown in Table 193. \n\n\nTable 19-3    The Methods Defined by Optional \n\nThe best way to understand Optional is to work through an example that uses its",
    "Table 19-3    The Methods Defined by Optional \n\nThe best way to understand Optional is to work through an example that uses its \n\ncore methods. At the foundation of Optional are isPresent ( ) and get ( ) . You \ncan determine if a value is present by calling isPresent ( ) . If a value is available, \nit will return true . Otherwise, false is returned. If a value is present in an \nOptional instance, you can obtain it by calling get ( ) . However, if you call get ( ) \non an object that does not contain a value, NoSuchElementException is \nthrown. For this reason, you should always first confirm that a value is present",
    "before calling get ( ) on an Optional object. \nOf course, having to call two methods to retrieve a value adds overhead to each access. \nFortunately, Optional defines methods that combine the check for a value with the \nretrieval of the value. One such method is orElse ( ) . If the object on which it is called \ncontains a value, the value is returned. Otherwise, a default value is returned. \nOptional does not define any constructors. Instead, you will use one of its methods to \n\n\ncreate an instance. For example, you can create an Optional instance with a specified value \n\nby using of ( ) . You can create an instance of Optional that does not contain a value by \nusing empty ( ) . \nThe following program demonstrates these methods: \n\nThe output is shown here:",
    "by using of ( ) . You can create an instance of Optional that does not contain a value by \nusing empty ( ) . \nThe following program demonstrates these methods: \n\nThe output is shown here: \n\nAs the output shows, a value can be obtained from an Optional object only if one is \npresent. This basic mechanism enables Optional to prevent null pointer exceptions. \nThe OptionalDouble , OptionalInt , and OptionalLong classes work much like \nOptional , except that they are designed expressly for use on double , int , and long values, \nrespectively. As such, they specify the methods getAsDouble ( ) , getAsInt ( ) , and \ngetAsLong ( ) , respectively, rather than get ( ) . Also, they do not support the filter ( ) , \nofNullable ( ) , map ( ) and flatMap ( ) methods. \n\nDate \n\nThe Date class encapsulates the current date and time. Before beginning our examination of",
    "Date \n\nThe Date class encapsulates the current date and time. Before beginning our examination of \n\nDate , it is important to point out that it has changed substantially from its original version \ndefined by Java 1.0. When Java 1.1 was released, many of the functions carried out by the \noriginal Date class were moved into the Calendar and DateFormat classes, and as a \nresult, many of the original 1.0 Date methods were deprecated. Since the deprecated 1.0 \nmethods should not be used for new code, they are not described here. \n\n\nDate supports the following non-deprecated constructors: \n\nDate ( ) \nDate ( long millisec ) \n\nThe first constructor initializes the object with the current date and time. The \nsecond constructor accepts one argument that equals the number of milliseconds \nthat have elapsed since midnight, January 1, 1970. The nondeprecated methods \ndefined by Date are shown in Table 19-4. Date also implements the \nComparable interface.",
    "Table 19-4    The Nondeprecated Methods Defined by Date \n\nAs you can see by examining Table 19-4, the non-deprecated Date features do not \nallow you to obtain the individual components of the date or time. As the following \nprogram demonstrates, you can only obtain the date and time in terms of \nmilliseconds, in its default string representation as returned by toString ( ) , or \n( beginning with JDK 8 ) as an Instant object. To obtain more-detailed information \nabout the date and time, you will use the Calendar class. \n\n\nSample output is shown here: \n\nCalendar",
    "Sample output is shown here: \n\nCalendar \n\nThe abstract Calendar class provides a set of methods that allows you to convert a time in \nmilliseconds to a number of useful components. Some examples of the type of information \nthat can be provided are year, month, day, hour, minute, and second. It is intended that \nsubclasses of Calendar will provide the specific functionality to interpret time information \naccording to their own rules. This is one aspect of the Java class library that enables you to \nwrite programs that can operate in international environments. An example of such a \nsubclass is GregorianCalendar . \n\nNOTE    JDK 8 defines a new date and time API in java.time , which new \napplications may want to employ. See Chapter 30.",
    "NOTE    JDK 8 defines a new date and time API in java.time , which new \napplications may want to employ. See Chapter 30. \n\nCalendar provides no public constructors. Calendar defines several protected instance \nvariables. areFieldsSet is a boolean that indicates if the time components have been set. \nfields is an array of int s that holds the components of the time. isSet is a boolean array \nthat indicates if a specific time component has been set. time is a long that holds the \ncurrent time for this object. isTimeSet is a boolean that indicates if the current time has \nbeen set. \n\nA sampling of methods defined by Calendar are shown in Table 19-5. \n\n\nTable 19-5    A Sampling of the Methods Defined by Calendar \n\n\nCalendar defines the following int constants, which are used when you get or set \ncomponents of the calendar. ( The ones with the suffix FORMAT or \nSTANDALONE were added by JDK 8.) \n\nThe following program demonstrates several Calendar methods:",
    "The following program demonstrates several Calendar methods: \n\n\nSample output is shown here: \n\nGregorianCalendar \n\nGregorianCalendar is a concrete implementation of a Calendar that implements the \nnormal Gregorian calendar with which you are familiar. The getInstance ( ) method of \nCalendar will typically return a GregorianCalendar initialized with the current date and \ntime in the default locale and time zone. \n\n\nGregorianCalendar defines two fields: AD and BC . These represent the two eras defined \nby the Gregorian calendar. \nThere are also several constructors for GregorianCalendar objects. The default, \nGregorianCalendar ( ) , initializes the object with the current date and time in the default \nlocale and time zone. Three more constructors offer increasing levels of specificity:",
    "All three versions set the day, month, and year. Here, year specifies the year. The month is \nspecified by month , with zero indicating January. The day of the month is specified by \ndayOfMonth . The first version sets the time to midnight. The second version also sets the \nhours and the minutes. The third version adds seconds. \nYou can also construct a GregorianCalendar object by specifying the locale and/or time \nzone. The following constructors create objects initialized with the current date and time \nusing the specified time zone and/or locale: \n\nGregorianCalendar ( Locale locale ) \nGregorianCalendar ( TimeZone timeZone ) \nGregorianCalendar ( TimeZone timeZone , Locale locale ) \n\nGregorianCalendar provides an implementation of all the abstract methods in \nCalendar . It also provides some additional methods. Perhaps the most interesting \nis isLeapYear ( ) , which tests if the year is a leap year. Its form is \n\nboolean isLeapYear ( int year )",
    "boolean isLeapYear ( int year ) \n\nThis method returns true if year is a leap year and false otherwise. JDK 8 also \nadds the following methods: from ( ) and toZonedDateTime ( ) , which support \nthe new date and time API, and getCalendarType ( ) , which returns the calendar \ntype as a string, which is \u201cgregory\u201d. \nThe following program demonstrates GregorianCalendar : \n\n\nSample output is shown here: \n\nTimeZone \n\nAnother time-related class is TimeZone . The abstract TimeZone class allows you to work \nwith time zone offsets from Greenwich mean time ( GMT ), also referred to as Coordinated \n\nUniversal Time ( UTC ). It also computes daylight saving time. TimeZone only supplies the \ndefault constructor. \nA sampling of methods defined by TimeZone is given in Table 19-6. \n\n\nTable 19-6    A Sampling of the Methods Defined by TimeZone \n\nSimpleTimeZone",
    "Table 19-6    A Sampling of the Methods Defined by TimeZone \n\nSimpleTimeZone \n\nThe SimpleTimeZone class is a convenient subclass of TimeZone . It implements \nTimeZone 's abstract methods and allows you to work with time zones for a Gregorian \ncalendar. It also computes daylight saving time. \nSimpleTimeZone defines four constructors. One is \n\nSimpleTimeZone ( int timeDelta , String tzName ) \n\nThis constructor creates a SimpleTimeZone object. The offset relative to \nGreenwich mean time ( GMT ) is timeDelta . The time zone is named tzName . \nThe second SimpleTimeZone constructor is \n\n\nHere, the offset relative to GMT is specified in timeDelta . The time zone name is passed in \ntzId . The start of daylight saving time is indicated by the parameters dstMonth0 , \ndstDayInMonth0 , dstDay0 , and time0 . The end of daylight saving time is indicated by the \nparameters dstMonth1 , dstDayInMonth1 , dstDay1 , and time1 . \nThe third SimpleTimeZone constructor is",
    "Here, dstDelta is the number of milliseconds saved during daylight saving time. \nThe fourth SimpleTimeZone constructor is: \n\nHere, time0mode specifies the mode of the starting time, and time1mode specifies the mode \nof the ending time. Valid mode values include: \n\nThe time mode indicates how the time values are interpreted. The default mode used by the \nother constructors is WALL_TIME . \n\nLocale \n\nThe Locale class is instantiated to produce objects that describe a geographical or cultural \nregion. It is one of several classes that provide you with the ability to write programs that \ncan execute in different international environments. For example, the formats used to \ndisplay dates, times, and numbers are different in various regions.",
    "Internationalization is a large topic that is beyond the scope of this book. However, many \nprograms will only need to deal with its basics, which include setting the current locale. \nThe Locale class defines the following constants that are useful for dealing with several \ncommon locales: \n\n\nFor example, the expression Locale . CANADA represents the Locale object for Canada. \nThe constructors for Locale are \n\nLocale ( String language ) \nLocale ( String language , String country ) \nLocale ( String language , String country , String variant ) \n\nThese constructors build a Locale object to represent a specific language and in \nthe case of the last two, country . These values must contain standard language and \ncountry codes. Auxiliary variant information can be provided in variant . \nLocale defines several methods. One of the most important is setDefault ( ) , shown here: \n\nstatic void setDefault ( Locale localeObj )",
    "static void setDefault ( Locale localeObj ) \n\nThis sets the default locale used by the JVM to that specified by localeObj . \nSome other interesting methods are the following: \n\nfinal String getDisplayCountry ( ) \nfinal String getDisplayLanguage ( ) \nfinal String getDisplayName ( ) \n\nThese return human-readable strings that can be used to display the name of the \ncountry, the name of the language, and the complete description of the locale. \nThe default locale can be obtained using getDefault ( ) , shown here: \n\nstatic Locale getDefault ( ) \n\nJDK 7 added significant upgrades to the Locale class that support Internet \nEngineering Task Force ( IETF ) BCP 47, which defines tags for identifying \nlanguages, and Unicode Technical Standard ( UTS ) 35, which defines the Locale \nData Markup Language ( LDML ). Support for BCP 47 and UTS 35 caused several",
    "features to be added to Locale , including several new methods and the \nLocale.Builder class. Among others, new methods include getScript ( ) , which \nobtains the locale\u2019s script, and toLanguageTag ( ) , which obtains a string that \ncontains the locale\u2019s language tag. The Locale.Builder class constructs Locale \ninstances. It ensures that a locale specification is well-formed as defined by BCP \n47. ( The Locale constructors do not provide such a check.) Several new methods \n\n\nhave also been added to Locale by JDK 8. Among these are methods that support \nfiltering, extensions, and lookups. \nCalendar and GregorianCalendar are examples of classes that operate in a localesensitive manner. DateFormat and SimpleDateFormat also depend on the locale. \n\nRandom \n\nThe Random class is a generator of pseudorandom numbers. These are called \npseudorandom numbers because they are simply uniformly distributed sequences. \nRandom defines the following constructors:",
    "The Random class is a generator of pseudorandom numbers. These are called \npseudorandom numbers because they are simply uniformly distributed sequences. \nRandom defines the following constructors: \n\nRandom ( ) \nRandom ( long seed )",
    "The first version creates a number generator that uses a reasonably unique seed. \nThe second form allows you to specify a seed value manually. \nIf you initialize a Random object with a seed, you define the starting point for the random \nsequence. If you use the same seed to initialize another Random object, you will extract the \nsame random sequence. If you want to generate different sequences, specify different seed \nvalues. One way to do this is to use the current time to seed a Random object. This \napproach reduces the possibility of getting repeated sequences. \nThe core public methods defined by Random are shown in Table 19-7. These are the \nmethods that have been available in Random for several years ( many since Java 1.0 ) and \nare widely used. \nAs you can see, there are seven types of random numbers that you can extract from a \nRandom object. Random Boolean values are available from nextBoolean ( ) . Random \nbytes can be obtained by calling nextBytes ( )",
    ". Random Boolean values are available from nextBoolean ( ) . Random \nbytes can be obtained by calling nextBytes ( ) . Integers can be extracted via the nextInt ( ) \nmethod. Long integers, uniformly distributed over their range, can be obtained with \nnextLong ( ) . The nextFloat ( ) and nextDouble ( ) methods return a uniformly \ndistributed float and double , respectively, between 0.0 and 1.0. Finally, nextGaussian ( ) \nreturns a double value centered at 0.0 with a standard deviation of 1.0. This is what is \nknown as a bell curve . \nHere is an example that demonstrates the sequence produced by nextGaussian ( ) . It \nobtains 100 random Gaussian values and averages these values. The program also counts \nthe number of values that fall within two standard deviations, plus or minus, using \nincrements of 0.5 for each category. The result is graphically displayed sideways on the \nscreen.",
    "Table 19-7    The Core Methods Defined by Random \n\nHere is a sample program run. As you can see, a bell-like distribution of numbers is \n\n\nobtained. \n\nJDK 8 adds three new methods to Random that support the new stream API ( see Chapter \n29 ). They are called doubles ( ) , ints ( ) , and longs ( ) , and each returns a reference to a \nstream that contains a sequence of pseudorandom values of the specified type. Each method \ndefines several overloads. Here are their simplest forms: \n\nDoubleStream doubles ( ) \n\nIntStream ints ( ) \n\nLongStream longs ( )",
    "DoubleStream doubles ( ) \n\nIntStream ints ( ) \n\nLongStream longs ( ) \n\nThe doubles ( ) method returns a stream that contains pseudorandom double \nvalues. ( The range of these values will be less than 1.0 but greater than 0.0.) The \nints ( ) method returns a stream that contains pseudorandom int values. The \nlongs ( ) method returns a stream that contains pseudorandom long values. For \nthese three methods, the stream returned is effectively infinite. Several overloads of \neach method are provided that let you specify the size of the stream, an origin, and \nan upper bound. \n\nObservable \n\nThe Observable class is used to create subclasses that other parts of your program can \nobserve. When an object of such a subclass undergoes a change, observing classes are \nnotified. Observing classes must implement the Observer interface, which defines the \nupdate ( ) method. The update ( ) method is called when an observer is notified of a",
    "change in an observed object. \nObservable defines the methods shown in Table 19-8. An object that is being observed \nmust follow two simple rules. First, if it has changed, it must call setChanged ( ) . Second, \nwhen it is ready to notify observers of this change, it must call notifyObservers ( ) . This \ncauses the update ( ) method in the observing object ( s ) to be called. Be careful\u2014if the \nobject calls notifyObservers ( ) without having previously called setChanged ( ) , no \naction will take place. The observed object must call both setChanged ( ) and \n\n\nnotifyObservers ( ) before update ( ) will be called. \n\nTable 19-8    The Methods Defined by Observable",
    "notifyObservers ( ) before update ( ) will be called. \n\nTable 19-8    The Methods Defined by Observable \n\nNotice that notifyObservers ( ) has two forms: one that takes an argument and \none that does not. If you call notifyObservers ( ) with an argument, this object is \npassed to the observer\u2019s update ( ) method as its second parameter. Otherwise, \nnull is passed to update ( ) . You can use the second parameter for passing any \ntype of object that is appropriate for your application. \n\nThe Observer Interface \n\nTo observe an observable object, you must implement the Observer interface. This \ninterface defines only the one method shown here: \n\nvoid update ( Observable observOb , Object arg ) \n\nHere, observOb is the object being observed, and arg is the value passed by \nnotifyObservers ( ) . The update ( ) method is called when a change in the \nobserved object takes place. \n\nAn Observer Example",
    "An Observer Example \n\nHere is an example that demonstrates an observable object. It creates an observer class, \ncalled Watcher , that implements the Observer interface. The class being monitored is \ncalled BeingWatched . It extends Observable . Inside BeingWatched is the method \ncounter ( ) , which simply counts down from a specified value. It uses sleep ( ) to wait a \ntenth of a second between counts. Each time the count changes, notifyObservers ( ) is \n\ncalled with the current count passed as its argument. This causes the update ( ) method \ninside Watcher to be called, which displays the current count. Inside main ( ) , a Watcher \nand a BeingWatched object, called observing and observed , respectively, are created. \nThen, observing is added to the list of observers for observed . This means that \n\n\nobserving.update ( ) will be called each time counter ( ) calls notifyObservers ( ) . \n\nThe output from this program is shown here:",
    "observing.update ( ) will be called each time counter ( ) calls notifyObservers ( ) . \n\nThe output from this program is shown here: \n\n\nMore than one object can be an observer. For example, the following program implements \ntwo observing classes and adds an object of each class to the BeingWatched observer list. \nThe second observer waits until the count reaches zero and then rings the bell. \n\n\nThe Observable class and the Observer interface allow you to implement sophisticated \nprogram architectures based on the document/view methodology. \n\nTimer and TimerTask \n\nAn interesting and useful feature offered by java.util is the ability to schedule a task for",
    "execution at some future time. The classes that support this are Timer and TimerTask . \nUsing these classes, you can create a thread that runs in the background, waiting for a \nspecific time. When the time arrives, the task linked to that thread is executed. Various \noptions allow you to schedule a task for repeated execution, and to schedule a task to run on \na specific date. Although it was always possible to manually create a task that would be \nexecuted at a specific time using the Thread class, Timer and TimerTask greatly simplify \nthis process. \nTimer and TimerTask work together. Timer is the class that you will use to schedule a \ntask for execution. The task being scheduled must be an instance of TimerTask . Thus, to \nschedule a task, you will first create a TimerTask object and then schedule it for execution \nusing an instance of Timer . \nTimerTask implements the Runnable interface ; thus, it can be used to create a thread of \nexecution",
    ". \nTimerTask implements the Runnable interface ; thus, it can be used to create a thread of \nexecution. Its constructor is shown here:",
    "protected TimerTask ( ) \n\nTimerTask defines the methods shown in Table 19-9. Notice that run ( ) is \nabstract, which means that it must be overridden. The run ( ) method, defined by \nthe Runnable interface, contains the code that will be executed. Thus, the easiest \nway to create a timer task is to extend TimerTask and override run ( ) . \nOnce a task has been created, it is scheduled for execution by an object of type Timer . The \nconstructors for Timer are shown here: \n\nTimer ( ) \nTimer ( boolean DThread ) \nTimer ( String tName ) \nTimer ( String tName , boolean DThread ) \n\nThe first version creates a Timer object that runs as a normal thread. The second",
    "Timer ( ) \nTimer ( boolean DThread ) \nTimer ( String tName ) \nTimer ( String tName , boolean DThread ) \n\nThe first version creates a Timer object that runs as a normal thread. The second \n\nuses a daemon thread if DThread is true . A daemon thread will execute only as \nlong as the rest of the program continues to execute. The third and fourth \nconstructors allow you to specify a name for the Timer thread. The methods \ndefined by Timer are shown in Table 19-9. \nOnce a Timer has been created, you will schedule a task by calling schedule ( ) on the \nTimer that you created. As Table 19-10 shows, there are several forms of schedule ( ) \nwhich allow you to schedule tasks in a variety of ways. \n\n\nTable 19-9    The Methods Defined by TimerTask \n\nTable 19-10    The Methods Defined by Timer",
    "Table 19-9    The Methods Defined by TimerTask \n\nTable 19-10    The Methods Defined by Timer \n\nIf you create a non-daemon task, then you will want to call cancel ( ) to end the \ntask when your program ends. If you don\u2019t do this, then your program may \"hang\" \nfor a period of time. \nThe following program demonstrates Timer and TimerTask . It defines a timer task whose \nrun ( ) method displays the message \"Timer task executed.\" This task is scheduled to run \nonce every half second after an initial delay of one second. \n\n\nCurrency \n\nThe Currency class encapsulates information about a currency. It defines no constructors. \nThe methods supported by Currency are shown in Table 19-11. The following program \n\ndemonstrates Currency : \n\n\nTable 19-11    The Methods Defined by Currency \n\nThe output is shown here: \n\nFormatter \n\nAt the core of Java\u2019s support for creating formatted output is the Formatter class. It",
    "Table 19-11    The Methods Defined by Currency \n\nThe output is shown here: \n\nFormatter \n\nAt the core of Java\u2019s support for creating formatted output is the Formatter class. It \n\nprovides format conversions that let you display numbers, strings, and time and date in \nvirtually any format you like. It operates in a manner similar to the C/C++ printf ( ) \nfunction, which means that if you are familiar with C/C++, then learning to use Formatter \nwill be very easy. It also further streamlines the conversion of C/C++ code to Java. If you \nare not familiar with C/C++, it is still quite easy to format data. \n\n\nNOTE    Although Java\u2019s Formatter class operates in a manner very \nsimilar to the C/C++ printf ( ) function, there are some differences, and \nsome new features. Therefore, if you have a C/C++ background, a careful \nreading is advised. \n\nThe Formatter Constructors",
    "The Formatter Constructors \n\nBefore you can use Formatter to format output, you must create a Formatter object. In \ngeneral, Formatter works by converting the binary form of data used by a program into \nformatted text. It stores the formatted text in a buffer, the contents of which can be \nobtained by your program whenever they are needed. It is possible to let Formatter supply \nthis buffer automatically, or you can specify the buffer explicitly when a Formatter object \nis created. It is also possible to have Formatter output its buffer to a file. \nThe Formatter class defines many constructors, which enable you to construct a \nFormatter in a variety of ways. Here is a sampling:",
    "Here, buf specifies a buffer for the formatted output. If buf is null, then Formatter \nautomatically allocates a StringBuilder to hold the formatted output. The loc parameter \nspecifies a locale. If no locale is specified, the default locale is used. The filename parameter \nspecifies the name of a file that will receive the formatted output. The charset parameter \n\nspecifies the character set. If no character set is specified, then the default character set is \nused. The outF parameter specifies a reference to an open file that will receive output. The \noutStrm parameter specifies a reference to an output stream that will receive output. When \nusing a file, output is also written to the file. \n\n\nPerhaps the most widely used constructor is the first, which has no parameters. It \nautomatically uses the default locale and allocates a StringBuilder to hold the formatted \noutput. \n\nThe Formatter Methods \n\nFormatter defines the methods shown in Table 19-12.",
    "The Formatter Methods \n\nFormatter defines the methods shown in Table 19-12. \n\nTable 19-12    The Methods Defined by Formatter \n\nFormatting Basics \n\nAfter you have created a Formatter , you can use it to create a formatted string. To do so, \nuse the format ( ) method. The most commonly used version is shown here: \n\nFormatter format ( String fmtString , Object \u2026 arg s ) \n\nThe fmtSring consists of two types of items. The first type is composed of \ncharacters that are simply copied to the output buffer. The second type contains \nformat specifiers that define the way the subsequent arguments are displayed. \nIn its simplest form, a format specifier begins with a percent sign followed by the format \nconversion specifier . All format conversion specifiers consist of a single character. For \nexample, the format specifier for floating-point data is %f . In general, there must be the",
    "same number of arguments as there are format specifiers, and the format specifiers and the \narguments are matched in order from left to right. For example, consider this fragment: \n\nThis sequence creates a Formatter that contains the following string:",
    "In this example, the format specifiers, %s , %d , and %f , are replaced with the arguments \nthat follow the format string. Thus, %s is replaced by \u201cwith Java\u201d, %d is replaced by 10, and \n%f is replaced by 98.6. All other characters are simply used as-is. As you might guess, the \nformat specifier %s specifies a string, and %d specifies an integer value. As mentioned \nearlier, the %f specifies a floating-point value. \nThe format ( ) method accepts a wide variety of format specifiers, which are shown in \nTable 19-13. Notice that many specifiers have both upper- and lowercase forms. When an \nuppercase specifier is used, then letters are shown in uppercase. Otherwise, the upper- and \nlowercase specifiers perform the same conversion. It is important to understand that Java \ntype-checks each format specifier against its corresponding argument. If the argument \ndoesn\u2019t match, an IllegalFormatException is thrown. \n\nTable 19-13    The Format Specifiers",
    "Table 19-13    The Format Specifiers \n\nOnce you have formatted a string, you can obtain it by calling toString ( ) . For \nexample, continuing with the preceding example, the following statement obtains \nthe formatted string contained in fmt : \n\n\nOf course, if you simply want to display the formatted string, there is no reason to first \n\nassign it to a String object. When a Formatter object is passed to println ( ) , for \nexample, its toString ( ) method is automatically called. \nHere is a short program that puts together all of the pieces, showing how to create and \ndisplay a formatted string: \n\nOne other point: You can obtain a reference to the underlying output buffer by calling out ( \n) . It returns a reference to an Appendable object. \nNow that you know the general mechanism used to create a formatted string, the remainder \nof this section discusses in detail each conversion. It also describes various options, such as \njustification, minimum field width, and precision.",
    "Formatting Strings and Characters \n\nTo format an individual character, use %c . This causes the matching character argument to \nbe output, unmodified. To format a string, use %s . \n\nFormatting Numbers \n\nTo format an integer in decimal format, use %d . To format a floating-point value in decimal \nformat, use %f . To format a floating-point value in scientific notation, use %e . Numbers \nrepresented in scientific notation take this general form: \n\nx.dddddd e+/\u2013yy \n\nThe %g format specifier causes Formatter to use either %f or %e , based on the \nvalue being formatted and the precision, which is 6 by default. The following \n\nprogram demonstrates the effect of the %f and %e format specifiers: \n\n\nIt produces the following output: \n\nYou can display integers in octal or hexadecimal format by using %o and %x , respectively. \nFor example, this fragment: \n\nproduces this output:",
    "It produces the following output: \n\nYou can display integers in octal or hexadecimal format by using %o and %x , respectively. \nFor example, this fragment: \n\nproduces this output: \n\nYou can display floating-point values in hexadecimal format by using %a . The format \nproduced by %a appears a bit strange at first glance. This is because its representation uses \na form similar to scientific notation that consists of a hexadecimal significand and a decimal \nexponent of powers of 2. Here is the general format: \n\n0x1. sig p exp \n\nHere, sig contains the fractional portion of the significand and exp contains the \nexponent. The p indicates the start of the exponent. For example, this call: \n\nproduces this output: \n\n\nFormatting Time and Date",
    "produces this output: \n\n\nFormatting Time and Date \n\nOne of the more powerful conversion specifiers is %t . It lets you format time and date \ninformation. The %t specifier works a bit differently than the others because it requires the \nuse of a suffix to describe the portion and precise format of the time or date desired. The \nsuffixes are shown in Table 19-14. For example, to display minutes, you would use %tM , \nwhere M indicates minutes in a two-character field. The argument corresponding to the %t \nspecifier must be of type Calendar , Date , Long , or long . \nHere is a program that demonstrates several of the formats: \n\n\nTable 19-14    The Time and Date Format Suffixes \n\nSample output is shown here: \n\nThe %n and %% Specifiers",
    "Table 19-14    The Time and Date Format Suffixes \n\nSample output is shown here: \n\nThe %n and %% Specifiers \n\nThe %n and %% format specifiers differ from the others in that they do not match an \nargument. Instead, they are simply escape sequences that insert a character into the output \nsequence. The %n inserts a newline. The %% inserts a percent sign. Neither of these \n\n\ncharacters can be entered directly into the format string. Of course, you can also use the \nstandard escape sequence \\n to embed a newline character. \nHere is an example that demonstrates the %n and %% format specifiers: \n\nIt displays the following output: \n\nSpecifying a Minimum Field Width",
    "It displays the following output: \n\nSpecifying a Minimum Field Width \n\nAn integer placed between the % sign and the format conversion code acts as a minimum \nfield-width specifier . This pads the output with spaces to ensure that it reaches a certain \nminimum length. If the string or number is longer than that minimum, it will still be \nprinted in full. The default padding is done with spaces. If you want to pad with 0\u2019s, place a \n0 before the field-width specifier. For example, %05d will pad a number of less than five \ndigits with 0\u2019s so that its total length is five. The field-width specifier can be used with all \nformat specifiers except %n . \nThe following program demonstrates the minimum field-width specifier by applying it to \nthe %f conversion: \n\n\nThis program produces the following output:",
    "This program produces the following output: \n\nThe first line displays the number 10.12345 in its default width. The second line displays \nthat value in a 12-character field. The third line displays the value in a 12-character field, \npadded with leading zeros. \nThe minimum field-width modifier is often used to produce tables in which the columns \nline up. For example, the next program produces a table of squares and cubes for the \nnumbers between 1 and 10: \n\n\nIts output is shown here: \n\nSpecifying Precision \n\nA precision specifier can be applied to the %f , %e , %g , and %s format specifiers. It follows \n\nthe minimum field-width specifier ( if there is one ) and consists of a period followed by an \ninteger. Its exact meaning depends upon the type of data to which it is applied. \nWhen you apply the precision specifier to floating-point data using the %f or %e specifiers, \nit determines the number of decimal places displayed. For example, %10.4f displays a",
    "number at least ten characters wide with four decimal places. When using %g , the precision \ndetermines the number of significant digits. The default precision is 6. \nApplied to strings, the precision specifier specifies the maximum field length. For example, \n%5.7s displays a string of at least five and not exceeding seven characters long. If the string \nis longer than the maximum field width, the end characters will be truncated. \nThe following program illustrates the precision specifier: \n\n\nIt produces the following output: \n\nUsing the Format Flags \n\nFormatter recognizes a set of format flags that lets you control various aspects of a \nconversion. All format flags are single characters, and a format flag follows the % in a \nformat specification. The flags are shown here: \n\nFlag \nEffect \n\n\u2013 \nLeft justification \n\n# \nAlternate conversion format \n\n0 \nOutput is padded with zeros rather than spaces \n\nspace \nPositive numeric output is preceded by a space",
    "Flag \nEffect \n\n\u2013 \nLeft justification \n\n# \nAlternate conversion format \n\n0 \nOutput is padded with zeros rather than spaces \n\nspace \nPositive numeric output is preceded by a space \n\n\n+ \nPositive numeric output is preceded by a + sign \n\n, \nNumeric values include grouping separators \n\n( \nNegative numeric values are enclosed within \nparentheses \n\nNot all flags apply to all format specifiers. The following sections explain each in detail. \n\nJustifying Output \n\nBy default, all output is right-justified. That is, if the field width is larger than the data \nprinted, the data will be placed on the right edge of the field. You can force output to be leftjustified by placing a minus sign directly after the %. For instance, %\u201310.2f left-justifies a \nfloating-point number with two decimal places in a 10-character field. For example, \nconsider this program: \n\nIt produces the following output: \n\nAs you can see, the second line is left-justified within a 10-character field.",
    "It produces the following output: \n\nAs you can see, the second line is left-justified within a 10-character field. \n\nThe Space, +, 0, and ( Flags \n\nTo cause a + sign to be shown before positive numeric values, add the + flag. For example, \n\n\ncreates this string: \n\nWhen creating columns of numbers, it is sometimes useful to output a space before positive \nvalues so that positive and negative values line up. To do this, add the space flag. For \nexample, \n\nThe output is shown here: \n\n\nNotice that the positive values have a leading space, which causes the digits in the column \nto line up properly. \nTo show negative numeric output inside parentheses, rather than with a leading \u2013, use the ( \nflag. For example, \n\ncreates this string: \n\nThe 0 flag causes output to be padded with zeros rather than spaces. \n\nThe Comma Flag",
    "creates this string: \n\nThe 0 flag causes output to be padded with zeros rather than spaces. \n\nThe Comma Flag \n\nWhen displaying large numbers, it is often useful to add grouping separators, which in \nEnglish are commas. For example, the value 1234567 is more easily read when formatted as \n1,234,567. To add grouping specifiers, use the comma (,) flag. For example, \n\ncreates this string: \n\nThe # Flag \n\nThe # can be applied to %o , %x , %e, and %f . For %e, and %f , the # ensures that there will \nbe a decimal point even if there are no decimal digits. If you precede the %x format specifier \nwith a # , the hexadecimal number will be printed with a 0x prefix. Preceding the %o \nspecifier with # causes the number to be printed with a leading zero. \n\nThe Uppercase Option \n\nAs mentioned earlier, several of the format specifiers have uppercase versions that cause the \nconversion to use uppercase where appropriate. The following table describes the effect. \n\nSpecifier \nEffect",
    "Specifier \nEffect \n\n%A \nCauses the hexadecimal digits a through f to be \ndisplayed in uppercase as A through F . Also, the prefix \n0x is displayed as 0X , and the p will be displayed as P . \n\n%B \nUppercases the values true and false . \n\n%E \nCauses the e symbol that indicates the exponent to be \ndisplayed in uppercase. \n\n\n%G \nCauses the e symbol that indicates the exponent to be \ndisplayed in uppercase. \n\n%H \nCauses the hexadecimal digits a through f to be \ndisplayed in uppercase as A through F . \n\n%S \nUppercases the corresponding string. \n\n%T \nCauses all alphabetical output to be displayed in \nuppercase. \n\n%X \nCauses the hexadecimal digits a through f to be \ndisplayed in uppercase as A through F . Also, the optional \nprefix 0x is displayed as 0X , if present. \n\nFor example, this call: \n\ncreates this string: \n\nThis call: \n\ncreates this string: \n\nUsing an Argument Index",
    "For example, this call: \n\ncreates this string: \n\nThis call: \n\ncreates this string: \n\nUsing an Argument Index \n\nFormatter includes a very useful feature that lets you specify the argument to which a \nformat specifier applies. Normally, format specifiers and arguments are matched in order, \nfrom left to right. That is, the first format specifier matches the first argument, the second \nformat specifier matches the second argument, and so on. However, by using an argument \nindex , you can explicitly control which argument a format specifier matches. \nAn argument index immediately follows the % in a format specifier. It has the following \nformat: \n\nn $ \n\nwhere n is the index of the desired argument, beginning with 1. For example, \nconsider this example: \n\n\nIt produces this string:",
    "n $ \n\nwhere n is the index of the desired argument, beginning with 1. For example, \nconsider this example: \n\n\nIt produces this string: \n\nIn this example, the first format specifier matches 30, the second matches 10, and the third \nmatches 20. Thus, the arguments are used in an order other than strictly left to right. \nOne advantage of argument indexes is that they enable you to reuse an argument without \nhaving to specify it twice. For example, consider this line: \n\nIt produces the following string: \n\nAs you can see, the argument 255 is used by both format specifiers. \nThere is a convenient shorthand called a relative index that enables you to reuse the \nargument matched by the preceding format specifier. Simply specify < for the argument \nindex. For example, the following call to format ( ) produces the same results as the \nprevious example: \n\nRelative indexes are especially useful when creating custom time and date formats. Consider \nthe following example:",
    "Relative indexes are especially useful when creating custom time and date formats. Consider \nthe following example: \n\nHere is sample output: \n\n\nBecause of relative indexing, the argument cal need only be passed once, rather than three \ntimes. \n\nClosing a Formatter",
    "Closing a Formatter \n\nIn general, you should close a Formatter when you are done using it. Doing so frees any \nresources that it was using. This is especially important when formatting to a file, but it can \nbe important in other cases, too. As the previous examples have shown, one way to close a \nFormatter is to explicitly call close ( ) . However, beginning with JDK 7, Formatter \nimplements the AutoCloseable interface. This means that it supports the try -withresources statement. Using this approach, the Formatter is automatically closed when it is \nno longer needed. \nThe try -with-resources statement is described in Chapter 13, in connection with files, \nbecause files are some of the most commonly used resources that must be closed. However, \nthe same basic techniques apply here. For example, here is the first Formatter example \nreworked to use automatic resource management: \n\nThe output is the same as before. \n\nThe Java printf ( ) Connection",
    "The output is the same as before. \n\nThe Java printf ( ) Connection \n\nAlthough there is nothing technically wrong with using Formatter directly ( as the \n\npreceding examples have done ) when creating output that will be displayed on the console, \nthere is a more convenient alternative: the printf ( ) method. The printf ( ) method \nautomatically uses Formatter to create a formatted string. It then displays that string on \nSystem.out , which is the console by default. The printf ( ) method is defined by both \nPrintStream and PrintWriter . The printf ( ) method is described in Chapter 20. \n\n\nScanner",
    "Scanner \n\nScanner is the complement of Formatter . It reads formatted input and converts it into its \nbinary form. Scanner can be used to read input from the console, a file, a string, or any \nsource that implements the Readable interface or ReadableByteChannel . For example, \nyou can use Scanner to read a number from the keyboard and assign its value to a variable. \nAs you will see, given its power, Scanner is surprisingly easy to use. \n\nThe Scanner Constructors \n\nScanner defines the constructors shown in Table 19-15. In general, a Scanner can be \ncreated for a String , an InputStream , a File , or any object that implements the \nReadable or ReadableByteChannel interfaces. Here are some examples. \nThe following sequence creates a Scanner that reads the file Test.txt :",
    "This works because FileReader implements the Readable interface. Thus, the call to the \nconstructor resolves to Scanner ( Readable ) . \nThis next line creates a Scanner that reads from standard input, which is the keyboard by \ndefault: \n\nThis works because System.in is an object of type InputStream . Thus, the call to the \nconstructor maps to Scanner ( InputStream ) . \nThe next sequence creates a Scanner that reads from a string. \n\nScanning Basics \n\nOnce you have created a Scanner , it is a simple matter to use it to read formatted input. In \ngeneral, a Scanner reads tokens from the underlying source that you specified when the \nScanner was created. As it relates to Scanner , a token is a portion of input that is \ndelineated by a set of delimiters, which is whitespace by default. A token is read by matching \nit with a particular regular expression , which defines the format of the data. Although",
    "Scanner allows you to define the specific type of expression that its next input operation \nwill match, it includes many predefined patterns, which match the primitive types, such as \nint and double , and strings. Thus, often you won\u2019t need to specify a pattern to match. \n\n\nTable 19-15    The Scanner Constructors \n\nIn general, to use Scanner , follow this procedure: \n\n1.  Determine if a specific type of input is available by calling one of \nScanner \u2019s hasNext X methods, where X is the type of data desired. \n\n2.  If input is available, read it by calling one of Scanner \u2019s next X methods. \n\n3.  Repeat the process until input is exhausted. \n\n4.  Close the Scanner by calling close ( ) . \n\nAs the preceding indicates, Scanner defines two sets of methods that enable you \nto read input. The first are the hasNext X methods, which are shown in Table 1916. These methods determine if the specified type of input is available. For",
    "example, calling hasNextInt ( ) returns true only if the next token to be read is an \ninteger. If the desired data is available, then you read it by calling one of \nScanner \u2019s next X methods, which are shown in Table 19-17. \n\n\nTable 19-16    The Scanner hasNext Methods \n\n\nTable 19-17    The Scanner next Methods \n\nFor example, to read the next integer, call nextInt ( ) . The following sequence \nshows how to read a list of integers from the keyboard. \n\nThe while loop stops as soon as the next token is not an integer. Thus, the loop stops \nreading integers as soon as a non-integer is encountered in the input stream. \nIf a next method cannot find the type of data it is looking for, it throws an \n\n\nInputMismatchException . A NoSuchElementException is thrown if no more input is \navailable. For this reason, it is best to first confirm that the desired type of data is available \nby calling a hasNext method before calling its corresponding next method.",
    "Some Scanner Examples \n\nScanner makes what could be a tedious task into an easy one. To understand why, let\u2019s \nlook at some examples. The following program averages a list of numbers entered at the \nkeyboard: \n\nThe program reads numbers from the keyboard, summing them in the process, until the \nuser enters the string \"done\". It then stops input and displays the average of the numbers. \nHere is a sample run:",
    "The program reads numbers until it encounters a token that does not represent a valid \ndouble value. When this occurs, it confirms that the token is the string \"done\". If it is, the \nprogram terminates normally. Otherwise, it displays an error. \nNotice that the numbers are read by calling nextDouble ( ) . This method reads any number \nthat can be converted into a double value, including an integer value, such as 2, and a \nfloating-point value like 3.4. Thus, a number read by nextDouble ( ) need not specify a \ndecimal point. This same general principle applies to all next methods. They will match and \nread any data format that can represent the type of value being requested. \nOne thing that is especially nice about Scanner is that the same technique used to read \nfrom one source can be used to read from another. For example, here is the preceding \nprogram reworked to average a list of numbers contained in a text file: \n\n\nHere is the output:",
    "Here is the output: \n\nThe preceding program illustrates another important feature of Scanner . Notice that the \nfile reader referred to by fin is not closed directly. Rather, it is closed automatically when \nsrc calls close ( ) . When you close a Scanner , the Readable associated with it is also \nclosed ( if that Readable implements the Closeable interface ). Therefore, in this case, the \n\n\nfile referred to by fin is automatically closed when src is closed. \n\nBeginning with JDK 7, Scanner also implements the AutoCloseable interface. This \nmeans that it can be managed by a try -with-resources block. As explained in Chapter 13, \nwhen try -with-resources is used, the scanner is automatically closed when the block ends. \nFor example, src in the preceding program could have been managed like this:",
    "To clearly demonstrate the closing of a Scanner , the following examples will call close ( ) \nexplicitly. ( Doing so also allows them to be compiled by versions of Java prior to JDK 7.) \nHowever, the try -with-resources approach is more streamlined and can help prevent errors. \nIts use is recommended for new code. \nOne other point: To keep this and the other examples in this section compact, I/O \nexceptions are simply thrown out of main ( ) . However, your real-world code will normally \nhandle I/O exceptions itself. \nYou can use Scanner to read input that contains several different types of data\u2014even if the \norder of that data is unknown in advance. You must simply check what type of data is \navailable before reading it. For example, consider this program: \n\n\nHere is the output:",
    "Here is the output: \n\n\nWhen reading mixed data types, as the preceding program does, you need to be a bit careful \nabout the order in which you call the next methods. For example, if the loop reversed the \norder of the calls to nextInt ( ) and nextDouble ( ) , both numeric values would have been \nread as double s, because nextDouble ( ) matches any numeric string that can be \nrepresented as a double . \n\nSetting Delimiters \n\nScanner defines where a token starts and ends based on a set of delimiters . The default \ndelimiters are the whitespace characters, and this is the delimiter set that the preceding \nexamples have used. However, it is possible to change the delimiters by calling the \nuseDelimiter ( ) method, shown here: \n\nScanner useDelimiter ( String pattern ) \n\nScanner useDelimiter ( Pattern pattern )",
    "Scanner useDelimiter ( String pattern ) \n\nScanner useDelimiter ( Pattern pattern ) \n\nHere, pattern is a regular expression that specifies the delimiter set. \nHere is the program that reworks the average program shown earlier so that it reads a list of \nnumbers that are separated by commas, and any number of spaces: \n\n\nIn this version, the numbers written to test.txt are separated by commas and spaces. The \nuse of the delimiter pattern \", * \" tells Scanner to match a comma and zero or more spaces \nas delimiters. The output is the same as before. \nYou can obtain the current delimiter pattern by calling delimiter ( ) , shown here: \n\n\nPattern delimiter ( ) \n\nOther Scanner Features \n\nScanner defines several other methods in addition to those already discussed. One that is \nparticularly useful in some circumstances is findInLine ( ) . Its general forms are shown \nhere: \n\nString findInLine ( Pattern pattern ) \nString findInLine ( String pattern )",
    "String findInLine ( Pattern pattern ) \nString findInLine ( String pattern ) \n\nThis method searches for the specified pattern within the next line of text. If the \npattern is found, the matching token is consumed and returned. Otherwise, null is \nreturned. It operates independently of any delimiter set. This method is useful if \nyou want to locate a specific pattern. For example, the following program locates \nthe Age field in the input string and then displays the age: \n\nThe output is 28 . In the program, findInLine ( ) is used to find an occurrence of the \npattern \"Age\". Once found, the next token is read, which is the age. \nRelated to findInLine ( ) is findWithinHorizon ( ) . It is shown here: \n\nString findWithinHorizon ( Pattern pattern , int count ) \n\nString findWithinHorizon ( String pattern , int count ) \n\nThis method attempts to find an occurrence of the specified pattern within the next \ncount characters. If successful, it returns the matching pattern. Otherwise, it",
    "This method attempts to find an occurrence of the specified pattern within the next \ncount characters. If successful, it returns the matching pattern. Otherwise, it \n\n\nreturns null . If count is zero, then all input is searched until either a match is \nfound or the end of input is encountered. \nYou can bypass a pattern using skip ( ) , shown here: \n\nScanner skip ( Pattern pattern ) \n\nScanner skip ( String pattern ) \n\nIf pattern is matched, skip ( ) simply advances beyond it and returns a reference \nto the invoking object. If pattern is not found, skip ( ) throws \nNoSuchElementException . \nOther Scanner methods include radix ( ) , which returns the default radix used by the \nScanner ; useRadix ( ) , which sets the radix ; reset ( ) , which resets the scanner ; and \nclose ( ) , which closes the scanner. \n\nThe ResourceBundle, ListResourceBundle, and \nPropertyResourceBundle Classes",
    "The java.util package includes three classes that aid in the internationalization of your \nprogram. The first is the abstract class ResourceBundle . It defines methods that enable \nyou to manage a collection of locale-sensitive resources, such as the strings that are used to \nlabel the user interface elements in your program. You can define two or more sets of \ntranslated strings that support various languages, such as English, German, or Chinese, with \neach translation set residing in its own bundle. You can then load the bundle appropriate to \nthe current locale and use the strings to construct the program\u2019s user interface. \nResource bundles are identified by their family name ( also called their base name ). To the \nfamily name can be added a two-character lowercase language code which specifies the \nlanguage. In this case, if a requested locale matches the language code, then that version of \nthe resource bundle is used",
    ". In this case, if a requested locale matches the language code, then that version of \nthe resource bundle is used. For example, a resource bundle with a family name of \nSampleRB could have a German version called SampleRB_de and a Russian version \ncalled SampleRB_ru . ( Notice that an underscore links the family name to the language \ncode.) Therefore, if the locale is Locale.GERMAN , SampleRB_de will be used. \nIt is also possible to indicate specific variants of a language that relate to a specific country \nby specifying a country code after the language code. A country code is a two-character \nuppercase identifier, such as AU for Australia or IN for India. A country code is also \npreceded by an underscore when linked to the resource bundle name. A resource bundle \nthat has only the family name is the default bundle. It is used when no language-specific \nbundles are applicable.",
    "NOTE    The language codes are defined by ISO standard 639 and the \ncountry codes by ISO standard 3166. \n\n\nThe methods defined by ResourceBundle are summarized in Table 19-18. One important \npoint: null keys are not allowed and several of the methods will throw a \nNullPointerException if null is passed as the key. Notice the nested class \nResourceBundle.Control . It is used to control the resource-bundle loading process. \n\n\nTable 19-18    The Methods Defined by ResourceBundle \n\nThere are two subclasses of ResourceBundle . The first is \nPropertyResourceBundle , which manages resources by using property files. \nPropertyResourceBundle adds no methods of its own. The second is the \nabstract class ListResourceBundle , which manages resources in an array of \n\nkey/value pairs. ListResourceBundle adds the method getContents ( ) , which \n\nall subclasses must implement. It is shown here: \n\nprotected abstract Object[ ][ ] getContents ( )",
    "key/value pairs. ListResourceBundle adds the method getContents ( ) , which \n\nall subclasses must implement. It is shown here: \n\nprotected abstract Object[ ][ ] getContents ( ) \n\nIt returns a two-dimensional array that contains key/value pairs that represent \nresources. The keys must be strings. The values are typically strings, but can be \n\n\nother types of objects. \nHere is an example that demonstrates using a resource bundle. The resource bundle has the \nfamily name SampleRB . Two resource bundle classes of this family are created by \nextending ListResourceBundle . The first is called SampleRB , and it is the default \nbundle ( which uses English ). It is shown here: \n\nThe second resource bundle, shown next, is called SampleRB_de . It contains the German \ntranslation. \n\n\nThe following program demonstrates these two resource bundles by displaying the string \nassociated with each key for both the default ( English ) version and the German version:",
    "The following program demonstrates these two resource bundles by displaying the string \nassociated with each key for both the default ( English ) version and the German version: \n\nThe output from the program is shown here: \n\n\nMiscellaneous Utility Classes and Interfaces \n\nIn addition to the classes already discussed, java.util includes the following classes: \n\nBase64 \n\nSupports Base64 encoding. Encoder and \nDecoder nested classes are also defined. \n( Added by JDK 8.) \n\nDoubleSummaryStatistics \n\nSupports the compilation of double values. \nThe following statistics are available: average, \nminimum, maximum, count, and sum. ( Added \nby JDK 8.) \n\nEventListenerProxy \nExtends the EventListener class to allow \nadditional parameters. See Chapter 24 for a \ndiscussion of event listeners. \n\nEventObject \nThe superclass for all event classes. Events are \ndiscussed in Chapter 24. \n\nFormattableFlags \nDefines formatting flags that are used with the \nFormattable interface.",
    "EventObject \nThe superclass for all event classes. Events are \ndiscussed in Chapter 24. \n\nFormattableFlags \nDefines formatting flags that are used with the \nFormattable interface. \n\nIntSummaryStatistics \n\nSupports the compilation of int values. The \nfollowing statistics are available: average, \nminimum, maximum, count, and sum. ( Added \nby JDK 8.) \n\nObjects \nVarious methods that operate on objects. \n\nPropertyPermission \nManages property permissions. \n\nServiceLoader \nProvides a means of finding service providers. \n\nStringJoiner \n\nSupports the concatenation of \nCharSequence s, which may include a \nseparator, a prefix, and a suffix. ( Added by \nJDK 8.) \n\nUUID \nEncapsulates and manages Universally Unique \nIdentifiers ( UUIDs ). \n\nThe following interfaces are also packaged in java.util : \n\n\nEventListener \nIndicates that a class is an event listener. Events are \ndiscussed in Chapter 24. \n\nFormattable \nEnables a class to provide custom formatting. \n\nThe java.util Subpackages",
    "EventListener \nIndicates that a class is an event listener. Events are \ndiscussed in Chapter 24. \n\nFormattable \nEnables a class to provide custom formatting. \n\nThe java.util Subpackages \n\nJava defines the following subpackages of java.util : \n\n\u2022  java.util.concurrent \n\n\u2022  java.util.concurrent.atomic \n\n\u2022  java.util.concurrent.locks \n\n\u2022  java.util.function \n\n\u2022  java.util.jar \n\n\u2022  java.util.logging \n\n\u2022  java.util.prefs \n\n\u2022  java.util.regex \n\n\u2022  java.util.spi \n\n\u2022  java.util.stream \n\n\u2022  java.util.zip \n\nEach is briefly examined here. \n\njava.util.concurrent, java.util.concurrent.atomic, and \njava.util.concurrent.locks",
    "\u2022  java.util.regex \n\n\u2022  java.util.spi \n\n\u2022  java.util.stream \n\n\u2022  java.util.zip \n\nEach is briefly examined here. \n\njava.util.concurrent, java.util.concurrent.atomic, and \njava.util.concurrent.locks \n\nThe java.util.concurrent package along with its two subpackages, \njava.util.concurrent.atomic and java.util.concurrent.locks , support concurrent \nprogramming. These packages provide a high-performance alternative to using Java\u2019s builtin synchronization features when thread-safe operation is required. Beginning with JDK 7, \njava.util.concurrent also provides the Fork/Join Framework. These packages are \nexamined in detail in Chapter 28. \n\njava.util.function",
    "java.util.function \n\nThe java.util.function package defines several predefined functional interfaces that you \ncan use when creating lambda expressions or method references. They are also widely used \nthroughout the Java API. The functional interfaces defined by java.util.function are \nshown in Table 19-19 along with a synopsis of their abstract methods. Be aware that some of \nthese interfaces also define default or static methods that supply additional functionality. \nYou will want to explore them fully on your own. ( For a discussion of the use of functional \ninterfaces, see Chapter 15.) \n\n\n\n\nTable 19-19    Functional Interfaces Defined by java.util.function \nand Their Abstract Methods \n\njava.util.jar \n\nThe java.util.jar package provides the ability to read and write Java Archive ( JAR ) files. \n\n\njava.util.logging",
    "java.util.jar \n\nThe java.util.jar package provides the ability to read and write Java Archive ( JAR ) files. \n\n\njava.util.logging \n\nThe java.util.logging package provides support for program activity logs, which can be \nused to record program actions, and to help find and debug problems. \n\njava.util.prefs \n\nThe java.util.prefs package provides support for user preferences. It is typically used to \nsupport program configuration. \n\njava.util.regex \n\nThe java.util.regex package provides support for regular expression handling. It is \ndescribed in detail in Chapter 30. \n\njava.util.spi \n\nThe java.util.spi package provides support for service providers. \n\njava.util.stream \n\nThe java.util.stream package contains Java\u2019s stream API, which was added by JDK 8. A \ndiscussion of the stream API is found in Chapter 29. \n\njava.util.zip",
    "java.util.stream \n\nThe java.util.stream package contains Java\u2019s stream API, which was added by JDK 8. A \ndiscussion of the stream API is found in Chapter 29. \n\njava.util.zip \n\nThe java.util.zip package provides the ability to read and write files in the popular ZIP and \nGZIP formats. Both ZIP and GZIP input and output streams are available. \n\n\uf709 \nPREV \nChapter 18: java.util Part 1: The Collections Fra\u2026 \n\u23ee \n\nNEXT \nChapter 20: Input/Output: Exploring java.io \u23ed \n\n\nPREV \nChapter 19: java.util Part 2: More Utility Classes \n\u23ee \n\nNEXT \nChapter 21: Exploring NIO \n\u23ed \n\nCHAPTER \n\n20 \nInput/Output: Exploring java.io",
    "This chapter explores java.io , which provides support for I/O operations. Chapter 13 \npresented an overview of Java\u2019s I/O system, including basic techniques for reading and \nwriting files, handling I/O exceptions, and closing a file. Here, we will examine the Java I/O \nsystem in greater detail. \nAs all programmers learn early on, most programs cannot accomplish their goals without \naccessing external data. Data is retrieved from an input source. The results of a program are \nsent to an output destination. In Java, these sources or destinations are defined very \nbroadly. For example, a network connection, memory buffer, or disk file can be manipulated \nby the Java I/O classes. Although physically different, these devices are all handled by the \nsame abstraction: the stream . An I/O stream, as explained in Chapter 13, is a logical entity \nthat either produces or consumes information. An I/O stream is linked to a physical device \nby the Java I/O system",
    ". An I/O stream, as explained in Chapter 13, is a logical entity \nthat either produces or consumes information. An I/O stream is linked to a physical device \nby the Java I/O system. All I/O streams behave in the same manner, even if the actual \nphysical devices they are linked to differ.",
    "NOTE    The stream-based I/O system packaged in java.io and described \nin this chapter has been part of Java since its original release and is \nwidely used. However, beginning with version 1.4, a second I/O system \nwas added to Java. It is called NIO ( which was originally an acronym for \nNew I/O ). NIO is packaged in java.nio and its subpackages. The NIO \nsystem is described in Chapter 21. \n\nNOTE    It is important not to confuse the I/O streams used by the I/O \nsystem discussed here with the new stream API added by JDK 8. \n\n\nAlthough conceptually related, they are two different things. Therefore, \nwhen the term stream is used in this chapter, it refers to an I/O stream. \n\nThe I/O Classes and Interfaces \n\nThe I/O classes defined by java.io are listed here:",
    "The I/O Classes and Interfaces \n\nThe I/O classes defined by java.io are listed here: \n\nThe java.io package also contains two deprecated classes that are not shown in the \npreceding table: LineNumberInputStream and StringBufferInputStream . These \nclasses should not be used for new code. \nThe following interfaces are defined by java.io : \n\nAs you can see, there are many classes and interfaces in the java.io package. These include \nbyte and character streams, and object serialization ( the storage and retrieval of objects ). \nThis chapter examines several commonly used I/O components. We begin our discussion \n\nwith one of the most distinctive I/O classes: File . \n\nFile",
    "with one of the most distinctive I/O classes: File . \n\nFile \n\n\nAlthough most of the classes defined by java.io operate on streams, the File class does not. \nIt deals directly with files and the file system. That is, the File class does not specify how \ninformation is retrieved from or stored in files ; it describes the properties of a file itself. A \nFile object is used to obtain or manipulate the information associated with a disk file, such \nas the permissions, time, date, and directory path, and to navigate subdirectory hierarchies. \n\nNOTE    The Path interface and Files class, which are part of the NIO \nsystem, offer a powerful alternative to File in many cases. See Chapter 21 \nfor details.",
    "NOTE    The Path interface and Files class, which are part of the NIO \nsystem, offer a powerful alternative to File in many cases. See Chapter 21 \nfor details. \n\nFiles are a primary source and destination for data within many programs. Although there \nare severe restrictions on their use within applets for security reasons, files are still a central \nresource for storing persistent and shared information. A directory in Java is treated simply \nas a File with one additional property\u2014a list of filenames that can be examined by the list ( \n) method. \nThe following constructors can be used to create File objects: \n\nFile ( String directoryPath ) \nFile ( String directoryPath , String filename ) \nFile ( File dirObj , String filename ) \nFile ( URI uriObj ) \n\nHere, directoryPath is the path name of the file ; filename is the name of the file or",
    "Here, directoryPath is the path name of the file ; filename is the name of the file or \n\nsubdirectory ; dirObj is a File object that specifies a directory ; and uriObj is a URI \nobject that describes a file. \nThe following example creates three files: f1 , f2 , and f3 . The first File object is constructed \nwith a directory path as the only argument. The second includes two arguments\u2014the path \nand the filename. The third includes the file path assigned to f1 and a filename ; f3 refers to \nthe same file as f2 . \n\nNOTE    Java does the right thing with path separators between UNIX \n\n\nand Windows conventions. If you use a forward slash (/) on a Windows \nversion of Java, the path will still resolve correctly. Remember, if you are \nusing the Windows convention of a backslash character (\\), you will need \nto use its escape sequence (\\\\) within a string.",
    "File defines many methods that obtain the standard properties of a File object. For \nexample, getName ( ) returns the name of the file ; getParent ( ) returns the name of the \nparent directory ; and exists ( ) returns true if the file exists, false if it does not. The \nfollowing example demonstrates several of the File methods. It assumes that a directory \ncalled java exists off the root directory and that it contains a file called COPYRIGHT . \n\nThis program will produce output similar to this:",
    "This program will produce output similar to this: \n\n\nMost of the File methods are self-explanatory. isFile ( ) and isAbsolute ( ) are not. isFile ( \n) returns true if called on a file and false if called on a directory. Also, isFile ( ) returns \nfalse for some special files, such as device drivers and named pipes, so this method can be \nused to make sure the file will behave as a file. The isAbsolute ( ) method returns true if \nthe file has an absolute path and false if its path is relative. \nFile includes two useful utility methods of special interest. The first is renameTo ( ) , \nshown here: \n\nboolean renameTo ( File newName )",
    "boolean renameTo ( File newName ) \n\nHere, the filename specified by newName becomes the new name of the invoking \nFile object. It will return true upon success and false if the file cannot be \nrenamed ( if you attempt to rename a file so that it uses an existing filename, for \nexample ). \nThe second utility method is delete ( ) , which deletes the disk file represented by the path \nof the invoking File object. It is shown here: \n\nboolean delete ( ) \n\nYou can also use delete ( ) to delete a directory if the directory is empty. delete ( ) \nreturns true if it deletes the file and false if the file cannot be removed. \nHere are some other File methods that you will find helpful: \n\nMethod \nDescription \n\nvoid deleteOnExit ( \n) \nRemoves the file associated with the invoking \nobject when the Java Virtual Machine terminates. \n\nlong getFreeSpace ( \n) \n\nReturns the number of free bytes of storage \navailable on the partition associated with the \ninvoking object.",
    "long getFreeSpace ( \n) \n\nReturns the number of free bytes of storage \navailable on the partition associated with the \ninvoking object. \n\n\nlong getTotalSpace ( \n) \n\nReturns the storage capacity of the partition \nassociated with the invoking object. \n\nlong \ngetUsableSpace ( ) \n\nReturns the number of usable free bytes of storage \navailable on the partition associated with the \ninvoking object. \n\nboolean isHidden ( ) \nReturns true if the invoking file is hidden. Returns \nfalse otherwise. \n\nboolean \nsetLastModified ( long \nmillisec ) \n\nSets the time stamp on the invoking file to that \nspecified by millisec , which is the number of \nmilliseconds from January 1, 1970, Coordinated \nUniversal Time ( UTC ). \n\nboolean \nsetReadOnly ( ) \nSets the invoking file to read-only.",
    "boolean \nsetReadOnly ( ) \nSets the invoking file to read-only. \n\nMethods also exist to mark files as readable, writable, and executable. Because File \nimplements the Comparable interface, the method compareTo ( ) is also supported. \nJDK 7 added a method to File called toPath ( ) , which is shown here: \n\nPath toPath ( ) \n\ntoPath ( ) returns a Path object that represents the file encapsulated by the \ninvoking File object. ( In other words, toPath ( ) converts a File into a Path .) \nPath is packaged in java.nio.file and is part of NIO. Thus, toPath ( ) forms a \nbridge between the older File class and the newer Path interface. ( See Chapter 21 \nfor a discussion of Path .) \n\nDirectories",
    "Directories \n\nA directory is a File that contains a list of other files and directories. When you create a \nFile object that is a directory, the isDirectory ( ) method will return true . In this case, you \ncan call list ( ) on that object to extract the list of other files and directories inside. It has \ntwo forms. The first is shown here: \n\nString[ ] list ( ) \n\nThe list of files is returned in an array of String objects. \nThe program shown here illustrates how to use list ( ) to examine the contents of a \ndirectory: \n\n\nHere is sample output from the program. ( Of course, the output you see will be different, \nbased on what is in the directory.) \n\nUsing FilenameFilter \n\nYou will often want to limit the number of files returned by the list ( ) method to include \n\nonly those files that match a certain filename pattern, or filter . To do this, you must use a \nsecond form of list ( ) , shown here: \n\nString[ ] list ( FilenameFilter FFObj )",
    "only those files that match a certain filename pattern, or filter . To do this, you must use a \nsecond form of list ( ) , shown here: \n\nString[ ] list ( FilenameFilter FFObj ) \n\n\nIn this form, FFObj is an object of a class that implements the FilenameFilter \n\ninterface. \nFilenameFilter defines only a single method, accept ( ) , which is called once for each file \nin a list. Its general form is given here: \n\nboolean accept ( File directory , String filename ) \n\nThe accept ( ) method returns true for files in the directory specified by directory \nthat should be included in the list ( that is, those that match the filename \nargument ) and returns false for those files that should be excluded. \nThe OnlyExt class, shown next, implements FilenameFilter . It will be used to modify the \npreceding program to restrict the visibility of the filenames returned by list ( ) to files with \nnames that end in the file extension specified when the object is constructed.",
    "The modified directory listing program is shown here. Now it will only display files that use \n\nthe .html extension. \n\n\nThe listFiles ( ) Alternative \n\nThere is a variation to the list ( ) method, called listFiles ( ) , which you might find useful. \nThe signatures for listFiles ( ) are shown here: \n\nFile[ ] listFiles ( ) \nFile[ ] listFiles ( FilenameFilter FFObj ) \nFile[ ] listFiles ( FileFilter FObj ) \n\nThese methods return the file list as an array of File objects instead of strings. The \nfirst method returns all files, and the second returns those files that satisfy the \nspecified FilenameFilter . Aside from returning an array of File objects, these \ntwo versions of listFiles ( ) work like their equivalent list ( ) methods. \nThe third version of listFiles ( ) returns those files with path names that satisfy the \nspecified FileFilter . FileFilter defines only a single method, accept ( ) , which is called \nonce for each file in a list. Its general form is given here:",
    "boolean accept ( File path ) \n\nThe accept ( ) method returns true for files that should be included in the list \n( that is, those that match the path argument ) and false for those that should be \nexcluded. \n\nCreating Directories \n\nAnother two useful File utility methods are mkdir ( ) and mkdirs ( ) . The mkdir ( ) \nmethod creates a directory, returning true on success and false on failure. Failure can \noccur for various reasons, such as the path specified in the File object already exists, or the \ndirectory cannot be created because the entire path does not exist yet. To create a directory \n\nfor which no path exists, use the mkdirs ( ) method. It creates both a directory and all the \nparents of the directory. \n\n\nThe AutoCloseable, Closeable, and Flushable Interfaces",
    "for which no path exists, use the mkdirs ( ) method. It creates both a directory and all the \nparents of the directory. \n\n\nThe AutoCloseable, Closeable, and Flushable Interfaces \n\nThere are three interfaces that are quite important to the stream classes. Two are \nCloseable and Flushable . They are defined in java.io and were added by JDK 5. The \nthird, AutoCloseable , was added by JDK 7. It is packaged in java.lang . \nAutoCloseable provides support for the try -with-resources statement, which automates \nthe process of closing a resource. ( See Chapter 13.) Only objects of classes that implement \nAutoCloseable can be managed by try -with-resources. AutoCloseable is discussed in \nChapter 17, but it is reviewed here for convenience. The AutoCloseable interface defines \nonly the close ( ) method: \n\nvoid close ( ) throws Exception",
    "void close ( ) throws Exception \n\nThis method closes the invoking object, releasing any resources that it may hold. It \nis called automatically at the end of a try -with-resources statement, thus \neliminating the need to explicitly call close ( ) . Because this interface is \nimplemented by all of the I/O classes that open a stream, all such streams can be \nautomatically closed by a try -with-resources statement. Automatically closing a \nstream ensures that it is properly closed when it is no longer needed, thus \npreventing memory leaks and other problems. \nThe Closeable interface also defines the close ( ) method. Objects of a class that \nimplement Closeable can be closed. Beginning with JDK 7, Closeable extends \nAutoCloseable . Therefore, any class that implements Closeable also implements \nAutoCloseable . \nObjects of a class that implements Flushable can force buffered output to be written to the \nstream to which the object is attached. It defines the flush ( ) method, shown here:",
    "void flush ( ) throws IOException \n\nFlushing a stream typically causes buffered output to be physically written to the \nunderlying device. This interface is implemented by all of the I/O classes that write \nto a stream. \n\nI/O Exceptions \n\nTwo exceptions play an important role in I/O handling. The first is IOException . As it \nrelates to most of the I/O classes described in this chapter, if an I/O error occurs, an \nIOException is thrown. In many cases, if a file cannot be opened, a \n\nFileNotFoundException is thrown. FileNotFoundException is a subclass of \nIOException , so both can be caught with a single catch that catches IOException . For \nbrevity, this is the approach used by most of the sample code in this chapter. However, in \nyour own applications, you might find it useful to catch each exception separately. \nAnother exception class that is sometimes important when performing I/O is \nSecurityException . As explained in Chapter 13, in situations in which a security manager",
    "is present, several of the file classes will throw a SecurityException if a security violation \n\n\noccurs when attempting to open a file. By default, applications run via java do not use a \nsecurity manager. For that reason, the I/O examples in this book do not need to watch for a \npossible SecurityException . However, applets will use the security manager provided by \nthe browser, and file I/O performed by an applet could generate a SecurityException . In \nsuch a case, you will need to handle this exception. \n\nTwo Ways to Close a Stream",
    "Two Ways to Close a Stream \n\nIn general, a stream must be closed when it is no longer needed. Failure to do so can lead to \nmemory leaks and resource starvation. The techniques used to close a stream were \ndescribed in Chapter 13, but because of their importance, they warrant a brief review here \nbefore the stream classes are examined. \nBeginning with JDK 7, there are two basic ways in which you can close a stream. The first is \nto explicitly call close ( ) on the stream. This is the traditional approach that has been used \nsince the original release of Java. With this approach, close ( ) is typically called within a \nfinally block. Thus, a simplified skeleton for the traditional approach is shown here: \n\nThis general technique ( or variation thereof ) is common in code that predates JDK 7.",
    "This general technique ( or variation thereof ) is common in code that predates JDK 7. \n\nThe second approach to closing a stream is to automate the process by using the try -withresources statement that was added by JDK 7 ( and, of course, supported by JDK 8 ). The \ntry -with-resources statement is an enhanced form of try that has the following form: \n\nHere, resource-specification is a statement or statements that declares and initializes a \n\nresource, such as a file or other stream-related resource. It consists of a variable declaration \nin which the variable is initialized with a reference to the object being managed. When the \ntry block ends, the resource is automatically released. In the case of a file, this means that \nthe file is automatically closed. Thus, there is no need to call close ( ) explicitly. \nHere are three key points about the try -with-resources statement:",
    "\u2022  Resources managed by try -with-resources must be objects of classes that \nimplement AutoCloseable . \n\n\u2022  The resource declared in the try is implicitly final .",
    "\u2022  You can manage more than one resource by separating each declaration \nby a semicolon. \nAlso, remember that the scope of the declared resource is limited to the try -with-resources \nstatement. \nThe principal advantage of try -with-resources is that the resource ( in this case, a stream ) is \nclosed automatically when the try block ends. Thus, it is not possible to forget to close the \nstream, for example. The try -with-resources approach also typically results in shorter, \nclearer, easier-to-maintain source code. \nBecause of its advantages, try -with-resources is expected to be used extensively in new \ncode. As a result, most of the code in this chapter ( and in this book ) will use it. However, \nbecause a large amount of older code still exists, it is important for all programmers to also \nbe familiar with the traditional approach to closing a stream",
    ". However, \nbecause a large amount of older code still exists, it is important for all programmers to also \nbe familiar with the traditional approach to closing a stream. For example, you will quite \nlikely have to work on legacy code that uses the traditional approach or in an environment \nthat uses an older version of Java. There may also be times when the automated approach is \nnot appropriate because of other aspects of your code. For this reason, a few I/O examples \nin this book will demonstrate the traditional approach so you can see it in action. \nOne last point: The examples that use try -with-resources must be compiled by a modern \nversion of Java. They won\u2019t work with an older compiler. The examples that use the \ntraditional approach can be compiled by older versions of Java.",
    "REMEMBER   Because try -with-resources streamlines the process of \nreleasing a resource and eliminates the possibility of accidentally \nforgetting to release a resource, it is the approach recommended for new \ncode when its use is appropriate. \n\nThe Stream Classes \n\nJava\u2019s stream-based I/O is built upon four abstract classes: InputStream , \n\nOutputStream , Reader , and Writer . These classes were briefly discussed in Chapter 13. \nThey are used to create several concrete stream subclasses. Although your programs \nperform their I/O operations through concrete subclasses, the top-level classes define the \nbasic functionality common to all stream classes. \nInputStream and OutputStream are designed for byte streams. Reader and Writer \n\nare designed for character streams. The byte stream classes and the character stream classes",
    "are designed for character streams. The byte stream classes and the character stream classes \n\n\nform separate hierarchies. In general, you should use the character stream classes when \nworking with characters or strings and use the byte stream classes when working with bytes \nor other binary objects. \nIn the remainder of this chapter, both the byte- and character-oriented streams are \nexamined. \n\nThe Byte Streams \n\nThe byte stream classes provide a rich environment for handling byte-oriented I/O. A byte \nstream can be used with any type of object, including binary data. This versatility makes \nbyte streams important to many types of programs. Since the byte stream classes are topped \nby InputStream and OutputStream , our discussion begins with them. \n\nInputStream",
    "InputStream \n\nInputStream is an abstract class that defines Java\u2019s model of streaming byte input. It \nimplements the AutoCloseable and Closeable interfaces. Most of the methods in this \nclass will throw an IOException when an I/O error occurs. ( The exceptions are mark ( ) \nand markSupported ( ) .) Table 20-1 shows the methods in InputStream . \n\nNOTE    Most of the methods described in Table 20-1 are implemented by \nthe subclasses of InputStream . The mark ( ) and reset ( ) methods are \nexceptions ; notice their use, or lack thereof, by each subclass in the \ndiscussions that follow. \n\nOutputStream \n\nOutputStream is an abstract class that defines streaming byte output. It implements the \n\nAutoCloseable , Closeable , and Flushable interfaces. Most of the methods defined by \nthis class return void and throw an IOException in the case of I/O errors. Table 20-2 \n\nshows the methods in OutputStream . \n\n\nTable 20-1    The Methods Defined by InputStream",
    "shows the methods in OutputStream . \n\n\nTable 20-1    The Methods Defined by InputStream \n\nTable 20-2    The Methods Defined by OutputStream \n\nFileInputStream \n\nThe FileInputStream class creates an InputStream that you can use to read bytes from \na file. Two commonly used constructors are shown here: \n\nFileInputStream ( String filePath ) \n\nFileInputStream ( File fileObj ) \n\nEither can throw a FileNotFoundException . Here, filePath is the full path \nname of a file, and fileObj is a File object that describes the file. \nThe following example creates two FileInputStream s that use the same disk file and each \nof the two constructors:",
    "Although the first constructor is probably more commonly used, the second allows you to \nclosely examine the file using the File methods, before attaching it to an input stream. \nWhen a FileInputStream is created, it is also opened for reading. FileInputStream \noverrides six of the methods in the abstract class InputStream . The mark ( ) and reset ( ) \nmethods are not overridden, and any attempt to use reset ( ) on a FileInputStream will \ngenerate an IOException . \nThe next example shows how to read a single byte, an array of bytes, and a subrange of an \narray of bytes. It also illustrates how to use available ( ) to determine the number of bytes \nremaining and how to use the skip ( ) method to skip over unwanted bytes. The program \nreads its own source file, which must be in the current directory. Notice that it uses the try - \nwith-resources statement to automatically close the file when it is no longer needed. \n\n\nHere is the output produced by this program:",
    "Here is the output produced by this program: \n\n\nThis somewhat contrived example demonstrates how to read three ways, to skip input, and \nto inspect the amount of data available on a stream. \n\nNOTE    The preceding example and the other examples in this chapter \nhandle any I/O exceptions that might occur as described in Chapter 13. \nSee Chapter 13 for details and alternatives. \n\nFileOutputStream \n\nFileOutputStream creates an OutputStream that you can use to write bytes to a file. It \n\nimplements the AutoCloseable , Closeable , and Flushable interfaces. Four of its \nconstructors are shown here: \n\nFileOutputStream ( String filePath ) \nFileOutputStream ( File fileObj ) \nFileOutputStream ( String filePath , boolean append ) \nFileOutputStream ( File fileObj , boolean append ) \n\nThey can throw a FileNotFoundException . Here, filePath is the full path name \nof a file, and fileObj is a File object that describes the file. If append is true , the",
    "They can throw a FileNotFoundException . Here, filePath is the full path name \nof a file, and fileObj is a File object that describes the file. If append is true , the \n\nfile is opened in append mode. \nCreation of a FileOutputStream is not dependent on the file already existing. \nFileOutputStream will create the file before opening it for output when you create the \n\nobject. In the case where you attempt to open a read-only file, an exception will be thrown. \n\n\nThe following example creates a sample buffer of bytes by first making a String and then \nusing the getBytes ( ) method to extract the byte array equivalent. It then creates three \nfiles. The first, file1.txt , will contain every other byte from the sample. The second, \nfile2.txt , will contain the entire set of bytes. The third and last, file3.txt , will contain only \nthe last quarter. \n\n\nHere are the contents of each file after running this program. First, file1.txt : \n\nNext, file2.txt :",
    "Here are the contents of each file after running this program. First, file1.txt : \n\nNext, file2.txt : \n\nFinally, file3.txt : \n\nAs the comment at the top of the program states, the preceding program shows an example \nthat uses the traditional approach to closing a file when it is no longer needed. This \napproach is required by all versions of Java prior to JDK 7 and is widely used in legacy \ncode. As you can see, quite a bit of rather awkward code is required to explicitly call close ( \n) because each call could generate an IOException if the close operation fails. This \nprogram can be substantially improved by using the new try -with-resources statement. For \ncomparison, here is the revised version. Notice that it is much shorter and streamlined: \n\n\nByteArrayInputStream",
    "ByteArrayInputStream \n\nByteArrayInputStream is an implementation of an input stream that uses a byte array as \nthe source. This class has two constructors, each of which requires a byte array to provide \nthe data source: \n\nByteArrayInputStream ( byte array [ ]) \nByteArrayInputStream ( byte array [ ], int start , int numBytes ) \n\nHere, array is the input source. The second constructor creates an InputStream \n\nfrom a subset of the byte array that begins with the character at the index specified \nby start and is numBytes long. \nThe close ( ) method has no effect on a ByteArrayInputStream . Therefore, it is not \n\nnecessary to call close ( ) on a ByteArrayInputStream , but doing so is not an error. \nThe following example creates a pair of ByteArrayInputStream s, initializing them with \nthe byte representation of the alphabet:",
    "The input1 object contains the entire lowercase alphabet, whereas input2 contains only the \nfirst three letters. \nA ByteArrayInputStream implements both mark ( ) and reset ( ) . However, if mark ( ) \nhas not been called, then reset ( ) sets the stream pointer to the start of the stream\u2014which, \nin this case, is the start of the byte array passed to the constructor. The next example shows \nhow to use the reset ( ) method to read the same input twice. In this case, the program \nreads and prints the letters \"abc\" once in lowercase and then again in uppercase. \n\nThis example first reads each character from the stream and prints it as-is in lowercase. It \nthen resets the stream and begins reading again, this time converting each character to \nuppercase before printing. Here\u2019s the output: \n\n\nByteArrayOutputStream",
    "ByteArrayOutputStream \n\nByteArrayOutputStream is an implementation of an output stream that uses a byte \narray as the destination. ByteArrayOutputStream has two constructors, shown here: \n\nByteArrayOutputStream ( ) \nByteArrayOutputStream ( int numBytes ) \n\nIn the first form, a buffer of 32 bytes is created. In the second, a buffer is created \nwith a size equal to that specified by numBytes . The buffer is held in the protected \nbuf field of ByteArrayOutputStream . The buffer size will be increased \nautomatically, if needed. The number of bytes held by the buffer is contained in the \nprotected count field of ByteArrayOutputStream . \nThe close ( ) method has no effect on a ByteArrayOutputStream . Therefore, it is not \nnecessary to call close ( ) on a ByteArrayOutputStream , but doing so is not an error. \nThe following example demonstrates ByteArrayOutputStream :",
    "When you run the program, you will create the following output. Notice how after the call to \nreset ( ) , the three X\u2019s end up at the beginning. \n\n\nThis example uses the writeTo ( ) convenience method to write the contents of f to \ntest.txt . Examining the contents of the test.txt file created in the preceding example shows \nthe result we expected: \n\nFiltered Byte Streams \n\nFiltered streams are simply wrappers around underlying input or output streams that \ntransparently provide some extended level of functionality. These streams are typically \naccessed by methods that are expecting a generic stream, which is a superclass of the \nfiltered streams. Typical extensions are buffering, character translation, and raw data \ntranslation. The filtered byte streams are FilterInputStream and FilterOutputStream . \nTheir constructors are shown here: \n\nFilterOutputStream ( OutputStream os ) \nFilterInputStream ( InputStream is )",
    "FilterOutputStream ( OutputStream os ) \nFilterInputStream ( InputStream is ) \n\nThe methods provided in these classes are identical to those in InputStream and \nOutputStream . \n\nBuffered Byte Streams \n\nFor the byte-oriented streams, a buffered stream extends a filtered stream class by \nattaching a memory buffer to the I/O stream. This buffer allows Java to do I/O operations \non more than a byte at a time, thereby improving performance. Because the buffer is \navailable, skipping, marking, and resetting of the stream become possible. The buffered byte \nstream classes are BufferedInputStream and BufferedOutputStream . \nPushbackInputStream also implements a buffered stream. \n\nBufferedInputStream \n\nBuffering I/O is a very common performance optimization. Java\u2019s BufferedInputStream \n\nclass allows you to \"wrap\" any InputStream into a buffered stream to improve \nperformance. BufferedInputStream has two constructors:",
    "class allows you to \"wrap\" any InputStream into a buffered stream to improve \nperformance. BufferedInputStream has two constructors: \n\nBufferedInputStream ( InputStream inputStream ) \nBufferedInputStream ( InputStream inputStream , int bufSize ) \n\nThe first form creates a buffered stream using a default buffer size. In the second,",
    "the size of the buffer is passed in bufSize . Use of sizes that are multiples of a \nmemory page, a disk block, and so on, can have a significant positive impact on \nperformance. This is, however, implementation-dependent. An optimal buffer size \nis generally dependent on the host operating system, the amount of memory \navailable, and how the machine is configured. To make good use of buffering \ndoesn\u2019t necessarily require quite this degree of sophistication. A good guess for a \nsize is around 8,192 bytes, and attaching even a rather small buffer to an I/O \nstream is always a good idea. That way, the low-level system can read blocks of \ndata from the disk or network and store the results in your buffer. Thus, even if \nyou are reading the data a byte at a time out of the InputStream , you will be \nmanipulating fast memory most of the time. \nBuffering an input stream also provides the foundation required to support moving \nbackward in the stream of the available buffer",
    ". \nBuffering an input stream also provides the foundation required to support moving \nbackward in the stream of the available buffer. Beyond the read ( ) and skip ( ) methods \nimplemented in any InputStream , BufferedInputStream also supports the mark ( ) \nand reset ( ) methods. This support is reflected by \nBufferedInputStream.markSupported ( ) returning true . \nThe following example contrives a situation where we can use mark ( ) to remember where \nwe are in an input stream and later use reset ( ) to get back there. This example is parsing a \nstream for the HTML entity reference for the copyright symbol. Such a reference begins with \nan ampersand (&) and ends with a semicolon (;) without any intervening whitespace. The \nsample input has two ampersands to show the case where the reset ( ) happens and where \nit does not.",
    "Notice that this example uses mark ( 32 ) , which preserves the mark for the next 32 bytes \nread ( which is enough for all entity references ). Here is the output produced by this \nprogram: \n\n\nBufferedOutputStream \n\nA BufferedOutputStream is similar to any OutputStream with the exception that the \nflush ( ) method is used to ensure that data buffers are written to the stream being \nbuffered. Since the point of a BufferedOutputStream is to improve performance by \nreducing the number of times the system actually writes data, you may need to call flush ( ) \nto cause any data that is in the buffer to be immediately written. \nUnlike buffered input, buffering output does not provide additional functionality. Buffers \nfor output in Java are there to increase performance. Here are the two available \nconstructors: \n\nBufferedOutputStream ( OutputStream outputStream ) \nBufferedOutputStream ( OutputStream outputStream , int bufSize )",
    "BufferedOutputStream ( OutputStream outputStream ) \nBufferedOutputStream ( OutputStream outputStream , int bufSize ) \n\nThe first form creates a buffered stream using the default buffer size. In the second \nform, the size of the buffer is passed in bufSize . \n\nPushbackInputStream \n\nOne of the novel uses of buffering is the implementation of pushback. Pushback is used on \nan input stream to allow a byte to be read and then returned ( that is, \"pushed back\") to the \nstream. The PushbackInputStream class implements this idea. It provides a mechanism \nto \"peek\" at what is coming from an input stream without disrupting it. \nPushbackInputStream has the following constructors: \n\nPushbackInputStream ( InputStream inputStream ) \nPushbackInputStream ( InputStream inputStream , int numBytes ) \n\nThe first form creates a stream object that allows one byte to be returned to the",
    "PushbackInputStream ( InputStream inputStream ) \nPushbackInputStream ( InputStream inputStream , int numBytes ) \n\nThe first form creates a stream object that allows one byte to be returned to the \n\ninput stream. The second form creates a stream that has a pushback buffer that is \nnumBytes long. This allows multiple bytes to be returned to the input stream. \nBeyond the familiar methods of InputStream , PushbackInputStream provides \nunread ( ) , shown here: \n\nvoid unread ( int b ) \nvoid unread ( byte buffer [ ]) \nvoid unread ( byte buffer , int offset , int numBytes ) \n\nThe first form pushes back the low-order byte of b . This will be the next byte \nreturned by a subsequent call to read ( ) . The second form pushes back the bytes \n\nin buffer . The third form pushes back numBytes bytes beginning at offset from",
    "in buffer . The third form pushes back numBytes bytes beginning at offset from \n\nbuffer . An IOException will be thrown if there is an attempt to push back a byte \nwhen the pushback buffer is full. \nHere is an example that shows how a programming language parser might use a \nPushbackInputStream and unread ( ) to deal with the difference between the = = \noperator for comparison and the = operator for assignment: \n\n\nHere is the output for this example. Notice that == was replaced by \".eq.\" and = was \n\nreplaced by \"<\u2013\" . \n\nCAUTION    PushbackInputStream has the side effect of invalidating \nthe mark ( ) or reset ( ) methods of the InputStream used to create it. \nUse markSupported ( ) to check any stream on which you are going to \nuse mark ( )/reset ( ) . \n\nSequenceInputStream",
    "SequenceInputStream \n\n\nThe SequenceInputStream class allows you to concatenate multiple InputStream s. The \nconstruction of a SequenceInputStream is different from any other InputStream . A \nSequenceInputStream constructor uses either a pair of InputStream s or an \nEnumeration of InputStream s as its argument: \n\nSequenceInputStream ( InputStream first , InputStream second ) \nSequenceInputStream ( Enumeration <? extends InputStream> streamEnum )",
    "SequenceInputStream ( InputStream first , InputStream second ) \nSequenceInputStream ( Enumeration <? extends InputStream> streamEnum ) \n\nOperationally, the class fulfills read requests from the first InputStream until it \nruns out and then switches over to the second one. In the case of an \nEnumeration , it will continue through all of the InputStream s until the end of \nthe last one is reached. When the end of each file is reached, its associated stream \nis closed. Closing the stream created by SequenceInputStream causes all \nunclosed streams to be closed. \nHere is a simple example that uses a SequenceInputStream to output the contents of \ntwo files. For demonstration purposes, this program uses the traditional technique used to \nclose a file. As an exercise, you might want to try changing it to use the try -with-resources \nstatement.",
    "This example creates a Vector and then adds three filenames to it. It passes that vector of \nnames to the InputStreamEnumerator class, which is designed to provide a wrapper on \nthe vector where the elements returned are not the filenames but, rather, open \nFileInputStream s on those names. The SequenceInputStream opens each file in turn, \nand this example prints the contents of the files. \n\n\nNotice in nextElement ( ) that if a file cannot be opened, null is returned. This results in a \nNullPointerException , which is caught in main ( ) . \n\nPrintStream \n\nThe PrintStream class provides all of the output capabilities we have been using from the \nSystem file handle, System.out , since the beginning of the book. This makes \nPrintStream one of Java\u2019s most often used classes. It implements the Appendable , \nAutoCloseable , Closeable , and Flushable interfaces. \nPrintStream defines several constructors. The ones shown next have been specified from \nthe start:",
    "Here, outputStream specifies an open OutputStream that will receive output. The \nautoFlushingOn parameter controls whether the output buffer is automatically flushed \nevery time a newline ( \\n ) character or a byte array is written or when println ( ) is called. \nIf autoFlushingOn is true , flushing automatically takes place. If it is false , flushing is not \nautomatic. The first constructor does not automatically flush. You can specify a character \nencoding by passing its name in charSet . \nThe next set of constructors gives you an easy way to construct a PrintStream that writes \nits output to a file: \n\nThese allow a PrintStream to be created from a File object or by specifying the \n\nname of a file. In either case, the file is automatically created. Any preexisting file \nby the same name is destroyed. Once created, the PrintStream object directs all \n\noutput to the specified file. You can specify a character encoding by passing its \nname in charSet .",
    "output to the specified file. You can specify a character encoding by passing its \nname in charSet . \n\n\nNOTE    If a security manager is present, some PrintStream \nconstructors will throw a SecurityException if a security violation \noccurs.",
    "PrintStream supports the print ( ) and println ( ) methods for all types, including \nObject . If an argument is not a primitive type, the PrintStream methods will call the \nobject\u2019s toString ( ) method and then display the result. \nSomewhat recently ( with the release of JDK 5 ), the printf ( ) method was added to \nPrintStream . It allows you to specify the precise format of the data to be written. The \nprintf ( ) method uses the Formatter class ( described in Chapter 19 ) to format data. It \nthen writes this data to the invoking stream. Although formatting can be done manually, by \nusing Formatter directly, printf ( ) streamlines the process. It also parallels the C/C++ \nprintf ( ) function, which makes it easy to convert existing C/C++ code into Java. Frankly, \nprintf ( ) was a much welcome addition to the Java API because it greatly simplified the \noutput of formatted data to the console. \nThe printf ( ) method has the following general forms:",
    "PrintStream printf ( String fmtString , Object \u2026 args ) \nPrintStream printf ( Locale loc , String fmtString , Object \u2026 args ) \n\nThe first version writes args to standard output in the format specified by \nfmtString , using the default locale. The second lets you specify a locale. Both \nreturn the invoking PrintStream . \nIn general, printf ( ) works in a manner similar to the format ( ) method specified by \nFormatter . The fmtString consists of two types of items. The first type is composed of \ncharacters that are simply copied to the output buffer. The second type contains format \nspecifiers that define the way the subsequent arguments, specified by args , are displayed. \nFor complete information on formatting output, including a description of the format \nspecifiers, see the Formatter class in Chapter 19.",
    "Because System.out is a PrintStream , you can call printf ( ) on System.out . Thus, \nprintf ( ) can be used in place of println ( ) when writing to the console whenever \nformatted output is desired. For example, the following program uses printf ( ) to output \nnumeric values in various formats. Prior to JDK 5, such formatting required a bit of work. \nWith the addition of printf ( ) , this is now an easy task. \n\n\nThe output is shown here: \n\nPrintStream also defines the format ( ) method. It has these general forms: \n\nPrintStream format ( String fmtString , Object \u2026 args ) \nPrintStream format ( Locale loc , String fmtString , Object \u2026 args ) \n\nIt works exactly like printf ( ) . \n\n\nDataOutputStream and DataInputStream",
    "It works exactly like printf ( ) . \n\n\nDataOutputStream and DataInputStream \n\nDataOutputStream and DataInputStream enable you to write or read primitive data to \nor from a stream. They implement the DataOutput and DataInput interfaces, \nrespectively. These interfaces define methods that convert primitive values to or from a \nsequence of bytes. These streams make it easy to store binary data, such as integers or \nfloating-point values, in a file. Each is examined here. \nDataOutputStream extends FilterOutputStream , which extends OutputStream . In \naddition to implementing DataOutput , DataOutputStream also implements \nAutoCloseable , Closeable , and Flushable . DataOutputStream defines the following \nconstructor: \n\nDataOutputStream ( OutputStream outputStream )",
    "DataOutputStream ( OutputStream outputStream ) \n\nHere, outputStream specifies the output stream to which data will be written. \nWhen a DataOutputStream is closed ( by calling close ( ) ), the underlying \nstream specified by outputStream is also closed automatically. \nDataOutputStream supports all of the methods defined by its superclasses. However, it is \nthe methods defined by the DataOutput interface, which it implements, that make it \ninteresting. DataOutput defines methods that convert values of a primitive type into a byte \nsequence and then writes it to the underlying stream. Here is a sampling of these methods: \n\nfinal void writeDouble ( double value ) throws IOException \nfinal void writeBoolean ( boolean value ) throws IOException \nfinal void writeInt ( int value ) throws IOException",
    "final void writeDouble ( double value ) throws IOException \nfinal void writeBoolean ( boolean value ) throws IOException \nfinal void writeInt ( int value ) throws IOException \n\nHere, value is the value written to the stream. \nDataInputStream is the complement of DataOuputStream . It extends \nFilterInputStream , which extends InputStream . In addition to implementing the \nDataInput interface, DataInputStream also implements AutoCloseable and \nCloseable . Here is its only constructor: \n\nDataInputStream ( InputStream inputStream ) \n\nHere, inputStream specifies the input stream from which data will be read. When \na DataInputStream is closed ( by calling close ( ) ), the underlying stream \nspecified by inputStream is also closed automatically. \nLike DataOutputStream , DataInputStream supports all of the methods of its \nsuperclasses, but it is the methods defined by the DataInput interface that make it unique.",
    "These methods read a sequence of bytes and convert them into values of a primitive type. \nHere is a sampling of these methods: \n\nfinal double readDouble ( ) throws IOException \nfinal boolean readBoolean ( ) throws IOException \nfinal int readInt ( ) throws IOException \n\nThe following program demonstrates the use of DataOutputStream and \n\n\nDataInputStream : \n\nThe output is shown here: \n\nRandomAccessFile \n\nRandomAccessFile encapsulates a random-access file. It is not derived from \n\nInputStream or OutputStream . Instead, it implements the interfaces DataInput and \nDataOutput , which define the basic I/O methods. It also implements the AutoCloseable \n\n\nand Closeable interfaces. RandomAccessFile is special because it supports positioning \nrequests\u2014that is, you can position the file pointer within the file. It has these two \nconstructors:",
    "In the first form, fileObj specifies the file to open as a File object. In the second form, the \nname of the file is passed in filename . In both cases, access determines what type of file \naccess is permitted. If it is \"r\", then the file can be read, but not written. If it is \"rw\", then \nthe file is opened in read-write mode. If it is \"rws\", the file is opened for read-write \noperations and every change to the file\u2019s data or metadata will be immediately written to the \nphysical device. If it is \"rwd\", the file is opened for read-write operations and every change \nto the file\u2019s data will be immediately written to the physical device. \nThe method seek ( ) , shown here, is used to set the current position of the file pointer \nwithin the file: \n\nvoid seek ( long newPos ) throws IOException",
    "void seek ( long newPos ) throws IOException \n\nHere, newPos specifies the new position, in bytes, of the file pointer from the \nbeginning of the file. After a call to seek ( ) , the next read or write operation will \noccur at the new file position. \nRandomAccessFile implements the standard input and output methods, which you can \nuse to read and write to random access files. It also includes some additional methods. One \nis setLength ( ) . It has this signature: \n\nvoid setLength ( long len ) throws IOException \n\nThis method sets the length of the invoking file to that specified by len . This \nmethod can be used to lengthen or shorten a file. If the file is lengthened, the \nadded portion is undefined. \n\nThe Character Streams \n\nWhile the byte stream classes provide sufficient functionality to handle any type of I/O \noperation, they cannot work directly with Unicode characters. Since one of the main",
    "The Character Streams \n\nWhile the byte stream classes provide sufficient functionality to handle any type of I/O \noperation, they cannot work directly with Unicode characters. Since one of the main \n\npurposes of Java is to support the \"write once, run anywhere\" philosophy, it was necessary \nto include direct I/O support for characters. In this section, several of the character I/O \nclasses are discussed. As explained earlier, at the top of the character stream hierarchies are \nthe Reader and Writer abstract classes. We will begin with them. \n\nReader \n\n\nReader is an abstract class that defines Java\u2019s model of streaming character input. It \nimplements the AutoCloseable , Closeable , and Readable interfaces. All of the methods \nin this class ( except for markSupported ( ) ) will throw an IOException on error \nconditions. Table 20-3 provides a synopsis of the methods in Reader . \n\nWriter",
    "Writer \n\nWriter is an abstract class that defines streaming character output. It implements the \nAutoCloseable , Closeable , Flushable , and Appendable interfaces. All of the methods \nin this class throw an IOException in the case of errors. Table 20-4 shows a synopsis of \nthe methods in Writer . \n\nTable 20-3    The Methods Defined by Reader \n\n\nTable 20-4    The Methods Defined by Writer \n\nFileReader \n\nThe FileReader class creates a Reader that you can use to read the contents of a file. Two \ncommonly used constructors are shown here: \n\nFileReader ( String filePath ) \nFileReader ( File fileObj ) \n\nEither can throw a FileNotFoundException . Here, filePath is the full path \nname of a file, and fileObj is a File object that describes the file. \nThe following example shows how to read lines from a file and display them on the standard \noutput device. It reads its own source file, which must be in the current directory. \n\nFileWriter",
    "FileWriter \n\nFileWriter creates a Writer that you can use to write to a file. Four commonly used \n\n\nconstructors are shown here: \n\nFileWriter ( String filePath ) \nFileWriter ( String filePath , boolean append ) \nFileWriter ( File fileObj ) \nFileWriter ( File fileObj , boolean append )",
    "They can all throw an IOException . Here, filePath is the full path name of a file, \nand fileObj is a File object that describes the file. If append is true , then output is \nappended to the end of the file. \nCreation of a FileWriter is not dependent on the file already existing. FileWriter will \ncreate the file before opening it for output when you create the object. In the case where you \nattempt to open a read-only file, an IOException will be thrown. \nThe following example is a character stream version of an example shown earlier when \nFileOutputStream was discussed. This version creates a sample buffer of characters by \nfirst making a String and then using the getChars ( ) method to extract the character \narray equivalent. It then creates three files. The first, file1.txt , will contain every other \ncharacter from the sample. The second, file2.txt , will contain the entire set of characters. \nFinally, the third, file3.txt , will contain only the last quarter.",
    "CharArrayReader \n\nCharArrayReader is an implementation of an input stream that uses a character array as \n\nthe source. This class has two constructors, each of which requires a character array to \nprovide the data source: \n\nCharArrayReader ( char array [ ]) \nCharArrayReader ( char array [ ], int start , int numChars ) \n\nHere, array is the input source. The second constructor creates a Reader from a \n\nsubset of your character array that begins with the character at the index specified \nby start and is numChars long. \n\nThe close ( ) method implemented by CharArrayReader does not throw any exceptions. \nThis is because it cannot fail. \nThe following example uses a pair of CharArrayReader s: \n\n\nThe input1 object is constructed using the entire lowercase alphabet, whereas input2 \ncontains only the first five letters. Here is the output: \n\nCharArrayWriter",
    "The input1 object is constructed using the entire lowercase alphabet, whereas input2 \ncontains only the first five letters. Here is the output: \n\nCharArrayWriter \n\nCharArrayWriter is an implementation of an output stream that uses an array as the \ndestination. CharArrayWriter has two constructors, shown here: \n\nCharArrayWriter ( ) \n\n\nCharArrayWriter ( int numChars )",
    "CharArrayWriter ( ) \n\n\nCharArrayWriter ( int numChars ) \n\nIn the first form, a buffer with a default size is created. In the second, a buffer is \ncreated with a size equal to that specified by numChars . The buffer is held in the \nbuf field of CharArrayWriter . The buffer size will be increased automatically, if \nneeded. The number of characters held by the buffer is contained in the count \nfield of CharArrayWriter . Both buf and count are protected fields. \nThe close ( ) method has no effect on a CharArrayWriter . \nThe following example demonstrates CharArrayWriter by reworking the sample program \nshown earlier for ByteArrayOutputStream . It produces the same output as the previous \nversion. \n\n\nBufferedReader \n\nBufferedReader improves performance by buffering input. It has two constructors: \n\nBufferedReader ( Reader inputStream ) \nBufferedReader ( Reader inputStream , int bufSize )",
    "BufferedReader improves performance by buffering input. It has two constructors: \n\nBufferedReader ( Reader inputStream ) \nBufferedReader ( Reader inputStream , int bufSize ) \n\nThe first form creates a buffered character stream using a default buffer size. In the",
    "second, the size of the buffer is passed in bufSize . \nClosing a BufferedReader also causes the underlying stream specified by inputStream to \nbe closed. \nAs is the case with the byte-oriented stream, buffering an input character stream also \nprovides the foundation required to support moving backward in the stream within the \navailable buffer. To support this, BufferedReader implements the mark ( ) and reset ( ) \nmethods, and BufferedReader.markSupported ( ) returns true . JDK 8 adds a new \nmethod to BufferedReader called lines ( ) . It returns a Stream reference to the sequence \nof lines read by the reader. ( Stream is part of the new stream API discussed in Chapter 29.) \nThe following example reworks the BufferedInputStream example, shown earlier, so that \nit uses a BufferedReader character stream rather than a buffered byte stream. As before, \nit uses the mark ( ) and reset ( ) methods to parse a stream for the HTML entity reference \nfor the copyright symbol",
    ". As before, \nit uses the mark ( ) and reset ( ) methods to parse a stream for the HTML entity reference \nfor the copyright symbol. Such a reference begins with an ampersand (&) and ends with a \nsemicolon (;) without any intervening whitespace. The sample input has two ampersands to \nshow the case where the reset ( ) happens and where it does not. Output is the same as that \nshown earlier.",
    "BufferedWriter \n\nA BufferedWriter is a Writer that buffers output. Using a BufferedWriter can improve \nperformance by reducing the number of times data is actually physically written to the \noutput device. \nA BufferedWriter has these two constructors: \n\n\nBufferedWriter ( Writer outputStream ) \nBufferedWriter ( Writer outputStream , int bufSize ) \n\nThe first form creates a buffered stream using a buffer with a default size. In the \nsecond, the size of the buffer is passed in bufSize . \n\nPushbackReader \n\nThe PushbackReader class allows one or more characters to be returned to the input \nstream. This allows you to look ahead in the input stream. Here are its two constructors: \n\nPushbackReader ( Reader inputStream ) \nPushbackReader ( Reader inputStream , int bufSize )",
    "PushbackReader ( Reader inputStream ) \nPushbackReader ( Reader inputStream , int bufSize ) \n\nThe first form creates a buffered stream that allows one character to be pushed \nback. In the second, the size of the pushback buffer is passed in bufSize . \nClosing a PushbackReader also closes the underlying stream specified by inputStream . \nPushbackReader provides unread ( ) , which returns one or more characters to the \ninvoking input stream. It has the three forms shown here: \n\nvoid unread ( int ch ) throws IOException \nvoid unread ( char buffer [ ]) throws IOException \nvoid unread ( char buffer [ ], int offset , int numChars ) throws IOException",
    "void unread ( int ch ) throws IOException \nvoid unread ( char buffer [ ]) throws IOException \nvoid unread ( char buffer [ ], int offset , int numChars ) throws IOException \n\nThe first form pushes back the character passed in ch . This will be the next \ncharacter returned by a subsequent call to read ( ) . The second form returns the \ncharacters in buffer . The third form pushes back numChars characters beginning \nat offset from buffer . An IOException will be thrown if there is an attempt to \nreturn a character when the pushback buffer is full. \nThe following program reworks the earlier PushbackInputStream example by replacing \nPushbackInputStream with PushbackReader . As before, it shows how a programming \nlanguage parser can use a pushback stream to deal with the difference between the == \noperator for comparison and the = operator for assignment. \n\n\nPrintWriter \n\nPrintWriter is essentially a character-oriented version of PrintStream . It implements",
    "PrintWriter \n\nPrintWriter is essentially a character-oriented version of PrintStream . It implements \n\nthe Appendable , AutoCloseable , Closeable , and Flushable interfaces. PrintWriter \nhas several constructors. The following have been supplied by PrintWriter from the start: \n\nPrintWriter ( OutputStream outputStream ) \nPrintWriter ( OutputStream outputStream , boolean autoFlushingOn ) \nPrintWriter ( Writer outputStream ) \nPrintWriter ( Writer outputStream , boolean autoFlushingOn ) \n\nHere, outputStream specifies an open OutputStream that will receive output. \n\nThe autoFlushingOn parameter controls whether the output buffer is automatically \nflushed every time println ( ) , printf ( ) , or format ( ) is called. If \nautoFlushingOn is true , flushing automatically takes place. If false , flushing is \nnot automatic. Constructors that do not specify the autoFlushingOn parameter do",
    "not automatically flush. \nThe next set of constructors gives you an easy way to construct a PrintWriter that writes \nits output to a file. \n\nThese allow a PrintWriter to be created from a File object or by specifying the name of a \nfile. In either case, the file is automatically created. Any preexisting file by the same name is \ndestroyed. Once created, the PrintWriter object directs all output to the specified file. You \ncan specify a character encoding by passing its name in charSet . \nPrintWriter supports the print ( ) and println ( ) methods for all types, including \nObject . If an argument is not a primitive type, the PrintWriter methods will call the \nobject\u2019s toString ( ) method and then output the result. \nPrintWriter also supports the printf ( ) method. It works the same way it does in the \nPrintStream class described earlier: It allows you to specify the precise format of the data. \nHere is how printf ( ) is declared in PrintWriter :",
    "PrintWriter printf ( String fmtString , Object \u2026 args ) \nPrintWriter printf ( Locale loc , String fmtString , Object \u2026 args ) \n\nThe first version writes args to standard output in the format specified by \n\nfmtString , using the default locale. The second lets you specify a locale. Both \nreturn the invoking PrintWriter . \nThe format ( ) method is also supported. It has these general forms: \n\nPrintWriter format ( String fmtString , Object \u2026 args ) \nPrintWriter format ( Locale loc , String fmtString , Object \u2026 args ) \n\nIt works exactly like printf ( ) . \n\nThe Console Class",
    "PrintWriter format ( String fmtString , Object \u2026 args ) \nPrintWriter format ( Locale loc , String fmtString , Object \u2026 args ) \n\nIt works exactly like printf ( ) . \n\nThe Console Class \n\nThe Console class was added to java.io by JDK 6. It is used to read from and write to the \nconsole, if one exists. It implements the Flushable interface. Console is primarily a \nconvenience class because most of its functionality is available through System.in and \nSystem.out . However, its use can simplify some types of console interactions, especially \nwhen reading strings from the console. \nConsole supplies no constructors. Instead, a Console object is obtained by calling \n\nSystem.console ( ) , which is shown here: \n\n\nstatic Console console ( )",
    "If a console is available, then a reference to it is returned. Otherwise, null is \nreturned. A console will not be available in all cases. Thus, if null is returned, no \nconsole I/O is possible. \nConsole defines the methods shown in Table 20-5. Notice that the input methods, such as \nreadLine ( ) , throw IOError if an input error occurs. IOError is a subclass of Error . It \nindicates an I/O failure that is beyond the control of your program. Thus, you will not \nnormally catch an IOError . Frankly, if an IOError is thrown while accessing the console, \nit usually means there has been a catastrophic system failure. \nAlso notice the readPassword ( ) methods. These methods let your application read a \npassword without echoing what is typed. When reading passwords, you should \"zero-out\" \nboth the array that holds the string entered by the user and the array that holds the \npassword that the string is tested against",
    ". When reading passwords, you should \"zero-out\" \nboth the array that holds the string entered by the user and the array that holds the \npassword that the string is tested against. This reduces the chance that a malicious program \nwill be able to obtain a password by scanning memory.",
    "Table 20-5    The Methods Defined by Console \n\nHere is an example that demonstrates the Console class: \n\n\nHere is sample output: \n\nSerialization \n\nSerialization is the process of writing the state of an object to a byte stream. This is useful \nwhen you want to save the state of your program to a persistent storage area, such as a file. \nAt a later time, you may restore these objects by using the process of deserialization. \nSerialization is also needed to implement Remote Method Invocation ( RMI ) . RMI allows a \nJava object on one machine to invoke a method of a Java object on a different machine. An \nobject may be supplied as an argument to that remote method. The sending machine \nserializes the object and transmits it. The receiving machine deserializes it. ( More \ninformation about RMI appears in Chapter 30.)",
    "Assume that an object to be serialized has references to other objects, which, in turn, have \nreferences to still more objects. This set of objects and the relationships among them form a \ndirected graph. There may also be circular references within this object graph. That is, \n\nobject X may contain a reference to object Y, and object Y may contain a reference back to \nobject X. Objects may also contain references to themselves. The object serialization and \ndeserialization facilities have been designed to work correctly in these scenarios. If you \nattempt to serialize an object at the top of an object graph, all of the other referenced objects \nare recursively located and serialized. Similarly, during the process of deserialization, all of \nthese objects and their references are correctly restored. \n\n\nAn overview of the interfaces and classes that support serialization follows. \n\nSerializable",
    "An overview of the interfaces and classes that support serialization follows. \n\nSerializable \n\nOnly an object that implements the Serializable interface can be saved and restored by the \nserialization facilities. The Serializable interface defines no members. It is simply used to \nindicate that a class may be serialized. If a class is serializable, all of its subclasses are also \nserializable. \nVariables that are declared as transient are not saved by the serialization facilities. Also, \nstatic variables are not saved. \n\nExternalizable",
    "Externalizable \n\nThe Java facilities for serialization and deserialization have been designed so that much of \nthe work to save and restore the state of an object occurs automatically. However, there are \ncases in which the programmer may need to have control over these processes. For \nexample, it may be desirable to use compression or encryption techniques. The \nExternalizable interface is designed for these situations. \nThe Externalizable interface defines these two methods: \n\nIn these methods, inStream is the byte stream from which the object is to be read, and \noutStream is the byte stream to which the object is to be written. \n\nObjectOutput \n\nThe ObjectOutput interface extends the DataOutput and AutoCloseable interfaces and \nsupports object serialization. It defines the methods shown in Table 20-6. Note especially \n\nthe writeObject ( ) method. This is called to serialize an object. All of these methods will \nthrow an IOException on error conditions.",
    "the writeObject ( ) method. This is called to serialize an object. All of these methods will \nthrow an IOException on error conditions. \n\n\nTable 20-6    The Methods Defined by ObjectOutput \n\nObjectOutputStream \n\nThe ObjectOutputStream class extends the OutputStream class and implements the \nObjectOutput interface. It is responsible for writing objects to a stream. One constructor \nof this class is shown here: \n\nObjectOutputStream ( OutputStream outStream ) throws IOException \n\nThe argument outStream is the output stream to which serialized objects will be \nwritten. Closing an ObjectOutputStream automatically closes the underlying \nstream specified by outStream . \nSeveral commonly used methods in this class are shown in Table 20-7. They will throw an \nIOException on error conditions. There is also an inner class to ObjectOuputStream \ncalled PutField . It facilitates the writing of persistent fields, and its use is beyond the scope \nof this book.",
    "Table 20-7    A Sampling of Commonly Used Methods Defined by \nObjectOutputStream \n\nObjectInput \n\n\nThe ObjectInput interface extends the DataInput and AutoCloseable interfaces and \ndefines the methods shown in Table 20-8. It supports object serialization. Note especially \nthe readObject ( ) method. This is called to deserialize an object. All of these methods will \nthrow an IOException on error conditions. The readObject ( ) method can also throw \nClassNotFoundException . \n\nObjectInputStream \n\nThe ObjectInputStream class extends the InputStream class and implements the \nObjectInput interface. ObjectInputStream is responsible for reading objects from a \nstream. One constructor of this class is shown here: \n\nObjectInputStream ( InputStream inStream ) throws IOException",
    "ObjectInputStream ( InputStream inStream ) throws IOException \n\nThe argument inStream is the input stream from which serialized objects should \nbe read. Closing an ObjectInputStream automatically closes the underlying \nstream specified by inStream . \nSeveral commonly used methods in this class are shown in Table 20-9. They will throw an \nIOException on error conditions. The readObject ( ) method can also throw \nClassNotFoundException . There is also an inner class to ObjectInputStream called \nGetField . It facilitates the reading of persistent fields, and its use is beyond the scope of \nthis book. \n\nTable 20-8    The Methods Defined by ObjectInput \n\n\nTable 20-9    Commonly Used Methods Defined by ObjectInputStream \n\nA Serialization Example",
    "A Serialization Example \n\nThe following program illustrates how to use object serialization and deserialization. It \nbegins by instantiating an object of class MyClass . This object has three instance variables \nthat are of types String , int , and double . This is the information we want to save and \nrestore. \nA FileOutputStream is created that refers to a file named \"serial\", and an \nObjectOutputStream is created for that file stream. The writeObject ( ) method of \nObjectOutputStream is then used to serialize our object. The object output stream is \nflushed and closed. \nA FileInputStream is then created that refers to the file named \"serial\", and an \nObjectInputStream is created for that file stream. The readObject ( ) method of \nObjectInputStream is then used to deserialize our object. The object input stream is then \nclosed. \nNote that MyClass is defined to implement the Serializable interface. If this is not done,",
    "a NotSerializableException is thrown. Try experimenting with this program by declaring \nsome of the MyClass instance variables to be transient . That data is then not saved \nduring serialization. \n\n\nThis program demonstrates that the instance variables of object1 and object2 are \nidentical. The output is shown here: \n\n\nStream Benefits",
    "This program demonstrates that the instance variables of object1 and object2 are \nidentical. The output is shown here: \n\n\nStream Benefits \n\nThe streaming interface to I/O in Java provides a clean abstraction for a complex and often \ncumbersome task. The composition of the filtered stream classes allows you to dynamically \nbuild the custom streaming interface to suit your data transfer requirements. Java programs \nwritten to adhere to the abstract, high-level InputStream , OutputStream , Reader , and \nWriter classes will function properly in the future even when new and improved concrete \nstream classes are invented. As you will see in Chapter 22, this model works very well when \nwe switch from a file system\u2013based set of streams to the network and socket streams. \nFinally, serialization of objects plays an important role in many types of Java programs. \nJava\u2019s serialization I/O classes provide a portable solution to this sometimes tricky task.",
    "\uf709 \nPREV \nChapter 19: java.util Part 2: More Utility Classes \n\u23ee \n\nNEXT \nChapter 21: Exploring NIO \n\u23ed \n\n\nPREV \nChapter 20: Input/Output: Exploring java.io \n\u23ee \n\nNEXT \nChapter 22: Networking \u23ed \n\nCHAPTER \n\n21 \nExploring NIO \n\nBeginning with version 1.4, Java has provided a second I/O system called NIO ( which is \nshort for New I/O ). It supports a buffer-oriented, channel-based approach to I/O \noperations. With the release of JDK 7, the NIO system was greatly expanded, providing \nenhanced support for file-handling and file system features. In fact, so significant were the \nchanges that the term NIO.2 is often used. Because of the capabilities supported by the NIO \nfile classes, NIO is expected to become an increasingly important approach to file handling. \nThis chapter explores several of the key features of the NIO system. \n\nThe NIO Classes \n\nThe NIO classes are contained in the packages shown here: \n\nPackage \nPurpose \n\njava.nio",
    "The NIO Classes \n\nThe NIO classes are contained in the packages shown here: \n\nPackage \nPurpose \n\njava.nio \n\nTop-level package for the NIO system. Encapsulates various \ntypes of buffers that contain data operated upon by the NIO \nsystem. \n\njava.nio.channels \nSupports channels, which are essentially open I/O connections. \n\njava.nio.channels.spi \nSupports service providers for channels. \n\njava.nio.charset \n\nEncapsulates character sets. Also supports encoders and \ndecoders that convert characters to bytes and bytes to \ncharacters, respectively. \n\njava.nio.charset.spi \nSupports service providers for character sets. \n\njava.nio.file \nProvides support for files. \n\njava.nio.file.attribute \nProvides support for file attributes. \n\njava.nio.file.spi \nSupports service providers for file systems. \n\nBefore we begin, it is important to emphasize that the NIO subsystem does not replace the \nstream-based I/O classes found in java.io , which are discussed in Chapter 20, and good",
    "Before we begin, it is important to emphasize that the NIO subsystem does not replace the \nstream-based I/O classes found in java.io , which are discussed in Chapter 20, and good \n\n\nworking knowledge of the stream-based I/O in java.io is helpful to understanding NIO. \n\nNOTE This chapter assumes that you have read the overview of I/O given \nin Chapter 13 and the discussion of stream-based I/O supplied in Chapter \n\n20. \n\nNIO Fundamentals \n\nThe NIO system is built on two foundational items: buffers and channels. A buffer holds \ndata. A channel represents an open connection to an I/O device, such as a file or a socket. \nIn general, to use the NIO system, you obtain a channel to an I/O device and a buffer to \nhold data. You then operate on the buffer, inputting or outputting data as needed. The \nfollowing sections examine buffers and channels in more detail. \n\nBuffers",
    "Buffers \n\nBuffers are defined in the java.nio package. All buffers are subclasses of the Buffer class, \nwhich defines the core functionality common to all buffers: current position, limit, and \ncapacity. The current position is the index within the buffer at which the next read or write \noperation will take place. The current position is advanced by most read or write operations. \nThe limit is the index value one past the last valid location in the buffer. The capacity is the \nnumber of elements that the buffer can hold. Often the limit equals the capacity of the \nbuffer. Buffer also supports mark and reset. Buffer defines several methods, which are \nshown in Table 21-1. \n\n\nTable 21-1    The Methods Defined by Buffer \n\nFrom Buffer , the following specific buffer classes are derived, which hold the type of data \nthat their names imply:",
    "Table 21-1    The Methods Defined by Buffer \n\nFrom Buffer , the following specific buffer classes are derived, which hold the type of data \nthat their names imply: \n\nMappedByteBuffer is a subclass of ByteBuffer and is used to map a file to a buffer. \nAll of the aforementioned buffers provide various get ( ) and put ( ) methods, which allow \nyou to get data from a buffer or put data into a buffer. ( Of course, if a buffer is read-only, \nthen put ( ) operations are not available.) Table 21-2 shows the get ( ) and put ( ) methods \ndefined by ByteBuffer . The other buffer classes have similar methods. All buffer classes \nalso support methods that perform various buffer operations. For example, you can allocate \na buffer manually using allocate ( ) . You can wrap an array inside a buffer using wrap ( ) . \nYou can create a subsequence of a buffer using slice ( ) . \n\nChannels",
    "Channels \n\nChannels are defined in java.nio.channels . A channel represents an open connection to \nan I/O source or destination. Channels implement the Channel interface. It extends \nCloseable , and it extends AutoCloseable . By implementing AutoCloseable , channels \n\ncan be managed with a try -with-resources statement. When used in a try -with-resources \nblock, a channel is closed automatically when it is no longer needed. ( See Chapter 13 for a \ndiscussion of try -with-resources.) \n\n\nTable 21-2    The get ( ) and put ( ) Methods Defined for ByteBuffer \n\nOne way to obtain a channel is by calling getChannel ( ) on an object that supports \nchannels. For example, getChannel ( ) is supported by the following I/O classes: \n\nThe specific type of channel returned depends upon the type of object getChannel ( ) is",
    "The specific type of channel returned depends upon the type of object getChannel ( ) is \n\ncalled on. For example, when called on a FileInputStream , FileOutputStream , or \nRandomAccessFile , getChannel ( ) returns a channel of type FileChannel . When \ncalled on a Socket , getChannel ( ) returns a SocketChannel . \nAnother way to obtain a channel is to use one of the static methods defined by the Files \nclass. For example, using Files , you can obtain a byte channel by calling \n\nnewByteChannel ( ) . It returns a SeekableByteChannel , which is an interface \nimplemented by FileChannel . ( The Files class is examined in detail later in this chapter.) \nChannels such as FileChannel and SocketChannel support various read ( ) and write ( ) \nmethods that enable you to perform I/O operations through the channel. For example, here \nare a few of the read ( ) and write ( ) methods defined for FileChannel .",
    "All channels support additional methods that give you access to and control over the \nchannel. For example, FileChannel supports methods to get or set the current position, \ntransfer information between file channels, obtain the current size of the channel, and lock \nthe channel, among others. FileChannel provides a static method called open ( ) , which \nopens a file and returns a channel to it. This provides another way to obtain a channel. \nFileChannel also provides the map ( ) method, which lets you map a file to a buffer. \n\nCharsets and Selectors",
    "Charsets and Selectors \n\nTwo other entities used by NIO are charsets and selectors. A charset defines the way that \nbytes are mapped to characters. You can encode a sequence of characters into bytes using \nan encoder . You can decode a sequence of bytes into characters using a decoder . Charsets, \nencoders, and decoders are supported by classes defined in the java.nio.charset package. \nBecause default encoders and decoders are provided, you will not often need to work \nexplicitly with charsets. \nA selector supports key-based, non-blocking, multiplexed I/O. In other words, selectors \nenable you to perform I/O through multiple channels. Selectors are supported by classes \ndefined in the java.nio.channels package. Selectors are most applicable to socket-backed \nchannels. \nWe will not use charsets or selectors in this chapter, but you might find them useful in your \nown applications. \n\nEnhancements Added to NIO by JDK 7",
    "Enhancements Added to NIO by JDK 7 \n\nBeginning with JDK 7, the NIO system was substantially expanded and enhanced. In \naddition to support for the try -with-resources statement ( which provides automatic \nresource management ), the improvements included three new packages ( java.nio.file , \njava.nio.file.attribute , and java.nio.file.spi ); several new classes, interfaces, and \nmethods ; and direct support for stream-based I/O. The additions have greatly expanded the \n\nways in which NIO can be used, especially with files. Several of the key additions are \n\n\ndescribed in the following sections. \n\nThe Path Interface",
    "Perhaps the single most important addition to the NIO system is the Path interface because \nit encapsulates a path to a file. As you will see, Path is the glue that binds together many of \nthe NIO.2 file-based features. It describes a file\u2019s location within the directory structure. \nPath is packaged in java.nio.file , and it inherits the following interfaces: Watchable , \nIterable<Path> , and Comparable<Path> . Watchable describes an object that can be \nmonitored for changes. The Iterable and Comparable interfaces were described earlier in \nthis book. \nPath declares a number of methods that operate on the path. A sampling is shown in Table \n21-3. Pay special attention to the getName ( ) method. It is used to obtain an element in a \npath. It works using an index. At index zero is the part of the path nearest the root, which is \nthe leftmost element in a path. Subsequent indexes specify elements to the right of the root",
    ". It works using an index. At index zero is the part of the path nearest the root, which is \nthe leftmost element in a path. Subsequent indexes specify elements to the right of the root. \nThe number of elements in a path can be obtained by calling getNameCount ( ) . If you \nwant to obtain a string representation of the entire path, simply call toString ( ) . Notice \nthat you can resolve a relative path into an absolute path by using the resolve ( ) method.",
    "Table 21-3    A Sampling of Methods Specified by Path \n\nOne other point: When updating legacy code that uses the File class defined by java.io , it \nis possible to convert a File instance into a Path instance by calling toPath ( ) on the File \nobject. Furthermore, it is possible to obtain a File instance by calling the toFile ( ) method \ndefined by Path . \n\nThe Files Class",
    "Many of the actions that you perform on a file are provided by static methods within the \nFiles class. The file to be acted upon is specified by its Path . Thus, the Files methods use a \nPath to specify the file that is being operated upon. Files contains a wide array of \nfunctionality. For example, it has methods that let you open or create a file that has the \nspecified path. You can obtain information about a Path , such as whether it is executable, \nhidden, or read-only. Files also supplies methods that let you copy or move files. A \nsampling is shown in Table 21-4. In addition to IOException , several other exceptions are \npossible. JDK 8 adds these four methods to Files : list ( ) , walk ( ) , lines ( ) , and find ( ) . \nAll return a Stream object. These methods help integrate NIO with the new stream API \ndefined by JDK 8 and described in Chapter 29. \nNotice that several of the methods in Table 21-4 take an argument of type OpenOption",
    ". These methods help integrate NIO with the new stream API \ndefined by JDK 8 and described in Chapter 29. \nNotice that several of the methods in Table 21-4 take an argument of type OpenOption . \nThis is an interface that describes how to open a file. It is implemented by the \nStandardOpenOption class, which defines an enumeration that has the values shown in \nTable 21-5.",
    "Table 21-4    A Sampling of Methods Defined by Files \n\nTable 21-5    The Standard Open Options \n\nThe Paths Class \n\nBecause Path is an interface, not a class, you can\u2019t create an instance of Path directly \nthrough the use of a constructor. Instead, you obtain a Path by a calling a method that \nreturns one. Frequently, you do this by using the get ( ) method defined by the Paths class. \nThere are two forms of get ( ) . The one used in this chapter is shown here: \n\nstatic Path get ( String pathname , String \u2026 parts ) \n\nIt returns a Path that encapsulates the specified path. The path can be specified in \n\ntwo ways. First, if parts is not used, then the path must be specified in its entirety \nby pathname . Alternatively, you can pass the path in pieces, with the first part",
    "two ways. First, if parts is not used, then the path must be specified in its entirety \nby pathname . Alternatively, you can pass the path in pieces, with the first part \n\n\npassed in pathname and the subsequent elements specified by the parts varargs \nparameter. In either case, if the path specified is syntactically invalid, get ( ) will \nthrow an InvalidPathException . \nThe second form of get ( ) creates a Path from a URI . It is shown here: \n\nstatic Path get ( URI uri ) \n\nThe Path corresponding to uri is returned. \nIt is important to understand that creating a Path to a file does not open or create a file. It \nsimply creates an object that encapsulates the file\u2019s directory path. \n\nThe File Attribute Interfaces",
    "The File Attribute Interfaces \n\nAssociated with a file is a set of attributes. These attributes include such things as the file\u2019s \ntime of creation, the time of its last modification, whether the file is a directory, and its size. \nNIO organizes file attributes into several different interfaces. Attributes are represented by a \nhierarchy of interfaces defined in java.nio.file.attribute . At the top is \nBasicFileAttributes . It encapsulates the set of attributes that are commonly found in a \nvariety of file systems. The methods defined by BasicFileAttributes are shown in Table \n21-6. \n\nTable 21-6    The Methods Defined by BasicFileAttributes \n\nFrom BasicFileAttributes two interfaces are derived: DosFileAttributes and \nPosixFileAttributes . DosFileAttributes describes those attributes related to the FAT \nfile system as first defined by DOS. It defines the methods shown here: \n\nMethod \nDescription",
    "Method \nDescription \n\nboolean isArchive ( ) \nReturns true if the file is flagged for archiving and false \notherwise. \n\n\nboolean isHidden ( ) \nReturns true if the file is hidden and false otherwise. \n\nboolean \nisReadOnly ( ) \nReturns true if the file is read-only and false otherwise. \n\nboolean isSystem ( ) \nReturns true if the file is flagged as a system file and false \notherwise. \n\nPosixFileAttributes encapsulates attributes defined by the POSIX standards. ( POSIX \nstands for Portable Operating System Interface .) It defines the methods shown here: \n\nMethod \nDescription \n\nGroupPrincipal group ( ) \nReturns the file\u2019s group owner. \n\nUserPrincipal owner ( ) \nReturns the file\u2019s owner. \n\nSet<PosixFilePermission> \npermissions ( ) \nReturns the file\u2019s permissions.",
    "GroupPrincipal group ( ) \nReturns the file\u2019s group owner. \n\nUserPrincipal owner ( ) \nReturns the file\u2019s owner. \n\nSet<PosixFilePermission> \npermissions ( ) \nReturns the file\u2019s permissions. \n\nThere are various ways to access a file\u2019s attributes. First, you can obtain an object that \nencapsulates a file\u2019s attributes by calling readAttributes ( ) , which is a static method \ndefined by Files . One of its forms is shown here:",
    "This method returns a reference to an object that specifies the attributes associated with the \nfile passed in path . The specific type of attributes is specified as a Class object in the \nattrType parameter. For example, to obtain the basic file attributes, pass \nBasicFileAttributes.class to attrType . For DOS attributes, use \nDosFileAttributes.class , and for POSIX attributes, use PosixFileAttributes.class . \nOptional link options are passed via opts . If not specified, symbolic links are followed. The \nmethod returns a reference to requested attributes. If the requested attribute type is not \navailable, UnsupportedOperationException is thrown. Using the object returned, you \ncan access the file\u2019s attributes. \nA second way to gain access to a file\u2019s attributes is to call getFileAttributeView ( ) defined",
    "by Files . NIO defines several attribute view interfaces, including AttributeView , \nBasicFileAttributeView , DosFileAttributeView , and PosixFileAttributeView , \namong others. Although we won\u2019t be using attribute views in this chapter, they are a feature \nthat you may find helpful in some situations. \nIn some cases, you won\u2019t need to use the file attribute interfaces directly because the Files \nclass offers static convenience methods that access several of the attributes. For example, \n\n\nFiles includes methods such as isHidden ( ) and isWritable ( ) . \nIt is important to understand that not all file systems support all possible attributes. For \nexample, the DOS file attributes apply to the older FAT file system as first defined by DOS. \nThe attributes that will apply to a wide variety of file systems are described by \nBasicFileAttributes . For this reason, these attributes are used in the examples in this \nchapter. \n\nThe FileSystem, FileSystems, and FileStore Classes",
    "The FileSystem, FileSystems, and FileStore Classes \n\nYou can easily access the file system through the FileSystem and FileSystems classes \npackaged in java.nio.file . In fact, by using the newFileSystem ( ) method defined by \nFileSystems , it is even possible to obtain a new file system. The FileStore class \nencapsulates the file storage system. Although these classes are not used directly in this \nchapter, you may find them helpful in your own applications. \n\nUsing the NIO System",
    "Using the NIO System \n\nThis section illustrates how to apply the NIO system to a variety of tasks. Before beginning, \nit is important to emphasize that with the release of JDK 7, the NIO subsystem was greatly \nexpanded. As a result, its uses have also been greatly expanded. As mentioned, the enhanced \nversion is sometimes referred to as NIO.2. Because the features added by NIO.2 are so \nsubstantial, they have changed the way that much NIO-based code is written and have \nincreased the types of tasks to which NIO can be applied. Because of its importance, most of \nthe remaining discussion and examples in this chapter utilize NIO.2 features and, therefore, \nrequire JDK 7, JDK 8, or later. However, at the end of the chapter is a brief description of \npre-JDK 7 code. This will be of aid to those programmers working in pre-JDK 7 \nenvironments or maintaining older code. \n\nREMEMBER Most of the examples in this chapter require JDK 7 or \n\nlater.",
    "REMEMBER Most of the examples in this chapter require JDK 7 or \n\nlater. \n\nIn the past, the primary purpose of NIO was channel-based I/O, and this is still a very \nimportant use. However, you can now use NIO for stream-based I/O and for performing \nfile-system operations. As a result, the discussion of using NIO is divided into three parts: \n\n\u2022  Using NIO for channel-based I/O \n\n\u2022  Using NIO for stream-based I/O \n\n\u2022  Using NIO for path and file system operations \n\nBecause the most common I/O device is the disk file, the rest of this chapter uses \n\n\ndisk files in the examples. Because all file channel operations are byte-based, the \n\ntype of buffers that we will be using are of type ByteBuffer . \nBefore you can open a file for access via the NIO system, you must obtain a Path that \ndescribes the file. One way to do this is to call the Paths.get ( ) factory method, which was \ndescribed earlier. The form of get ( ) used in the examples is shown here:",
    "static Path get ( String pathname , String \u2026 parts ) \n\nRecall that the path can be specified in two ways. It can be passed in pieces, with \nthe first part passed in pathname and the subsequent elements specified by the \nparts varargs parameter. Alternatively, the entire path can be specified in \npathname and parts is not used. This is the approach used by the examples. \n\nUse NIO for Channel-Based I/O \n\nAn important use of NIO is to access a file via a channel and buffers. The following sections \ndemonstrate some techniques that use a channel to read from and write to a file.",
    "An important use of NIO is to access a file via a channel and buffers. The following sections \ndemonstrate some techniques that use a channel to read from and write to a file. \n\nReading a File via a Channel \nThere are several ways to read data from a file using a channel. Perhaps the most common \nway is to manually allocate a buffer and then perform an explicit read operation that loads \nthat buffer with data from the file. It is with this approach that we begin. \nBefore you can read from a file, you must open it. To do this, first create a Path that \ndescribes the file. Then use this Path to open the file. There are various ways to open the \nfile depending on how it will be used. In this example, the file will be opened for byte-based \ninput via explicit input operations. Therefore, this example will open the file and establish a \nchannel to it by calling Files.newByteChannel ( ) . The newByteChannel ( ) method has \nthis general form:",
    "static SeekableByteChannel newByteChannel ( Path path , OpenOption \u2026 how ) \n\n   throws IOException \n\nIt returns a SeekableByteChannel object, which encapsulates the channel for \nfile operations. The Path that describes the file is passed in path . The how \nparameter specifies how the file will be opened. Because it is a varargs parameter, \nyou can specify zero or more comma-separated arguments. ( The valid values were \ndiscussed earlier and shown in Table 21-5.) If no arguments are specified, the file \nis opened for input operations. SeekableByteChannel is an interface that \ndescribes a channel that can be used for file operations. It is implemented by the \nFileChannel class. When the default file system is used, the returned object can \nbe cast to FileChannel . You must close the channel after you have finished with",
    "it. Since all channels, including FileChannel , implement AutoCloseable , you \ncan use a try -with-resources statement to close the file automatically instead of \ncalling close ( ) explicitly. This approach is used in the examples. \nNext, you must obtain a buffer that will be used by the channel either by wrapping an \n\n\nexisting array or by allocating the buffer dynamically. The examples use allocation, but the \n\nchoice is yours. Because file channels operate on byte buffers, we will use the allocate ( ) \nmethod defined by ByteBuffer to obtain the buffer. It has this general form: \n\nstatic ByteBuffer allocate ( int cap ) \n\nHere, cap specifies the capacity of the buffer. A reference to the buffer is returned. \nAfter you have created the buffer, call read ( ) on the channel, passing a reference to the \nbuffer. The version of read ( ) that we will use is shown next: \n\nint read ( ByteBuffer buf ) throws IOException",
    "int read ( ByteBuffer buf ) throws IOException \n\nEach time it is called, read ( ) fills the buffer specified by buf with data from the \nfile. The reads are sequential, meaning that each call to read ( ) reads the next \nbuffer\u2019s worth of bytes from the file. The read ( ) method returns the number of \nbytes actually read. It returns \u20131 when there is an attempt to read at the end of the \nfile. \nThe following program puts the preceding discussion into action by reading a file called \ntest.txt through a channel using explicit input operations:",
    "Here is how the program works. First, a Path object is obtained that contains the relative \npath to a file called test.txt . A reference to this object is assigned to filepath . Next, a \nchannel connected to the file is obtained by calling newByteChannel ( ) , passing in \nfilepath . Because no open option is specified, the file is opened for reading. Notice that this \nchannel is the object managed by the try -with-resources statement. Thus, the channel is \nautomatically closed when the block ends. The program then calls the allocate ( ) method \nof ByteBuffer to allocate a buffer that will hold the contents of the file when it is read. A \nreference to this buffer is stored in mBuf . The contents of the file are then read, one buffer",
    "at a time, into mBuf through a call to read ( ) . The number of bytes read is stored in \ncount . Next, the buffer is rewound through a call to rewind ( ) . This call is necessary \nbecause the current position is at the end of the buffer after the call to read ( ) . It must be",
    "reset to the start of the buffer in order for the bytes in mBuf to be read by calling get ( ) . \n( Recall that get ( ) is defined by ByteBuffer .) Because mBuf is a byte buffer, the values \nreturned by get ( ) are bytes. They are cast to char so the file can be displayed as text. \n( Alternatively, it is possible to create a buffer that encodes the bytes into characters and \nthen read that buffer.) When the end of the file has been reached, the value returned by \nread ( ) will be \u20131. When this occurs, the program ends, and the channel is automatically \nclosed. \nAs a point of interest, notice that the program obtains the Path within one try block and \nthen uses another try block to obtain and manage a channel linked to that path. Although \nthere is nothing wrong, per se, with this approach, in many cases, it can be streamlined so \nthat only one try block is needed. In this approach, the calls to Paths.get ( ) and \nnewByteChannel ( ) are sequenced together",
    ". In this approach, the calls to Paths.get ( ) and \nnewByteChannel ( ) are sequenced together. For example, here is a reworked version of \nthe program that uses this approach:",
    "In this version, the variable filepath is not needed and both exceptions are handled by the \nsame try statement. Because this approach is more compact, it is the approach used in the \nrest of the examples in this chapter. Of course, in your own code, you may encounter \nsituations in which the creation of a Path object needs to be separate from the acquisition \nof a channel. In these cases, the previous approach can be used. \nAnother way to read a file is to map it to a buffer. The advantage is that the buffer \nautomatically contains the contents of the file. No explicit read operation is necessary. To \nmap and read the contents of a file, follow this general procedure. First, obtain a Path \nobject that encapsulates the file as previously described. Next, obtain a channel to that file \nby calling Files.newByteChannel ( ) , passing in the Path and casting the returned object \nto FileChannel . As explained, newByteChannel ( ) returns a SeekableByteChannel",
    ". As explained, newByteChannel ( ) returns a SeekableByteChannel . \nWhen using the default file system, this object can be cast to FileChannel . Then, map the \nchannel to a buffer by calling map ( ) on the channel. The map ( ) method is defined by \nFileChannel . This is why the cast to FileChannel is needed. The map ( ) function is \nshown here:",
    "The map ( ) method causes the data in the file to be mapped into a buffer in memory. The \nvalue in how determines what type of operations are allowed. It must be one of these values: \n\nFor reading a file, use MapMode.READ_ONLY . To read and write, use \n\nMapMode.READ_WRITE . MapMode.PRIVATE causes a private copy of the \nfile to be made, and changes to the buffer do not affect the underlying file. The \nlocation within the file to begin mapping is specified by pos , and the number of \n\nbytes to map are specified by size . A reference to this buffer is returned as a \nMappedByteBuffer , which is a subclass of ByteBuffer . Once the file has been \nmapped to a buffer, you can read the file from that buffer. Here is an example that \nillustrates this approach:",
    "In the program, a Path to the file is created and then opened via newByteChannel ( ) . \nThe channel is cast to FileChannel and stored in fChan . Next, the size of the file is \nobtained by calling size ( ) on the channel. Then, the entire file is mapped into memory by \ncalling map ( ) on fChan and a reference to the buffer is stored in mBuf . Notice that \nmBuf is declared as a reference to a MappedByteBuffer . The bytes in mBuf are read by \ncalling get ( ) . \n\nWriting to a File via a Channel \n\nAs is the case when reading from a file, there are also several ways to write data to a file \nusing a channel. We will begin with one of the most common. In this approach, you \nmanually allocate a buffer, write data to that buffer, and then perform an explicit write \noperation to write that data to a file.",
    "Before you can write to a file, you must open it. To do this, first obtain a Path that describes \nthe file and then use this Path to open the file. In this example, the file will be opened for \nbyte-based output via explicit output operations. Therefore, this example will open the file \nand establish a channel to it by calling Files.newByteChannel ( ) . As shown in the \nprevious section, the newByteChannel ( ) method has this general form: \n\nstatic SeekableByteChannel newByteChannel ( Path path , OpenOption \u2026 how ) \n\n\n      throws IOException",
    "It returns a SeekableByteChannel object, which encapsulates the channel for \nfile operations. To open a file for output, the how parameter must specify \nStandardOpenOption.WRITE . If you want to create the file if it does not \nalready exist, then you must also specify StandardOpenOption.CREATE . \n( Other options, which are shown in Table 21-5, are also available.) As explained in \nthe previous section, SeekableByteChannel is an interface that describes a \nchannel that can be used for file operations. It is implemented by the \nFileChannel class. When the default file system is used, the return object can be \ncast to FileChannel . You must close the channel after you have finished with it. \nHere is one way to write to a file through a channel using explicit calls to write ( ) . First, \nobtain a Path to the file and then open it with a call to newByteChannel ( ) , casting the \nresult to FileChannel . Next, allocate a byte buffer and write data to that buffer",
    ". First, \nobtain a Path to the file and then open it with a call to newByteChannel ( ) , casting the \nresult to FileChannel . Next, allocate a byte buffer and write data to that buffer. Before the \ndata is written to the file, call rewind ( ) on the buffer to set its current position to zero. \n( Each output operation on the buffer increases the current position. Thus, it must be reset \nprior to writing to the file.) Then, call write ( ) on the channel, passing in the buffer. The \nfollowing program demonstrates this procedure. It writes the alphabet to a file called \ntest.txt .",
    "It is useful to emphasize an important aspect of this program. As mentioned, after data is \nwritten to mBuf , but before it is written to the file, a call to rewind ( ) on mBuf is made. \nThis is necessary in order to reset the current position to zero after data has been written to \nmBuf . Remember, each call to put ( ) on mBuf advances the current position. Therefore, it \nis necessary for the current position to be reset to the start of the buffer before calling \nwrite ( ) . If this is not done, write ( ) will think that there is no data in the buffer.",
    "Another way to handle the resetting of the buffer between input and output operations is to \ncall flip ( ) instead of rewind ( ) . The flip ( ) method sets the value of the current position \nto zero and the limit to the previous current position. In the preceding example, because the \ncapacity of the buffer equals its limit, flip ( ) could have been used instead of rewind ( ) . \nHowever, the two methods are not interchangeable in all cases. \nIn general, you must reset the buffer between read and write operations. For example, \n\nassuming the preceding example, the following loop will write the alphabet to the file three \n\n\ntimes. Pay special attention to the calls to rewind ( ) .",
    "Notice that rewind ( ) is called between each read and write operation. \nOne other thing about the program warrants mentioning: When the buffer is written to the \nfile, the first 26 bytes in the file will contain the output. If the file test.txt was preexisting, \nthen after the program executes, the first 26 bytes of test.txt will contain the alphabet, but \nthe remainder of the file will remain unchanged. \nAnother way to write to a file is to map it to a buffer. The advantage to this approach is that \nthe data written to the buffer will automatically be written to the file. No explicit write \noperation is necessary. To map and write the contents of a file, we will use this general \nprocedure. First, obtain a Path object that encapsulates the file and then create a channel to \nthat file by calling Files.newByteChannel ( ) , passing in the Path . Cast the reference \nreturned by newByteChannel ( ) to FileChannel . Next, map the channel to a buffer by \ncalling map ( ) on the channel",
    ". Cast the reference \nreturned by newByteChannel ( ) to FileChannel . Next, map the channel to a buffer by \ncalling map ( ) on the channel. The map ( ) method was described in detail in the previous \nsection. It is summarized here for your convenience. Here is its general form:",
    "The map ( ) method causes the data in the file to be mapped into a buffer in \nmemory. The value in how determines what type of operations are allowed. For \nwriting to a file, how must be MapMode.READ_WRITE . The location within \n\nthe file to begin mapping is specified by pos , and the number of bytes to map are \nspecified by size . A reference to this buffer is returned. Once the file has been \nmapped to a buffer, you can write data to that buffer, and it will automatically be \nwritten to the file. Therefore, no explicit write operations to the channel are \nnecessary. \nHere is the preceding program reworked so that a mapped file is used. Notice that in the \ncall to newByteChannel ( ) , the open option StandardOpenOption.READ has been \n\n\nadded. This is because a mapped buffer can either be read-only or read/write. Thus, to write \nto the mapped buffer, the channel must be opened as read/write.",
    "added. This is because a mapped buffer can either be read-only or read/write. Thus, to write \nto the mapped buffer, the channel must be opened as read/write. \n\nAs you can see, there are no explicit write operations to the channel itself. Because mBuf is \nmapped to the file, changes to mBuf are automatically reflected in the underlying file. \n\nCopying a File Using NIO \n\nNIO simplifies several types of file operations. Although we can\u2019t examine them all, an \nexample will give you an idea of what is available. The following program copies a file using \na call to a single NIO method: copy ( ) , which is a static method defined by Files . It has \nseveral forms. Here is the one we will be using: \n\nstatic Path copy ( Path src , Path dest , CopyOption \u2026 how ) throws IOException",
    "static Path copy ( Path src , Path dest , CopyOption \u2026 how ) throws IOException \n\nThe file specified by src is copied to the file specified by dest . How the copy is \nperformed is specified by how . Because it is a varargs parameter, it can be missing. \nIf specified, it can be one or more of these values, which are valid for all file \n\nsystems: \n\nRequest that the file\u2019s attributes be \n\n\nStandardCopyOption.COPY_ATTRIBUTES \ncopied. \n\nStandardLinkOption.NOFOLLOW_LINKS \nDo not follow symbolic links. \n\nStandardCopyOption.REPLACE_EXISTING \nOverwrite a preexisting file.",
    "StandardCopyOption.COPY_ATTRIBUTES \ncopied. \n\nStandardLinkOption.NOFOLLOW_LINKS \nDo not follow symbolic links. \n\nStandardCopyOption.REPLACE_EXISTING \nOverwrite a preexisting file. \n\nOther options may be supported, depending on the implementation. \nThe following program demonstrates copy ( ) . The source and destination files are specified \non the command line, with the source file specified first. Notice how short the program is. \nYou might want to compare this version of the file copy program to the one found in \nChapter 13. As you will find, the part of the program that actually copies the file is \nsubstantially shorter in the NIO version shown here. \n\nUse NIO for Stream-Based I/O",
    "Use NIO for Stream-Based I/O \n\nBeginning with NIO.2, you can use NIO to open an I/O stream. Once you have a Path , open \na file by calling newInputStream ( ) or newOutputStream ( ) , which are static \nmethods defined by Files . These methods return a stream connected to the specified file. In \neither case, the stream can then be operated on in the way described in Chapter 20, and the \nsame techniques apply. The advantage of using Path to open a file is that all of the features \ndefined by NIO are available for your use. \n\n\nTo open a file for stream-based input, use Files.newInputStream ( ) . It is shown here:",
    "To open a file for stream-based input, use Files.newInputStream ( ) . It is shown here: \n\nHere, path specifies the file to open and how specifies how the file will be opened. \nIt must be one or more of the values defined by StandardOpenOption , \ndescribed earlier. ( Of course, only those options that relate to an input stream will \napply.) If no options are specified, then the file is opened as if \nStandardOpenOption.READ were passed. \nOnce opened, you can use any of the methods defined by InputStream . For example, you \ncan use read ( ) to read bytes from the file. \nThe following program demonstrates the use of NIO-based stream I/O. It reworks the \nShowFile program from Chapter 13 so that it uses NIO features to open the file and obtain \na stream. As you can see, it is very similar to the original, except for the use of Path and \nnewInputStream ( ) .",
    "Because the stream returned by newInputStream ( ) is a normal stream, it can be used \nlike any other stream. For example, you can wrap the stream inside a buffered stream, such \nas a BufferedInputStream , to provide buffering, as shown here: \n\nNow, all reads will be automatically buffered. \nTo open a file for output, use Files.newOutputStream ( ) . It is shown here: \n\nHere, path specifies the file to open and how specifies how the file will be opened.",
    "Here, path specifies the file to open and how specifies how the file will be opened. \n\n\nIt must be one or more of the values defined by StandardOpenOption , \ndescribed earlier. ( Of course, only those options that relate to an output stream \nwill apply.) If no options are specified, then the file is opened as if \nStandardOpenOption.WRITE , StandardOpenOption.CREATE , and \nStandardOpenOption.TRUNCATE_EXISTING were passed. \nThe methodology for using newOutputStream ( ) is similar to that shown previously for \nnewInputStream ( ) . Once opened, you can use any of the methods defined by \nOutputStream . For example, you can use write ( ) to write bytes to the file. You can also \nwrap the stream inside a BufferedOutputStream to buffer the stream. \nThe following program shows newOutputStream ( ) in action. It writes the alphabet to a \nfile called test.txt . Notice the use of buffered I/O. \n\nUse NIO for Path and File System Operations",
    "Use NIO for Path and File System Operations \n\nAt the beginning of Chapter 20, the File class in the java.io package was examined. As \n\nexplained there, the File class deals with the file system and with the various attributes \nassociated with a file, such as whether a file is read-only, hidden, and so on. It was also used \n\nto obtain information about a file\u2019s path. Although the File class is still perfectly acceptable, \nthe interfaces and classes defined by NIO.2 offer a better way to perform these functions. \nThe benefits include support for symbolic links, better support for directory tree traversal, \nand improved handling of metadata, among others. The following sections show samples of \ntwo common file system operations: obtaining information about a path and file and getting \n\n\nthe contents of a directory.",
    "the contents of a directory. \n\nREMEMBER If you want to update older code that uses java.io.File to \nthe new Path interface, you can use the toPath ( ) method to obtain a \nPath instance from a File instance. \n\nObtain Information About a Path and a File \n\nInformation about a path can be obtained by using methods defined by Path . Some \nattributes associated with the file described by a Path ( such as whether or not the file is \nhidden ) are obtained by using methods defined by Files . The Path methods used here are \ngetName ( ) , getParent ( ) , and toAbsolutePath ( ) . Those provided by Files are \nisExecutable ( ) , isHidden ( ) , isReadable ( ) , isWritable ( ) , and exists ( ) . These are \nsummarized in Tables 21-3 and 21-4, shown earlier.",
    "CAUTION Methods such as isExecutable ( ), isReadable ( ), \nisWritable ( ), and exists ( ) must be used with care because the state of \nthe file system may change after the call, in which case a program \nmalfunction could occur. Such a situation could have security \nimplications. \n\nOther file attributes are obtained by requesting a list of attributes by calling \nFiles.readAttributes ( ) . In the program, this method is called to obtain the \nBasicFileAttributes associated with a file, but the general approach applies to other types \nof attributes. \nThe following program demonstrates several of the Path and Files methods, along with \nseveral methods provided by BasicFileAttributes . This program assumes that a file called \n\ntest.txt exists in a directory called examples , which must be a subdirectory of the current \ndirectory.",
    "test.txt exists in a directory called examples , which must be a subdirectory of the current \ndirectory. \n\n\n\n\nIf you execute this program from a directory called MyDir , which has a subdirectory called \nexamples , and the examples directory contains the test.txt file, then you will see output \nsimilar to that shown here. ( Of course, the information you see will differ.) \n\n\nIf you are using a computer that supports the FAT file system ( i.e., the DOS file system ), \nthen you might want to try using the methods defined by DosFileAttributes . If you are \nusing a POSIX-compatible system, then try using PosixFileAttributes . \n\nList the Contents of a Directory",
    "List the Contents of a Directory \n\nIf a path describes a directory, then you can read the contents of that directory by using \nstatic methods defined by Files . To do this, you first obtain a directory stream by calling \nnewDirectoryStream ( ) , passing in a Path that describes the directory. One form of \nnewDirectoryStream ( ) is shown here: \n\nHere, dirPath encapsulates the path to the directory. The method returns a",
    "Here, dirPath encapsulates the path to the directory. The method returns a \n\nDirectoryStream<Path> object that can be used to obtain the contents of the \ndirectory. It will throw an IOException if an I/O error occurs and a \nNotDirectoryException ( which is a subclass of IOException ) if the specified \npath is not a directory. A SecurityException is also possible if access to the \ndirectory is not permitted. \nDirectoryStream<Path> implements AutoCloseable , so it can be managed by a try - \nwith-resources statement. It also implements Iterable<Path> . This means that you can \nobtain the contents of the directory by iterating over the DirectoryStream object. When \niterating, each directory entry is represented by a Path instance. An easy way to iterate over",
    "a DirectoryStream is to use a for-each style for loop. It is important to understand, \nhowever, that the iterator implemented by DirectoryStream<Path> can be obtained only \nonce for each instance. Thus, the iterator ( ) method can be called only once, and a foreach loop can be executed only once. \nThe following program displays the contents of a directory called MyDir : \n\n\nHere is sample output from the program: \n\nYou can filter the contents of a directory in two ways. The easiest is to use this version of \nnewDirectoryStream ( ) : \n\nIn this version, only files that match the wildcard filename specified by wildcard will be \n\n\nobtained. For wildcard , you can specify either a complete filename or a glob . A glob is a \nstring that defines a general pattern that will match one or more files using the familiar * \nand ? wildcard characters. These match zero or more of any character and any one \ncharacter, respectively. The following are also recognized within a glob.",
    "** \nMatches zero or more of any character across directories. \n\n[ chars ] \nMatches any one character in chars . A * or ? within chars will be treated as \na normal character, not a wildcard. A range can be specified by use of a \nhyphen, such as [x-z]. \n\n{ globlist } \nMatches any one of the globs specified in a comma-separated list of globs \nin globlist . \n\nYou can specify a * or ? character, using \\* and \\? . To specify a \\ , use \\\\ . You can \nexperiment with a glob by substituting this call to newDirectoryStream ( ) into the \nprevious program: \n\nThis obtains a directory stream that contains only those files whose names begin with either \n\"Path\" or \"Dir\" and use either the \"java\" or \"class\" extension. Thus, it would match names \nlike DirList.java and PathDemo.java , but not MyPathDemo.java , for example. \nAnother way to filter a directory is to use this version of newDirectoryStream ( ) : \n\nHere, DirectoryStream.Filter is an interface that specifies the following method:",
    "Here, DirectoryStream.Filter is an interface that specifies the following method: \n\nboolean accept ( T entry ) throws IOException \n\nIn this case, T will be Path . If you want to include entry in the list, return true . \nOtherwise, return false . This form of newDirectoryStream ( ) offers the \nadvantage of being able to filter a directory based on something other than a \nfilename. For example, you can filter based on size, creation date, modification \n\ndate, or attribute, to name a few. \nThe following program demonstrates the process. It will list only those files that are \nwritable. \n\n\nUse walkFileTree ( ) to List a Directory Tree",
    "date, or attribute, to name a few. \nThe following program demonstrates the process. It will list only those files that are \nwritable. \n\n\nUse walkFileTree ( ) to List a Directory Tree \n\nThe preceding examples have obtained the contents of only a single directory. However, \nsometimes you will want to obtain a list of the files in a directory tree. In the past, this was \nquite a chore, but NIO.2 makes it easy because now you can use the walkFileTree ( ) \nmethod defined by Files to process a directory tree. It has two forms. The one used in this \n\nchapter is shown here:",
    "chapter is shown here: \n\n\nThe path to the starting point of the directory walk is passed in root . An instance of \nFileVisitor is passed in fv . The implementation of FileVisitor determines how the \ndirectory tree is traversed, and it gives you access to the directory information. If an I/O \nerror occurs, an IOException is thrown. A SecurityException is also possible. \nFileVisitor is an interface that defines how files are visited when a directory tree is \ntraversed. It is a generic interface that is declared like this: \n\ninterface FileVisitor<T> \n\nFor use in walkFileTree ( ) , T will be Path ( or any type derived from Path ). \nFileVisitor defines the following methods. \n\nNotice that each method returns a FileVisitResult . This enumeration defines the following \nvalues: \n\nIn general, to continue traversing the directory and subdirectories, a method should return",
    "Notice that each method returns a FileVisitResult . This enumeration defines the following \nvalues: \n\nIn general, to continue traversing the directory and subdirectories, a method should return \n\nCONTINUE . For preVisitDirectory ( ) , return SKIP_SIBLINGS to bypass the \ndirectory and its siblings and prevent postVisitDirectory ( ) from being called. To bypass \njust the directory and subdirectories, return SKIP_SUBTREE . To stop the directory \n\ntraversal, return TERMINATE . \nAlthough it is certainly possible to create your own visitor class that implements these \nmethods defined by FileVisitor , you won\u2019t normally do so because a simple \nimplementation is provided by SimpleFileVisitor . You can just override the default \nimplementation of the method or methods in which you are interested. Here is a short \nexample that illustrates the process. It displays all files in the directory tree that has \n\n\n\\MyDir as its root. Notice how short this program is.",
    "\\MyDir as its root. Notice how short this program is. \n\nHere is sample output produced by the program when used on the same MyDir directory \nshown earlier. In this example, the subdirectory called examples contains one file called \nMyProgram.java . \n\nIn the program, the class MyFileVisitor extends SimpleFileVisitor , overriding only the \nvisitFile ( ) method. In this example, visitFile ( ) simply displays the files, but more \nsophisticated functionality is easy to achieve. For example, you could filter the files or \nperform actions on the files, such as copying them to a backup device. For the sake of \n\nclarity, a named class was used to override visitFile ( ) , but you could also use an \nanonymous inner class. \n\n\nOne last point: It is possible to watch a directory for changes by using \njava.nio.file.WatchService . \n\nPre-JDK 7 Channel-Based Examples",
    "Pre-JDK 7 Channel-Based Examples \n\nBefore concluding this chapter, one more aspect of NIO needs to be covered. The preceding \nsections have used several of the new features added to NIO by JDK 7. However, you may \nencounter pre-JDK 7 code that will need to be maintained or possibly converted to use the \nnew features. For this reason, the following sections show how to read and write files using \nthe pre-JDK 7 NIO system. They do so by reworking some of the examples shown earlier so \nthat they use the original NIO features, rather than those supported by NIO.2. This means \nthat the examples in this section will work with versions of Java prior to JDK 7. \nThe key difference between pre-JDK 7 NIO code and newer NIO code is the Path interface, \nwhich was added by JDK 7. Thus, pre-JDK 7 code does not use Path to describe a file or \nopen a channel to it. Also, pre-JDK 7 code does not use try -with-resource statements since \nautomatic resource management was also added by JDK 7.",
    "REMEMBER The examples in this section describe how legacy NIO code \nworks. This section is strictly for the benefit of those programmers \nworking on pre-JDK 7 code or using pre-JDK 7 compilers. New code \nshould take advantage of the NIO features added by JDK 7. \n\nRead a File, Pre-JDK 7 \n\nThis section reworks the two channel-based file input examples shown earlier so they use \nonly pre-JDK 7 features. The first example reads a file by manually allocating a buffer and \nthen performing an explicit read operation. The second example uses a mapped file, which \nautomates the process. \nWhen using a pre-JDK 7 version of Java to read a file using a channel and a manually \nallocated buffer, you first open the file for input using FileInputStream , using the same \nmechanism explained in Chapter 20. Next, obtain a channel to this file by calling \ngetChannel ( ) on the FileInputStream object. It has this general form: \n\nFileChannel getChannel ( )",
    "FileChannel getChannel ( ) \n\nIt returns a FileChannel object, which encapsulates the channel for file \n\noperations. Then, call allocate ( ) to allocate a buffer. Because file channels \noperate on byte buffers, you will use the allocate ( ) method defined by \nByteBuffer , which works as previously described. \nThe following program shows how to read and display a file called test.txt through a \n\n\nchannel using explicit input operations for versions of Java prior to JDK 7: \n\n\nIn this program, notice that the file is opened by using the FileInputStream constructor, \n\nand a reference to that object is assigned to fIn . Next, a channel connected to the file is \nobtained by calling getChannel ( ) on fIn . After this point, the program works like the \nNIO.2 version shown previously. To synopsize: The program then calls the allocate ( )",
    "method of ByteBuffer to allocate a buffer that will hold the contents of the file when it is \nread. A byte buffer is used because FileChannel operates on bytes. A reference to this \nbuffer is stored in mBuf . The contents of the file are then read, one buffer at a time, into \nmBuf through a call to read ( ) . The number of bytes read is stored in count . Next, the \nbuffer is rewound through a call to rewind ( ) . This call is necessary because the current \nposition is at the end of the buffer after the call to read ( ) , and it must be reset to the start \nof the buffer in order for the bytes in mBuf to be read by calling get ( ) . When the end of",
    "the file has been reached, the value returned by read ( ) will be \u20131. When this occurs, the \nprogram ends, explicitly closing the channel and the file. \nAnother way to read a file is to map it to a buffer. As explained earlier, a principal \nadvantage to this approach is that the buffer automatically contains the contents of the file. \nNo explicit read operation is necessary. To map and read the contents of a file using preJDK 7 NIO, first open the file using FileInputStream . Next, obtain a channel to that file \nby calling getChannel ( ) on the file object. Then, map the channel to a buffer by calling \nmap ( ) on the FileChannel object. The map ( ) method works as described earlier. \nThe following program reworks the preceding example so that it uses only pre-JDK 7 \nfeatures to create a mapped file:",
    "In the program, the file is opened by using the FileInputStream constructor, and a \nreference to that object is assigned to fIn . A channel connected to the file is obtained by \ncalling getChannel ( ) on fIn . Next, the size of the file is obtained. Then, the entire file is \n\nmapped into memory by calling map ( ) , and a reference to the buffer is stored in mBuf . \nThe bytes in mBuf are read by calling get ( ) . \n\n\nWrite to a File, Pre-JDK 7",
    "This section reworks the two channel-based file output examples shown earlier so that they \nuse only pre-JDK 7 features. The first example writes to a file by manually allocating a \nbuffer and then performing an explicit output operation. The second example uses a \nmapped file, which automates the process. In both cases, neither Path nor try -withresources is used. This is because neither were part of Java until JDK 7. \nWhen using a pre-JDK 7 version of Java to write a file using a channel and a manually \nallocated buffer, first open the file for output. This is done by creating a \nFileOutputStream , as described in Chapter 20. Next, obtain a channel to the file by \ncalling getChannel ( ) and then allocate a byte buffer by calling allocate ( ) , as described \nin the previous section. Next, put the data you want to write into that buffer, and then call \nwrite ( ) on the channel. The following program demonstrates this procedure. It writes the \nalphabet to a file called test.txt .",
    "The call to rewind ( ) on mBuf is necessary in order to reset the current position to zero \nafter data has been written to mBuf . Remember, each call to put ( ) advances the current \nposition. Therefore, it is necessary for the current position to be reset to the start of the \nbuffer before calling write ( ) . If this is not done, write ( ) will think that there is no data in \nthe buffer. \nWhen using a pre-JDK 7 version of Java to write to a file using a mapped file, follow these \nsteps. First, open the file for read/write operations by creating a RandomAccessFile \nobject. This is necessary to enable the file to be both read from and written to. Next, map \nthat file to a buffer by calling map ( ) on that object. Then, write to the buffer. Because the \nbuffer is mapped to the file, any changes to that buffer are automatically reflected in the file. \nThus, no explicit write operations to the channel are necessary",
    ". Because the \nbuffer is mapped to the file, any changes to that buffer are automatically reflected in the file. \nThus, no explicit write operations to the channel are necessary. \nHere is the preceding program reworked so that a mapped file is used:",
    "As you can see, there are no explicit write operations to the channel itself. Because mBuf is \nmapped to the file, changes to mBuf are automatically reflected in the underlying file. \n\n\uf709 \nPREV \n\u23ee \n\nNEXT \n\n\u23ed \n\n\nChapter 20: Input/Output: Exploring java.io \nChapter 22: Networking \n\n\nPREV \nChapter 21: Exploring NIO \n\u23ee \n\nNEXT \nChapter 23: The Applet Class \u23ed \n\nCHAPTER \n\n22 \nNetworking",
    "\u23ed \n\n\nChapter 20: Input/Output: Exploring java.io \nChapter 22: Networking \n\n\nPREV \nChapter 21: Exploring NIO \n\u23ee \n\nNEXT \nChapter 23: The Applet Class \u23ed \n\nCHAPTER \n\n22 \nNetworking \n\nAs all readers know, Java is practically a synonym for Internet programming. There are a \nnumber of reasons for this, not the least of which is its ability to generate secure, crossplatform, portable code. However, one of the most important reasons that Java is the \npremier language for network programming are the classes defined in the java.net \npackage. They provide an easy-to-use means by which programmers of all skill levels can \naccess network resources. \nThis chapter explores the java.net package. It is important to emphasize that networking is \na very large and at times complicated topic. It is not possible for this book to discuss all of \nthe capabilities contained in java.net. Instead, this chapter focuses on several of its core \nclasses and interfaces. \n\nNetworking Basics",
    "Networking Basics \n\nBefore we begin, it will be useful to review some key networking concepts and terms. At the \ncore of Java\u2019s networking support is the concept of a socket . A socket identifies an endpoint \nin a network. The socket paradigm was part of the 4.2BSD Berkeley UNIX release in the \nearly 1980s. Because of this, the term Berkeley socket is also used. Sockets are at the \nfoundation of modern networking because a socket allows a single computer to serve many \ndifferent clients at once, as well as to serve many different types of information. This is \naccomplished through the use of a port , which is a numbered socket on a particular \nmachine. A server process is said to \"listen\" to a port until a client connects to it. A server is \nallowed to accept multiple clients connected to the same port number, although each \nsession is unique. To manage multiple client connections, a server process must be \nmultithreaded or have some other means of multiplexing the simultaneous I/O.",
    "Socket communication takes place via a protocol. Internet Protocol ( IP ) is a low-level \nrouting protocol that breaks data into small packets and sends them to an address across a \nnetwork, which does not guarantee to deliver said packets to the destination. Transmission \nControl Protocol ( TCP ) is a higher-level protocol that manages to robustly string together \nthese packets, sorting and retransmitting them as necessary to reliably transmit data. A \nthird protocol, User Datagram Protocol ( UDP ) , sits next to TCP and can be used directly to \n\nsupport fast, connectionless, unreliable transport of packets.",
    "Once a connection has been established, a higher-level protocol ensues, which is dependent \non which port you are using. TCP/IP reserves the lower 1,024 ports for specific protocols. \nMany of these will seem familiar to you if you have spent any time surfing the Internet. Port \nnumber 21 is for FTP ; 23 is for Telnet ; 25 is for e-mail ; 43 is for whois ; 80 is for HTTP ; 119 \nis for netnews\u2014and the list goes on. It is up to each protocol to determine how a client \nshould interact with the port. \nFor example, HTTP is the protocol that web browsers and servers use to transfer hypertext \npages and images. It is a quite simple protocol for a basic page-browsing web server. Here\u2019s \nhow it works. When a client requests a file from an HTTP server, an action known as a hit , \nit simply sends the name of the file in a special format to a predefined port and reads back \nthe contents of the file",
    ". When a client requests a file from an HTTP server, an action known as a hit , \nit simply sends the name of the file in a special format to a predefined port and reads back \nthe contents of the file. The server also responds with a status code to tell the client whether \nor not the request can be fulfilled and why. \nA key component of the Internet is the address . Every computer on the Internet has one. \nAn Internet address is a number that uniquely identifies each computer on the Net. \nOriginally, all Internet addresses consisted of 32-bit values, organized as four 8-bit values. \nThis address type was specified by IPv4 ( Internet Protocol, version 4 ). However, a new \naddressing scheme, called IPv6 ( Internet Protocol, version 6 ) has come into play. IPv6 uses \na 128-bit value to represent an address, organized into eight 16-bit chunks. Although there \nare several reasons for and advantages to IPv6, the main one is that it supports a much \nlarger address space than does IPv4",
    ". Although there \nare several reasons for and advantages to IPv6, the main one is that it supports a much \nlarger address space than does IPv4. Fortunately, when using Java, you won\u2019t normally \nneed to worry about whether IPv4 or IPv6 addresses are used because Java handles the \ndetails for you. \nJust as the numbers of an IP address describe a network hierarchy, the name of an Internet \naddress, called its domain name , describes a machine\u2019s location in a name space. For \nexample, www.HerbSchildt.com is in the COM top-level domain ( reserved for U.S. \ncommercial sites ); it is called HerbSchildt , and www identifies the server for web requests. \nAn Internet domain name is mapped to an IP address by the Domain Naming Service \n( DNS ) . This enables users to work with domain names, but the Internet operates on IP \naddresses.",
    "The Networking Classes and Interfaces \n\nJava supports TCP/IP both by extending the already established stream I/O interface \nintroduced in Chapter 20 and by adding the features required to build I/O objects across the \nnetwork. Java supports both the TCP and UDP protocol families. TCP is used for reliable \nstream-based I/O across the network. UDP supports a simpler, hence faster, point-to-point \ndatagram-oriented model. The classes contained in the java.net package are shown here: \n\n\nThe java.net package\u2019s interfaces are listed here: \n\nIn the sections that follow, we will examine the main networking classes and show several \nexamples that apply to them. Once you understand these core networking classes, you will \nbe able to easily explore the others on your own. \n\nInetAddress",
    "InetAddress \n\nThe InetAddress class is used to encapsulate both the numerical IP address and the \ndomain name for that address. You interact with this class by using the name of an IP host, \nwhich is more convenient and understandable than its IP address. The InetAddress class \nhides the number inside. InetAddress can handle both IPv4 and IPv6 addresses. \n\nFactory Methods \n\nThe InetAddress class has no visible constructors. To create an InetAddress object, you \nhave to use one of the available factory methods. Factory methods are merely a convention \nwhereby static methods in a class return an instance of that class. This is done in lieu of \n\noverloading a constructor with various parameter lists when having unique method names \nmakes the results much clearer. Three commonly used InetAddress factory methods are \nshown here: \n\nstatic InetAddress getLocalHost ( ) \n\n   throws UnknownHostException \n\nstatic InetAddress getByName ( String hostName )",
    "static InetAddress getLocalHost ( ) \n\n   throws UnknownHostException \n\nstatic InetAddress getByName ( String hostName ) \n\n\n   throws UnknownHostException \n\nstatic InetAddress[ ] getAllByName ( String hostName ) \n\n   throws UnknownHostException",
    "throws UnknownHostException \n\nThe getLocalHost ( ) method simply returns the InetAddress object that \nrepresents the local host. The getByName ( ) method returns an InetAddress \nfor a host name passed to it. If these methods are unable to resolve the host name, \nthey throw an UnknownHostException . \nOn the Internet, it is common for a single name to be used to represent several machines. \nIn the world of web servers, this is one way to provide some degree of scaling. The \ngetAllByName ( ) factory method returns an array of InetAddress es that represent all of \nthe addresses that a particular name resolves to. It will also throw an \nUnknownHostException if it can\u2019t resolve the name to at least one address. \nInetAddress also includes the factory method getByAddress ( ), which takes an IP \naddress and returns an InetAddress object. Either an IPv4 or an IPv6 address can be used. \nThe following example prints the addresses and names of the local machine and two \nInternet web sites:",
    "Here is the output produced by this program. ( Of course, the output you see may be slightly \ndifferent.) \n\nInstance Methods \n\n\nThe InetAddress class has several other methods, which can be used on the objects \nreturned by the methods just discussed. Here are some of the more commonly used \nmethods: \n\nboolean \nequals ( Object other ) \nReturns true if this object has the same Internet address as \nother . \n\nbyte[ ] getAddress ( ) \nReturns a byte array that represents the object\u2019s IP address in \nnetwork byte order. \n\nString \ngetHostAddress ( ) \nReturns a string that represents the host address associated \nwith the InetAddress object. \n\nString \ngetHostName ( ) \nReturns a string that represents the host name associated with \nthe InetAddress object. \n\nboolean \nisMulticastAddress ( \n) \n\nReturns true if this address is a multicast address. Otherwise, it \nreturns false. \n\nString toString ( ) \nReturns a string that lists the host name and the IP address for \nconvenience.",
    "Returns true if this address is a multicast address. Otherwise, it \nreturns false. \n\nString toString ( ) \nReturns a string that lists the host name and the IP address for \nconvenience. \n\nInternet addresses are looked up in a series of hierarchically cached servers. That means \nthat your local computer might know a particular name-to-IP-address mapping \nautomatically, such as for itself and nearby servers. For other names, it may ask a local DNS \nserver for IP address information. If that server doesn\u2019t have a particular address, it can go \nto a remote site and ask for it. This can continue all the way up to the root server. This \nprocess might take a long time, so it is wise to structure your code so that you cache IP \naddress information locally rather than look it up repeatedly. \n\nInet4Address and Inet6Address",
    "Inet4Address and Inet6Address \n\nJava includes support for both IPv4 and IPv6 addresses. Because of this, two subclasses of \nInetAddress were created: Inet4Address and Inet6Address . Inet4Address \nrepresents a traditional-style IPv4 address. Inet6Address encapsulates a newer IPv6 \naddress. Because they are subclasses of InetAddress, an InetAddress reference can refer \nto either. This is one way that Java was able to add IPv6 functionality without breaking \n\nexisting code or adding many more classes. For the most part, you can simply use \nInetAddress when working with IP addresses because it can accommodate both styles. \n\nTCP/IP Client Sockets \n\nTCP/IP sockets are used to implement reliable, bidirectional, persistent, point-to-point, \nstream-based connections between hosts on the Internet. A socket can be used to connect \n\nJava\u2019s I/O system to other programs that may reside either on the local machine or on any \n\n\nother machine on the Internet.",
    "Java\u2019s I/O system to other programs that may reside either on the local machine or on any \n\n\nother machine on the Internet. \n\nNOTE As a general rule, applets may only establish socket connections \nback to the host from which the applet was downloaded. This restriction \nexists because it would be dangerous for applets loaded through a firewall \nto have access to any arbitrary machine.",
    "There are two kinds of TCP sockets in Java. One is for servers, and the other is for clients. \nThe ServerSocket class is designed to be a \"listener,\" which waits for clients to connect \nbefore doing anything. Thus, ServerSocket is for servers. The Socket class is for clients. It \nis designed to connect to server sockets and initiate protocol exchanges. Because client \nsockets are the most commonly used by Java applications, they are examined here. \nThe creation of a Socket object implicitly establishes a connection between the client and \nserver. There are no methods or constructors that explicitly expose the details of \nestablishing that connection. Here are two constructors used to create client sockets: \n\nSocket ( String hostName , int port ) throws \nUnknownHostException, IOException \nCreates a socket connected to the \nnamed host and port. \n\nSocket ( InetAddress ipAddress , int port ) \nthrows IOException \nCreates a socket using a preexisting \nInetAddress object and a port.",
    "Socket ( InetAddress ipAddress , int port ) \nthrows IOException \nCreates a socket using a preexisting \nInetAddress object and a port. \n\nSocket defines several instance methods. For example, a Socket can be examined at any \n\ntime for the address and port information associated with it, by use of the following \nmethods: \n\nInetAddress \n\ngetInetAddress ( \n) \n\nReturns the InetAddress associated with the Socket object. It \n\nreturns null if the socket is not connected. \n\nint getPort ( ) \nReturns the remote port to which the invoking Socket object is \nconnected. It returns 0 if the socket is not connected. \n\nint getLocalPort ( \n) \nReturns the local port to which the invoking Socket object is \nbound. It returns \u20131 if the socket is not bound. \n\nYou can gain access to the input and output streams associated with a Socket by use of the \n\ngetInputStream ( ) and getOuptutStream ( ) methods, as shown here. Each can throw",
    "You can gain access to the input and output streams associated with a Socket by use of the \n\ngetInputStream ( ) and getOuptutStream ( ) methods, as shown here. Each can throw \n\n\nan IOException if the socket has been invalidated by a loss of connection. These streams \nare used exactly like the I/O streams described in Chapter 20 to send and receive data. \n\nInputStream getInputStream ( ) throws \nIOException \nReturns the InputStream associated with \nthe invoking socket. \n\nOutputStream getOutputStream ( ) \nthrows IOException \nReturns the OutputStream associated with \nthe invoking socket.",
    "Several other methods are available, including connect ( ), which allows you to specify a \nnew connection ; isConnected ( ), which returns true if the socket is connected to a server ; \nisBound ( ), which returns true if the socket is bound to an address ; and isClosed ( ), \nwhich returns true if the socket is closed. To close a socket, call close ( ) . Closing a socket \nalso closes the I/O streams associated with the socket. Beginning with JDK 7, Socket also \nimplements AutoCloseable , which means that you can use a try -with-resources block to \nmanage a socket. \nThe following program provides a simple Socket example. It opens a connection to a \n\"whois\" port ( port 43 ) on the InterNIC server, sends the command-line argument down the \nsocket, and then prints the data that is returned. InterNIC will try to look up the argument \nas a registered Internet domain name, and then send back the IP address and contact \ninformation for that site.",
    "If, for example, you obtained information about MHProfessional.com , you\u2019d get \nsomething similar to the following: \n\nHere is how the program works. First, a Socket is constructed that specifies the host name \n\"whois.internic.net\" and the port number 43. Internic.net is the InterNIC web site that \nhandles whois requests. Port 43 is the whois port. Next, both input and output streams are \nopened on the socket. Then, a string is constructed that contains the name of the web site \nyou want to obtain information about. In this case, if no web site is specified on the \n\n\ncommand line, then \"MHProfessional.com\" is used. The string is converted into a byte",
    "command line, then \"MHProfessional.com\" is used. The string is converted into a byte \n\narray and then sent out of the socket. The response is read by inputting from the socket, and \nthe results are displayed. Finally, the socket is closed, which also closes the I/O streams. \nIn the preceding example, the socket was closed manually by calling close ( ) . If you are \nusing JDK 7 or later, then you can use a try -with-resources block to automatically close the \nsocket. For example, here is another way to write the main ( ) method of the previous \nprogram:",
    "In this version, the socket is automatically closed when the try block ends. \nSo the examples will work with earlier versions of Java and to clearly illustrate when a \nnetwork resource can be closed, subsequent examples will continue to call close ( ) \nexplicitly. However, in your own code, you should consider using automatic resource \nmanagement since it offers a more streamlined approach. One other point: In this version, \nexceptions are still thrown out of main ( ) , but they could be handled by adding catch \nclauses to the end of the try -with-resources block. \n\nNOTE For simplicity, the examples in this chapter simply throw all \nexceptions out of main ( ). This allows the logic of the network code to be \nclearly illustrated. However, in real-world code, you will normally need to \nhandle the exceptions in an appropriate way. \n\n\nURL",
    "The preceding example was rather obscure because the modern Internet is not about the \nolder protocols such as whois, finger, and FTP. It is about WWW, the World Wide Web. The \nWeb is a loose collection of higher-level protocols and file formats, all unified in a web \nbrowser. One of the most important aspects of the Web is that Tim Berners-Lee devised a \nscalable way to locate all of the resources of the Net. Once you can reliably name anything \nand everything, it becomes a very powerful paradigm. The Uniform Resource Locator ( URL ) \ndoes exactly that. \nThe URL provides a reasonably intelligible form to uniquely identify or address information \non the Internet. URLs are ubiquitous ; every browser uses them to identify information on \nthe Web. Within Java\u2019s network class library, the URL class provides a simple, concise API \nto access information across the Internet using URLs. \nAll URLs share the same basic format, although some variation is allowed",
    ". \nAll URLs share the same basic format, although some variation is allowed. Here are two \nexamples: http://www.MHProfessional.com/ and \nhttp://www.MHProfessional.com:80/index.htm . A URL specification is based on \nfour components. The first is the protocol to use, separated from the rest of the locator by a \ncolon (:). Common protocols are HTTP, FTP, gopher, and file, although these days almost \neverything is being done via HTTP ( in fact, most browsers will proceed correctly if you leave \noff the \"http://\" from your URL specification ). The second component is the host name or \nIP address of the host to use ; this is delimited on the left by double slashes (//) and on the \nright by a slash (/) or optionally a colon (:). The third component, the port number, is an \noptional parameter, delimited on the left from the host name by a colon (:) and on the right \nby a slash (/)",
    ". The third component, the port number, is an \noptional parameter, delimited on the left from the host name by a colon (:) and on the right \nby a slash (/). ( It defaults to port 80, the predefined HTTP port ; thus, \":80\" is redundant.) \nThe fourth part is the actual file path. Most HTTP servers will append a file named \nindex.html or index.htm to URLs that refer directly to a directory resource. Thus, \nhttp://www.MHProfessional.com/ is the same as \nhttp://www.MHProfessional.com/index.htm . \nJava\u2019s URL class has several constructors ; each can throw a MalformedURLException . \nOne commonly used form specifies the URL with a string that is identical to what you see \ndisplayed in a browser:",
    "URL ( String urlSpecifier ) throws MalformedURLException \n\nThe next two forms of the constructor allow you to break up the URL into its \ncomponent parts: \n\nURL ( String protocolName , String hostName , int port , String path ) \n\n   throws MalformedURLException \n\nURL ( String protocolName , String hostName , String path ) \n\n   throws MalformedURLException \n\n\nAnother frequently used constructor allows you to use an existing URL as a \nreference context and then create a new URL from that context. Although this \nsounds a little contorted, it\u2019s really quite easy and useful. \n\nURL ( URL urlObj , String urlSpecifier ) throws MalformedURLException \n\nThe following example creates a URL to a page on HerbSchildt.com and then \nexamines its properties: \n\nWhen you run this, you will get the following output:",
    "The following example creates a URL to a page on HerbSchildt.com and then \nexamines its properties: \n\nWhen you run this, you will get the following output: \n\nNotice that the port is \u20131 ; this means that a port was not explicitly set. Given a URL object, \nyou can retrieve the data associated with it. To access the actual bits or content information \nof a URL, create a URLConnection object from it, using its openConnection ( ) \nmethod, like this: \n\nopenConnection ( ) has the following general form: \n\nURLConnection openConnection ( ) throws IOException \n\nIt returns a URLConnection object associated with the invoking URL object. \nNotice that it may throw an IOException . \n\nURLConnection \n\nURLConnection is a general-purpose class for accessing the attributes of a remote \nresource. Once you make a connection to a remote server, you can use URLConnection to \n\ninspect the properties of the remote object before actually transporting it locally. These",
    "inspect the properties of the remote object before actually transporting it locally. These \n\n\nattributes are exposed by the HTTP protocol specification and, as such, only make sense for \nURL objects that are using the HTTP protocol. \nURLConnection defines several methods. Here is a sampling: \n\nint getContentLength ( ) \nReturns the size in bytes of the content associated with the \nresource. If the length is unavailable, \u20131 is returned. \n\nlong \ngetContentLengthLong ( \n) \n\nReturns the size in bytes of the content associated with the \nresource. If the length is unavailable, \u20131 is returned. \n\nString getContentType ( \n) \n\nReturns the type of content found in the resource. This is the \nvalue of the content-type header field. Returns null if the \ncontent type is not available. \n\nlong getDate ( ) \nReturns the time and date of the response represented in \nterms of milliseconds since January 1, 1970 GMT.",
    "long getDate ( ) \nReturns the time and date of the response represented in \nterms of milliseconds since January 1, 1970 GMT. \n\nlong getExpiration ( ) \nReturns the expiration time and date of the resource \nrepresented in terms of milliseconds since January 1, 1970 \nGMT. Zero is returned if the expiration date is unavailable. \n\nString \ngetHeaderField ( int idx ) \n\nReturns the value of the header field at index idx . ( Header \nfield indexes begin at 0.) Returns null if the value of idx \nexceeds the number of fields. \n\nString \ngetHeaderField ( String \nfieldName ) \n\nReturns the value of header field whose name is specified by \nfieldName . Returns null if the specified name is not found. \n\nString \n\ngetHeaderFieldKey ( int \nidx ) \n\nReturns the header field key at index idx . ( Header field \n\nindexes begin at 0.) Returns null if the value of idx exceeds \nthe number of fields. \n\nMap<String, \nList<String>> \ngetHeaderFields ( ) \n\nReturns a map that contains all of the header fields and",
    "indexes begin at 0.) Returns null if the value of idx exceeds \nthe number of fields. \n\nMap<String, \nList<String>> \ngetHeaderFields ( ) \n\nReturns a map that contains all of the header fields and \n\nvalues. \n\nlong getLastModified ( ) \n\nReturns the time and date, represented in terms of \nmilliseconds since January 1, 1970 GMT, of the last \nmodification of the resource. Zero is returned if the lastmodified date is unavailable. \n\nInputStream \ngetInputStream ( ) \n\nthrows IOException \n\nReturns an InputStream that is linked to the resource. This \nstream can be used to obtain the content of the resource. \n\nNotice that URLConnection defines several methods that handle header information. A",
    "Notice that URLConnection defines several methods that handle header information. A \n\n\nheader consists of pairs of keys and values represented as strings. By using \ngetHeaderField ( ) , you can obtain the value associated with a header key. By calling \ngetHeaderFields ( ) , you can obtain a map that contains all of the headers. Several \nstandard header fields are available directly through methods such as getDate ( ) and \ngetContentType ( ) . \nThe following example creates a URLConnection using the openConnection ( ) method \nof a URL object and then uses it to examine the document\u2019s properties and content: \n\n\nThe program establishes an HTTP connection to www.internic.net over port 80. It then \ndisplays several header values and retrieves the content. You might find it interesting to try \nthis example, observing the results, and then for comparison purposes try a different web \nsite of your own choosing. \n\nHttpURLConnection",
    "HttpURLConnection \n\n\nJava provides a subclass of URLConnection that provides support for HTTP connections. \nThis class is called HttpURLConnection. You obtain an HttpURLConnection in the \nsame way just shown, by calling openConnection ( ) on a URL object, but you must cast \nthe result to HttpURLConnection. ( Of course, you must make sure that you are actually \nopening an HTTP connection.) Once you have obtained a reference to an \nHttpURLConnection object, you can use any of the methods inherited from \nURLConnection. You can also use any of the several methods defined by \nHttpURLConnection. Here is a sampling: \n\nstatic boolean \ngetFollowRedirects ( ) \nReturns true if redirects are automatically followed and \nfalse otherwise. This feature is on by default. \n\nString getRequestMethod ( \n) \n\nReturns a string representing how URL requests are \nmade. The default is GET. Other options, such as POST, \nare available. \n\nint getResponseCode ( ) \nthrows IOException",
    "Returns a string representing how URL requests are \nmade. The default is GET. Other options, such as POST, \nare available. \n\nint getResponseCode ( ) \nthrows IOException \n\nReturns the HTTP response code. \u20131 is returned if no \nresponse code can be obtained. An IOException is \nthrown if the connection fails. \n\nString \ngetResponseMessage ( ) \nthrows IOException \n\nReturns the response message associated with the \nresponse code. Returns null if no message is available. \nAn IOException is thrown if the connection fails. \n\nstatic void \nsetFollowRedirects ( boolean \nhow ) \n\nIf how is true, then redirects are automatically followed. \nIf how is false, redirects are not automatically followed. \nBy default, redirects are automatically followed. \n\nvoid \nsetRequestMethod ( String \nhow ) throws \nProtocolException",
    "void \nsetRequestMethod ( String \nhow ) throws \nProtocolException \n\nSets the method by which HTTP requests are made to \nthat specified by how . The default method is GET, but \nother options, such as POST, are available. If how is \ninvalid, a ProtocolException is thrown. \n\nThe following program demonstrates HttpURLConnection. It first establishes a \n\nconnection to www.google.com . Then it displays the request method, the response code, \nand the response message. Finally, it displays the keys and values in the response header. \n\n\nThe output produced by the program is shown here. ( Of course, the exact response returned \nby www.google.com will vary over time.)",
    "The output produced by the program is shown here. ( Of course, the exact response returned \nby www.google.com will vary over time.) \n\n\nNotice how the header keys and values are displayed. First, a map of the header keys and \nvalues is obtained by calling getHeaderFields ( ) ( which is inherited from \nURLConnection ). Next, a set of the header keys is retrieved by calling keySet ( ) on the \nmap. Then, the key set is cycled through by using a for-each style for loop. The value \nassociated with each key is obtained by calling get ( ) on the map. \n\nThe URI Class \n\nThe URI class encapsulates a Uniform Resource Identifier ( URI ) . URIs are similar to URLs. \nIn fact, URLs constitute a subset of URIs. A URI represents a standard way to identify a \nresource. A URL also describes how to access the resource. \n\nCookies",
    "Cookies \n\nThe java.net package includes classes and interfaces that help manage cookies and can be \nused to create a stateful ( as opposed to stateless ) HTTP session. The classes are \nCookieHandler, CookieManager, and HttpCookie. The interfaces are CookiePolicy \nand CookieStore. The creation of a stateful HTTP session is beyond the scope of this book. \n\nNOTE For information about using cookies with servlets, see Chapter 38. \n\nTCP/IP Server Sockets \n\nAs mentioned earlier, Java has a different socket class that must be used for creating server \n\n\napplications. The ServerSocket class is used to create servers that listen for either local or",
    "applications. The ServerSocket class is used to create servers that listen for either local or \n\nremote client programs to connect to them on published ports. ServerSocket s are quite \ndifferent from normal Socket s. When you create a ServerSocket, it will register itself \nwith the system as having an interest in client connections. The constructors for \nServerSocket reflect the port number that you want to accept connections on and, \noptionally, how long you want the queue for said port to be. The queue length tells the \nsystem how many client connections it can leave pending before it should simply refuse \nconnections. The default is 50. The constructors might throw an IOException under \nadverse conditions. Here are three of its constructors: \n\nServerSocket ( int port ) \nthrows IOException \nCreates server socket on the specified port with a queue \nlength of 50. \n\nServerSocket ( int port , int \nmaxQueue ) throws \nIOException",
    "ServerSocket ( int port ) \nthrows IOException \nCreates server socket on the specified port with a queue \nlength of 50. \n\nServerSocket ( int port , int \nmaxQueue ) throws \nIOException \n\nCreates a server socket on the specified port with a \nmaximum queue length of maxQueue . \n\nServerSocket ( int port , int \nmaxQueue , InetAddress \nlocalAddress ) throws \nIOException \n\nCreates a server socket on the specified port with a \nmaximum queue length of maxQueue . On a multihomed \nhost, localAddress specifies the IP address to which this \nsocket binds. \n\nServerSocket has a method called accept ( ), which is a blocking call that will wait for a \nclient to initiate communications and then return with a normal Socket that is then used \nfor communication with the client. \n\nDatagrams",
    "Datagrams \n\nTCP/IP-style networking is appropriate for most networking needs. It provides a serialized, \npredictable, reliable stream of packet data. This is not without its cost, however. TCP \nincludes many complicated algorithms for dealing with congestion control on crowded \nnetworks, as well as pessimistic expectations about packet loss. This leads to a somewhat \ninefficient way to transport data. Datagrams provide an alternative. \nDatagrams are bundles of information passed between machines. They are somewhat like a \nhard throw from a well-trained but blindfolded catcher to the third baseman. Once the \ndatagram has been released to its intended target, there is no assurance that it will arrive or \neven that someone will be there to catch it. Likewise, when the datagram is received, there is \nno assurance that it hasn\u2019t been damaged in transit or that whoever sent it is still there to \nreceive a response.",
    "Java implements datagrams on top of the UDP protocol by using two classes: the \nDatagramPacket object is the data container, while the DatagramSocket is the \nmechanism used to send or receive the DatagramPacket s. Each is examined here. \n\n\nDatagramSocket \n\nDatagramSocket defines four public constructors. They are shown here: \n\nDatagramSocket ( ) throws SocketException \n\nDatagramSocket ( int port ) throws SocketException \n\nDatagramSocket ( int port , InetAddress ipAddress ) throws SocketException \n\nDatagramSocket ( SocketAddress address ) throws SocketException",
    "DatagramSocket ( int port ) throws SocketException \n\nDatagramSocket ( int port , InetAddress ipAddress ) throws SocketException \n\nDatagramSocket ( SocketAddress address ) throws SocketException \n\nThe first creates a DatagramSocket bound to any unused port on the local \ncomputer. The second creates a DatagramSocket bound to the port specified by \nport . The third constructs a DatagramSocket bound to the specified port and \nInetAddress . The fourth constructs a DatagramSocket bound to the specified \nSocketAddress . SocketAddress is an abstract class that is implemented by the \nconcrete class InetSocketAddress . InetSocketAddress encapsulates an IP \naddress with a port number. All can throw a SocketException if an error occurs \nwhile creating the socket. \nDatagramSocket defines many methods. Two of the most important are send ( ) and \nreceive ( ) , which are shown here: \n\nvoid send ( DatagramPacket packet ) throws IOException \n\nvoid receive ( DatagramPacket packet ) throws IOException",
    "void send ( DatagramPacket packet ) throws IOException \n\nvoid receive ( DatagramPacket packet ) throws IOException \n\nThe send ( ) method sends a packet to the port specified by packet . The receive ( \n) method waits for a packet to be received and returns the result. \nDatagramSocket also defines the close ( ) method, which closes the socket. Beginning \nwith JDK 7, DatagramSocket implements AutoCloseable , which means that a \nDatagramSocket can be managed by a try -with-resources block. \nOther methods give you access to various attributes associated with a DatagramSocket . \nHere is a sampling: \n\nInetAddress \ngetInetAddress ( ) \nIf the socket is connected, then the address is returned. \nOtherwise, null is returned. \n\nint getLocalPort ( ) \nReturns the number of the local port. \n\nint getPort ( ) \nReturns the number of the port to which the socket is \nconnected. It returns \u20131 if the socket is not connected to a \nport.",
    "int getPort ( ) \nReturns the number of the port to which the socket is \nconnected. It returns \u20131 if the socket is not connected to a \nport. \n\nboolean isBound ( ) \nReturns true if the socket is bound to an address. Returns \n\nfalse otherwise. \n\nboolean isConnected ( ) \nReturns true if the socket is connected to a server. \nReturns false otherwise. \n\n\nvoid setSoTimeout ( int \nmillis ) throws \nSocketException \n\nSets the time-out period to the number of milliseconds \npassed in millis . \n\nDatagramPacket \n\nDatagramPacket defines several constructors. Four are shown here: \n\nDatagramPacket ( byte data [ ], int size ) \nDatagramPacket ( byte data [ ], int offset , int size ) \nDatagramPacket ( byte data [ ], int size , InetAddress ipAddress , int port ) \nDatagramPacket ( byte data [ ], int offset , int size , InetAddress ipAddress , int port )",
    "The first constructor specifies a buffer that will receive data and the size of a \npacket. It is used for receiving data over a DatagramSocket. The second form \nallows you to specify an offset into the buffer at which data will be stored. The \nthird form specifies a target address and port, which are used by a \nDatagramSocket to determine where the data in the packet will be sent. The \nfourth form transmits packets beginning at the specified offset into the data. Think \nof the first two forms as building an \"in box,\" and the second two forms as stuffing \nand addressing an envelope. \nDatagramPacket defines several methods, including those shown here, that give access to \nthe address and port number of a packet, as well as the raw data and its length. \n\nInetAddress \ngetAddress ( ) \nReturns the address of the source ( for datagrams being \nreceived ) or destination ( for datagrams being sent ).",
    "InetAddress \ngetAddress ( ) \nReturns the address of the source ( for datagrams being \nreceived ) or destination ( for datagrams being sent ). \n\nbyte[ ] getData ( ) \nReturns the byte array of data contained in the datagram. \nMostly used to retrieve data from the datagram after it has \nbeen received. \n\nint getLength ( ) \nReturns the length of the valid data contained in the byte \narray that would be returned from the getData ( ) method. \nThis may not equal the length of the whole byte array. \n\nint getOffset ( ) \nReturns the starting index of the data. \n\nint getPort ( ) \nReturns the port number. \n\nvoid \nsetAddress ( InetAddress \nipAddress ) \n\nSets the address to which a packet will be sent. The address \nis specified by ipAddress . \n\nvoid setData ( byte[ ] \ndata ) \nSets the data to data , the offset to zero, and the length to \nnumber of bytes in data . \n\nvoid setData ( byte[ ] \n\ndata , int idx , int size ) \nSets the data to data , the offset to idx , and the length to size .",
    "void setData ( byte[ ] \n\ndata , int idx , int size ) \nSets the data to data , the offset to idx , and the length to size . \n\n\nvoid setLength ( int size ) \nSets the length of the packet to size . \n\nvoid setPort ( int port ) \nSets the port to port . \n\nA Datagram Example \n\nThe following example implements a very simple networked communications client and \nserver. Messages are typed into the window at the server and written across the network to \nthe client side, where they are displayed. \n\n\nThis sample program is restricted by the DatagramSocket constructor to running between \ntwo ports on the local machine. To use the program, run \n\nin one window ; this will be the client. Then run \n\nThis will be the server. Anything that is typed in the server window will be sent to the client \nwindow after a newline is received. \n\nNOTE The use of datagrams may not be allowed on your computer. ( For \nexample, a firewall may prevent their use.) If this is the case, the",
    "NOTE The use of datagrams may not be allowed on your computer. ( For \nexample, a firewall may prevent their use.) If this is the case, the \n\n\npreceding example cannot be used. Also, the port numbers used in the \nprogram work on the author's system, but may have to be adjusted for \nyour environment. \n\n\uf709 \nPREV \nChapter 21: Exploring NIO \n\u23ee \n\nNEXT \nChapter 23: The Applet Class \u23ed \n\n\nPREV \nChapter 22: Networking \n\u23ee \n\nNEXT \nChapter 24: Event Handling \u23ed \n\nCHAPTER \n\n23 \nThe Applet Class \n\nThis chapter examines the Applet class, which provides the foundation for applets. The \nApplet class is contained in the java.applet package. Applet contains several methods \nthat give you detailed control over the execution of your applet. In addition, java.applet \nalso defines three interfaces: AppletContext , AudioClip , and AppletStub . \n\nTwo Types of Applets",
    "It is important to state at the outset that there are two varieties of applets based on Applet . \nThe first are those based directly on the Applet class described in this chapter. These \napplets use the Abstract Window Toolkit ( AWT ) to provide the graphical user interface ( or \nuse no GUI at all ). This style of applet has been available since Java was first created. \nThe second type of applets are those based on the Swing class JApplet , which inherits \nApplet . Swing applets use the Swing classes to provide the GUI. Swing offers a richer and \noften easier-to-use user interface than does the AWT. Thus, Swing-based applets are now \nthe most popular. However, traditional AWT-based applets are still used, especially when \nonly a very simple user interface is required. Thus, both AWT- and Swing-based applets are \nvalid. \nThis chapter describes AWT-based applets",
    ". Thus, both AWT- and Swing-based applets are \nvalid. \nThis chapter describes AWT-based applets. However, because JApplet inherits Applet , all \nthe features of Applet are also available in JApplet , and much of the information in this \nchapter applies to both types of applets. Therefore, even if you are interested in only Swing \napplets, the information in this chapter is still relevant and necessary. Understand, however, \nthat when creating Swing-based applets, some additional constraints apply and these are \ndescribed later in this book, when Swing is covered.",
    "NOTE For information on building applets when using Swing, see \nChapter 31. \n\n\nApplet Basics",
    "Chapter 13 introduced the general form of an applet and the steps necessary to compile and \nrun one. Let\u2019s begin by reviewing this information. \nAWT-based applets are subclasses of Applet . Applets are not stand-alone programs. \nInstead, they run within either a web browser or an applet viewer. The illustrations shown \nin this chapter were created with the standard applet viewer, called appletviewer , \nprovided by the JDK. \nExecution of an applet does not begin at main ( ) . Actually, few applets even have main ( ) \nmethods. Instead, execution of an applet is started and controlled with an entirely different \nmechanism, which will be explained shortly. Output to your applet\u2019s window is not \nperformed by System.out.println ( ) . Rather, in an AWT-based applet, output is handled \nwith various AWT methods, such as drawString ( ) , which outputs a string to a specified \nX,Y location. Input is also handled differently than in a console application",
    ". Input is also handled differently than in a console application. \nBefore an applet can be used, a deployment strategy must be chosen. There are two basic \napproaches. The first is to use the Java Network Launch Protocol ( JNLP ). This approach \noffers the most flexibility, especially as it relates to rich Internet applications. For real-world \napplets that you create, JNLP will often be the best choice. However, a detailed discussion of \nJNLP is beyond the scope of this book. ( See the JDK documentation for the latest details on \nJNLP.) Fortunately, JNLP is not required for the example applets shown here. \nThe second basic approach to deploying an applet is to specify the applet directly in an \nHTML file, without the use of JNLP. This is the original way that applets were launched \nwhen Java was created, and it is still used today\u2014especially for simple applets",
    ". This is the original way that applets were launched \nwhen Java was created, and it is still used today\u2014especially for simple applets. \nFurthermore, because of its inherent simplicity, it is the appropriate method for the applet \nexamples described in this book. At the time of this writing, Oracle recommends the \nAPPLET tag for this purpose. Therefore, the APPLET tag is used in this book. ( Be aware \nthat the APPLET tag is currently deprecated by the HTML specification. The alternative is \nthe OBJECT tag. You should check the JDK documentation in this regard for the latest \nrecommendations.) When an APPLET tag is encountered in the HTML file, the specified \napplet will be executed by a Java-enabled web browser. \nThe use of the APPLET tag offers a secondary advantage when developing applets because it \nenables you to easily view and test the applet. To do so, simply include a comment at the \nhead of your Java source code file that contains the APPLET tag",
    ". To do so, simply include a comment at the \nhead of your Java source code file that contains the APPLET tag. This way, your code is \ndocumented with the necessary HTML statements needed by your applet, and you can test \nthe compiled applet by starting the applet viewer with your Java source code file specified as \nthe target. Here is an example of such a comment:",
    "This comment contains an APPLET tag that will run an applet called MyApplet in a \nwindow that is 200 pixels wide and 60 pixels high. Because the inclusion of an APPLET \ncommand makes testing applets easier, all of the applets shown in this book will contain the \nappropriate APPLET tag embedded in a comment.",
    "NOTE As noted in Chapter 13, beginning with the release of Java 7, \nupdate 21, Java applets must be signed to prevent security warnings when \nrun in a browser. In fact, in some cases, the applet may be prevented \nfrom running. Applets stored in the local file system, such as you would \ncreate when compiling the examples in this book, are especially sensitive \nto this change. You may need to adjust the security settings in the Java \nControl Panel to run a local applet in a browser. At the time of this \nwriting, Oracle recommends against the use of local applets, \nrecommending instead that applets be executed through a web server. \nFurthermore, unsigned local applets may be blocked from execution in \nthe future. In general, for applets that will be distributed via the Internet, \nsuch as commercial applications, signing is a virtual necessity. The \nconcepts and techniques required to sign applets ( and other types of Java \nprograms ) are beyond the scope of this book",
    ". The \nconcepts and techniques required to sign applets ( and other types of Java \nprograms ) are beyond the scope of this book. However, extensive \ninformation is found on Oracle\u2019s website. Finally, as mentioned, the \neasiest way to try the applet examples is to use appletviewer .",
    "The Applet Class \n\nThe Applet class defines the methods shown in Table 23-1. Applet provides all necessary \n\nsupport for applet execution, such as starting and stopping. It also provides methods that \nload and display images, and methods that load and play audio clips. Applet extends the \nAWT class Panel . In turn, Panel extends Container , which extends Component . These \nclasses provide support for Java\u2019s window-based, graphical interface. Thus, Applet provides \nall of the necessary support for window-based activities. ( An overview of the AWT is \n\npresented in subsequent chapters.) \n\n\n\n\nTable 23-1    The Methods Defined by Applet \n\nApplet Architecture \n\nAs a general rule, an applet is a GUI-based program. As such, its architecture is different",
    "Table 23-1    The Methods Defined by Applet \n\nApplet Architecture \n\nAs a general rule, an applet is a GUI-based program. As such, its architecture is different \n\nfrom the console-based programs shown in the first part of this book. If you are already \nfamiliar with GUI programming, you will be right at home writing applets. If not, then there \nare a few key concepts you must understand. \n\nFirst, applets are event driven. Although we won\u2019t examine event handling until the \nfollowing chapter, it is important to understand in a general way how the event-driven \narchitecture impacts the design of an applet. An applet resembles a set of interrupt service \nroutines. Here is how the process works. An applet waits until an event occurs. The runtime system notifies the applet about an event by calling an event handler that has been \n\n\nprovided by the applet. Once this happens, the applet must take appropriate action and then",
    "quickly return. This is a crucial point. For the most part, your applet should not enter a \n\"mode\" of operation in which it maintains control for an extended period. Instead, it must \nperform specific actions in response to events and then return control to the run-time \nsystem. In those situations in which your applet needs to perform a repetitive task on its \nown ( for example, displaying a scrolling message across its window ), you must start an \nadditional thread of execution. ( You will see an example later in this chapter.) \nSecond, the user initiates interaction with an applet\u2014not the other way around. As you \nknow, in a console-based program, when the program needs input, it will prompt the user \nand then call some input method, such as readLine ( ) . This is not the way it works in an \napplet. Instead, the user interacts with the applet as he or she wants, when he or she wants. \nThese interactions are sent to the applet as events to which the applet must respond",
    ". Instead, the user interacts with the applet as he or she wants, when he or she wants. \nThese interactions are sent to the applet as events to which the applet must respond. For \nexample, when the user clicks the mouse inside the applet\u2019s window, a mouse-clicked event \nis generated. If the user presses a key while the applet\u2019s window has input focus, a keypress \nevent is generated. As you will see in later chapters, applets can contain various controls, \nsuch as push buttons and check boxes. When the user interacts with one of these controls, \nan event is generated. \nWhile the architecture of an applet is not as easy to understand as that of a console-based \nprogram, Java makes it as simple as possible. If you have written programs for Windows ( or \nother GUI-based operating systems ), you know how intimidating that environment can be. \nFortunately, Java provides a much cleaner approach that is more quickly mastered.",
    "An Applet Skeleton \n\nAll but the most trivial applets override a set of methods that provides the basic mechanism \nby which the browser or applet viewer interfaces to the applet and controls its execution. \nFour of these methods, init ( ) , start ( ) , stop ( ) , and destroy ( ) , apply to all applets and \nare defined by Applet . Default implementations for all of these methods are provided. \nApplets do not need to override those methods they do not use. However, only very simple \napplets will not need to define all of them. \nAWT-based applets ( such as those discussed in this chapter ) will also often override the \npaint ( ) method, which is defined by the AWT Component class. This method is called \nwhen the applet\u2019s output must be redisplayed. ( Swing-based applets use a different \nmechanism to accomplish this task.) These five methods can be assembled into the skeleton \nshown here:",
    "Although this skeleton does not do anything, it can be compiled and run. When run, it \ngenerates the following empty window when viewed with appletviewer . Of course, in this \nand all subsequent examples, the precise look of the appletviewer frame may differ based \n\non your execution environment. To help illustrate this fact, a variety of environments were \nused to generate the screen captures shown throughout this book. \n\n\nApplet Initialization and Termination \n\nIt is important to understand the order in which the various methods shown in the skeleton \nare called. When an applet begins, the following methods are called, in this sequence: \n\n1.   init ( ) \n\n2.   start ( ) \n\n3.   paint ( ) \n\nWhen an applet is terminated, the following sequence of method calls takes place: \n\n1.   stop ( ) \n\n2.   destroy ( ) \n\nLet\u2019s look more closely at these methods.",
    "2.   start ( ) \n\n3.   paint ( ) \n\nWhen an applet is terminated, the following sequence of method calls takes place: \n\n1.   stop ( ) \n\n2.   destroy ( ) \n\nLet\u2019s look more closely at these methods. \n\ninit ( ) \nThe init ( ) method is the first method to be called. This is where you should initialize \nvariables. This method is called only once during the run time of your applet. \n\nstart ( ) \n\nThe start ( ) method is called after init ( ) . It is also called to restart an applet after it has \nbeen stopped. Whereas init ( ) is called once\u2014the first time an applet is loaded\u2014 start ( ) is \ncalled each time an applet\u2019s HTML document is displayed onscreen. So, if a user leaves a \nweb page and comes back, the applet resumes execution at start ( ) .",
    "paint ( ) \nThe paint ( ) method is called each time an AWT-based applet\u2019s output must be redrawn. \nThis situation can occur for several reasons. For example, the window in which the applet is \nrunning may be overwritten by another window and then uncovered. Or the applet window \nmay be minimized and then restored. paint ( ) is also called when the applet begins \nexecution. Whatever the cause, whenever the applet must redraw its output, paint ( ) is \n\ncalled. The paint ( ) method has one parameter of type Graphics . This parameter will \ncontain the graphics context, which describes the graphics environment in which the applet \nis running. This context is used whenever output to the applet is required.",
    "stop ( ) \nThe stop ( ) method is called when a web browser leaves the HTML document containing \nthe applet\u2014when it goes to another page, for example. When stop ( ) is called, the applet is \nprobably running. You should use stop ( ) to suspend threads that don\u2019t need to run when \nthe applet is not visible. You can restart them when start ( ) is called if the user returns to \nthe page. \n\ndestroy ( ) \nThe destroy ( ) method is called when the environment determines that your applet needs \nto be removed completely from memory. At this point, you should free up any resources the \napplet may be using. The stop ( ) method is always called before destroy ( ) . \n\nOverriding update ( )",
    "Overriding update ( ) \n\nIn some situations, an AWT-based applet may need to override another method defined by \nthe AWT, called update ( ) . This method is called when your applet has requested that a \nportion of its window be redrawn. The default version of update ( ) simply calls paint ( ) . \nHowever, you can override the update ( ) method so that it performs more subtle \nrepainting. In general, overriding update ( ) is a specialized technique that is not applicable \nto all applets, and the examples in this chapter do not override update ( ) . \n\nSimple Applet Display Methods",
    "Simple Applet Display Methods \n\nAs we\u2019ve mentioned, applets are displayed in a window, and AWT-based applets use the \nAWT to perform input and output. Although we will examine the methods, procedures, and \ntechniques related to the AWT in subsequent chapters, a few are described here, because we \nwill use them to write sample applets. ( Remember, Swing-based applets are described later \nin this book.) \nAs described in Chapter 13, to output a string to an applet, use drawString ( ) , which is a \nmember of the Graphics class. Typically, it is called from within either update ( ) or \npaint ( ) . It has the following general form: \n\nvoid drawString ( String message , int x , int y ) \n\nHere, message is the string to be output beginning at x,y . In a Java window, the \nupper-left corner is location 0,0. The drawString ( ) method will not recognize \nnewline characters. If you want to start a line of text on another line, you must do",
    "so manually, specifying the precise X,Y location where you want the line to begin. \n( As you will see in later chapters, there are techniques that make this process \neasy.) \nTo set the background color of an applet\u2019s window, use setBackground ( ) . To set the \nforeground color ( the color in which text is shown, for example ), use setForeground ( ) . \nThese methods are defined by Component , and they have the following general forms: \n\nvoid setBackground ( Color newColor ) \n\n\nvoid setForeground ( Color newColor ) \n\nHere, newColor specifies the new color. The class Color defines the constants \nshown here that can be used to specify colors: \n\nColor.black \nColor.magenta \n\nColor.blue \nColor.orange \n\nColor.cyan \nColor.pink \n\nColor.darkGray \nColor.red \n\nColor.gray \nColor.white \n\nColor.green \nColor.yellow \n\nColor.lightGray \n\nUppercase versions of the constants are also defined. \nThe following example sets the background color to green and the text color to red:",
    "Color.green \nColor.yellow \n\nColor.lightGray \n\nUppercase versions of the constants are also defined. \nThe following example sets the background color to green and the text color to red: \n\nA good place to set the foreground and background colors is in the init ( ) method. Of \ncourse, you can change these colors as often as necessary during the execution of your \napplet. \nYou can obtain the current settings for the background and foreground colors by calling \ngetBackground ( ) and getForeground ( ) , respectively. They are also defined by \nComponent and are shown here: \n\nColor getBackground ( ) \nColor getForeground ( ) \n\nHere is a very simple applet that sets the background color to cyan, the foreground \n\ncolor to red, and displays a message that illustrates the order in which the init ( ) , \nstart ( ) , and paint ( ) methods are called when an applet starts up: \n\n\nSample output is shown here:",
    "Sample output is shown here: \n\nThe methods stop ( ) and destroy ( ) are not overridden, because they are not needed by \nthis simple applet. \n\nRequesting Repainting \n\nAs a general rule, an applet writes to its window only when its paint ( ) method is called by \n\nthe AWT. This raises an interesting question: How can the applet itself cause its window to",
    "be updated when its information changes? For example, if an applet is displaying a moving \nbanner, what mechanism does the applet use to update the window each time this banner \nscrolls? Remember, one of the fundamental architectural constraints imposed on an applet \nis that it must quickly return control to the run-time system. It cannot create a loop inside \npaint ( ) that repeatedly scrolls the banner, for example. This would prevent control from \npassing back to the AWT. Given this constraint, it may seem that output to your applet\u2019s \nwindow will be difficult at best. Fortunately, this is not the case. Whenever your applet \nneeds to update the information displayed in its window, it simply calls repaint ( ) . \nThe repaint ( ) method is defined by the AWT. It causes the AWT run-time system to \nexecute a call to your applet\u2019s update ( ) method, which, in its default implementation, calls \npaint ( )",
    ". \nThe repaint ( ) method is defined by the AWT. It causes the AWT run-time system to \nexecute a call to your applet\u2019s update ( ) method, which, in its default implementation, calls \npaint ( ) . Thus, for another part of your applet to output to its window, simply store the \noutput and then call repaint ( ) . The AWT will then execute a call to paint ( ) , which can \ndisplay the stored information. For example, if part of your applet needs to output a string, \nit can store this string in a String variable and then call repaint ( ) . Inside paint ( ) , you \nwill output the string using drawString ( ) . \nThe repaint ( ) method has four forms. Let\u2019s look at each one, in turn. The simplest version \nof repaint ( ) is shown here:",
    "void repaint ( ) \n\nThis version causes the entire window to be repainted. The following version \nspecifies a region that will be repainted: \n\nvoid repaint ( int left , int top , int width , int height )",
    "void repaint ( int left , int top , int width , int height ) \n\nHere, the coordinates of the upper-left corner of the region are specified by left and \ntop , and the width and height of the region are passed in width and height . These \ndimensions are specified in pixels. You save time by specifying a region to repaint. \nWindow updates are costly in terms of time. If you need to update only a small \nportion of the window, it is more efficient to repaint only that region. \nCalling repaint ( ) is essentially a request that your applet be repainted sometime soon. \nHowever, if your system is slow or busy, update ( ) might not be called immediately. \nMultiple requests for repainting that occur within a short time can be collapsed by the AWT \nin a manner such that update ( ) is only called sporadically. This can be a problem in many \nsituations, including animation, in which a consistent update time is necessary. One \nsolution to this problem is to use the following forms of repaint ( ) :",
    "void repaint ( long maxDelay ) \nvoid repaint ( long maxDelay , int x , int y , int width , int height ) \n\nHere, maxDelay specifies the maximum number of milliseconds that can elapse \n\nbefore update ( ) is called. Beware, though. If the time elapses before update ( ) \ncan be called, it isn\u2019t called. There\u2019s no return value or exception thrown, so you \nmust be careful. \n\n\nNOTE It is possible for a method other than paint ( ) or update ( ) to \noutput to an applet\u2019s window. To do so, it must obtain a graphics context \nby calling getGraphics ( ) ( defined by Component ) and then use this \ncontext to output to the window. However, for most applications, it is \nbetter and easier to route window output through paint ( ) and to call \nrepaint ( ) when the contents of the window change. \n\nA Simple Banner Applet",
    "A Simple Banner Applet \n\nTo demonstrate repaint ( ) , a simple banner applet is developed. This applet scrolls a \nmessage, from right to left, across the applet\u2019s window. Since the scrolling of the message is \na repetitive task, it is performed by a separate thread, created by the applet when it is \ninitialized. The banner applet is shown here: \n\n\nFollowing is sample output:",
    "Let\u2019s take a close look at how this applet operates. First, notice that SimpleBanner \nextends Applet , as expected, but it also implements Runnable . This is necessary, since the \napplet will be creating a second thread of execution that will be used to scroll the banner. \nInside init ( ) , the foreground and background colors of the applet are set. \nAfter initialization, the run-time system calls start ( ) to start the applet running. Inside \nstart ( ) , a new thread of execution is created and assigned to the Thread variable t . Then, \nthe boolean variable stopFlag , which controls the execution of the applet, is set to false . \nNext, the thread is started by a call to t.start ( ) . Remember that t.start ( ) calls a method \ndefined by Thread , which causes run ( ) to begin executing. It does not cause a call to the \nversion of start ( ) defined by Applet . These are two separate methods. \nInside run ( ) , a call to repaint ( ) is made",
    ". It does not cause a call to the \nversion of start ( ) defined by Applet . These are two separate methods. \nInside run ( ) , a call to repaint ( ) is made. This eventually causes the paint ( ) method to \nbe called, and the rotated contents of msg are displayed. Between each iteration, run ( ) \nsleeps for a quarter of a second. The net effect is that the contents of msg are scrolled right \nto left in a constantly moving display. The stopFlag variable is checked on each iteration. \nWhen it is true , the run ( ) method terminates. \nIf a browser is displaying the applet when a new page is viewed, the stop ( ) method is \ncalled, which sets stopFlag to true , causing run ( ) to terminate. This is the mechanism \nused to stop the thread when its page is no longer in view. When the applet is brought back \ninto view, start ( ) is once again called, which starts a new thread to execute the banner.",
    "Using the Status Window \n\nIn addition to displaying information in its window, an applet can also output a message to \nthe status window of the browser or applet viewer on which it is running. To do so, call \nshowStatus ( ) with the string that you want displayed. The status window is a good place \nto give the user feedback about what is occurring in the applet, suggest options, or possibly \nreport some types of errors. The status window also makes an excellent debugging aid, \nbecause it gives you an easy way to output information about your applet. \nThe following applet demonstrates showStatus ( ) : \n\n\nSample output from this program is shown here: \n\nThe HTML APPLET Tag",
    "Sample output from this program is shown here: \n\nThe HTML APPLET Tag \n\nAs mentioned earlier, at the time of this writing, Oracle recommends that the APPLET tag \nbe used to manually start an applet when JNLP is not used. An applet viewer will execute \neach APPLET tag that it finds in a separate window, while web browsers will allow many \napplets on a single page. So far, we have been using only a simplified form of the APPLET \ntag. Now it is time to take a closer look at it. \nThe syntax for a fuller form of the APPLET tag is shown here. Bracketed items are optional. \n\n\nLet\u2019s take a look at each part now. \n\nCODEBASE    CODEBASE is an optional attribute that specifies the base URL of \nthe applet code, which is the directory that will be searched for the applet\u2019s \nexecutable class file ( specified by the CODE tag ). The HTML document\u2019s URL \ndirectory is used as the CODEBASE if this attribute is not specified.",
    "CODE    CODE is a required attribute that gives the name of the file containing \nyour applet\u2019s compiled .class file. This file is relative to the code base URL of the \napplet, which is the directory that the HTML file was in or the directory indicated \nby CODEBASE if set. \n\nALT    The ALT tag is an optional attribute used to specify a short text message that \n\nshould be displayed if the browser recognizes the APPLET tag but can\u2019t currently \nrun Java applets. This is distinct from the alternate HTML you provide for \nbrowsers that don\u2019t support applets. \n\nNAME    NAME is an optional attribute used to specify a name for the applet \ninstance. Applets must be named in order for other applets on the same page to \nfind them by name and communicate with them. To obtain an applet by name, use \ngetApplet ( ) , which is defined by the AppletContext interface. \n\nWIDTH and HEIGHT    WIDTH and HEIGHT are required attributes that give \nthe size ( in pixels ) of the applet display area.",
    "WIDTH and HEIGHT    WIDTH and HEIGHT are required attributes that give \nthe size ( in pixels ) of the applet display area. \n\nALIGN    ALIGN is an optional attribute that specifies the alignment of the applet. \nThis attribute is treated the same as the HTML IMG tag with these possible values: \nLEFT, RIGHT, TOP, BOTTOM, MIDDLE, BASELINE, TEXTTOP, ABSMIDDLE, \n\n\nand ABSBOTTOM. \n\nVSPACE and HSPACE    These attributes are optional. VSPACE specifies the \nspace, in pixels, above and below the applet. HSPACE specifies the space, in pixels, \non each side of the applet. They\u2019re treated the same as the IMG tag\u2019s VSPACE and \nHSPACE attributes. \n\nPARAM NAME and VALUE    The PARAM tag allows you to specify appletspecific arguments. Applets access their attributes with the getParameter ( ) \nmethod.",
    "PARAM NAME and VALUE    The PARAM tag allows you to specify appletspecific arguments. Applets access their attributes with the getParameter ( ) \nmethod. \n\nOther valid APPLET attributes include ARCHIVE, which lets you specify one or \nmore archive files, and OBJECT, which specifies a saved version of the applet. In \ngeneral, an APPLET tag should include only a CODE or an OBJECT attribute, but \nnot both. \n\nPassing Parameters to Applets \n\nAs just discussed, the APPLET tag allows you to pass parameters to your applet. To retrieve \na parameter, use the getParameter ( ) method. It returns the value of the specified \nparameter in the form of a String object. Thus, for numeric and boolean values, you will \nneed to convert their string representations into their internal formats. Here is an example \nthat demonstrates passing parameters: \n\n\nSample output from this program is shown here:",
    "Sample output from this program is shown here: \n\n\nAs the program shows, you should test the return values from getParameter ( ) . If a \nparameter isn\u2019t available, getParameter ( ) will return null . Also, conversions to numeric \ntypes must be attempted in a try statement that catches NumberFormatException . \nUncaught exceptions should never occur within an applet. \n\nImproving the Banner Applet \n\nIt is possible to use a parameter to enhance the banner applet shown earlier. In the previous \nversion, the message being scrolled was hard-coded into the applet. However, passing the \nmessage as a parameter allows the banner applet to display a different message each time it \nis executed. This improved version is shown here. Notice that the APPLET tag at the top of \nthe file now specifies a parameter called message that is linked to a quoted string. \n\n\n\n\ngetDocumentBase ( ) and getCodeBase ( )",
    "getDocumentBase ( ) and getCodeBase ( ) \n\nOften, you will create applets that will need to explicitly load media and text. Java will allow \nthe applet to load data from the directory holding the HTML file that started the applet ( the \ndocument base ) and the directory from which the applet\u2019s class file was loaded ( the code \nbase ). These directories are returned as URL objects ( described in Chapter 22 ) by \ngetDocumentBase ( ) and getCodeBase ( ) . They can be concatenated with a string that \nnames the file you want to load. To actually load another file, you will use the \nshowDocument ( ) method defined by the AppletContext interface, discussed in the \nnext section. \nThe following applet illustrates these methods: \n\n\nSample output from this program is shown here: \n\nAppletContext and showDocument ( )",
    "Sample output from this program is shown here: \n\nAppletContext and showDocument ( ) \n\nOne application of Java is to use active images and animation to provide a graphical means \nof navigating the Web that is more interesting than simple text-based links. To allow your \napplet to transfer control to another URL, you must use the showDocument ( ) method \n\ndefined by the AppletContext interface. AppletContext is an interface that lets you get \ninformation from the applet\u2019s execution environment. The methods defined by \nAppletContext are shown in Table 23-2. The context of the currently executing applet is \nobtained by a call to the getAppletContext ( ) method defined by Applet . \n\n\nTable 23-2    The Methods Defined by the AppletContext Interface",
    "Within an applet, once you have obtained the applet\u2019s context, you can bring another \ndocument into view by calling showDocument ( ) . This method has no return value and \nthrows no exception if it fails, so use it carefully. There are two showDocument ( ) \nmethods. The method showDocument ( URL ) displays the document at the specified \nURL . The method showDocument ( URL, String ) displays the specified document at the \nspecified location within the browser window. Valid arguments for where are \"_self\" ( show \nin current frame ), \"_parent\" ( show in parent frame ), \"_top\" ( show in topmost frame ), and \n\"_blank\" ( show in new browser window ). You can also specify a name, which causes the \ndocument to be shown in a new browser window by that name. \nThe following applet demonstrates AppletContext and showDocument ( ) . Upon \nexecution, it obtains the current applet context and uses that context to transfer control to a \nfile called Test.html",
    ". \nThe following applet demonstrates AppletContext and showDocument ( ) . Upon \nexecution, it obtains the current applet context and uses that context to transfer control to a \nfile called Test.html . This file must be in the same directory as the applet. Test.html can \ncontain any valid hypertext that you like.",
    "The AudioClip Interface \n\nThe AudioClip interface defines these methods: play ( ) ( play a clip from the beginning ), \nstop ( ) ( stop playing the clip ), and loop ( ) ( play the loop continuously ). After you have \nloaded an audio clip using getAudioClip ( ) , you can use these methods to play it. \n\nThe AppletStub Interface \n\nThe AppletStub interface provides the means by which an applet and the browser ( or \napplet viewer ) communicate. Your code will not typically implement this interface. \n\nOutputting to the Console \n\nAlthough output to an applet\u2019s window must be accomplished through GUI-based methods, \nsuch as drawString ( ) , it is still possible to use console output in your applet\u2014especially \nfor debugging purposes. In an applet, when you call a method such as \nSystem.out.println ( ) , the output is not sent to your applet\u2019s window. Instead, it appears \neither in the console session in which you launched the applet viewer or in the Java console",
    "that is available in some browsers. Use of console output for purposes other than debugging \nis discouraged, since it violates the design principles of the graphical interface most users \nwill expect. \n\n\n\uf709 \nPREV \nChapter 22: Networking \n\u23ee \n\nNEXT \nChapter 24: Event Handling \u23ed \n\n\nPREV \nChapter 23: The Applet Class \n\u23ee \n\nNEXT \nChapter 25: Introducing the AWT: Working with \u2026 \u23ed \n\nCHAPTER \n\n24 \nEvent Handling",
    "This chapter examines an important aspect of Java: the event. Event handling is \nfundamental to Java programming because it is integral to the creation of many kinds of \napplications, including applets and other types of GUI-based programs. As explained in \nChapter 23, applets are event-driven programs that use a graphical user interface to interact \nwith the user. Furthermore, any program that uses a graphical user interface, such as a Java \napplication written for Windows, is event driven. Thus, you cannot write these types of \nprograms without a solid command of event handling. Events are supported by a number of \npackages, including java.util , java.awt , and java.awt.event . \nMost events to which your program will respond are generated when the user interacts with \na GUI-based program. These are the types of events examined in this chapter. They are \npassed to your program in a variety of ways, with the specific method dependent upon the \nactual event",
    ". These are the types of events examined in this chapter. They are \npassed to your program in a variety of ways, with the specific method dependent upon the \nactual event. There are several types of events, including those generated by the mouse, the \nkeyboard, and various GUI controls, such as a push button, scroll bar, or check box. \nThis chapter begins with an overview of Java\u2019s event handling mechanism. It then examines \nthe main event classes and interfaces used by the AWT and develops several examples that \ndemonstrate the fundamentals of event processing. This chapter also explains how to use \nadapter classes, inner classes, and anonymous inner classes to streamline event handling \ncode. The examples provided in the remainder of this book make frequent use of these \ntechniques.",
    "NOTE This chapter focuses on events related to GUI-based programs. \nHowever, events are also occasionally used for purposes not directly \n\nrelated to GUI-based programs. In all cases, the same basic event \nhandling techniques apply. \n\nTwo Event Handling Mechanisms \n\n\nBefore beginning our discussion of event handling, an important historical point must be \nmade: The way in which events are handled changed significantly between the original \nversion of Java ( 1.0 ) and all subsequent versions of Java, beginning with version 1.1. \nAlthough the 1.0 method of event handling is still supported, it is not recommended for new \nprograms. Also, many of the methods that support the old 1.0 event model have been \ndeprecated. The modern approach is the way that events should be handled by all new \nprograms and thus is the method employed by programs in this book. \n\nThe Delegation Event Model",
    "The modern approach to handling events is based on the delegation event model , which \ndefines standard and consistent mechanisms to generate and process events. Its concept is \nquite simple: a source generates an event and sends it to one or more listeners . In this \nscheme, the listener simply waits until it receives an event. Once an event is received, the \nlistener processes the event and then returns. The advantage of this design is that the \napplication logic that processes events is cleanly separated from the user interface logic that \ngenerates those events. A user interface element is able to \u201cdelegate\u201d the processing of an \nevent to a separate piece of code. \nIn the delegation event model, listeners must register with a source in order to receive an \nevent notification. This provides an important benefit: notifications are sent only to listeners \nthat want to receive them. This is a more efficient way to handle events than the design \nused by the original Java 1.0 approach",
    ". This is a more efficient way to handle events than the design \nused by the original Java 1.0 approach. Previously, an event was propagated up the \ncontainment hierarchy until it was handled by a component. This required components to \nreceive events that they did not process, and it wasted valuable time. The delegation event \nmodel eliminates this overhead. \nThe following sections define events and describe the roles of sources and listeners.",
    "Events \n\nIn the delegation model, an event is an object that describes a state change in a source. \nAmong other causes, an event can be generated as a consequence of a person interacting \nwith the elements in a graphical user interface. Some of the activities that cause events to be \ngenerated are pressing a button, entering a character via the keyboard, selecting an item in \na list, and clicking the mouse. Many other user operations could also be cited as examples. \nEvents may also occur that are not directly caused by interactions with a user interface. For \nexample, an event may be generated when a timer expires, a counter exceeds a value, a \n\nsoftware or hardware failure occurs, or an operation is completed. You are free to define \nevents that are appropriate for your application. \n\nEvent Sources",
    "software or hardware failure occurs, or an operation is completed. You are free to define \nevents that are appropriate for your application. \n\nEvent Sources \n\nA source is an object that generates an event. This occurs when the internal state of that \nobject changes in some way. Sources may generate more than one type of event. \nA source must register listeners in order for the listeners to receive notifications about a \n\n\nspecific type of event. Each type of event has its own registration method. Here is the \ngeneral form: \n\npublic void add Type Listener ( Type Listener el )",
    "specific type of event. Each type of event has its own registration method. Here is the \ngeneral form: \n\npublic void add Type Listener ( Type Listener el ) \n\nHere, Type is the name of the event, and el is a reference to the event listener. For \nexample, the method that registers a keyboard event listener is called \naddKeyListener ( ) . The method that registers a mouse motion listener is called \naddMouseMotionListener ( ) . When an event occurs, all registered listeners \nare notified and receive a copy of the event object. This is known as multicasting \nthe event. In all cases, notifications are sent only to listeners that register to \nreceive them. \nSome sources may allow only one listener to register. The general form of such a method is \nthis: \n\npublic void add Type Listener ( Type Listener el ) \n\n    throws java.util.TooManyListenersException",
    "public void add Type Listener ( Type Listener el ) \n\n    throws java.util.TooManyListenersException \n\nHere, Type is the name of the event, and el is a reference to the event listener. \nWhen such an event occurs, the registered listener is notified. This is known as \nunicasting the event. \nA source must also provide a method that allows a listener to unregister an interest in a \nspecific type of event. The general form of such a method is this: \n\npublic void remove Type Listener ( Type Listener el ) \n\nHere, Type is the name of the event, and el is a reference to the event listener. For \nexample, to remove a keyboard listener, you would call removeKeyListener ( ) . \nThe methods that add or remove listeners are provided by the source that generates events. \nFor example, the Component class provides methods to add and remove keyboard and \nmouse event listeners. \n\nEvent Listeners",
    "Event Listeners \n\nA listener is an object that is notified when an event occurs. It has two major requirements. \nFirst, it must have been registered with one or more sources to receive notifications about \nspecific types of events. Second, it must implement methods to receive and process these \nnotifications. \nThe methods that receive and process events are defined in a set of interfaces, such as those \n\nfound in java.awt.event . For example, the MouseMotionListener interface defines two \nmethods to receive notifications when the mouse is dragged or moved. Any object may \nreceive and process one or both of these events if it provides an implementation of this \ninterface. Other listener interfaces are discussed later in this and other chapters. \n\nEvent Classes \n\nThe classes that represent events are at the core of Java\u2019s event handling mechanism. Thus,",
    "Event Classes \n\nThe classes that represent events are at the core of Java\u2019s event handling mechanism. Thus, \n\n\na discussion of event handling must begin with the event classes. It is important to \nunderstand, however, that Java defines several types of events and that not all event classes \ncan be discussed in this chapter. Arguably, the most widely used events at the time of this \nwriting are those defined by the AWT and those defined by Swing. This chapter focuses on \nthe AWT events. ( Most of these events also apply to Swing.) Several Swing-specific events \nare described in Chapter 31, when Swing is covered. \nAt the root of the Java event class hierarchy is EventObject , which is in java.util . \nIt is the superclass for all events. Its one constructor is shown here: \n\nEventObject ( Object src )",
    "EventObject ( Object src ) \n\nHere, src is the object that generates this event. \nEventObject defines two methods: getSource ( ) and toString ( ) . The getSource ( ) \nmethod returns the source of the event. Its general form is shown here: \n\nObject getSource ( ) \n\nAs expected, toString ( ) returns the string equivalent of the event. \nThe class AWTEvent , defined within the java.awt package, is a subclass of EventObject . \nIt is the superclass ( either directly or indirectly ) of all AWT-based events used by the \ndelegation event model. Its getID ( ) method can be used to determine the type of the event. \nThe signature of this method is shown here: \n\nint getID ( ) \n\nAdditional details about AWTEvent are provided at the end of Chapter 26. At this \npoint, it is important to know only that all of the other classes discussed in this \nsection are subclasses of AWTEvent . To summarize: \n\n\u2022   EventObject     is a superclass of all events.",
    "\u2022   EventObject     is a superclass of all events. \n\n\u2022   AWTEvent     is a superclass of all AWT events that are handled by the \ndelegation event model. \n\nThe package java.awt.event defines many types of events that are generated by \n\nvarious user interface elements. Table 24-1 shows several commonly used event \nclasses and provides a brief description of when they are generated. Commonly \nused constructors and methods in each class are described in the following \nsections. \n\n\nTable 24-1    Commonly Used Event Classes in java.awt.event \n\nThe ActionEvent Class",
    "Table 24-1    Commonly Used Event Classes in java.awt.event \n\nThe ActionEvent Class \n\nAn ActionEvent is generated when a button is pressed, a list item is double-clicked, or a \nmenu item is selected. The ActionEvent class defines four integer constants that can be \nused to identify any modifiers associated with an action event: ALT_MASK , \nCTRL_MASK , META_MASK , and SHIFT_MASK . In addition, there is an integer \nconstant, ACTION_PERFORMED , which can be used to identify action events. \nActionEvent has these three constructors: \n\nActionEvent ( Object src , int type , String cmd ) \nActionEvent ( Object src , int type , String cmd , int modifiers ) \nActionEvent ( Object src , int type , String cmd , long when , int modifiers )",
    "Here, src is a reference to the object that generated this event. The type of the \nevent is specified by type , and its command string is cmd . The argument modifiers \nindicates which modifier keys ( ALT , CTRL , META , and/or SHIFT ) were pressed when \n\nthe event was generated. The when parameter specifies when the event occurred. \nYou can obtain the command name for the invoking ActionEvent object by using the \ngetActionCommand ( ) method, shown here: \n\nString getActionCommand ( ) \n\nFor example, when a button is pressed, an action event is generated that has a \ncommand name equal to the label on that button. \nThe getModifiers ( ) method returns a value that indicates which modifier keys ( ALT , CTRL , \n\nMETA , and/or SHIFT ) were pressed when the event was generated. Its form is shown here: \n\nint getModifiers ( ) \n\nThe method getWhen ( ) returns the time at which the event took place. This is \n\n\ncalled the event\u2019s timestamp . The getWhen ( ) method is shown here:",
    "int getModifiers ( ) \n\nThe method getWhen ( ) returns the time at which the event took place. This is \n\n\ncalled the event\u2019s timestamp . The getWhen ( ) method is shown here: \n\nlong getWhen ( ) \n\nThe AdjustmentEvent Class \n\nAn AdjustmentEvent is generated by a scroll bar. There are five types of adjustment \nevents. The AdjustmentEvent class defines integer constants that can be used to identify \nthem. The constants and their meanings are shown here: \n\nBLOCK_DECREMENT \nThe user clicked inside the scroll bar to decrease its value. \n\nBLOCK_INCREMENT \nThe user clicked inside the scroll bar to increase its value. \n\nTRACK \nThe slider was dragged. \n\nUNIT_DECREMENT \nThe button at the end of the scroll bar was clicked to decrease \nits value. \n\nUNIT_INCREMENT \nThe button at the end of the scroll bar was clicked to increase \nits value.",
    "UNIT_DECREMENT \nThe button at the end of the scroll bar was clicked to decrease \nits value. \n\nUNIT_INCREMENT \nThe button at the end of the scroll bar was clicked to increase \nits value. \n\nIn addition, there is an integer constant, ADJUSTMENT_VALUE_CHANGED , that \nindicates that a change has occurred. \nHere is one AdjustmentEvent constructor: \n\nAdjustmentEvent ( Adjustable src , int id , int type , int val ) \n\nHere, src is a reference to the object that generated this event. The id specifies the \nevent. The type of the adjustment is specified by type , and its associated value is \nval . \nThe getAdjustable ( ) method returns the object that generated the event. Its form is \nshown here: \n\nAdjustable getAdjustable ( ) \n\nThe type of the adjustment event may be obtained by the getAdjustmentType ( ) \nmethod. It returns one of the constants defined by AdjustmentEvent . The \ngeneral form is shown here: \n\nint getAdjustmentType ( )",
    "int getAdjustmentType ( ) \n\nThe amount of the adjustment can be obtained from the getValue ( ) method, \nshown here: \n\nint getValue ( ) \n\nFor example, when a scroll bar is manipulated, this method returns the value \nrepresented by that change. \n\nThe ComponentEvent Class \n\n\nA ComponentEvent is generated when the size, position, or visibility of a component is \nchanged. There are four types of component events. The ComponentEvent class defines \ninteger constants that can be used to identify them. The constants and their meanings are \nshown here: \n\nCOMPONENT_HIDDEN \nThe component was hidden. \n\nCOMPONENT_MOVED \nThe component was moved. \n\nCOMPONENT_RESIZED \nThe component was resized. \n\nCOMPONENT_SHOWN \nThe component became visible. \n\nComponentEvent has this constructor: \n\nComponentEvent ( Component src , int type )",
    "COMPONENT_RESIZED \nThe component was resized. \n\nCOMPONENT_SHOWN \nThe component became visible. \n\nComponentEvent has this constructor: \n\nComponentEvent ( Component src , int type ) \n\nHere, src is a reference to the object that generated this event. The type of the \nevent is specified by type . \nComponentEvent is the superclass either directly or indirectly of ContainerEvent , \nFocusEvent , KeyEvent , MouseEvent , and WindowEvent , among others. \nThe getComponent ( ) method returns the component that generated the event. It is \nshown here: \n\nComponent getComponent ( ) \n\nThe ContainerEvent Class",
    "Component getComponent ( ) \n\nThe ContainerEvent Class \n\nA ContainerEvent is generated when a component is added to or removed from a \ncontainer. There are two types of container events. The ContainerEvent class defines int \nconstants that can be used to identify them: COMPONENT_ADDED and \nCOMPONENT_REMOVED . They indicate that a component has been added to or \nremoved from the container. \nContainerEvent is a subclass of ComponentEvent and has this constructor: \n\nContainerEvent ( Component src , int type , Component comp ) \n\nHere, src is a reference to the container that generated this event. The type of the \nevent is specified by type , and the component that has been added to or removed \nfrom the container is comp . \n\nYou can obtain a reference to the container that generated this event by using the \ngetContainer ( ) method, shown here: \n\nContainer getContainer ( )",
    "You can obtain a reference to the container that generated this event by using the \ngetContainer ( ) method, shown here: \n\nContainer getContainer ( ) \n\nThe getChild ( ) method returns a reference to the component that was added to \nor removed from the container. Its general form is shown here: \n\n\nComponent getChild ( ) \n\nThe FocusEvent Class \n\nA FocusEvent is generated when a component gains or loses input focus. These events are \nidentified by the integer constants FOCUS_GAINED and FOCUS_LOST . \nFocusEvent is a subclass of ComponentEvent and has these constructors: \n\nFocusEvent ( Component src , int type ) \nFocusEvent ( Component src , int type , boolean temporaryFlag ) \nFocusEvent ( Component src , int type , boolean temporaryFlag , Component other )",
    "Here, src is a reference to the component that generated this event. The type of the \nevent is specified by type . The argument temporaryFlag is set to true if the focus \nevent is temporary. Otherwise, it is set to false . ( A temporary focus event occurs \nas a result of another user interface operation. For example, assume that the focus \nis in a text field. If the user moves the mouse to adjust a scroll bar, the focus is \ntemporarily lost.) \nThe other component involved in the focus change, called the opposite component , is passed \nin other . Therefore, if a FOCUS_GAINED event occurred, other will refer to the \ncomponent that lost focus. Conversely, if a FOCUS_LOST event occurred, other will refer \nto the component that gains focus. \nYou can determine the other component by calling getOppositeComponent ( ) , shown \nhere: \n\nComponent getOppositeComponent ( )",
    "Component getOppositeComponent ( ) \n\nThe opposite component is returned. \nThe isTemporary ( ) method indicates if this focus change is temporary. Its form is shown \nhere: \n\nboolean isTemporary ( ) \n\nThe method returns true if the change is temporary. Otherwise, it returns false . \n\nThe InputEvent Class \n\nThe abstract class InputEvent is a subclass of ComponentEvent and is the superclass for \ncomponent input events. Its subclasses are KeyEvent and MouseEvent . \nInputEvent defines several integer constants that represent any modifiers, such as the \ncontrol key being pressed, that might be associated with the event. Originally, the \nInputEvent class defined the following eight values to represent the modifiers: \n\n\nHowever, because of possible conflicts between the modifiers used by keyboard events and \nmouse events, and other issues, the following extended modifier values were added:",
    "However, because of possible conflicts between the modifiers used by keyboard events and \nmouse events, and other issues, the following extended modifier values were added: \n\nWhen writing new code, it is recommended that you use the new, extended modifiers rather \nthan the original modifiers. \nTo test if a modifier was pressed at the time an event is generated, use the isAltDown ( ) , \nisAltGraphDown ( ) , isControlDown ( ) , isMetaDown ( ) , and isShiftDown ( ) \nmethods. The forms of these methods are shown here: \n\nboolean isAltDown ( ) \nboolean isAltGraphDown ( ) \nboolean isControlDown ( ) \nboolean isMetaDown ( ) \nboolean isShiftDown ( ) \n\nYou can obtain a value that contains all of the original modifier flags by calling the \ngetModifiers ( ) method. It is shown here: \n\nint getModifiers ( ) \n\nYou can obtain the extended modifiers by calling getModifiersEx ( ) , which is \nshown here: \n\nint getModifiersEx ( ) \n\nThe ItemEvent Class",
    "int getModifiers ( ) \n\nYou can obtain the extended modifiers by calling getModifiersEx ( ) , which is \nshown here: \n\nint getModifiersEx ( ) \n\nThe ItemEvent Class \n\nAn ItemEvent is generated when a check box or a list item is clicked or when a checkable \n\nmenu item is selected or deselected. ( Check boxes and list boxes are described later in this \nbook.) There are two types of item events, which are identified by the following integer \nconstants: \n\nDESELECTED \nThe user deselected an item. \n\nSELECTED \nThe user selected an item. \n\nIn addition, ItemEvent defines one integer constant, ITEM_STATE_CHANGED , that \nsignifies a change of state. \n\nItemEvent has this constructor: \n\nItemEvent ( ItemSelectable src , int type , Object entry , int state ) \n\nHere, src is a reference to the component that generated this event. For example,",
    "ItemEvent has this constructor: \n\nItemEvent ( ItemSelectable src , int type , Object entry , int state ) \n\nHere, src is a reference to the component that generated this event. For example, \n\n\nthis might be a list or choice element. The type of the event is specified by type . \nThe specific item that generated the item event is passed in entry . The current \nstate of that item is in state . \nThe getItem ( ) method can be used to obtain a reference to the item that changed. Its \nsignature is shown here: \n\nObject getItem ( ) \n\nThe getItemSelectable ( ) method can be used to obtain a reference to the \nItemSelectable object that generated an event. Its general form is shown here: \n\nItemSelectable getItemSelectable ( ) \n\nLists and choices are examples of user interface elements that implement the \nItemSelectable interface. \nThe getStateChange ( ) method returns the state change ( that is, SELECTED or \nDESELECTED ) for the event. It is shown here: \n\nint getStateChange ( )",
    "int getStateChange ( ) \n\nThe KeyEvent Class \n\nA KeyEvent is generated when keyboard input occurs. There are three types of key events, \nwhich are identified by these integer constants: KEY_PRESSED , KEY_RELEASED , and \nKEY_TYPED . The first two events are generated when any key is pressed or released. The \nlast event occurs only when a character is generated. Remember, not all keypresses result in \ncharacters. For example, pressing shift does not generate a character. \nThere are many other integer constants that are defined by KeyEvent . For example, VK_0 \nthrough VK_9 and VK_A through VK_Z define the ASCII equivalents of the numbers and \nletters. Here are some others: \n\nThe VK constants specify virtual key codes and are independent of any modifiers, such as \ncontrol, shift, or alt. \nKeyEvent is a subclass of InputEvent . Here is one of its constructors: \n\nKeyEvent ( Component src , int type , long when , int modifiers , int code , char ch )",
    "KeyEvent ( Component src , int type , long when , int modifiers , int code , char ch ) \n\nHere, src is a reference to the component that generated the event. The type of the \nevent is specified by type . The system time at which the key was pressed is passed \nin when . The modifiers argument indicates which modifiers were pressed when \nthis key event occurred. The virtual key code, such as VK_UP , VK_A , and so \nforth, is passed in code . The character equivalent ( if one exists ) is passed in ch . If \nno valid character exists, then ch contains CHAR_UNDEFINED . For \n\n\nKEY_TYPED events, code will contain VK_UNDEFINED . \nThe KeyEvent class defines several methods, but probably the most commonly used ones \nare getKeyChar ( ) , which returns the character that was entered, and getKeyCode ( ) , \nwhich returns the key code. Their general forms are shown here: \n\nchar getKeyChar ( ) \nint getKeyCode ( )",
    "char getKeyChar ( ) \nint getKeyCode ( ) \n\nIf no valid character is available, then getKeyChar ( ) returns \nCHAR_UNDEFINED . When a KEY_TYPED event occurs, getKeyCode ( ) \nreturns VK_UNDEFINED . \n\nThe MouseEvent Class \n\nThere are eight types of mouse events. The MouseEvent class defines the following integer \nconstants that can be used to identify them: \n\nMOUSE_CLICKED \nThe user clicked the mouse. \n\nMOUSE_DRAGGED \nThe user dragged the mouse. \n\nMOUSE_ENTERED \nThe mouse entered a component. \n\nMOUSE_EXITED \nThe mouse exited from a component. \n\nMOUSE_MOVED \nThe mouse moved. \n\nMOUSE_PRESSED \nThe mouse was pressed. \n\nMOUSE_RELEASED \nThe mouse was released. \n\nMOUSE_WHEEL \nThe mouse wheel was moved. \n\nMouseEvent is a subclass of InputEvent . Here is one of its constructors:",
    "MOUSE_PRESSED \nThe mouse was pressed. \n\nMOUSE_RELEASED \nThe mouse was released. \n\nMOUSE_WHEEL \nThe mouse wheel was moved. \n\nMouseEvent is a subclass of InputEvent . Here is one of its constructors: \n\nHere, src is a reference to the component that generated the event. The type of the event is \nspecified by type . The system time at which the mouse event occurred is passed in when . \nThe modifiers argument indicates which modifiers were pressed when a mouse event \noccurred. The coordinates of the mouse are passed in x and y . The click count is passed in \nclicks . The triggersPopup flag indicates if this event causes a pop-up menu to appear on \nthis platform. \n\nTwo commonly used methods in this class are getX ( ) and getY ( ) . These return the X and \nY coordinates of the mouse within the component when the event occurred. Their forms are \nshown here: \n\nint getX ( ) \n\n\nint getY ( )",
    "int getX ( ) \n\n\nint getY ( ) \n\nAlternatively, you can use the getPoint ( ) method to obtain the coordinates of the \nmouse. It is shown here: \n\nPoint getPoint ( ) \n\nIt returns a Point object that contains the X,Y coordinates in its integer members: \nx and y . \nThe translatePoint ( ) method changes the location of the event. Its form is shown here: \n\nvoid translatePoint ( int x , int y ) \n\nHere, the arguments x and y are added to the coordinates of the event. \nThe getClickCount ( ) method obtains the number of mouse clicks for this event. Its \nsignature is shown here: \n\nint getClickCount ( ) \n\nThe isPopupTrigger ( ) method tests if this event causes a pop-up menu to \nappear on this platform. Its form is shown here: \n\nboolean isPopupTrigger ( ) \n\nAlso available is the getButton ( ) method, shown here: \n\nint getButton ( )",
    "boolean isPopupTrigger ( ) \n\nAlso available is the getButton ( ) method, shown here: \n\nint getButton ( ) \n\nIt returns a value that represents the button that caused the event. For most cases, \nthe return value will be one of these constants defined by MouseEvent : \n\nThe NOBUTTON value indicates that no button was pressed or released. \nAlso available are three methods that obtain the coordinates of the mouse relative to the \nscreen rather than the component. They are shown here: \n\nPoint getLocationOnScreen ( ) \n\nint getXOnScreen ( ) \n\nint getYOnScreen ( ) \n\nThe getLocationOnScreen ( ) method returns a Point object that contains both \nthe X and Y coordinate. The other two methods return the indicated coordinate. \n\nThe MouseWheelEvent Class \n\nThe MouseWheelEvent class encapsulates a mouse wheel event. It is a subclass of",
    "The MouseWheelEvent Class \n\nThe MouseWheelEvent class encapsulates a mouse wheel event. It is a subclass of \n\nMouseEvent . Not all mice have wheels. If a mouse has a wheel, it is typically located \nbetween the left and right buttons. Mouse wheels are used for scrolling. \nMouseWheelEvent defines these two integer constants: \n\n\nWHEEL_BLOCK_SCROLL \nA page-up or page-down scroll event occurred. \n\nWHEEL_UNIT_SCROLL \nA line-up or line-down scroll event occurred. \n\nHere is one of the constructors defined by MouseWheelEvent :",
    "WHEEL_UNIT_SCROLL \nA line-up or line-down scroll event occurred. \n\nHere is one of the constructors defined by MouseWheelEvent : \n\nHere, src is a reference to the object that generated the event. The type of the event is \nspecified by type . The system time at which the mouse event occurred is passed in when . \nThe modifiers argument indicates which modifiers were pressed when the event occurred. \nThe coordinates of the mouse are passed in x and y . The number of clicks is passed in clicks . \nThe triggersPopup flag indicates if this event causes a pop-up menu to appear on this \nplatform. The scrollHow value must be either WHEEL_UNIT_SCROLL or \nWHEEL_BLOCK_ SCROLL . The number of units to scroll is passed in amount . The \ncount parameter indicates the number of rotational units that the wheel moved. \nMouseWheelEvent defines methods that give you access to the wheel event. To obtain the \nnumber of rotational units, call getWheelRotation ( ) , shown here: \n\nint getWheelRotation ( )",
    "int getWheelRotation ( ) \n\nIt returns the number of rotational units. If the value is positive, the wheel moved \ncounterclockwise. If the value is negative, the wheel moved clockwise. JDK 7 added \na method called getPreciseWheelRotation ( ) , which supports high-resolution \nwheels. It works like getWheelRotation ( ) , but returns a double . \nTo obtain the type of scroll, call getScrollType ( ) , shown next: \n\nint getScrollType ( ) \n\nIt returns either WHEEL_UNIT_SCROLL or WHEEL_BLOCK_SCROLL . \nIf the scroll type is WHEEL_UNIT_SCROLL , you can obtain the number of units to \nscroll by calling getScrollAmount ( ) . It is shown here: \n\nint getScrollAmount ( ) \n\nThe TextEvent Class \n\nInstances of this class describe text events. These are generated by text fields and text areas \nwhen characters are entered by a user or program. TextEvent defines the integer constant \n\nTEXT_VALUE_CHANGED . \n\nThe one constructor for this class is shown here: \n\nTextEvent ( Object src , int type )",
    "TEXT_VALUE_CHANGED . \n\nThe one constructor for this class is shown here: \n\nTextEvent ( Object src , int type ) \n\n\nHere, src is a reference to the object that generated this event. The type of the \nevent is specified by type . \nThe TextEvent object does not include the characters currently in the text component that \ngenerated the event. Instead, your program must use other methods associated with the text \ncomponent to retrieve that information. This operation differs from other event objects \ndiscussed in this section. Think of a text event notification as a signal to a listener that it \nshould retrieve information from a specific text component. \n\nThe WindowEvent Class \n\nThere are ten types of window events. The WindowEvent class defines integer constants \nthat can be used to identify them. The constants and their meanings are shown here: \n\nWINDOW_ACTIVATED \nThe window was activated. \n\nWINDOW_CLOSED \nThe window has been closed.",
    "WINDOW_ACTIVATED \nThe window was activated. \n\nWINDOW_CLOSED \nThe window has been closed. \n\nWINDOW_CLOSING \nThe user requested that the window be closed. \n\nWINDOW_DEACTIVATED \nThe window was deactivated. \n\nWINDOW_DEICONIFIED \nThe window was deiconified. \n\nWINDOW_GAINED_FOCUS \nThe window gained input focus. \n\nWINDOW_ICONIFIED \nThe window was iconified. \n\nWINDOW_LOST_FOCUS \nThe window lost input focus. \n\nWINDOW_OPENED \nThe window was opened. \n\nWINDOW_STATE_CHANGED \nThe state of the window changed. \n\nWindowEvent is a subclass of ComponentEvent . It defines several constructors. The \nfirst is \n\nWindowEvent ( Window src , int type ) \n\nHere, src is a reference to the object that generated this event. The type of the \nevent is type . The next three constructors offer more detailed control:",
    "WindowEvent ( Window src , int type ) \n\nHere, src is a reference to the object that generated this event. The type of the \nevent is type . The next three constructors offer more detailed control: \n\nWindowEvent ( Window src , int type , Window other ) \nWindowEvent ( Window src , int type , int fromState , int toState ) \nWindowEvent ( Window src , int type , Window other , int fromState , int toState ) \n\nHere, other specifies the opposite window when a focus or activation event occurs. \nThe fromState specifies the prior state of the window, and toState specifies the new \n\nstate that the window will have when a window state change occurs. \nA commonly used method in this class is getWindow ( ) . It returns the Window object \nthat generated the event. Its general form is shown here: \n\nWindow getWindow ( )",
    "Window getWindow ( ) \n\n\nWindowEvent also defines methods that return the opposite window ( when a \nfocus or activation event has occurred ), the previous window state, and the current \nwindow state. These methods are shown here: \n\nWindow getOppositeWindow ( ) \nint getOldState ( ) \nint getNewState ( ) \n\nSources of Events \n\nTable 24-2 lists some of the user interface components that can generate the events \ndescribed in the previous section. In addition to these graphical user interface elements, any \nclass derived from Component , such as Applet , can generate events. For example, you \ncan receive key and mouse events from an applet. ( You may also build your own \ncomponents that generate events.) In this chapter, we will be handling only mouse and \nkeyboard events, but the following two chapters will be handling events from the sources \nshown in Table 24-2. \n\nTable 24-2    Event Source Examples \n\nEvent Listener Interfaces",
    "Table 24-2    Event Source Examples \n\nEvent Listener Interfaces \n\nAs explained, the delegation event model has two parts: sources and listeners. As it relates \nto this chapter, listeners are created by implementing one or more of the interfaces defined \nby the java.awt.event package. When an event occurs, the event source invokes the \nappropriate method defined by the listener and provides an event object as its argument. \n\nTable 24-3 lists several commonly used listener interfaces and provides a brief description \n\nof the methods that they define. The following sections examine the specific methods that \n\nare contained in each interface. \n\n\nTable 24-3    Commonly Used Event Listener Interfaces \n\nThe ActionListener Interface \n\nThis interface defines the actionPerformed ( ) method that is invoked when an action \nevent occurs. Its general form is shown here: \n\nvoid actionPerformed ( ActionEvent ae ) \n\nThe AdjustmentListener Interface",
    "void actionPerformed ( ActionEvent ae ) \n\nThe AdjustmentListener Interface \n\nThis interface defines the adjustmentValueChanged ( ) method that is invoked when an \nadjustment event occurs. Its general form is shown here: \n\nvoid adjustmentValueChanged ( AdjustmentEvent ae ) \n\nThe ComponentListener Interface \n\nThis interface defines four methods that are invoked when a component is resized, moved, \n\nshown, or hidden. Their general forms are shown here: \n\nvoid componentResized ( ComponentEvent ce ) \nvoid componentMoved ( ComponentEvent ce ) \nvoid componentShown ( ComponentEvent ce ) \nvoid componentHidden ( ComponentEvent ce ) \n\nThe ContainerListener Interface \n\nThis interface contains two methods. When a component is added to a container, \ncomponentAdded ( ) is invoked. When a component is removed from a container, \ncomponentRemoved ( ) is invoked. Their general forms are shown here: \n\nvoid componentAdded ( ContainerEvent ce ) \nvoid componentRemoved ( ContainerEvent ce )",
    "void componentAdded ( ContainerEvent ce ) \nvoid componentRemoved ( ContainerEvent ce ) \n\n\nThe FocusListener Interface \n\nThis interface defines two methods. When a component obtains keyboard focus, \nfocusGained ( ) is invoked. When a component loses keyboard focus, focusLost ( ) is \ncalled. Their general forms are shown here: \n\nvoid focusGained ( FocusEvent fe ) \nvoid focusLost ( FocusEvent fe ) \n\nThe ItemListener Interface \n\nThis interface defines the itemStateChanged ( ) method that is invoked when the state of \nan item changes. Its general form is shown here: \n\nvoid itemStateChanged ( ItemEvent ie ) \n\nThe KeyListener Interface",
    "void itemStateChanged ( ItemEvent ie ) \n\nThe KeyListener Interface \n\nThis interface defines three methods. The keyPressed ( ) and keyReleased ( ) methods \nare invoked when a key is pressed and released, respectively. The keyTyped ( ) method is \ninvoked when a character has been entered. \nFor example, if a user presses and releases the a key, three events are generated in \nsequence: key pressed, typed, and released. If a user presses and releases the home key, two \nkey events are generated in sequence: key pressed and released. \nThe general forms of these methods are shown here: \n\nvoid keyPressed ( KeyEvent ke ) \nvoid keyReleased ( KeyEvent ke ) \nvoid keyTyped ( KeyEvent ke ) \n\nThe MouseListener Interface",
    "void keyPressed ( KeyEvent ke ) \nvoid keyReleased ( KeyEvent ke ) \nvoid keyTyped ( KeyEvent ke ) \n\nThe MouseListener Interface \n\nThis interface defines five methods. If the mouse is pressed and released at the same point, \nmouseClicked ( ) is invoked. When the mouse enters a component, the mouseEntered ( \n) method is called. When it leaves, mouseExited ( ) is called. The mousePressed ( ) and \nmouseReleased ( ) methods are invoked when the mouse is pressed and released, \nrespectively. \nThe general forms of these methods are shown here: \n\nvoid mouseClicked ( MouseEvent me ) \nvoid mouseEntered ( MouseEvent me ) \nvoid mouseExited ( MouseEvent me ) \nvoid mousePressed ( MouseEvent me ) \nvoid mouseReleased ( MouseEvent me ) \n\nThe MouseMotionListener Interface \n\nThis interface defines two methods. The mouseDragged ( ) method is called multiple times \nas the mouse is dragged. The mouseMoved ( ) method is called multiple times as the",
    "This interface defines two methods. The mouseDragged ( ) method is called multiple times \nas the mouse is dragged. The mouseMoved ( ) method is called multiple times as the \n\n\nmouse is moved. Their general forms are shown here: \n\nvoid mouseDragged ( MouseEvent me ) \nvoid mouseMoved ( MouseEvent me ) \n\nThe MouseWheelListener Interface \n\nThis interface defines the mouseWheelMoved ( ) method that is invoked when the mouse \nwheel is moved. Its general form is shown here: \n\nvoid mouseWheelMoved ( MouseWheelEvent mwe ) \n\nThe TextListener Interface \n\nThis interface defines the textValueChanged ( ) method that is invoked when a change \noccurs in a text area or text field. Its general form is shown here: \n\nvoid textValueChanged ( TextEvent te ) \n\nThe WindowFocusListener Interface \n\nThis interface defines two methods: windowGainedFocus ( ) and windowLostFocus ( ) . \nThese are called when a window gains or loses input focus. Their general forms are shown \nhere:",
    "This interface defines two methods: windowGainedFocus ( ) and windowLostFocus ( ) . \nThese are called when a window gains or loses input focus. Their general forms are shown \nhere: \n\nvoid windowGainedFocus ( WindowEvent we ) \nvoid windowLostFocus ( WindowEvent we ) \n\nThe WindowListener Interface \n\nThis interface defines seven methods. The windowActivated ( ) and \nwindowDeactivated ( ) methods are invoked when a window is activated or deactivated, \nrespectively. If a window is iconified, the windowIconified ( ) method is called. When a \nwindow is deiconified, the windowDeiconified ( ) method is called. When a window is \nopened or closed, the windowOpened ( ) or windowClosed ( ) methods are called, \nrespectively. The windowClosing ( ) method is called when a window is being closed. The \ngeneral forms of these methods are \n\nvoid windowActivated ( WindowEvent we )",
    "void windowActivated ( WindowEvent we ) \n\nvoid windowClosed ( WindowEvent we ) \nvoid windowClosing ( WindowEvent we ) \nvoid windowDeactivated ( WindowEvent we ) \nvoid windowDeiconified ( WindowEvent we ) \n\nvoid windowIconified ( WindowEvent we ) \nvoid windowOpened ( WindowEvent we ) \n\nUsing the Delegation Event Model \n\nNow that you have learned the theory behind the delegation event model and have had an \noverview of its various components, it is time to see it in practice. Using the delegation \nevent model is actually quite easy. Just follow these two steps: \n\n\n1.  Implement the appropriate interface in the listener so that it can receive \nthe type of event desired. \n\n2.  Implement code to register and unregister ( if necessary ) the listener as a \nrecipient for the event notifications.",
    "2.  Implement code to register and unregister ( if necessary ) the listener as a \nrecipient for the event notifications. \n\nRemember that a source may generate several types of events. Each event must be \nregistered separately. Also, an object may register to receive several types of \nevents, but it must implement all of the interfaces that are required to receive \nthese events. \nTo see how the delegation model works in practice, we will look at examples that handle two \ncommonly used event generators: the mouse and keyboard. \n\nHandling Mouse Events",
    "To handle mouse events, you must implement the MouseListener and the \nMouseMotionListener interfaces. ( You may also want to implement \nMouseWheelListener , but we won\u2019t be doing so, here.) The following applet \ndemonstrates the process. It displays the current coordinates of the mouse in the applet\u2019s \nstatus window. Each time a button is pressed, the word \"Down\" is displayed at the location \nof the mouse pointer. Each time the button is released, the word \"Up\" is shown. If a button \nis clicked, the message \"Mouse clicked\" is displayed in the upper-left corner of the applet \ndisplay area. \nAs the mouse enters or exits the applet window, a message is displayed in the upper-left \ncorner of the applet display area. When dragging the mouse, a * is shown, which tracks with \nthe mouse pointer as it is dragged. Notice that the two variables, mouseX and mouseY , \nstore the location of the mouse when a mouse pressed, released, or dragged event occurs",
    ". Notice that the two variables, mouseX and mouseY , \nstore the location of the mouse when a mouse pressed, released, or dragged event occurs. \nThese coordinates are then used by paint ( ) to display output at the point of these \noccurrences.",
    "Sample output from this program is shown here: \n\n\nLet's look closely at this example. The MouseEvents class extends Applet and implements \nboth the MouseListener and MouseMotionListener interfaces. These two interfaces \ncontain methods that receive and process the various types of mouse events. Notice that the \napplet is both the source and the listener for these events. This works because \nComponent , which supplies the addMouseListener ( ) and \naddMouseMotionListener ( ) methods, is a superclass of Applet . Being both the source \nand the listener for events is a common situation for applets. \nInside init ( ) , the applet registers itself as a listener for mouse events. This is done by using \naddMouseListener ( ) and addMouseMotionListener ( ) , which, as mentioned, are \nmembers of Component . They are shown here: \n\nvoid addMouseListener ( MouseListener ml ) \nvoid addMouseMotionListener ( MouseMotionListener mml )",
    "void addMouseListener ( MouseListener ml ) \nvoid addMouseMotionListener ( MouseMotionListener mml ) \n\nHere, ml is a reference to the object receiving mouse events, and mml is a \nreference to the object receiving mouse motion events. In this program, the same \nobject is used for both. \nThe applet then implements all of the methods defined by the MouseListener and \nMouseMotionListener interfaces. These are the event handlers for the various mouse \nevents. Each method handles its event and then returns. \n\nHandling Keyboard Events",
    "Handling Keyboard Events \n\nTo handle keyboard events, you use the same general architecture as that shown in the \nmouse event example in the preceding section. The difference, of course, is that you will be \nimplementing the KeyListener interface. \nBefore looking at an example, it is useful to review how key events are generated. When a \nkey is pressed, a KEY_PRESSED event is generated. This results in a call to the \nkeyPressed ( ) event handler. When the key is released, a KEY_RELEASED event is \ngenerated and the keyReleased ( ) handler is executed. If a character is generated by the",
    "keystroke, then a KEY_TYPED event is sent and the keyTyped ( ) handler is invoked. \nThus, each time the user presses a key, at least two and often three events are generated. If \nall you care about are actual characters, then you can ignore the information passed by the \nkey press and release events. However, if your program needs to handle special keys, such \nas the arrow or function keys, then it must watch for them through the keyPressed ( ) \n\n\nhandler. \n\nThe following program demonstrates keyboard input. It echoes keystrokes to the applet \nwindow and shows the pressed/released status of each key in the status window. \n\nSample output is shown here:",
    "The following program demonstrates keyboard input. It echoes keystrokes to the applet \nwindow and shows the pressed/released status of each key in the status window. \n\nSample output is shown here: \n\n\nIf you want to handle the special keys, such as the arrow or function keys, you need to \nrespond to them within the keyPressed ( ) handler. They are not available through \nkeyTyped ( ) . \nTo identify the keys, you use their virtual key codes. For example, the next applet outputs \nthe name of a few of the special keys: \n\n\n\n\nSample output is shown here: \n\nThe procedures shown in the preceding keyboard and mouse event examples can be \ngeneralized to any type of event handling, including those events generated by controls. In \nlater chapters, you will see many examples that handle other types of events, but they will \nall follow the same basic structure as the programs just described. \n\nAdapter Classes",
    "Adapter Classes \n\nJava provides a special feature, called an adapter class , that can simplify the creation of \nevent handlers in certain situations. An adapter class provides an empty implementation of \nall methods in an event listener interface. Adapter classes are useful when you want to \nreceive and process only some of the events that are handled by a particular event listener \ninterface. You can define a new class to act as an event listener by extending one of the \nadapter classes and implementing only those events in which you are interested. \nFor example, the MouseMotionAdapter class has two methods, mouseDragged ( ) and \nmouseMoved ( ) , which are the methods defined by the MouseMotionListener \n\ninterface. If you were interested in only mouse drag events, then you could simply extend \nMouseMotionAdapter and override mouseDragged ( ) . The empty implementation of \nmouseMoved ( ) would handle the mouse motion events for you.",
    "Table 24-4 lists several commonly used adapter classes in java.awt.event and notes the \n\n\ninterface that each implements. \n\nTable 24-4    Commonly Used Listener Interfaces Implemented by \nAdapter Classes",
    "The following example demonstrates an adapter. It displays a message in the status bar of \nan applet viewer or browser when the mouse is clicked or dragged. However, all other \nmouse events are silently ignored. The program has three classes. AdapterDemo extends \nApplet . Its init ( ) method creates an instance of MyMouseAdapter and registers that \nobject to receive notifications of mouse events. It also creates an instance of \nMyMouseMotionAdapter and registers that object to receive notifications of mouse \nmotion events. Both of the constructors take a reference to the applet as an argument. \nMyMouseAdapter extends MouseAdapter and overrides the mouseClicked ( ) \nmethod. The other mouse events are silently ignored by code inherited from the \nMouseAdapter class. MyMouseMotionAdapter extends MouseMotionAdapter and \noverrides the mouseDragged ( ) method. The other mouse motion event is silently ignored \nby code inherited from the MouseMotionAdapter class",
    ". MyMouseMotionAdapter extends MouseMotionAdapter and \noverrides the mouseDragged ( ) method. The other mouse motion event is silently ignored \nby code inherited from the MouseMotionAdapter class. ( MouseAdaptor also provides \nan empty implementation for MouseMotionListener . However, for the sake of \nillustration, this example handles each separately.) \nNote that both of the event listener classes save a reference to the applet. This information \nis provided as an argument to their constructors and is used later to invoke the \nshowStatus ( ) method.",
    "As you can see by looking at the program, not having to implement all of the methods \ndefined by the MouseMotionListener and MouseListener interfaces saves you a \n\nconsiderable amount of effort and prevents your code from becoming cluttered with empty \nmethods. As an exercise, you might want to try rewriting one of the keyboard input \nexamples shown earlier so that it uses a KeyAdapter . \n\n\nInner Classes",
    "In Chapter 7, the basics of inner classes were explained. Here, you will see why they are \nimportant. Recall that an inner class is a class defined within another class, or even within \nan expression. This section illustrates how inner classes can be used to simplify the code \nwhen using event adapter classes. \nTo understand the benefit provided by inner classes, consider the applet shown in the \nfollowing listing. It does not use an inner class. Its goal is to display the string \"Mouse \nPressed\" in the status bar of the applet viewer or browser when the mouse is pressed. There \nare two top-level classes in this program. MousePressedDemo extends Applet , and \nMyMouseAdapter extends MouseAdapter . The init ( ) method of \nMousePressedDemo instantiates MyMouseAdapter and provides this object as an \nargument to the addMouseListener ( ) method. \nNotice that a reference to the applet is supplied as an argument to the MyMouseAdapter \nconstructor",
    ". \nNotice that a reference to the applet is supplied as an argument to the MyMouseAdapter \nconstructor. This reference is stored in an instance variable for later use by the \nmousePressed ( ) method. When the mouse is pressed, it invokes the showStatus ( ) \nmethod of the applet through the stored applet reference. In other words, showStatus ( ) is \ninvoked relative to the applet reference stored by MyMouseAdapter .",
    "The following listing shows how the preceding program can be improved by using an inner \n\nclass. Here, InnerClassDemo is a top-level class that extends Applet . \nMyMouseAdapter is an inner class that extends MouseAdapter . Because \n\n\nMyMouseAdapter is defined within the scope of InnerClassDemo , it has access to all of \nthe variables and methods within the scope of that class. Therefore, the mousePressed ( ) \nmethod can call the showStatus ( ) method directly. It no longer needs to do this via a \nstored reference to the applet. Thus, it is no longer necessary to pass MyMouseAdapter ( ) \na reference to the invoking object. \n\nAnonymous Inner Classes",
    "Anonymous Inner Classes \n\nAn anonymous inner class is one that is not assigned a name. This section illustrates how \nan anonymous inner class can facilitate the writing of event handlers. Consider the applet \nshown in the following listing. As before, its goal is to display the string \"Mouse Pressed\" in \nthe status bar of the applet viewer or browser when the mouse is pressed.",
    "There is one top-level class in this program: AnonymousInnerClassDemo . The init ( ) \nmethod calls the addMouseListener ( ) method. Its argument is an expression that \ndefines and instantiates an anonymous inner class. Let\u2019s analyze this expression carefully. \nThe syntax new MouseAdapter (){\u2026} indicates to the compiler that the code between the \nbraces defines an anonymous inner class. Furthermore, that class extends MouseAdapter . \nThis new class is not named, but it is automatically instantiated when this expression is \nexecuted. \nBecause this anonymous inner class is defined within the scope of \nAnonymousInnerClassDemo , it has access to all of the variables and methods within \nthe scope of that class. Therefore, it can call the showStatus ( ) method directly. \nAs just illustrated, both named and anonymous inner classes solve some annoying problems \nin a simple yet effective way. They also allow you to create more efficient code.",
    "\uf709 \nPREV \nChapter 23: The Applet Class \n\u23ee \n\nNEXT \nChapter 25: Introducing the AWT: Working with \u2026 \u23ed \n\n\nPREV \nChapter 24: Event Handling \n\u23ee \n\nNEXT \nChapter 26: Using AWT Controls, Layout Manag\u2026 \u23ed \n\nCHAPTER \n\n25 \nIntroducing the AWT: Working with Windows, \nGraphics, and Text",
    "The Abstract Window Toolkit ( AWT ) was Java\u2019s first GUI framework, and it has been part of \nJava since version 1.0. It contains numerous classes and methods that allow you to create \nwindows and simple controls. The AWT was introduced in Chapter 23, where it was used in \nseveral short, example applets. This chapter begins a more detailed examination. Here, you \nwill learn how to create and manage windows, manage fonts, output text, and utilize \ngraphics. Chapter 26 describes various AWT controls, such as scroll bars and push buttons. \nIt also explains further aspects of Java\u2019s event handling mechanism. Chapter 27 introduces \nthe AWT\u2019s imaging subsystem. \nIt is important to state at the outset that you will seldom create GUIs based solely on the \nAWT because more powerful GUI frameworks ( Swing and JavaFX ) have been developed for \nJava. Despite this fact, the AWT remains an important part of Java. To understand why, \nconsider the following",
    ". Despite this fact, the AWT remains an important part of Java. To understand why, \nconsider the following. \nAt the time of this writing, the framework that is most widely used is Swing. Because Swing \nprovides a richer, more flexible GUI framework than does the AWT, it is easy to jump to the \nconclusion that the AWT is no longer relevant\u2014that it has been fully superseded by Swing. \nThis assumption is, however, false. Instead, an understanding of the AWT is still important \nbecause the AWT underpins Swing, with many AWT classes being used either directly or \nindirectly by Swing. As a result, a solid knowledge of the AWT is still required to use Swing \neffectively. \nJava\u2019s newest GUI framework is JavaFX. It is anticipated that, at some point in the future, \nJavaFX will replace Swing as Java\u2019s most popular GUI. Even when this occurs, however, \nmuch legacy code that relies on Swing ( and thus, the AWT ) will still need to be maintained \nfor some time to come",
    ". Even when this occurs, however, \nmuch legacy code that relies on Swing ( and thus, the AWT ) will still need to be maintained \nfor some time to come. Finally, for some types of small programs ( especially small applets ) \nthat make only minimal use of a GUI, using the AWT may still be appropriate. Therefore, \neven though the AWT constitutes Java\u2019s oldest GUI framework, a basic working knowledge",
    "of its fundamentals is still important today. \nAlthough a common use of the AWT is in applets, it is also used to create stand-alone \nwindows that run in a GUI environment, such as Windows. For the sake of convenience, \nmost of the examples in this chapter are contained in applets. The easiest way to run them \n\n\nis with the applet viewer. A few examples demonstrate the creation of stand-alone, \n\nwindowed programs, which can be executed directly. \nOne last point before beginning: The AWT is quite large and a full description would easily \nfill an entire book. Therefore, it is not possible to describe in detail every AWT class, \nmethod, or instance variable. However, this and the following chapters explain the basic \ntechniques needed to use the AWT. From there, you will be able to explore other parts of the \nAWT on your own. You will also be ready to move on to Swing.",
    "NOTE If you have not yet read Chapter 24, please do so now. It provides \nan overview of event handling, which is used by many of the examples in \nthis chapter. \n\nAWT Classes \n\nThe AWT classes are contained in the java.awt package. It is one of Java\u2019s largest packages. \nFortunately, because it is logically organized in a top-down, hierarchical fashion, it is easier \nto understand and use than you might at first believe. Table 25-1 lists some of the many \nAWT classes. \n\n\nTable 25-1    A Sampling of AWT Classes \n\nAlthough the basic structure of the AWT has been the same since Java 1.0, some of the \noriginal methods were deprecated and replaced by new ones. For backward-compatibility, \nJava still supports all the original 1.0 methods. However, because these methods are not for \n\nuse with new code, this book does not describe them. \n\n\nWindow Fundamentals",
    "use with new code, this book does not describe them. \n\n\nWindow Fundamentals \n\nThe AWT defines windows according to a class hierarchy that adds functionality and \nspecificity with each level. The two most common windows are those derived from Panel , \nwhich is used by applets, and those derived from Frame , which creates a standard \napplication window. Much of the functionality of these windows is derived from their parent \nclasses. Thus, a description of the class hierarchies relating to these two classes is \nfundamental to their understanding. Figure 25-1 shows the class hierarchy for Panel and \nFrame . Let\u2019s look at each of these classes now. \n\nFigure 25-1    The class hierarchy for Panel and Frame \n\nComponent",
    "Figure 25-1    The class hierarchy for Panel and Frame \n\nComponent \n\nAt the top of the AWT hierarchy is the Component class. Component is an abstract class \nthat encapsulates all of the attributes of a visual component. Except for menus, all user \ninterface elements that are displayed on the screen and that interact with the user are \nsubclasses of Component . It defines over a hundred public methods that are responsible \nfor managing events, such as mouse and keyboard input, positioning and sizing the window, \nand repainting. ( You already used many of these methods when you created applets in \n\nChapters 23 and 24.) A Component object is responsible for remembering the current \nforeground and background colors and the currently selected text font. \n\nContainer \n\nThe Container class is a subclass of Component . It has additional methods that allow \nother Component objects to be nested within it. Other Container objects can be stored",
    "Container \n\nThe Container class is a subclass of Component . It has additional methods that allow \nother Component objects to be nested within it. Other Container objects can be stored \n\ninside of a Container ( since they are themselves instances of Component ). This makes \nfor a multileveled containment system. A container is responsible for laying out ( that is, \npositioning ) any components that it contains. It does this through the use of various layout \n\n\nmanagers, which you will learn about in Chapter 26. \n\nPanel",
    "managers, which you will learn about in Chapter 26. \n\nPanel \n\nThe Panel class is a concrete subclass of Container . A Panel may be thought of as a \nrecursively nestable, concrete screen component. Panel is the superclass for Applet . When \nscreen output is directed to an applet, it is drawn on the surface of a Panel object. In \nessence, a Panel is a window that does not contain a title bar, menu bar, or border. This is \nwhy you don\u2019t see these items when an applet is run inside a browser. When you run an \napplet using an applet viewer, the applet viewer provides the title and border. \nOther components can be added to a Panel object by its add ( ) method ( inherited from \nContainer ). Once these components have been added, you can position and resize them \nmanually using the setLocation ( ) , setSize ( ) , setPreferredSize ( ) , or setBounds ( ) \nmethods defined by Component . \n\nWindow",
    "Window \n\nThe Window class creates a top-level window. A top-level window is not contained within \nany other object ; it sits directly on the desktop. Generally, you won\u2019t create Window \nobjects directly. Instead, you will use a subclass of Window called Frame , described next. \n\nFrame \n\nFrame encapsulates what is commonly thought of as a \u201cwindow.\u201d It is a subclass of \nWindow and has a title bar, menu bar, borders, and resizing corners. The precise look of a \nFrame will differ among environments. A number of environments are reflected in the \nscreen captures shown throughout this book. \n\nCanvas \n\nAlthough it is not part of the hierarchy for applet or frame windows, there is one other type \n\nof window that you will find valuable: Canvas . Derived from Component , Canvas \nencapsulates a blank window upon which you can draw. You will see an example of Canvas \nlater in this book. \n\nWorking with Frame Windows",
    "Working with Frame Windows \n\nIn addition to the applet, the type of AWT-based window you will most often create is \nderived from Frame . You will use it to create child windows within applets, and top-level \nor child windows for stand-alone applications. As mentioned, it creates a standard-style \nwindow. \nHere are two of Frame \u2019s constructors: \n\nFrame ( ) throws HeadlessException \n\nFrame ( String title ) throws HeadlessException \n\nThe first form creates a standard window that does not contain a title. The second \nform creates a window with the title specified by title . Notice that you cannot \n\n\nspecify the dimensions of the window. Instead, you must set the size of the window \nafter it has been created. A HeadlessException is thrown if an attempt is made \nto create a Frame instance in an environment that does not support user \ninteraction. \nThere are several key methods you will use when working with Frame windows. They are \nexamined here.",
    "Setting the Window\u2019s Dimensions \n\nThe setSize ( ) method is used to set the dimensions of the window. Its signature is shown \nhere: \n\nvoid setSize ( int newWidth , int newHeight ) \nvoid setSize ( Dimension newSize ) \n\nThe new size of the window is specified by newWidth and newHeight , or by the \nwidth and height fields of the Dimension object passed in newSize . The \ndimensions are specified in terms of pixels. \nThe getSize ( ) method is used to obtain the current size of a window. One of its forms is \nshown here: \n\nDimension getSize ( ) \n\nThis method returns the current size of the window contained within the width \nand height fields of a Dimension object. \n\nHiding and Showing a Window \n\nAfter a frame window has been created, it will not be visible until you call setVisible ( ) . Its \nsignature is shown here: \n\nvoid setVisible ( boolean visibleFlag ) \n\nThe component is visible if the argument to this method is true . Otherwise, it is \nhidden. \n\nSetting a Window\u2019s Title",
    "void setVisible ( boolean visibleFlag ) \n\nThe component is visible if the argument to this method is true . Otherwise, it is \nhidden. \n\nSetting a Window\u2019s Title \n\nYou can change the title in a frame window using setTitle ( ) , which has this general form: \n\nvoid setTitle ( String newTitle ) \n\nHere, newTitle is the new title for the window. \n\nClosing a Frame Window \n\nWhen using a frame window, your program must remove that window from the screen \nwhen it is closed, by calling setVisible ( false ) . To intercept a window-close event, you \nmust implement the windowClosing ( ) method of the WindowListener interface. \nInside windowClosing ( ) , you must remove the window from the screen. The example in \nthe next section illustrates this technique. \n\n\nCreating a Frame Window in an AWT-Based Applet",
    "While it is possible to simply create a window by creating an instance of Frame , you will \nseldom do so, because you will not be able to do much with it. For example, you will not be \nable to receive or process events that occur within it or easily output information to it. Most \nof the time, you will create a subclass of Frame . Doing so lets you override Frame \u2019s \nmethods and provide event handling. \nCreating a new frame window from within an AWT-based applet is actually quite easy. First, \ncreate a subclass of Frame . Next, override any of the standard applet methods, such as \ninit ( ) , start ( ) , and stop ( ) , to show or hide the frame as needed. Finally, implement the \nwindowClosing ( ) method of the WindowListener interface, calling setVisible ( false ) \nwhen the window is closed. \nOnce you have defined a Frame subclass, you can create an object of that class. This causes \na frame window to come into existence, but it will not be initially visible",
    ". \nOnce you have defined a Frame subclass, you can create an object of that class. This causes \na frame window to come into existence, but it will not be initially visible. You make it visible \nby calling setVisible ( ) . When created, the window is given a default height and width. You \ncan set the size of the window explicitly by calling the setSize ( ) method. \nThe following applet creates a subclass of Frame called SampleFrame . A window of this \nsubclass is instantiated within the init ( ) method of AppletFrame . Notice that \nSampleFrame calls Frame \u2019s constructor. This causes a standard frame window to be \ncreated with the title passed in title . This example overrides the applet\u2019s start ( ) and stop ( \n) methods so that they show and hide the child window, respectively. This causes the \nwindow to be removed automatically when you terminate the applet, when you close the \nwindow, or, if using a browser, when you move to another page",
    ". This causes the \nwindow to be removed automatically when you terminate the applet, when you close the \nwindow, or, if using a browser, when you move to another page. It also causes the child \nwindow to be shown when the browser returns to the applet.",
    "Sample output from this program is shown here: \n\n\nHandling Events in a Frame Window \n\nSince Frame is a subclass of Component , it inherits all the capabilities defined by \nComponent . This means that you can use and manage a frame window just like you \nmanage an applet\u2019s main window, as described earlier in this book. For example, you can \noverride paint ( ) to display output, call repaint ( ) when you need to restore the window, \nand add event handlers. Whenever an event occurs in a window, the event handlers defined \nby that window will be called. Each window handles its own events. For example, the \nfollowing program creates a window that responds to mouse events. The main applet \nwindow also responds to mouse events. When you experiment with this program, you will \nsee that mouse events are sent to the window in which the event occurs. \n\n\n\n\n\n\n\n\nSample output from this program is shown here:",
    "Sample output from this program is shown here: \n\n\nCreating a Windowed Program \n\nAlthough creating applets is a common use for Java\u2019s AWT, it is also possible to create \nstand-alone AWT-based applications. To do this, simply create an instance of the window or \nwindows you need inside main ( ) . For example, the following program creates a frame \nwindow that responds to mouse clicks and keystrokes: \n\n\n\n\nSample output from this program is shown here: \n\nOnce created, a frame window takes on a life of its own. Notice that main ( ) ends with the \n\n\ncall to appwin.setVisible ( true ) . However, the program keeps running until you close the \nwindow. In essence, when creating a windowed application, you will use main ( ) to launch \nits top-level window. After that, your program will function as a GUI-based application, not \nlike the console-based programs used earlier.",
    "Displaying Information Within a Window \n\nIn the most general sense, a window is a container for information. Although we have \nalready output small amounts of text to a window in the preceding examples, we have not \nbegun to take advantage of a window\u2019s ability to present high-quality text and graphics. \nIndeed, much of the power of the AWT comes from its support for these items. For this \nreason, the remainder of this chapter introduces the AWT\u2019s text-, graphics-, and fonthandling capabilities. As you will see, they are both powerful and flexible. \n\nIntroducing Graphics",
    "Introducing Graphics \n\nThe AWT includes several methods that support graphics. All graphics are drawn relative to \na window. This can be the main window of an applet, a child window of an applet, or a \nstand-alone application window. ( These methods are also supported by Swing-based \nwindows.) The origin of each window is at the top-left corner and is 0,0. Coordinates are \nspecified in pixels. All output to a window takes place through a graphics context . \nA graphics context is encapsulated by the Graphics class. Here are two ways in which a \ngraphics context can be obtained: \n\n\u2022  It is passed to a method, such as paint ( ) or update ( ) , as an argument. \n\n\u2022  It is returned by the getGraphics ( ) method of Component .",
    "\u2022  It is passed to a method, such as paint ( ) or update ( ) , as an argument. \n\n\u2022  It is returned by the getGraphics ( ) method of Component . \n\nAmong other things, the Graphics class defines a number of methods that draw \nvarious types of objects, such as lines, rectangles, and arcs. In several cases, objects \ncan be drawn edge-only or filled. Objects are drawn and filled in the currently \nselected color, which is black by default. When a graphics object is drawn that \nexceeds the dimensions of the window, output is automatically clipped. A sampling \nof the drawing methods supported by Graphics is presented here. \n\nNOTE With the release of version 1.2, the graphics capabilities of Java",
    "NOTE With the release of version 1.2, the graphics capabilities of Java \n\nwere expanded by the inclusion of several new classes. One of these is \nGraphics2D , which extends Graphics. Graphics2D supports several \npowerful enhancements to the basic capabilities provided by Graphics . \nTo gain access to this extended functionality, you must cast the graphics \ncontext obtained from a method such as paint ( ) , to Graphics2D . \nAlthough the basic graphics functions supported by Graphics are \n\n\nadequate for the purposes of this book, Graphics2D is a class that you \nwill want to explore fully on your own if you will be programming \nsophisticated graphics applications. \n\nDrawing Lines \n\nLines are drawn by means of the drawLine ( ) method, shown here: \n\nvoid drawLine ( int startX , int startY , int endX , int endY ) \n\ndrawLine ( ) displays a line in the current drawing color that begins at startX, \nstartY and ends at endX, endY . \n\nDrawing Rectangles",
    "drawLine ( ) displays a line in the current drawing color that begins at startX, \nstartY and ends at endX, endY . \n\nDrawing Rectangles \n\nThe drawRect ( ) and fillRect ( ) methods display an outlined and filled rectangle, \nrespectively. They are shown here: \n\nvoid drawRect ( int left , int top , int width , int height ) \nvoid fillRect ( int left , int top , int width , int height ) \n\nThe upper-left corner of the rectangle is at left , top . The dimensions of the \nrectangle are specified by width and height . \nTo draw a rounded rectangle, use drawRoundRect ( ) or fillRoundRect ( ) , both shown \nhere: \n\nA rounded rectangle has rounded corners. The upper-left corner of the rectangle is \nat left , top . The dimensions of the rectangle are specified by width and height . The \ndiameter of the rounding arc along the X axis is specified by xDiam . The diameter \nof the rounding arc along the Y axis is specified by yDiam . \n\nDrawing Ellipses and Circles",
    "Drawing Ellipses and Circles \n\nTo draw an ellipse, use drawOval ( ) . To fill an ellipse, use fillOval ( ) . These methods are \nshown here: \n\nvoid drawOval ( int left , int top , int width , int height ) \nvoid fillOval ( int left , int top , int width , int height ) \n\nThe ellipse is drawn within a bounding rectangle whose upper-left corner is \n\nspecified by left, top and whose width and height are specified by width and \nheight . To draw a circle, specify a square as the bounding rectangle. \n\n\nDrawing Arcs \n\nArcs can be drawn with drawArc ( ) and fillArc ( ) , shown here:",
    "Drawing Arcs \n\nArcs can be drawn with drawArc ( ) and fillArc ( ) , shown here: \n\nThe arc is bounded by the rectangle whose upper-left corner is specified by left, top and \nwhose width and height are specified by width and height . The arc is drawn from startAngle \nthrough the angular distance specified by sweepAngle . Angles are specified in degrees. Zero \ndegrees is on the horizontal, at the three o\u2019clock position. The arc is drawn counterclockwise \nif sweepAngle is positive, and clockwise if sweepAngle is negative. Therefore, to draw an arc \nfrom twelve o\u2019clock to six o\u2019clock, the start angle would be 90 and the sweep angle 180. \n\nDrawing Polygons \n\nIt is possible to draw arbitrarily shaped figures using drawPolygon ( ) and fillPolygon ( ) , \nshown here: \n\nvoid drawPolygon ( int x [ ], int y [ ], int numPoints ) \nvoid fillPolygon ( int x [ ], int y [ ], int numPoints )",
    "void drawPolygon ( int x [ ], int y [ ], int numPoints ) \nvoid fillPolygon ( int x [ ], int y [ ], int numPoints ) \n\nThe polygon\u2019s endpoints are specified by the coordinate pairs contained within the \nx and y arrays. The number of points defined by these arrays is specified by \nnumPoints . There are alternative forms of these methods in which the polygon is \nspecified by a Polygon object. \n\nDemonstrating the Drawing Methods \n\nThe following program demonstrates the drawing methods just described. \n\n\nSample output is shown in Figure 25-2. \n\n\nFigure 25-2    Sample output from the GraphicsDemo program \n\nSizing Graphics \n\nOften, you will want to size a graphics object to fit the current size of the window in which it \nis drawn. To do so, first obtain the current dimensions of the window by calling getSize ( ) \non the window object. It returns the dimensions of the window encapsulated within a",
    "Dimension object. Once you have the current size of the window, you can scale your \ngraphical output accordingly. \nTo demonstrate this technique, here is an applet that will start as a 200\u00d7200-pixel square \nand grow by 25 pixels in width and height with each mouse click until the applet gets larger \nthan 500\u00d7500. At that point, the next click will return it to 200\u00d7200, and the process starts \nover. \n\n\nWithin the window, a rectangle is drawn around the inner border of the window ; within that \n\nrectangle, an X is drawn so that it fills the window. This applet works in appletviewer , but \nit may not work in a browser window. \n\nWorking with Color",
    "rectangle, an X is drawn so that it fills the window. This applet works in appletviewer , but \nit may not work in a browser window. \n\nWorking with Color \n\nJava supports color in a portable, device-independent fashion. The AWT color system \nallows you to specify any color you want. It then finds the best match for that color, given \nthe limits of the display hardware currently executing your program or applet. Thus, your \ncode does not need to be concerned with the differences in the way color is supported by \nvarious hardware devices. Color is encapsulated by the Color class. \nAs you saw in Chapter 23, Color defines several constants ( for example, Color.black ) to \nspecify a number of common colors. You can also create your own colors, using one of the \ncolor constructors. Three commonly used forms are shown here: \n\n\nColor ( int red , int green , int blue ) \nColor ( int rgbValue ) \nColor ( float red , float green , float blue )",
    "Color ( int red , int green , int blue ) \nColor ( int rgbValue ) \nColor ( float red , float green , float blue ) \n\nThe first constructor takes three integers that specify the color as a mix of red, \ngreen, and blue. These values must be between 0 and 255, as in this example: \n\nThe second color constructor takes a single integer that contains the mix of red, green, and \nblue packed into an integer. The integer is organized with red in bits 16 to 23, green in bits \n8 to 15, and blue in bits 0 to 7. Here is an example of this constructor: \n\nThe final constructor, Color ( float, float, float ) , takes three float values ( between 0.0 and \n1.0 ) that specify the relative mix of red, green, and blue. \nOnce you have created a color, you can use it to set the foreground and/or background color \nby using the setForeground ( ) and setBackground ( ) methods described in Chapter 23. \nYou can also select it as the current drawing color. \n\nColor Methods",
    "Color Methods \n\nThe Color class defines several methods that help manipulate colors. Several are examined \nhere. \n\nUsing Hue, Saturation, and Brightness \n\nThe hue-saturation-brightness ( HSB ) color model is an alternative to red-green-blue ( RGB ) \nfor specifying particular colors. Figuratively, hue is a wheel of color. The hue can be \nspecified with a number between 0.0 and 1.0, which is used to obtain an angle into the color \nwheel. ( The principal colors are approximately red, orange, yellow, green, blue, indigo, and \nviolet.) Saturation is another scale ranging from 0.0 to 1.0, representing light pastels to \nintense hues. Brightness values also range from 0.0 to 1.0, where 1 is bright white and 0 is \nblack. Color supplies two methods that let you convert between RGB and HSB. They are \nshown here: \n\nstatic int HSBtoRGB ( float hue , float saturation , float brightness ) \n\nstatic float[ ] RGBtoHSB ( int red , int green , int blue , float values [ ])",
    "static int HSBtoRGB ( float hue , float saturation , float brightness ) \n\nstatic float[ ] RGBtoHSB ( int red , int green , int blue , float values [ ]) \n\nHSBtoRGB ( ) returns a packed RGB value compatible with the Color ( int ) \nconstructor. RGBtoHSB ( ) returns a float array of HSB values corresponding to \nRGB integers. If values is not null , then this array is given the HSB values and \nreturned. Otherwise, a new array is created and the HSB values are returned in it. \nIn either case, the array contains the hue at index 0, saturation at index 1, and \n\n\nbrightness at index 2. \n\ngetRed ( ), getGreen ( ), getBlue ( ) \nYou can obtain the red, green, and blue components of a color independently using getRed ( \n) , getGreen ( ) , and getBlue ( ) , shown here: \n\nint getRed ( ) \nint getGreen ( ) \nint getBlue ( ) \n\nEach of these methods returns the RGB color component found in the invoking \nColor object in the lower 8 bits of an integer.",
    "int getRed ( ) \nint getGreen ( ) \nint getBlue ( ) \n\nEach of these methods returns the RGB color component found in the invoking \nColor object in the lower 8 bits of an integer. \n\ngetRGB ( ) \nTo obtain a packed, RGB representation of a color, use getRGB ( ) , shown here: \n\nint getRGB ( ) \n\nThe return value is organized as described earlier. \n\nSetting the Current Graphics Color \n\nBy default, graphics objects are drawn in the current foreground color. You can change this \ncolor by calling the Graphics method setColor ( ) : \n\nvoid setColor ( Color newColor ) \n\nHere, newColor specifies the new drawing color. \nYou can obtain the current color by calling getColor ( ) , shown here: \n\nColor getColor ( ) \n\nA Color Demonstration Applet \n\nThe following applet constructs several colors and draws various objects using these colors: \n\n\nSetting the Paint Mode",
    "Color getColor ( ) \n\nA Color Demonstration Applet \n\nThe following applet constructs several colors and draws various objects using these colors: \n\n\nSetting the Paint Mode \n\nThe paint mode determines how objects are drawn in a window. By default, new output to a \nwindow overwrites any preexisting contents. However, it is possible to have new objects \nXORed onto the window by using setXORMode ( ) , as follows: \n\nvoid setXORMode ( Color xorColor ) \n\nHere, xorColor specifies the color that will be XORed to the window when an \n\n\nobject is drawn. The advantage of XOR mode is that the new object is always \n\nguaranteed to be visible no matter what color the object is drawn over. \nTo return to overwrite mode, call setPaintMode ( ) , shown here: \n\nvoid setPaintMode ( )",
    "guaranteed to be visible no matter what color the object is drawn over. \nTo return to overwrite mode, call setPaintMode ( ) , shown here: \n\nvoid setPaintMode ( ) \n\nIn general, you will want to use overwrite mode for normal output, and XOR mode \nfor special purposes. For example, the following program displays cross hairs that \ntrack the mouse pointer. The cross hairs are XORed onto the window and are \nalways visible, no matter what the underlying color is. \n\n\nSample output from this program is shown here: \n\n\nWorking with Fonts",
    "Sample output from this program is shown here: \n\n\nWorking with Fonts \n\nThe AWT supports multiple type fonts. Years ago, fonts emerged from the domain of \ntraditional typesetting to become an important part of computer-generated documents and \ndisplays. The AWT provides flexibility by abstracting font-manipulation operations and \nallowing for dynamic selection of fonts. \nFonts have a family name, a logical font name, and a face name. The family name is the \ngeneral name of the font, such as Courier. The logical name specifies a name, such as \nMonospaced, that is linked to an actual font at runtime. The face name specifies a specific \nfont, such as Courier Italic. \nFonts are encapsulated by the Font class. Several of the methods defined by Font are listed \nin Table 25-2. \n\n\nTable 25-2    A Sampling of Methods Defined by Font \n\nThe Font class defines these protected variables: \n\nVariable \nMeaning \n\nString name \nName of the font",
    "Table 25-2    A Sampling of Methods Defined by Font \n\nThe Font class defines these protected variables: \n\nVariable \nMeaning \n\nString name \nName of the font \n\nfloat pointSize \nSize of the font in points \n\nint size \nSize of the font in points \n\nint style \nFont style \n\nSeveral static fields are also defined. \n\nDetermining the Available Fonts \n\nWhen working with fonts, often you need to know which fonts are available on your \nmachine. To obtain this information, you can use the getAvailableFontFamilyNames ( ) \nmethod defined by the GraphicsEnvironment class. It is shown here: \n\nString[ ] getAvailableFontFamilyNames ( ) \n\nThis method returns an array of strings that contains the names of the available \nfont families. \n\n\nIn addition, the getAllFonts ( ) method is defined by the GraphicsEnvironment class. It \nis shown here: \n\nFont[ ] getAllFonts ( )",
    "In addition, the getAllFonts ( ) method is defined by the GraphicsEnvironment class. It \nis shown here: \n\nFont[ ] getAllFonts ( ) \n\nThis method returns an array of Font objects for all of the available fonts. \nSince these methods are members of GraphicsEnvironment , you need a \nGraphicsEnvironment reference to call them. You can obtain this reference by using the \ngetLocalGraphicsEnvironment ( ) static method, which is defined by \nGraphicsEnvironment . It is shown here: \n\nstatic GraphicsEnvironment getLocalGraphicsEnvironment ( ) \n\nHere is an applet that shows how to obtain the names of the available font \nfamilies: \n\nSample output from this program is shown next. However, when you run this program, you \nmay see a different list of fonts than the one shown in this illustration. \n\n\nCreating and Selecting a Font \n\nTo create a new font, construct a Font object that describes that font. One Font \nconstructor has this general form:",
    "Creating and Selecting a Font \n\nTo create a new font, construct a Font object that describes that font. One Font \nconstructor has this general form: \n\nFont ( String fontName , int fontStyle , int pointSize )",
    "Here, fontName specifies the name of the desired font. The name can be specified \nusing either the logical or face name. All Java environments will support the \nfollowing fonts: Dialog, DialogInput, SansSerif, Serif, and Monospaced. Dialog is \nthe font used by your system\u2019s dialog boxes. Dialog is also the default if you don\u2019t \nexplicitly set a font. You can also use any other fonts supported by your particular \nenvironment, but be careful\u2014these other fonts may not be universally available. \nThe style of the font is specified by fontStyle . It may consist of one or more of these three \nconstants: Font.PLAIN , Font.BOLD , and Font.ITALIC . To combine styles, OR them \ntogether. For example, Font.BOLD | Font.ITALIC specifies a bold, italics style. \nThe size, in points, of the font is specified by pointSize . \nTo use a font that you have created, you must select it using setFont ( ) , which is defined by \nComponent . It has this general form: \n\nvoid setFont ( Font fontObj )",
    "void setFont ( Font fontObj ) \n\nHere, fontObj is the object that contains the desired font. \nThe following program outputs a sample of each standard font. Each time you click the \nmouse within its window, a new font is selected and its name is displayed. \n\n\nSample output from this program is shown here: \n\n\nObtaining Font Information \n\nSuppose you want to obtain information about the currently selected font. To do this, you \nmust first get the current font by calling getFont ( ) . This method is defined by the \nGraphics class, as shown here: \n\nFont getFont ( ) \n\nOnce you have obtained the currently selected font, you can retrieve information \nabout it using various methods defined by Font . For example, this applet displays \nthe name, family, size, and style of the currently selected font: \n\n\nManaging Text Output Using FontMetrics",
    "Managing Text Output Using FontMetrics \n\nAs just explained, Java supports a number of fonts. For most fonts, characters are not all \nthe same dimension\u2014most fonts are proportional. Also, the height of each character, the \nlength of descenders ( the hanging parts of letters, such as y ), and the amount of space \nbetween horizontal lines vary from font to font. Further, the point size of a font can be \nchanged. That these ( and other ) attributes are variable would not be of too much \nconsequence except that Java demands that you, the programmer, manually manage \nvirtually all text output. \nGiven that the size of each font may differ and that fonts may be changed while your \n\nprogram is executing, there must be some way to determine the dimensions and various",
    "program is executing, there must be some way to determine the dimensions and various \n\nother attributes of the currently selected font. For example, to write one line of text after \nanother implies that you have some way of knowing how tall the font is and how many \npixels are needed between lines. To fill this need, the AWT includes the FontMetrics class, \nwhich encapsulates various information about a font. Let\u2019s begin by defining the common \nterminology used when describing fonts: \n\n\nHeight \nThe top-to-bottom size of a line of text \n\nBaseline \nThe line that the bottoms of characters are aligned to ( not counting descent ) \n\nAscent \nThe distance from the baseline to the top of a character \n\nDescent \nThe distance from the baseline to the bottom of a character \n\nLeading \nThe distance between the bottom of one line of text and the top of the next",
    "As you know, we have used the drawString ( ) method in many of the previous examples. \nIt paints a string in the current font and color, beginning at a specified location. However, \nthis location is at the left edge of the baseline of the characters, not at the upper-left corner \nas is usual with other drawing methods. It is a common error to draw a string at the same \ncoordinate that you would draw a box. For example, if you were to draw a rectangle at \ncoordinate 0,0, you would see a full rectangle. If you were to draw the string \u201cTypesetting\u201d \nat 0,0, you would only see the tails ( or descenders ) of the y, p , and g . As you will see, by \nusing font metrics, you can determine the proper placement of each string that you display. \nFontMetrics defines several methods that help you manage text output. Several commonly \nused ones are listed in Table 25-3. These methods help you properly display text in a \nwindow. Let\u2019s look at some examples.",
    "Table 25-3    A Sampling of Methods Defined by FontMetrics \n\nDisplaying Multiple Lines of Text \n\nPerhaps the most common use of FontMetrics is to determine the spacing between lines of",
    "text. The second most common use is to determine the length of a string that is being \ndisplayed. Here, you will see how to accomplish these tasks. \nIn general, to display multiple lines of text, your program must manually keep track of the \ncurrent output position. Each time a newline is desired, the Y coordinate must be advanced \nto the beginning of the next line. Each time a string is displayed, the X coordinate must be \nset to the point at which the string ends. This allows the next string to be written so that it \nbegins at the end of the preceding one. \nTo determine the spacing between lines, you can use the value returned by getLeading ( ) . \nTo determine the total height of the font, add the value returned by getAscent ( ) to the \nvalue returned by getDescent ( ) . You can then use these values to position each line of text \nyou output. However, in many cases, you will not need to use these individual values",
    ". You can then use these values to position each line of text \nyou output. However, in many cases, you will not need to use these individual values. Often, \nall that you will need to know is the total height of a line, which is the sum of the leading \nspace and the font\u2019s ascent and descent values. The easiest way to obtain this value is to call \ngetHeight ( ) . Simply increment the Y coordinate by this value each time you want to \nadvance to the next line when outputting text. \nTo start output at the end of previous output on the same line, you must know the length, in \npixels, of each string that you display. To obtain this value, call stringWidth ( ) . You can \nuse this value to advance the X coordinate each time you display a line. \nThe following applet shows how to output multiple lines of text in a window. It also displays \nmultiple sentences on the same line. Notice the variables curX and curY . They keep track \nof the current text output position.",
    "Sample output from this program is shown here: \n\n\nCentering Text \n\nHere is an example that centers text, left to right, top to bottom, in a window. It obtains the \nascent, descent, and width of the string and computes the position at which it must be \ndisplayed to be centered. \n\nFollowing is a sample output from this program: \n\n\nMultiline Text Alignment",
    "Following is a sample output from this program: \n\n\nMultiline Text Alignment \n\nWhen using a word processor, it is common for text to be aligned so that one or more of the \nedges of the text make a straight line. For example, most word processors can left-justify \nand/or right-justify text. Most can also center text. In the following program, you will see \nhow to accomplish these actions. \nIn the program, the string to be justified is broken into individual words. For each word, the \nprogram keeps track of its length in the current font and automatically advances to the next \nline if the word will not fit on the current line. Each completed line is displayed in the \nwindow in the currently selected alignment style. Each time you click the mouse in the \napplet\u2019s window, the alignment style is changed. Sample output from this program is shown \nhere:",
    "Let\u2019s take a closer look at how this applet works. The applet first creates several constants \nthat will be used to determine the alignment style, and then declares several variables. The \ninit ( ) method obtains the text that will be displayed. It then initializes the font size in a \ntry - catch block, which will set the font size to 14 if the fontSize parameter is missing from \nthe HTML. The text parameter is a long string of text, with the HTML tag <P> as a \nparagraph separator. \nThe update ( ) method is the engine for this example. It sets the font and gets the baseline \nand font height from a font metrics object. Next, it creates a StringTokenizer and uses it \nto retrieve the next token ( a string separated by whitespace ) from the string specified by \ntext . If the next token is <P> , it advances the vertical spacing. Otherwise, update ( ) \nchecks to see if the length of this token in the current font will go beyond the width of the \ncolumn",
    ". If the next token is <P> , it advances the vertical spacing. Otherwise, update ( ) \nchecks to see if the length of this token in the current font will go beyond the width of the \ncolumn. If the line is full of text or if there are no more tokens, the line is output by a \ncustom version of drawString ( ) . \nThe first three cases in drawString ( ) are simple. Each aligns the string that is passed in \nline to the left or right edge or to the center of the column, depending upon the alignment \nstyle. The LEFTRIGHT case aligns both the left and right sides of the string. This means \nthat we need to calculate the remaining whitespace ( the difference between the width of the \nstring and the width of the column ) and distribute that space between each of the words. \nThe last method in this class advances the alignment style each time you click the mouse on",
    "the applet\u2019s window. \n\n\uf709 \nPREV \nChapter 24: Event Handling \n\u23ee \n\nNEXT \nChapter 26: Using AWT Controls, Layout Manag\u2026 \u23ed \n\n\n\n\nPREV \nChapter 25: Introducing the AWT: Working with \u2026 \n\u23ee \n\nNEXT \nChapter 27: Images \n\u23ed \n\nCHAPTER \n\n26 \nUsing AWT Controls, Layout Managers, and Menus",
    "This chapter continues our overview of the Abstract Window Toolkit ( AWT ). It begins with a \nlook at several of the AWT\u2019s controls and layout managers. It then discusses menus and the \nmenu bar. The chapter also includes a discussion of two high-level components: the dialog \nbox and the file dialog box. It concludes with another look at event handling. \nControls are components that allow a user to interact with your application in various ways \n\u2014for example, a commonly used control is the push button. A layout manager \nautomatically positions components within a container. Thus, the appearance of a window is \ndetermined by a combination of the controls that it contains and the layout manager used to \nposition them. \nIn addition to the controls, a frame window can also include a standard-style menu bar . \nEach entry in a menu bar activates a drop-down menu of options from which the user can \nchoose. This constitutes the main menu of an application",
    ". \nEach entry in a menu bar activates a drop-down menu of options from which the user can \nchoose. This constitutes the main menu of an application. As a general rule, a menu bar is \npositioned at the top of a window. Although different in appearance, menu bars are handled \nin much the same way as are the other controls. \nWhile it is possible to manually position components within a window, doing so is quite \ntedious. The layout manager automates this task. For the first part of this chapter, which \nintroduces various controls, the default layout manager will be used. This displays \ncomponents in a container using left-to-right, top-to-bottom organization. Once the \ncontrols have been covered, several layout managers will be examined. There, you will see \nways to better manage the positioning of controls",
    ". Once the \ncontrols have been covered, several layout managers will be examined. There, you will see \nways to better manage the positioning of controls. \nBefore continuing, it is important to emphasize that today you will seldom create GUIs \nbased solely on the AWT because more powerful GUI frameworks ( Swing and JavaFX ) have \nbeen developed for Java. However, the material presented here remains important for the",
    "following reasons. First, much of the information and many of the techniques related to \ncontrols and event handling are generalizable to the other Java GUI frameworks. ( As \nmentioned in the previous chapter, Swing is built upon the AWT.) Second, the layout \nmanagers described here can also be used by Swing. Third, for some small applications, the \nAWT components might be the appropriate choice. Finally, and perhaps most importantly, \nyou may need to maintain or upgrade legacy code that uses the AWT. Therefore, a basic \n\n\nunderstanding of the AWT is important for all Java programmers. \n\nAWT Control Fundamentals \n\nThe AWT supports the following types of controls: \n\n\u2022  Labels \n\n\u2022  Push buttons \n\n\u2022  Check boxes \n\n\u2022  Choice lists \n\n\u2022  Lists \n\n\u2022  Scroll bars \n\n\u2022  Text Editing",
    "AWT Control Fundamentals \n\nThe AWT supports the following types of controls: \n\n\u2022  Labels \n\n\u2022  Push buttons \n\n\u2022  Check boxes \n\n\u2022  Choice lists \n\n\u2022  Lists \n\n\u2022  Scroll bars \n\n\u2022  Text Editing \n\nThese controls are subclasses of Component . Although this is not a particularly \nrich set of controls, it is sufficient for simple applications. ( Note that both Swing \nand JavaFX provide a substantially larger, more sophisticated set of controls.) \n\nAdding and Removing Controls \n\nTo include a control in a window, you must add it to the window. To do this, you must first \ncreate an instance of the desired control and then add it to a window by calling add ( ) , \nwhich is defined by Container . The add ( ) method has several forms. The following form \nis the one that is used for the first part of this chapter: \n\nComponent add ( Component compRef ) \n\nHere, compRef is a reference to an instance of the control that you want to add. A",
    "Component add ( Component compRef ) \n\nHere, compRef is a reference to an instance of the control that you want to add. A \n\nreference to the object is returned. Once a control has been added, it will \nautomatically be visible whenever its parent window is displayed. \nSometimes you will want to remove a control from a window when the control is no longer \nneeded. To do this, call remove ( ) . This method is also defined by Container . Here is one \nof its forms: \n\nvoid remove ( Component compRef ) \n\nHere, compRef is a reference to the control you want to remove. You can remove \nall controls by calling removeAll ( ) . \n\nResponding to Controls",
    "void remove ( Component compRef ) \n\nHere, compRef is a reference to the control you want to remove. You can remove \nall controls by calling removeAll ( ) . \n\nResponding to Controls \n\nExcept for labels, which are passive, all other controls generate events when they are \naccessed by the user. For example, when the user clicks on a push button, an event is sent \nthat identifies the push button. In general, your program simply implements the appropriate \ninterface and then registers an event listener for each control that you need to monitor. As \nexplained in Chapter 24, once a listener has been installed, events are automatically sent to \nit. In the sections that follow, the appropriate interface for each control is specified. \n\n\nThe HeadlessException",
    "The HeadlessException \n\nMost of the AWT controls described in this chapter have constructors that can throw a \nHeadlessException when an attempt is made to instantiate a GUI component in a noninteractive environment ( such as one in which no display, mouse, or keyboard is present ). \nYou can use this exception to write code that can adapt to non-interactive environments. ( Of \ncourse, this is not always possible.) This exception is not handled by the programs in this \nchapter because an interactive environment is required to demonstrate the AWT controls. \n\nLabels \n\nThe easiest control to use is a label. A label is an object of type Label , and it contains a \nstring, which it displays. Labels are passive controls that do not support any interaction with \nthe user. Label defines the following constructors: \n\nLabel ( ) throws HeadlessException \nLabel ( String str ) throws HeadlessException \nLabel ( String str , int how ) throws HeadlessException",
    "Label ( ) throws HeadlessException \nLabel ( String str ) throws HeadlessException \nLabel ( String str , int how ) throws HeadlessException \n\nThe first version creates a blank label. The second version creates a label that \ncontains the string specified by str . This string is left-justified. The third version \ncreates a label that contains the string specified by str using the alignment \nspecified by how . The value of how must be one of these three constants: \nLabel.LEFT , Label.RIGHT , or Label.CENTER . \nYou can set or change the text in a label by using the setText ( ) method. You can obtain the \ncurrent label by calling getText ( ) . These methods are shown here: \n\nvoid setText ( String str ) \nString getText ( ) \n\nFor setText ( ) , str specifies the new label. For getText ( ) , the current label is",
    "void setText ( String str ) \nString getText ( ) \n\nFor setText ( ) , str specifies the new label. For getText ( ) , the current label is \n\nreturned. \nYou can set the alignment of the string within the label by calling setAlignment ( ) . To \nobtain the current alignment, call getAlignment ( ) . The methods are as follows: \n\nvoid setAlignment ( int how ) \nint getAlignment ( ) \n\nHere, how must be one of the alignment constants shown earlier. \n\nThe following example creates three labels and adds them to an applet window: \n\n\nHere is sample output from the LabelDemo applet. Notice that the labels are \norganized in the window by the default layout manager. Later, you will see how to \ncontrol more precisely the placement of the labels. \n\nUsing Buttons",
    "Using Buttons \n\nPerhaps the most widely used control is the push button. A push button is a component that \ncontains a label and that generates an event when it is pressed. Push buttons are objects of \ntype Button . Button defines these two constructors: \n\nButton ( ) throws HeadlessException \nButton ( String str ) throws HeadlessException \n\nThe first version creates an empty button. The second creates a button that \ncontains str as a label. \nAfter a button has been created, you can set its label by calling setLabel ( ) . You can \nretrieve its label by calling getLabel ( ) . These methods are as follows: \n\n\nvoid setLabel ( String str ) \nString getLabel ( ) \n\nHere, str becomes the new label for the button. \n\nHandling Buttons",
    "Each time a button is pressed, an action event is generated. This is sent to any listeners that \npreviously registered an interest in receiving action event notifications from that \ncomponent. Each listener implements the ActionListener interface. That interface defines \nthe actionPerformed ( ) method, which is called when an event occurs. An ActionEvent \nobject is supplied as the argument to this method. It contains both a reference to the button \nthat generated the event and a reference to the action command string associated with the \nbutton. By default, the action command string is the label of the button. Either the button \nreference or the action command string can be used to identify the button. ( You will soon \nsee examples of each approach.) \nHere is an example that creates three buttons labeled \"Yes\", \"No\", and \"Undecided\". Each \ntime one is pressed, a message is displayed that reports which button has been pressed",
    ". Each \ntime one is pressed, a message is displayed that reports which button has been pressed. In \nthis version, the action command of the button ( which, by default, is its label ) is used to \ndetermine which button has been pressed. The label is obtained by calling the \ngetActionCommand ( ) method on the ActionEvent object passed to \nactionPerformed ( ) .",
    "Sample output from the ButtonDemo program is shown in Figure 26-1. \n\n\nFigure 26-1    Sample output from the ButtonDemo applet \n\nAs mentioned, in addition to comparing button action command strings, you can also \ndetermine which button has been pressed by comparing the object obtained from the \ngetSource ( ) method to the button objects that you added to the window. To do this, you \nmust keep a list of the objects when they are added. The following applet shows this \napproach: \n\n\nIn this version, the program stores each button reference in an array when the buttons are \nadded to the applet window. ( Recall that the add ( ) method returns a reference to the",
    "In this version, the program stores each button reference in an array when the buttons are \nadded to the applet window. ( Recall that the add ( ) method returns a reference to the \n\nbutton when it is added.) Inside actionPerformed ( ) , this array is then used to determine \nwhich button has been pressed. \nFor simple programs, it is usually easier to recognize buttons by their labels. However, in \nsituations in which you will be changing the label inside a button during the execution of \nyour program, or using buttons that have the same label, it may be easier to determine \nwhich button has been pushed by using its object reference. It is also possible to set the \naction command string associated with a button to something other than its label by calling \n\n\nsetActionCommand ( ) . This method changes the action command string, but does not",
    "setActionCommand ( ) . This method changes the action command string, but does not \n\naffect the string used to label the button. Thus, setting the action command enables the \naction command and the label of a button to differ. \nIn some cases, you can handle the action events generated by a button ( or some other type \nof control ) by use of an anonymous inner class ( as described in Chapter 24 ) or a lambda \nexpression ( discussed in Chapter 15 ). For example, assuming the previous programs, here is \na set of action event handlers that use lambda expressions:",
    "This code works because ActionListener defines a functional interface, which is an \ninterface with exactly one abstract method. Thus, it can be used by a lambda expression. In \ngeneral, you can use a lambda expression to handle an AWT event when its listener defines \na functional interface. For example, ItemListener is also a functional interface. Of course, \nwhether you use the traditional approach, an anonymous inner class, or a lambda \nexpression will be determined by the precise nature of your application. The remaining \nexamples in this chapter use the traditional approach to event handling so that they can be \ncompiled by nearly any version of Java. However, you might find it interesting to try \nconverting the event handlers to lambda expressions or anonymous inner classes, where \nappropriate. \n\nApplying Check Boxes",
    "Applying Check Boxes \n\nA check box is a control that is used to turn an option on or off. It consists of a small box \nthat can either contain a check mark or not. There is a label associated with each check box \nthat describes what option the box represents. You change the state of a check box by \nclicking on it. Check boxes can be used individually or as part of a group. Check boxes are \nobjects of the Checkbox class. \n\nCheckbox supports these constructors: \n\nCheckbox ( ) throws HeadlessException \n\n\nCheckbox ( String str ) throws HeadlessException \nCheckbox ( String str , boolean on ) throws HeadlessException \nCheckbox ( String str , boolean on , CheckboxGroup cbGroup ) throws HeadlessException \nCheckbox ( String str , CheckboxGroup cbGroup , boolean on ) throws HeadlessException",
    "The first form creates a check box whose label is initially blank. The state of the \ncheck box is unchecked. The second form creates a check box whose label is \nspecified by str . The state of the check box is unchecked. The third form allows you \nto set the initial state of the check box. If on is true , the check box is initially \nchecked ; otherwise, it is cleared. The fourth and fifth forms create a check box \nwhose label is specified by str and whose group is specified by cbGroup . If this \ncheck box is not part of a group, then cbGroup must be null . ( Check box groups \nare described in the next section.) The value of on determines the initial state of \nthe check box. \nTo retrieve the current state of a check box, call getState ( ) . To set its state, call setState ( \n) . You can obtain the current label associated with a check box by calling getLabel ( ) . To \nset the label, call setLabel ( ) . These methods are as follows:",
    "boolean getState ( ) \nvoid setState ( boolean on ) \nString getLabel ( ) \nvoid setLabel ( String str ) \n\nHere, if on is true , the box is checked. If it is false , the box is cleared. The string \npassed in str becomes the new label associated with the invoking check box. \n\nHandling Check Boxes \n\nEach time a check box is selected or deselected, an item event is generated. This is sent to \nany listeners that previously registered an interest in receiving item event notifications from \nthat component. Each listener implements the ItemListener interface. That interface \ndefines the itemStateChanged ( ) method. An ItemEvent object is supplied as the \nargument to this method. It contains information about the event ( for example, whether it \nwas a selection or deselection ). \nThe following program creates four check boxes. The initial state of the first box is checked. \nThe status of each check box is displayed. Each time you change the state of a check box, the \nstatus display is updated.",
    "Sample output is shown in Figure 26-2. \n\n\nFigure 26-2    Sample output from the CheckboxDemo applet \n\nCheckboxGroup \n\nIt is possible to create a set of mutually exclusive check boxes in which one and only one \ncheck box in the group can be checked at any one time. These check boxes are often called \nradio buttons , because they act like the station selector on a car radio\u2014only one station can \nbe selected at any one time. To create a set of mutually exclusive check boxes, you must first \ndefine the group to which they will belong and then specify that group when you construct \nthe check boxes. Check box groups are objects of type CheckboxGroup . Only the default \nconstructor is defined, which creates an empty group. \nYou can determine which check box in a group is currently selected by calling \ngetSelectedCheckbox ( ) . You can set a check box by calling setSelectedCheckbox ( ) . \nThese methods are as follows: \n\nCheckbox getSelectedCheckbox ( )",
    "Checkbox getSelectedCheckbox ( ) \n\nvoid setSelectedCheckbox ( Checkbox which ) \n\nHere, which is the check box that you want to be selected. The previously selected \ncheck box will be turned off. \nHere is a program that uses check boxes that are part of a group: \n\n\nSample output generated by the CBGroup applet is shown in Figure 26-3. Notice that the \ncheck boxes are now circular in shape. \n\n\nFigure 26-3    Sample output from the CBGroup applet \n\nChoice Controls",
    "Figure 26-3    Sample output from the CBGroup applet \n\nChoice Controls \n\nThe Choice class is used to create a pop-up list of items from which the user may choose. \nThus, a Choice control is a form of menu. When inactive, a Choice component takes up \nonly enough space to show the currently selected item. When the user clicks on it, the whole \nlist of choices pops up, and a new selection can be made. Each item in the list is a string that \nappears as a left-justified label in the order it is added to the Choice object. Choice defines \nonly the default constructor, which creates an empty list. \nTo add a selection to the list, call add ( ) . It has this general form: \n\nvoid add ( String name ) \n\nHere, name is the name of the item being added. Items are added to the list in the \norder in which calls to add ( ) occur. \nTo determine which item is currently selected, you may call either getSelectedItem ( ) or \ngetSelectedIndex ( ) . These methods are shown here:",
    "String getSelectedItem ( ) \nint getSelectedIndex ( ) \n\nThe getSelectedItem ( ) method returns a string containing the name of the item. \n\ngetSelectedIndex ( ) returns the index of the item. The first item is at index 0. \nBy default, the first item added to the list is selected. \nTo obtain the number of items in the list, call getItemCount ( ) . You can set the currently \n\nselected item using the select ( ) method with either a zero-based integer index or a string \nthat will match a name in the list. These methods are shown here: \n\nint getItemCount ( ) \nvoid select ( int index ) \nvoid select ( String name ) \n\n\nGiven an index, you can obtain the name associated with the item at that index by \ncalling getItem ( ) , which has this general form: \n\nString getItem ( int index ) \n\nHere, index specifies the index of the desired item. \n\nHandling Choice Lists",
    "String getItem ( int index ) \n\nHere, index specifies the index of the desired item. \n\nHandling Choice Lists \n\nEach time a choice is selected, an item event is generated. This is sent to any listeners that \npreviously registered an interest in receiving item event notifications from that component. \nEach listener implements the ItemListener interface. That interface defines the \nitemStateChanged ( ) method. An ItemEvent object is supplied as the argument to this \nmethod. \nHere is an example that creates two Choice menus. One selects the operating system. \nThe other selects the browser. \n\n\nSample output is shown in Figure 26-4. \n\n\nFigure 26-4    Sample output from the ChoiceDemo applet \n\nUsing Lists",
    "Sample output is shown in Figure 26-4. \n\n\nFigure 26-4    Sample output from the ChoiceDemo applet \n\nUsing Lists \n\nThe List class provides a compact, multiple-choice, scrolling selection list. Unlike the \nChoice object, which shows only the single selected item in the menu, a List object can be \nconstructed to show any number of choices in the visible window. It can also be created to \nallow multiple selections. List provides these constructors: \n\nList ( ) throws HeadlessException \nList ( int numRows ) throws HeadlessException \nList ( int numRows , boolean multipleSelect ) throws HeadlessException",
    "List ( ) throws HeadlessException \nList ( int numRows ) throws HeadlessException \nList ( int numRows , boolean multipleSelect ) throws HeadlessException \n\nThe first version creates a List control that allows only one item to be selected at \nany one time. In the second form, the value of numRows specifies the number of \nentries in the list that will always be visible ( others can be scrolled into view as \nneeded ). In the third form, if multipleSelect is true , then the user may select two \nor more items at a time. If it is false , then only one item may be selected. \nTo add a selection to the list, call add ( ) . It has the following two forms: \n\nvoid add ( String name ) \nvoid add ( String name , int index ) \n\nHere, name is the name of the item added to the list. The first form adds items to",
    "void add ( String name ) \nvoid add ( String name , int index ) \n\nHere, name is the name of the item added to the list. The first form adds items to \n\nthe end of the list. The second form adds the item at the index specified by index . \nIndexing begins at zero. You can specify \u20131 to add the item to the end of the list. \nFor lists that allow only single selection, you can determine which item is currently selected \n\nby calling either getSelectedItem ( ) or getSelectedIndex ( ) . These methods are shown \nhere: \n\nString getSelectedItem ( ) \nint getSelectedIndex ( )",
    "by calling either getSelectedItem ( ) or getSelectedIndex ( ) . These methods are shown \nhere: \n\nString getSelectedItem ( ) \nint getSelectedIndex ( ) \n\n\nThe getSelectedItem ( ) method returns a string containing the name of the item. \nIf more than one item is selected, or if no selection has yet been made, null is \nreturned. getSelectedIndex ( ) returns the index of the item. The first item is at \nindex 0. If more than one item is selected, or if no selection has yet been made, \u20131 \nis returned. \nFor lists that allow multiple selection, you must use either getSelectedItems ( ) or \ngetSelectedIndexes ( ) , shown here, to determine the current selections: \n\nString[ ] getSelectedItems ( ) \nint[ ] getSelectedIndexes ( )",
    "String[ ] getSelectedItems ( ) \nint[ ] getSelectedIndexes ( ) \n\ngetSelectedItems ( ) returns an array containing the names of the currently \nselected items. getSelectedIndexes ( ) returns an array containing the indexes of \nthe currently selected items. \nTo obtain the number of items in the list, call getItemCount ( ) . You can set the currently \nselected item by using the select ( ) method with a zero-based integer index. These methods \nare shown here: \n\nint getItemCount ( ) \nvoid select ( int index ) \n\nGiven an index, you can obtain the name associated with the item at that index by \ncalling getItem ( ) , which has this general form: \n\nString getItem ( int index ) \n\nHere, index specifies the index of the desired item. \n\nHandling Lists",
    "String getItem ( int index ) \n\nHere, index specifies the index of the desired item. \n\nHandling Lists \n\nTo process list events, you will need to implement the ActionListener interface. Each time \na List item is double-clicked, an ActionEvent object is generated. Its \ngetActionCommand ( ) method can be used to retrieve the name of the newly selected \nitem. Also, each time an item is selected or deselected with a single click, an ItemEvent \nobject is generated. Its getStateChange ( ) method can be used to determine whether a \nselection or deselection triggered this event. getItemSelectable ( ) returns a reference to \nthe object that triggered this event. \nHere is an example that converts the Choice controls in the preceding section into List \ncomponents, one multiple choice and the other single choice: \n\n\n\n\nSample output generated by the ListDemo applet is shown in Figure 26-5. \n\n\nFigure 26-5    Sample output from the ListDemo applet",
    "Sample output generated by the ListDemo applet is shown in Figure 26-5. \n\n\nFigure 26-5    Sample output from the ListDemo applet \n\nManaging Scroll Bars",
    "Managing Scroll Bars \n\nScroll bars are used to select continuous values between a specified minimum and \nmaximum. Scroll bars may be oriented horizontally or vertically. A scroll bar is actually a \ncomposite of several individual parts. Each end has an arrow that you can click to move the \ncurrent value of the scroll bar one unit in the direction of the arrow. The current value of the \nscroll bar relative to its minimum and maximum values is indicated by the slider box ( or \nthumb ) for the scroll bar. The slider box can be dragged by the user to a new position. The \nscroll bar will then reflect this value. In the background space on either side of the thumb, \nthe user can click to cause the thumb to jump in that direction by some increment larger \nthan 1. Typically, this action translates into some form of page up and page down. Scroll \nbars are encapsulated by the Scrollbar class. \nScrollbar defines the following constructors:",
    "The first form creates a vertical scroll bar. The second and third forms allow you to specify \nthe orientation of the scroll bar. If style is Scrollbar.VERTICAL , a vertical scroll bar is \ncreated. If style is Scrollbar.HORIZONTAL , the scroll bar is horizontal. In the third form \nof the constructor, the initial value of the scroll bar is passed in initialValue . The number of \n\nunits represented by the height of the thumb is passed in thumbSize . The minimum and \n\nmaximum values for the scroll bar are specified by min and max . \nIf you construct a scroll bar by using one of the first two constructors, then you need to set \nits parameters by using setValues ( ) , shown here, before it can be used: \n\nvoid setValues ( int initialValue , int thumbSize , int min , int max )",
    "void setValues ( int initialValue , int thumbSize , int min , int max ) \n\n\nThe parameters have the same meaning as they have in the third constructor just \ndescribed. \nTo obtain the current value of the scroll bar, call getValue ( ) . It returns the current setting. \nTo set the current value, call setValue ( ) . These methods are as follows: \n\nint getValue ( ) \nvoid setValue ( int newValue ) \n\nHere, newValue specifies the new value for the scroll bar. When you set a value, \nthe slider box inside the scroll bar will be positioned to reflect the new value. \nYou can also retrieve the minimum and maximum values via getMinimum ( ) and \ngetMaximum ( ) , shown here: \n\nint getMinimum ( ) \nint getMaximum ( )",
    "int getMinimum ( ) \nint getMaximum ( ) \n\nThey return the requested quantity. \nBy default, 1 is the increment added to or subtracted from the scroll bar each time it is \nscrolled up or down one line. You can change this increment by calling \nsetUnitIncrement ( ) . By default, page-up and page-down increments are 10. You can \nchange this value by calling setBlockIncrement ( ) . These methods are shown here: \n\nvoid setUnitIncrement ( int newIncr ) \nvoid setBlockIncrement ( int newIncr ) \n\nHandling Scroll Bars \n\nTo process scroll bar events, you need to implement the AdjustmentListener interface. \nEach time a user interacts with a scroll bar, an AdjustmentEvent object is generated. Its \ngetAdjustmentType ( ) method can be used to determine the type of the adjustment. The \ntypes of adjustment events are as follows: \n\nBLOCK_DECREMENT \nA page-down event has been generated. \n\nBLOCK_INCREMENT \nA page-up event has been generated. \n\nTRACK \nAn absolute tracking event has been generated.",
    "BLOCK_DECREMENT \nA page-down event has been generated. \n\nBLOCK_INCREMENT \nA page-up event has been generated. \n\nTRACK \nAn absolute tracking event has been generated. \n\nUNIT_DECREMENT \nThe line-down button in a scroll bar has been pressed. \n\nUNIT_INCREMENT \nThe line-up button in a scroll bar has been pressed. \n\nThe following example creates both a vertical and a horizontal scroll bar. The current \nsettings of the scroll bars are displayed. If you drag the mouse while inside the window, the \ncoordinates of each drag event are used to update the scroll bars. An asterisk is displayed at \nthe current drag position. Notice the use of setPreferredSize ( ) to set the size of the \n\nscrollbars. \n\n\n\n\nSample output from the SBDemo applet is shown in Figure 26-6. \n\n\nFigure 26-6    Sample output from the SBDemo applet \n\nUsing a TextField",
    "scrollbars. \n\n\n\n\nSample output from the SBDemo applet is shown in Figure 26-6. \n\n\nFigure 26-6    Sample output from the SBDemo applet \n\nUsing a TextField \n\nThe TextField class implements a single-line text-entry area, usually called an edit control . \nText fields allow the user to enter strings and to edit the text using the arrow keys, cut and \npaste keys, and mouse selections. TextField is a subclass of TextComponent . TextField \ndefines the following constructors: \n\nTextField ( ) throws HeadlessException \nTextField ( int numChars ) throws HeadlessException \nTextField ( String str ) throws HeadlessException \nTextField ( String str , int numChars ) throws HeadlessException \n\nThe first version creates a default text field. The second form creates a text field",
    "The first version creates a default text field. The second form creates a text field \n\nthat is numChars characters wide. The third form initializes the text field with the \nstring contained in str . The fourth form initializes a text field and sets its width. \nTextField ( and its superclass TextComponent ) provides several methods that allow you \nto utilize a text field. To obtain the string currently contained in the text field, call getText ( \n) . To set the text, call setText ( ) . These methods are as follows: \n\nString getText ( ) \nvoid setText ( String str ) \n\nHere, str is the new string. \nThe user can select a portion of the text in a text field. Also, you can select a portion of text \nunder program control by using select ( ) . Your program can obtain the currently selected \n\ntext by calling getSelectedText ( ) . These methods are shown here: \n\nString getSelectedText ( ) \nvoid select ( int startIndex , int endIndex )",
    "text by calling getSelectedText ( ) . These methods are shown here: \n\nString getSelectedText ( ) \nvoid select ( int startIndex , int endIndex ) \n\n\ngetSelectedText ( ) returns the selected text. The select ( ) method selects the \ncharacters beginning at startIndex and ending at endIndex \u20131. \nYou can control whether the contents of a text field may be modified by the user by calling \nsetEditable ( ) . You can determine editability by calling isEditable ( ) . These methods are \nshown here: \n\nboolean isEditable ( ) \nvoid setEditable ( boolean canEdit )",
    "boolean isEditable ( ) \nvoid setEditable ( boolean canEdit ) \n\nisEditable ( ) returns true if the text may be changed and false if not. In \nsetEditable ( ) , if canEdit is true , the text may be changed. If it is false , the text \ncannot be altered. \nThere may be times when you will want the user to enter text that is not displayed, such as a \npassword. You can disable the echoing of the characters as they are typed by calling \nsetEchoChar ( ) . This method specifies a single character that the TextField will display \nwhen characters are entered ( thus, the actual characters typed will not be shown ). You can \ncheck a text field to see if it is in this mode with the echoCharIsSet ( ) method. You can \nretrieve the echo character by calling the getEchoChar ( ) method. These methods are as \nfollows: \n\nvoid setEchoChar ( char ch ) \nboolean echoCharIsSet ( ) \nchar getEchoChar ( ) \n\nHere, ch specifies the character to be echoed. If ch is zero, then normal echoing is \nrestored.",
    "void setEchoChar ( char ch ) \nboolean echoCharIsSet ( ) \nchar getEchoChar ( ) \n\nHere, ch specifies the character to be echoed. If ch is zero, then normal echoing is \nrestored. \n\nHandling a TextField \n\nSince text fields perform their own editing functions, your program generally will not \nrespond to individual key events that occur within a text field. However, you may want to \nrespond when the user presses ENTER . When this occurs, an action event is generated. \n\nHere is an example that creates the classic user name and password screen: \n\n\nSample output from the TextFieldDemo applet is shown in Figure 26-7. \n\n\nFigure 26-7    Sample output from the TextFieldDemo applet \n\nUsing a TextArea \n\nSometimes a single line of text input is not enough for a given task. To handle these \nsituations, the AWT includes a simple multiline editor called TextArea . Following are the \nconstructors for TextArea :",
    "TextArea ( ) throws HeadlessException \nTextArea ( int numLines , int numChars ) throws HeadlessException \nTextArea ( String str ) throws HeadlessException \nTextArea ( String str , int numLines , int numChars ) throws HeadlessException \nTextArea ( String str , int numLines , int numChars , int sBars ) throws HeadlessException \n\nHere, numLines specifies the height, in lines, of the text area, and numChars \nspecifies its width, in characters. Initial text can be specified by str . In the fifth \nform, you can specify the scroll bars that you want the control to have. sBars must \nbe one of these values: \n\nSCROLLBARS_BOTH \nSCROLLBARS_NONE \n\nSCROLLBARS_HORIZONTAL_ONLY \nSCROLLBARS_VERTICAL_ONLY \n\nTextArea is a subclass of TextComponent . Therefore, it supports the getText ( ) , \nsetText ( ) , getSelectedText ( ) , select ( ) , isEditable ( ) , and setEditable ( ) methods \ndescribed in the preceding section. \nTextArea adds the following editing methods:",
    "void append ( String str ) \nvoid insert ( String str , int index ) \nvoid replaceRange ( String str , int startIndex , int endIndex ) \n\nThe append ( ) method appends the string specified by str to the end of the \n\n\ncurrent text. insert ( ) inserts the string passed in str at the specified index. To \n\nreplace text, call replaceRange ( ) . It replaces the characters from startIndex to \nendIndex \u20131, with the replacement text passed in str . \nText areas are almost self-contained controls. Your program incurs virtually no \nmanagement overhead. Normally, your program simply obtains the current text when it is \nneeded. You can, however, listen for TextEvent s, if you choose. \nThe following program creates a TextArea control: \n\nHere is sample output from the TextAreaDemo applet: \n\n\nUnderstanding Layout Managers",
    "All of the components that we have shown so far have been positioned by the default layout \nmanager. As we mentioned at the beginning of this chapter, a layout manager automatically \narranges your controls within a window by using some type of algorithm. If you have \nprogrammed for other GUI environments, such as Windows, then you may have laid out \nyour controls by hand. While it is possible to lay out Java controls by hand, too, you \ngenerally won\u2019t want to, for two main reasons. First, it is very tedious to manually lay out a \nlarge number of components. Second, sometimes the width and height information is not \nyet available when you need to arrange some control, because the native toolkit components \nhaven\u2019t been realized. This is a chicken-and-egg situation ; it is pretty confusing to figure out \nwhen it is okay to use the size of a given component to position it relative to another. \nEach Container object has a layout manager associated with it",
    ". \nEach Container object has a layout manager associated with it. A layout manager is an \ninstance of any class that implements the LayoutManager interface. The layout manager \nis set by the setLayout ( ) method. If no call to setLayout ( ) is made, then the default \nlayout manager is used. Whenever a container is resized ( or sized for the first time ), the \nlayout manager is used to position each of the components within it. \nThe setLayout ( ) method has the following general form:",
    "void setLayout ( LayoutManager layoutObj ) \n\nHere, layoutObj is a reference to the desired layout manager. If you wish to disable \nthe layout manager and position components manually, pass null for layoutObj . If \n\nyou do this, you will need to determine the shape and position of each component \nmanually, using the setBounds ( ) method defined by Component . Normally, \nyou will want to use a layout manager. \nEach layout manager keeps track of a list of components that are stored by their names. The \nlayout manager is notified each time you add a component to a container. Whenever the",
    "container needs to be resized, the layout manager is consulted via its \nminimumLayoutSize ( ) and preferredLayoutSize ( ) methods. Each component that is \nbeing managed by a layout manager contains the getPreferredSize ( ) and \ngetMinimumSize ( ) methods. These return the preferred and minimum size required to \ndisplay each component. The layout manager will honor these requests if at all possible, \nwhile maintaining the integrity of the layout policy. You may override these methods for \ncontrols that you subclass. Default values are provided otherwise. \nJava has several predefined LayoutManager classes, several of which are described next. \nYou can use the layout manager that best fits your application. \n\nFlowLayout",
    "FlowLayout \n\nFlowLayout is the default layout manager. This is the layout manager that the preceding \nexamples have used. FlowLayout implements a simple layout style, which is similar to \nhow words flow in a text editor. The direction of the layout is governed by the container\u2019s \ncomponent orientation property, which, by default, is left to right, top to bottom. Therefore, \nby default, components are laid out line-by-line beginning at the upper-left corner. In all \ncases, when a line is filled, layout advances to the next line. A small space is left between \neach component, above and below, as well as left and right. Here are the constructors for \nFlowLayout : \n\nFlowLayout ( ) \nFlowLayout ( int how ) \nFlowLayout ( int how , int horz , int vert ) \n\nThe first form creates the default layout, which centers components and leaves five \npixels of space between each component. The second form lets you specify how \neach line is aligned. Valid values for how are as follows: \n\nFlowLayout.LEFT",
    "FlowLayout.LEFT \n\nFlowLayout.CENTER \nFlowLayout.RIGHT \nFlowLayout.LEADING \nFlowLayout.TRAILING \n\nThese values specify left, center, right, leading edge, and trailing edge alignment, \nrespectively. The third constructor allows you to specify the horizontal and vertical \nspace left between components in horz and vert , respectively. \nHere is a version of the CheckboxDemo applet shown earlier in this chapter, modified so \nthat it uses left-aligned flow layout: \n\n\n\n\nHere is sample output generated by the FlowLayoutDemo applet. Compare this \nwith the output from the CheckboxDemo applet, shown earlier in Figure 26-2. \n\nBorderLayout \n\nThe BorderLayout class implements a common layout style for top-level windows. It has \nfour narrow, fixed-width components at the edges and one large area in the center. The four \nsides are referred to as north, south, east, and west. The middle area is called the center. \nHere are the constructors defined by BorderLayout :",
    "BorderLayout ( ) \nBorderLayout ( int horz , int vert ) \n\nThe first form creates a default border layout. The second allows you to specify the \n\n\nhorizontal and vertical space left between components in horz and vert , \nrespectively. \nBorderLayout defines the following constants that specify the regions: \n\nBorderLayout.CENTER \nBorderLayout.SOUTH \n\nBorderLayout.EAST \nBorderLayout.WEST \n\nBorderLayout.NORTH \n\nWhen adding components, you will use these constants with the following form of add ( ) , \nwhich is defined by Container : \n\nvoid add ( Component compRef , Object region ) \n\nHere, compRef is a reference to the component to be added, and region specifies \nwhere the component will be added. \nHere is an example of a BorderLayout with a component in each layout area: \n\n\nSample output from the BorderLayoutDemo applet is shown here: \n\n\nUsing Insets",
    "Sample output from the BorderLayoutDemo applet is shown here: \n\n\nUsing Insets \n\nSometimes you will want to leave a small amount of space between the container that holds \nyour components and the window that contains it. To do this, override the getInsets ( ) \nmethod that is defined by Container . This method returns an Insets object that contains \nthe top, bottom, left, and right inset to be used when the container is displayed. These \nvalues are used by the layout manager to inset the components when it lays out the window. \nThe constructor for Insets is shown here: \n\nInsets ( int top , int left , int bottom , int right ) \n\nThe values passed in top, left, bottom , and right specify the amount of space \nbetween the container and its enclosing window. \nThe getInsets ( ) method has this general form: \n\nInsets getInsets ( )",
    "Insets getInsets ( ) \n\nWhen overriding this method, you must return a new Insets object that contains \nthe inset spacing you desire. \nHere is the preceding BorderLayout example modified so that it insets its components ten \npixels from each border. The background color has been set to cyan to help make the insets \nmore visible. \n\n\nSample output from the InsetsDemo applet is shown here: \n\n\nGridLayout \n\nGridLayout lays out components in a two-dimensional grid. When you instantiate a \nGridLayout , you define the number of rows and columns. The constructors supported by \nGridLayout are shown here: \n\nGridLayout ( ) \nGridLayout ( int numRows , int numColumns ) \nGridLayout ( int numRows , int numColumns , int horz , int vert )",
    "GridLayout ( ) \nGridLayout ( int numRows , int numColumns ) \nGridLayout ( int numRows , int numColumns , int horz , int vert ) \n\nThe first form creates a single-column grid layout. The second form creates a grid \nlayout with the specified number of rows and columns. The third form allows you \nto specify the horizontal and vertical space left between components in horz and \nvert , respectively. Either numRows or numColumns can be zero. Specifying \nnumRows as zero allows for unlimited-length columns. Specifying numColumns as \nzero allows for unlimited-length rows. \nHere is a sample program that creates a 4\u00d74 grid and fills it in with 15 buttons, each labeled \nwith its index: \n\n\nFollowing is sample output generated by the GridLayoutDemo applet: \n\nTIP You might try using this example as the starting point for a 15-square \npuzzle. \n\n\nCardLayout",
    "Following is sample output generated by the GridLayoutDemo applet: \n\nTIP You might try using this example as the starting point for a 15-square \npuzzle. \n\n\nCardLayout \n\nThe CardLayout class is unique among the other layout managers in that it stores several \ndifferent layouts. Each layout can be thought of as being on a separate index card in a deck \nthat can be shuffled so that any card is on top at a given time. This can be useful for user \ninterfaces with optional components that can be dynamically enabled and disabled upon \nuser input. You can prepare the other layouts and have them hidden, ready to be activated \nwhen needed. \nCardLayout provides these two constructors: \n\nCardLayout ( ) \nCardLayout ( int horz , int vert )",
    "The first form creates a default card layout. The second form allows you to specify \nthe horizontal and vertical space left between components in horz and vert , \nrespectively. \nUse of a card layout requires a bit more work than the other layouts. The cards are typically \nheld in an object of type Panel . This panel must have CardLayout selected as its layout \nmanager. The cards that form the deck are also typically objects of type Panel . Thus, you \nmust create a panel that contains the deck and a panel for each card in the deck. Next, you \nadd to the appropriate panel the components that form each card. You then add these \npanels to the panel for which CardLayout is the layout manager. Finally, you add this \npanel to the window. Once these steps are complete, you must provide some way for the \nuser to select between cards. One common approach is to include one push button for each \ncard in the deck. \nWhen card panels are added to a panel, they are usually given a name",
    ". One common approach is to include one push button for each \ncard in the deck. \nWhen card panels are added to a panel, they are usually given a name. Thus, most of the \ntime, you will use this form of add ( ) when adding cards to a panel:",
    "void add ( Component panelRef , Object name ) \n\nHere, name is a string that specifies the name of the card whose panel is specified \nby panelRef . \nAfter you have created a deck, your program activates a card by calling one of the following \nmethods defined by CardLayout : \n\nvoid first ( Container deck ) \nvoid last ( Container deck ) \nvoid next ( Container deck ) \nvoid previous ( Container deck ) \nvoid show ( Container deck , String cardName ) \n\nHere, deck is a reference to the container ( usually a panel ) that holds the cards, \nand cardName is the name of a card. Calling first ( ) causes the first card in the \n\ndeck to be shown. To show the last card, call last ( ) . To show the next card, call",
    "deck to be shown. To show the last card, call last ( ) . To show the next card, call \n\n\nnext ( ) . To show the previous card, call previous ( ) . Both next ( ) and \nprevious ( ) automatically cycle back to the top or bottom of the deck, \nrespectively. The show ( ) method displays the card whose name is passed in \ncardName . \nThe following example creates a two-level card deck that allows the user to select an \noperating system. Windows-based operating systems are displayed in one card. Mac OS and \nSolaris are displayed in the other card. \n\n\n\n\nHere is sample output generated by the CardLayoutDemo applet. Each card is activated \nby pushing its button. You can also cycle through the cards by clicking the mouse. \n\nGridBagLayout",
    "Here is sample output generated by the CardLayoutDemo applet. Each card is activated \nby pushing its button. You can also cycle through the cards by clicking the mouse. \n\nGridBagLayout \n\nAlthough the preceding layouts are perfectly acceptable for many uses, some situations will \nrequire that you take a bit more control over how the components are arranged. A good way \nto do this is to use a grid bag layout, which is specified by the GridBagLayout class. What \nmakes the grid bag useful is that you can specify the relative placement of components by \nspecifying their positions within cells inside a grid. The key to the grid bag is that each",
    "component can be a different size, and each row in the grid can have a different number of \ncolumns. This is why the layout is called a grid bag . It\u2019s a collection of small grids joined \ntogether. \nThe location and size of each component in a grid bag are determined by a set of constraints \nlinked to it. The constraints are contained in an object of type GridBagConstraints . \nConstraints include the height and width of a cell, and the placement of a component, its \nalignment, and its anchor point within the cell. \nThe general procedure for using a grid bag is to first create a new GridBagLayout object \nand to make it the current layout manager. Then, set the constraints that apply to each \ncomponent that will be added to the grid bag. Finally, add the components to the layout \nmanager. Although GridBagLayout is a bit more complicated than the other layout \nmanagers, it is still quite easy to use once you understand how it works",
    ". Finally, add the components to the layout \nmanager. Although GridBagLayout is a bit more complicated than the other layout \nmanagers, it is still quite easy to use once you understand how it works. \nGridBagLayout defines only one constructor, which is shown here:",
    "GridBagLayout ( ) \n\nGridBagLayout defines several methods, of which many are protected and not \nfor general use. There is one method, however, that you must use: \nsetConstraints ( ) . It is shown here: \n\nvoid setConstraints ( Component comp , GridBagConstraints cons ) \n\nHere, comp is the component for which the constraints specified by cons apply. \nThis method sets the constraints that apply to each component in the grid bag. \nThe key to successfully using GridBagLayout is the proper setting of the constraints, \nwhich are stored in a GridBagConstraints object. GridBagConstraints defines several \nfields that you can set to govern the size, placement, and spacing of a component. These are \nshown in Table 26-1. Several are described in greater detail in the following discussion. \n\n\nTable 26-1    Constraint Fields Defined by GridBagConstraints",
    "Table 26-1    Constraint Fields Defined by GridBagConstraints \n\nGridBagConstraints also defines several static fields that contain standard constraint \nvalues, such as GridBagConstraints.CENTER and GridBagConstraints.VERTICAL . \nWhen a component is smaller than its cell, you can use the anchor field to specify where \nwithin the cell the component\u2019s top-left corner will be located. There are three types of \nvalues that you can give to anchor . The first are absolute: \n\nGridBagConstraints.CENTER \nGridBagConstraints.SOUTH \n\nGridBagConstraints.EAST \nGridBagConstraints.SOUTHEAST \n\nGridBagConstraints.NORTH \nGridBagConstraints.SOUTHWEST \n\nGridBagConstraints.NORTHEAST \nGridBagConstraints.WEST \n\nGridBagConstraints.NORTHWEST",
    "GridBagConstraints.EAST \nGridBagConstraints.SOUTHEAST \n\nGridBagConstraints.NORTH \nGridBagConstraints.SOUTHWEST \n\nGridBagConstraints.NORTHEAST \nGridBagConstraints.WEST \n\nGridBagConstraints.NORTHWEST \n\nAs their names imply, these values cause the component to be placed at the specific \nlocations. \nThe second type of values that can be given to anchor is relative, which means the values \nare relative to the container\u2019s orientation, which might differ for non-Western languages. \nThe relative values are shown here: \n\n\nGridBagConstraints.FIRST_LINE_END \nGridBagConstraints.LINE_END \n\nGridBagConstraints.FIRST_LINE_START \nGridBagConstraints.LINE_START \n\nGridBagConstraints.LAST_LINE_END \nGridBagConstraints.PAGE_END \n\nGridBagConstraints.LAST_LINE_START \nGridBagConstraints.PAGE_START \n\nTheir names describe the placement. \nThe third type of values that can be given to anchor allows you to position components \nrelative to the baseline of the row. These values are shown here:",
    "Their names describe the placement. \nThe third type of values that can be given to anchor allows you to position components \nrelative to the baseline of the row. These values are shown here: \n\nGridBagConstraints.BASELINE \nGridBagConstraints.BASELINE_LEADIN \n\nGridBagConstraints.BASELINE_TRAILING \nGridBagConstraints.ABOVE_BASELINE \n\nGridBagConstraints.ABOVE_BASELINE_LEADING \nGridBagConstraints.ABOVE_BASELINE_ \nTRAILING \n\nGridBagConstraints.BELOW_BASELINE \nGridBagConstraints.BELOW_BASELINE \nLEADING \n\nGridBagConstraints. \nBELOW_BASELINE_TRAILING",
    "The horizontal position can be either centered, against the leading edge ( LEADING ), or \nagainst the trailing edge ( TRAILING ). \nThe weightx and weighty fields are both quite important and quite confusing at first \nglance. In general, their values determine how much of the extra space within a container is \nallocated to each row and column. By default, both these values are zero. When all values \nwithin a row or a column are zero, extra space is distributed evenly between the edges of the \nwindow. By increasing the weight, you increase that row or column\u2019s allocation of space \nproportional to the other rows or columns. The best way to understand how these values \nwork is to experiment with them a bit. \nThe gridwidth variable lets you specify the width of a cell in terms of cell units. The default \nis 1. To specify that a component use the remaining space in a row, use \nGridBagConstraints.REMAINDER",
    ". The default \nis 1. To specify that a component use the remaining space in a row, use \nGridBagConstraints.REMAINDER . To specify that a component use the next-to-last \ncell in a row, use GridBagConstraints.RELATIVE . The gridheight constraint works \nthe same way, but in the vertical direction. \nYou can specify a padding value that will be used to increase the minimum size of a cell. To",
    "pad horizontally, assign a value to ipadx . To pad vertically, assign a value to ipady . \nHere is an example that uses GridBagLayout to demonstrate several of the points just \ndiscussed: \n\n\n\n\nSample output produced by the program is shown here. \n\n\nIn this layout, the operating system check boxes are positioned in a 2\u00d72 grid. Each cell has \na horizontal padding of 200. Each component is inset slightly ( by 4 units ) from the top left. \nThe column weight is set to 1, which causes any extra horizontal space to be distributed \nevenly between the columns. The first row uses a default weight of 0 ; the second has a \nweight of 1. This means that any extra vertical space is added to the second row. \nGridBagLayout is a powerful layout manager. It is worth taking some time to experiment \nwith and explore. Once you understand what the various settings do, you can use \nGridBagLayout to position components with a high degree of precision. \n\nMenu Bars and Menus",
    "Menu Bars and Menus \n\nA top-level window can have a menu bar associated with it. A menu bar displays a list of \ntop-level menu choices. Each choice is associated with a drop-down menu. This concept is \nimplemented in the AWT by the following classes: MenuBar , Menu , and MenuItem . In \ngeneral, a menu bar contains one or more Menu objects. Each Menu object contains a list \nof MenuItem objects. Each MenuItem object represents something that can be selected \nby the user. Since Menu is a subclass of MenuItem , a hierarchy of nested submenus can \nbe created. It is also possible to include checkable menu items. These are menu options of \ntype CheckboxMenuItem and will have a check mark next to them when they are \nselected. \nTo create a menu bar, first create an instance of MenuBar . This class defines only the \ndefault constructor. Next, create instances of Menu that will define the selections displayed \non the bar. Following are the constructors for Menu :",
    "Menu ( ) throws HeadlessException \nMenu ( String optionName ) throws HeadlessException \n\nMenu ( String optionName , boolean removable ) throws HeadlessException \n\nHere, optionName specifies the name of the menu selection. If removable is true , \nthe menu can be removed and allowed to float free. Otherwise, it will remain \n\n\nattached to the menu bar. ( Removable menus are implementation-dependent.) The \n\nfirst form creates an empty menu. Individual menu items are of type MenuItem . \nIt defines these constructors: \n\nMenuItem ( ) throws HeadlessException \nMenuItem ( String itemName ) throws HeadlessException \nMenuItem ( String itemName , MenuShortcut keyAccel ) throws HeadlessException \n\nHere, itemName is the name shown in the menu, and keyAccel is the menu \nshortcut for this item. \nYou can disable or enable a menu item by using the setEnabled ( ) method. Its form is \nshown here: \n\nvoid setEnabled ( boolean enabledFlag )",
    "void setEnabled ( boolean enabledFlag ) \n\nIf the argument enabledFlag is true , the menu item is enabled. If false , the menu \nitem is disabled. \nYou can determine an item\u2019s status by calling isEnabled ( ) . This method is shown here: \n\nboolean isEnabled ( ) \n\nisEnabled ( ) returns true if the menu item on which it is called is enabled. \nOtherwise, it returns false . \nYou can change the name of a menu item by calling setLabel ( ) . You can retrieve the \ncurrent name by using getLabel ( ) . These methods are as follows: \n\nvoid setLabel ( String newName ) \nString getLabel ( ) \n\nHere, newName becomes the new name of the invoking menu item. getLabel ( ) \n\nreturns the current name. \nYou can create a checkable menu item by using a subclass of MenuItem called \nCheckboxMenuItem . It has these constructors: \n\nCheckboxMenuItem ( ) throws HeadlessException \nCheckboxMenuItem ( String itemName ) throws HeadlessException \nCheckboxMenuItem ( String itemName , boolean on ) throws HeadlessException",
    "CheckboxMenuItem ( ) throws HeadlessException \nCheckboxMenuItem ( String itemName ) throws HeadlessException \nCheckboxMenuItem ( String itemName , boolean on ) throws HeadlessException \n\nHere, itemName is the name shown in the menu. Checkable items operate as \n\ntoggles. Each time one is selected, its state changes. In the first two forms, the \ncheckable entry is unchecked. In the third form, if on is true , the checkable entry \nis initially checked. Otherwise, it is cleared. \n\nYou can obtain the status of a checkable item by calling getState ( ) . You can set it to a \nknown state by using setState ( ) . These methods are shown here: \n\nboolean getState ( ) \nvoid setState ( boolean checked )",
    "boolean getState ( ) \nvoid setState ( boolean checked ) \n\n\nIf the item is checked, getState ( ) returns true . Otherwise, it returns false . To \ncheck an item, pass true to setState ( ) . To clear an item, pass false . \nOnce you have created a menu item, you must add the item to a Menu object by using \nadd ( ) , which has the following general form: \n\nMenuItem add ( MenuItem item ) \n\nHere, item is the item being added. Items are added to a menu in the order in \nwhich the calls to add ( ) take place. The item is returned. \nOnce you have added all items to a Menu object, you can add that object to the menu bar \nby using this version of add ( ) defined by MenuBar : \n\nMenu add ( Menu menu )",
    "Menu add ( Menu menu ) \n\nHere, menu is the menu being added. The menu is returned. \nMenus generate events only when an item of type MenuItem or CheckboxMenuItem is \nselected. They do not generate events when a menu bar is accessed to display a drop-down \nmenu, for example. Each time a menu item is selected, an ActionEvent object is \ngenerated. By default, the action command string is the name of the menu item. However, \nyou can specify a different action command string by calling setActionCommand ( ) on \nthe menu item. Each time a check box menu item is checked or unchecked, an ItemEvent \nobject is generated. Thus, you must implement the ActionListener and/or ItemListener \ninterfaces in order to handle these menu events. \nThe getItem ( ) method of ItemEvent returns a reference to the item that generated this \nevent. The general form of this method is shown here: \n\nObject getItem ( ) \n\nFollowing is an example that adds a series of nested menus to a pop-up window.",
    "Object getItem ( ) \n\nFollowing is an example that adds a series of nested menus to a pop-up window. \n\nThe item selected is displayed in the window. The state of the two check box menu \nitems is also displayed. \n\n\n\n\n\n\n\n\nSample output from the MenuDemo applet is shown in Figure 26-8. \n\n\nFigure 26-8    Sample output from the MenuDemo applet \n\nThere is one other menu-related class that you might find interesting: PopupMenu . It \nworks just like Menu , but produces a menu that can be displayed at a specific location. \nPopupMenu provides a flexible, useful alternative for some types of menuing situations. \n\nDialog Boxes",
    "Dialog Boxes \n\nOften, you will want to use a dialog box to hold a set of related controls. Dialog boxes are \nprimarily used to obtain user input and are often child windows of a top-level window. \nDialog boxes don\u2019t have menu bars, but in other respects, they function like frame windows. \n( You can add controls to them, for example, in the same way that you add controls to a \nframe window.) Dialog boxes may be modal or modeless. When a modal dialog box is \nactive, all input is directed to it until it is closed. This means that you cannot access other \nparts of your program until you have closed the dialog box. When a modeless dialog box is \nactive, input focus can be directed to another window in your program. Thus, other parts of \nyour program remain active and accessible. In the AWT, dialog boxes are of type Dialog . \nTwo commonly used constructors are shown here: \n\nDialog ( Frame parentWindow , boolean mode ) \nDialog ( Frame parentWindow , String title , boolean mode )",
    "Dialog ( Frame parentWindow , boolean mode ) \nDialog ( Frame parentWindow , String title , boolean mode ) \n\nHere, parentWindow is the owner of the dialog box. If mode is true , the dialog \n\nbox is modal. Otherwise, it is modeless. The title of the dialog box can be passed in \ntitle . Generally, you will subclass Dialog , adding the functionality required by your \n\napplication. \nFollowing is a modified version of the preceding menu program that displays a modeless \ndialog box when the New option is chosen. Notice that when the dialog box is closed, \ndispose ( ) is called. This method is defined by Window , and it frees all system resources \nassociated with the dialog box window. \n\n\n\n\n\n\n\n\n\n\nHere is sample output from the DialogDemo applet: \n\nTIP On your own, try defining dialog boxes for the other options \n\n\npresented by the menus. \n\nFileDialog",
    "Here is sample output from the DialogDemo applet: \n\nTIP On your own, try defining dialog boxes for the other options \n\n\npresented by the menus. \n\nFileDialog \n\nJava provides a built-in dialog box that lets the user specify a file. To create a file dialog box, \ninstantiate an object of type FileDialog . This causes a file dialog box to be displayed. \nUsually, this is the standard file dialog box provided by the operating system. Here are three \nFileDialog constructors: \n\nFileDialog ( Frame parent ) \nFileDialog ( Frame parent , String boxName ) \nFileDialog ( Frame parent , String boxName , int how )",
    "FileDialog ( Frame parent ) \nFileDialog ( Frame parent , String boxName ) \nFileDialog ( Frame parent , String boxName , int how ) \n\nHere, parent is the owner of the dialog box. The boxName parameter specifies the \nname displayed in the box\u2019s title bar. If boxName is omitted, the title of the dialog \nbox is empty. If how is FileDialog.LOAD , then the box is selecting a file for \nreading. If how is FileDialog.SAVE , the box is selecting a file for writing. If how \nis omitted, the box is selecting a file for reading. \nFileDialog provides methods that allow you to determine the name of the file and its path \nas selected by the user. Here are two examples: \n\nString getDirectory ( ) \nString getFile ( ) \n\nThese methods return the directory and the filename, respectively. \nThe following program activates the standard file dialog box: \n\n\nThe output generated by this program is shown here. ( The precise configuration of the \ndialog box may vary.)",
    "The output generated by this program is shown here. ( The precise configuration of the \ndialog box may vary.) \n\n\nOne last point: Beginning with JDK 7, you can use FileDialog to select a list of files. This \nfunctionality is supported by the setMultipleMode ( ) , isMultipleMode ( ) , and \ngetFiles ( ) methods. \n\nA Word About Overriding paint ( ) \n\nBefore concluding our examination of AWT controls, a short word about overriding paint ( \n) is in order. Although not relevant to the simple AWT examples shown in this book, when \noverriding paint ( ) , there are times when it is necessary to call the superclass \nimplementation of paint ( ) . Therefore, for some programs, you will need to use this paint ( \n) skeleton:",
    "In Java, there are two general types of components: heavyweight and lightweight. A \nheavyweight component has its own native window, which is called its peer . A lightweight \ncomponent is implemented completely in Java code and uses the window provided by an \nancestor. The AWT controls described and used in this chapter are all heavyweight. \nHowever, if a container holds any lightweight components ( that is, has lightweight child \n\n\ncomponents ), your override of paint ( ) for that container must call super.paint ( ) . By \ncalling super.paint ( ) , you ensure that any lightweight child components, such as \nlightweight controls, get properly painted. If you are unsure of a child component\u2019s type, \nyou can call isLightweight ( ) , defined by Component , to find out. It returns true if the \ncomponent is lightweight, and false otherwise. \n\n\uf709 \nPREV \nChapter 25: Introducing the AWT: Working with \u2026 \n\u23ee \n\nNEXT \nChapter 27: Images \n\u23ed",
    "\uf709 \nPREV \nChapter 25: Introducing the AWT: Working with \u2026 \n\u23ee \n\nNEXT \nChapter 27: Images \n\u23ed \n\n\nPREV \nChapter 26: Using AWT Controls, Layout Manag\u2026 \n\u23ee \n\nNEXT \nChapter 28: The Concurrency Utilities \u23ed \n\nCHAPTER \n\n27 \nImages",
    "This chapter examines the Image class and the java.awt.image package. Together, they \nprovide support for imaging ( the display and manipulation of graphical images ). An image \nis simply a rectangular graphical object. Images are a key component of web design. In fact, \nthe inclusion of the <img> tag in the Mosaic browser at NCSA ( National Center for \nSupercomputer Applications ) is what caused the Web to begin to grow explosively in 1993. \nThis tag was used to include an image inline with the flow of hypertext. Java expands upon \nthis basic concept, allowing images to be managed under program control. Because of its \nimportance, Java provides extensive support for imaging. \nImages are objects of the Image class, which is part of the java.awt package. Images are \nmanipulated using the classes found in the java.awt.image package. There are a large \nnumber of imaging classes and interfaces defined by java.awt.image , and it is not possible \nto examine them all",
    ". There are a large \nnumber of imaging classes and interfaces defined by java.awt.image , and it is not possible \nto examine them all. Instead, we will focus on those that form the foundation of imaging. \nHere are the java.awt.image classes discussed in this chapter:",
    "CropImageFilter \nMemoryImageSource \n\nFilteredImageSource \nPixelGrabber \n\nImageFilter \nRGBImageFilter \n\nThese are the interfaces that we will use: \n\nAlso examined is the MediaTracker class, which is part of java.awt . \n\nFile Formats \n\nOriginally, web images could only be in GIF format. The GIF image format was created by \nCompuServe in 1987 to make it possible for images to be viewed while online, so it was well \nsuited to the Internet. GIF images can have only up to 256 colors each. This limitation \n\n\ncaused the major browser vendors to add support for JPEG images in 1995. The JPEG",
    "caused the major browser vendors to add support for JPEG images in 1995. The JPEG \n\nformat was created by a group of photographic experts to store full-color-spectrum, \ncontinuous-tone images. These images, when properly created, can be of much higher \nfidelity as well as more highly compressed than a GIF encoding of the same source image. \nAnother file format is PNG. It too is an alternative to GIF. In almost all cases, you will never \ncare or notice which format is being used in your programs. The Java image classes abstract \nthe differences behind a clean interface. \n\nImage Fundamentals: Creating, Loading, and Displaying",
    "Image Fundamentals: Creating, Loading, and Displaying \n\nThere are three common operations that occur when you work with images: creating an \nimage, loading an image, and displaying an image. In Java, the Image class is used to refer \nto images in memory and to images that must be loaded from external sources. Thus, Java \nprovides ways for you to create a new image object and ways to load one. It also provides a \nmeans by which an image can be displayed. Let\u2019s look at each. \n\nCreating an Image Object \n\nYou might expect that you create a memory image using something like the following:",
    "Creating an Image Object \n\nYou might expect that you create a memory image using something like the following: \n\nNot so. Because images must eventually be painted on a window to be seen, the Image \nclass doesn\u2019t have enough information about its environment to create the proper data \nformat for the screen. Therefore, the Component class in java.awt has a factory method \ncalled createImage ( ) that is used to create Image objects. ( Remember that all of the \nAWT components are subclasses of Component , so all support this method.) \nThe createImage ( ) method has the following two forms: \n\nImage createImage ( ImageProducer imgProd ) \n\nImage createImage ( int width , int height ) \n\nThe first form returns an image produced by imgProd , which is an object of a class \nthat implements the ImageProducer interface. ( We will look at image producers \nlater.) The second form returns a blank ( that is, empty ) image that has the \nspecified width and height. Here is an example:",
    "This creates an instance of Canvas and then calls the createImage ( ) method to actually \n\nmake an Image object. At this point, the image is blank. Later, you will see how to write \ndata to it. \n\nLoading an Image \n\nThe other way to obtain an image is to load one. One way to do this is to use the getImage ( \n\n\n) method defined by the Applet class. It has the following forms: \n\nImage getImage ( URL url ) \nImage getImage ( URL url , String imageName ) \n\nThe first version returns an Image object that encapsulates the image found at the \nlocation specified by url . The second version returns an Image object that \nencapsulates the image found at the location specified by url and having the name \nspecified by imageName . \n\nDisplaying an Image \n\nOnce you have an image, you can display it by using drawImage ( ) , which is a member of \nthe Graphics class. It has several forms. The one we will be using is shown here:",
    "Displaying an Image \n\nOnce you have an image, you can display it by using drawImage ( ) , which is a member of \nthe Graphics class. It has several forms. The one we will be using is shown here: \n\nboolean drawImage ( Image imgObj , int left , int top , ImageObserver imgOb ) \n\nThis displays the image passed in imgObj with its upper-left corner specified by \nleft and top. imgOb is a reference to a class that implements the ImageObserver \ninterface. This interface is implemented by all AWT ( and Swing ) components. An \nimage observer is an object that can monitor an image while it loads. \nImageObserver is described in the next section. \nWith getImage ( ) and drawImage ( ) , it is actually quite easy to load and display an \nimage. Here is a sample applet that loads and displays a single image. The file Lilies.jpg is \nloaded, but you can substitute any GIF, JPG, or PNG file you like ( just make sure it is \navailable in the same directory with the HTML file that contains the applet ).",
    "In the init ( ) method, the img variable is assigned to the image returned by getImage ( ) . \n\nThe getImage ( ) method uses the string returned by getParameter (\"img\") as the \nfilename for the image. This image is loaded from a URL that is relative to the result of \ngetDocumentBase ( ) , which is the URL of the HTML page this applet tag was in. The \nfilename returned by getParameter (\"img\") comes from the applet tag <param name= \n\"img\" value=\"Lilies.jpg\"> . This is the equivalent, if a little slower, of using the HTML \ntag <img src=\"Lilies.jpg\" width=400 height=345> . Figure 27-1 shows what it looks \nlike when you run the program. \n\nFigure 27-1    Sample output from SimpleImageLoad \n\nWhen this applet runs, it starts loading img in the init ( ) method. Onscreen you can see \nthe image as it loads from the network, because Applet \u2019s implementation of the \nImageObserver interface calls paint ( ) every time more image data arrives.",
    "Seeing the image load is somewhat informative, but it might be better if you use the time it \ntakes to load the image to do other things in parallel. That way, the fully formed image can \nsimply appear on the screen in an instant, once it is fully loaded. You can use \nImageObserver , described next, to monitor loading an image while you paint the screen \nwith other information. \n\nImageObserver \n\n\nImageObserver is an interface used to receive notification as an image is being generated, \nand it defines only one method: imageUpdate ( ) . Using an image observer allows you to \nperform other actions, such as show a progress indicator or an attract screen, as you are \ninformed of the progress of the download. This kind of notification is very useful when an \nimage is being loaded over a slow network. \nThe imageUpdate ( ) method has this general form:",
    "Here, imgObj is the image being loaded, and flags is an integer that communicates the \nstatus of the update report. The four integers left, top, width , and height represent a \nrectangle that contains different values depending on the values passed in flags . \nimageUpdate ( ) should return false if it has completed loading, and true if there is more \nimage to process. \nThe flags parameter contains one or more bit flags defined as static variables inside the \nImageObserver interface. These flags and the information they provide are listed in Table \n27-1. \n\nTable 27-1    Bit Flags of the imageUpdate ( ) flags Parameter \n\nThe Applet class has an implementation of the imageUpdate ( ) method for the \n\nImageObserver interface that is used to repaint images as they are loaded. You can \noverride this method in your class to change that behavior. \nHere is a simple example of an imageUpdate ( ) method: \n\n\nDouble Buffering",
    "Not only are images useful for storing pictures, as we\u2019ve just shown, but you can also use \nthem as offscreen drawing surfaces. This allows you to render any image, including text and \ngraphics, to an offscreen buffer that you can display at a later time. The advantage to doing \nthis is that the image is seen only when it is complete. Drawing a complicated image could \ntake several milliseconds or more, which can be seen by the user as flashing or flickering. \nThis flashing is distracting and causes the user to perceive your rendering as slower than it \nactually is. Use of an offscreen image to reduce flicker is called double buffering , because the \nscreen is considered a buffer for pixels, and the offscreen image is the second buffer, where \nyou can prepare pixels for display. \nEarlier in this chapter, you saw how to create a blank Image object. Now you will see how \nto draw on that image rather than the screen",
    ". \nEarlier in this chapter, you saw how to create a blank Image object. Now you will see how \nto draw on that image rather than the screen. As you recall from earlier chapters, you need a \nGraphics object in order to use any of Java\u2019s rendering methods. Conveniently, the \nGraphics object that you can use to draw on an Image is available via the getGraphics ( ) \nmethod. Here is a code fragment that creates a new image, obtains its graphics context, and \nfills the entire image with red pixels:",
    "Once you have constructed and filled an offscreen image, it will still not be visible. To \nactually display the image, call drawImage ( ) . Here is an example that draws a timeconsuming image to demonstrate the difference that double buffering can make in perceived \ndrawing time: \n\n\n\n\nThis simple applet has a complicated paint ( ) method. It fills the background with blue and \nthen draws a red moir\u00e9 pattern on top of that. It paints some black text on top of that and \nthen paints a yellow circle centered at the coordinates mx , my . The mouseMoved ( ) and \nmouseDragged ( ) methods are overridden to track the mouse position. These methods \nare identical, except for the setting of the flicker Boolean variable. mouseMoved ( ) sets",
    "flicker to true , and mouseDragged ( ) sets it to false . This has the effect of calling \nrepaint ( ) with flicker set to true when the mouse is moved ( but no button is pressed ) \nand set to false when the mouse is dragged with any button pressed. \nWhen paint ( ) gets called with flicker set to true , we see each drawing operation as it is \nexecuted on the screen. In the case where a mouse button is pressed and paint ( ) is called \nwith flicker set to false , we see quite a different picture. The paint ( ) method swaps the \n\nGraphics reference g with the graphics context that refers to the offscreen canvas, buffer , \n\n\nwhich we created in init ( ) . Then all of the drawing operations are invisible. At the end of",
    "which we created in init ( ) . Then all of the drawing operations are invisible. At the end of \n\npaint ( ) , we simply call drawImage ( ) to show the results of these drawing methods all at \nonce. \nNotice that it is okay to pass in a null as the fourth parameter to drawImage ( ) . This is \nthe parameter used to pass an ImageObserver object that receives notification of image \nevents. Since this is an image that is not being produced from a network stream, we have no \nneed for notification. The left snapshot in Figure 27-2 is what the applet looks like with the \nmouse button not pressed. As you can see, the image was in the middle of repainting when \nthis snapshot was taken. The right snapshot shows how, when a mouse button is pressed, \nthe image is always complete and clean due to double buffering. \n\nFigure 27-2    Output from DoubleBuffer without ( left ) and with \n( right ) double buffering \n\nMediaTracker",
    "Figure 27-2    Output from DoubleBuffer without ( left ) and with \n( right ) double buffering \n\nMediaTracker \n\nA MediaTracker is an object that will check the status of an arbitrary number of images in \nparallel. To use MediaTracker , you create a new instance and use its addImage ( ) \nmethod to track the loading status of an image. addImage ( ) has the following general \nforms: \n\nvoid addImage ( Image imgObj , int imgID ) \n\nvoid addImage ( Image imgObj , int imgID , int width , int height ) \n\nHere, imgObj is the image being tracked. Its identification number is passed in",
    "void addImage ( Image imgObj , int imgID ) \n\nvoid addImage ( Image imgObj , int imgID , int width , int height ) \n\nHere, imgObj is the image being tracked. Its identification number is passed in \n\nimgID . ID numbers do not need to be unique. You can use the same number with \nseveral images as a means of identifying them as part of a group. Furthermore, \nimages with lower IDs are given priority over those with higher IDs when loading. \nIn the second form, width and height specify the dimensions of the object when it \nis displayed. \nOnce you\u2019ve registered an image, you can check whether it\u2019s loaded, or you can wait for it to \n\n\ncompletely load. To check the status of an image, call checkID ( ) . The version used in this \nchapter is shown here: \n\nboolean checkID ( int imgID )",
    "completely load. To check the status of an image, call checkID ( ) . The version used in this \nchapter is shown here: \n\nboolean checkID ( int imgID ) \n\nHere, imgID specifies the ID of the image you want to check. The method returns \ntrue if all images that have the specified ID have been loaded ( or if an error or \nuser-abort has terminated loading ). Otherwise, it returns false . You can use the \ncheckAll ( ) method to see if all images being tracked have been loaded. \nYou should use MediaTracker when loading a group of images. If all of the images that \nyou\u2019re interested in aren\u2019t downloaded, you can display something else to entertain the user \nuntil they all arrive.",
    "CAUTION If you use MediaTracker once you\u2019ve called addImage ( ) \non an image, a reference in MediaTracker will prevent the system from \ngarbage collecting it. If you want the system to be able to garbage collect \nimages that were being tracked, make sure it can collect the \nMediaTracker instance as well. \n\nHere\u2019s an example that loads a three-image slide show and displays a nice bar chart of the \nloading progress: \n\n\n\n\nThis example creates a new MediaTracker in the init ( ) method and then adds each of \nthe named images as a tracked image with addImage ( ) . In the paint ( ) method, it calls \ncheckID ( ) on each of the images that we\u2019re tracking. If all of the images are loaded, they \n\nare displayed. If not, a simple bar chart of the number of images loaded is shown, with the \nnames of the fully loaded images displayed underneath the bar. \n\n\nImageProducer",
    "are displayed. If not, a simple bar chart of the number of images loaded is shown, with the \nnames of the fully loaded images displayed underneath the bar. \n\n\nImageProducer \n\nImageProducer is an interface for objects that want to produce data for images. An object \nthat implements the ImageProducer interface will supply integer or byte arrays that \nrepresent image data and produce Image objects. As you saw earlier, one form of the \ncreateImage ( ) method takes an ImageProducer object as its argument. There are two \nimage producers contained in java.awt.image : MemoryImageSource and \nFilteredImageSource . Here, we will examine MemoryImageSource and create a new \nImage object from data generated in an applet. \n\nMemoryImageSource \n\nMemoryImageSource is a class that creates a new Image from an array of data. It \ndefines several constructors. Here is the one we will be using:",
    "The MemoryImageSource object is constructed out of the array of integers specified by \npixel , in the default RGB color model to produce data for an Image object. In the default \ncolor model, a pixel is an integer with Alpha, Red, Green, and Blue ( 0xAARRGGBB ). The \nAlpha value represents a degree of transparency for the pixel. Fully transparent is 0 and \nfully opaque is 255. The width and height of the resulting image are passed in width and \nheight . The starting point in the pixel array to begin reading data is passed in offset . The \nwidth of a scan line ( which is often the same as the width of the image ) is passed in \nscanLineWidth . \nThe following short example generates a MemoryImageSource object using a variation \non a simple algorithm ( a bitwise-exclusive-OR of the x and y address of each pixel ) from the \nbook Beyond Photography, The Digital Darkroom by Gerard J. Holzmann ( Prentice Hall, \n1988 ).",
    "The data for the new MemoryImageSource is created in the init ( ) method. An array of \nintegers is created to hold the pixel values ; the data is generated in the nested for loops \nwhere the r , g , and b values get shifted into a pixel in the pixels array. Finally, \ncreateImage ( ) is called with a new instance of a MemoryImageSource created from \nthe raw pixel data as its parameter. Figure 27-3 shows the image when we run the applet. ( It \nlooks much nicer in color.) \n\n\nFigure 27-3    Sample output from MemoryImageGenerator \n\nImageConsumer",
    "Figure 27-3    Sample output from MemoryImageGenerator \n\nImageConsumer \n\nImageConsumer is an interface for objects that want to take pixel data from images and \nsupply it as another kind of data. This, obviously, is the opposite of ImageProducer , \ndescribed earlier. An object that implements the ImageConsumer interface is going to \ncreate int or byte arrays that represent pixels from an Image object. We will examine the \nPixelGrabber class, which is a simple implementation of the ImageConsumer interface. \n\nPixelGrabber",
    "PixelGrabber \n\nThe PixelGrabber class is defined within java.lang.image . It is the inverse of the \nMemoryImageSource class. Rather than constructing an image from an array of pixel \nvalues, it takes an existing image and grabs the pixel array from it. To use PixelGrabber , \nyou first create an array of int s big enough to hold the pixel data, and then you create a \nPixelGrabber instance passing in the rectangle that you want to grab. Finally, you call \ngrabPixels ( ) on that instance. \nThe PixelGrabber constructor that is used in this chapter is shown here:",
    "Here, imgObj is the object whose pixels are being grabbed. The values of left and \ntop specify the upper-left corner of the rectangle, and width and height specify the \ndimensions of the rectangle from which the pixels will be obtained. The pixels will \nbe stored in pixel beginning at offset . The width of a scan line ( which is often the \nsame as the width of the image ) is passed in scanLineWidth . \ngrabPixels ( ) is defined like this: \n\n\nBoth methods return true if successful and false otherwise. In the second form, \nmilliseconds specifies how long the method will wait for the pixels. Both throw \nInterruptedException if execution is interrupted by another thread. \nHere is an example that grabs the pixels from an image and then creates a histogram of \npixel brightness. The histogram is simply a count of pixels that are a certain brightness for \nall brightness settings between 0 and 255. After the applet paints the image, it draws the \nhistogram over the top.",
    "Figure 27-4 shows an example image and its histogram. \n\nImageFilter \n\nGiven the ImageProducer and ImageConsumer interface pair\u2014and their concrete \nclasses MemoryImageSource and PixelGrabber \u2014you can create an arbitrary set of \ntranslation filters that takes a source of pixels, modifies them, and passes them on to an",
    "arbitrary consumer. This mechanism is analogous to the way concrete classes are created \nfrom the abstract I/O classes InputStream , OutputStream , Reader , and Writer \n( described in Chapter 20 ). This stream model for images is completed by the introduction of \nthe ImageFilter class. Some subclasses of ImageFilter in the java.awt.image package \nare AreaAveragingScaleFilter , CropImageFilter , ReplicateScaleFilter , and \nRGBImageFilter . There is also an implementation of ImageProducer called \nFilteredImageSource , which takes an arbitrary ImageFilter and wraps it around an \nImageProducer to filter the pixels it produces. An instance of FilteredImageSource \ncan be used as an ImageProducer in calls to createImage ( ) , in much the same way that \nBufferedInputStream s can be passed off as InputStream s. \n\nFigure 27-4    Sample output from HistoGrab \n\nIn this chapter, we examine two filters: CropImageFilter and RGBImageFilter . \n\nCropImageFilter",
    "Figure 27-4    Sample output from HistoGrab \n\nIn this chapter, we examine two filters: CropImageFilter and RGBImageFilter . \n\nCropImageFilter \n\nCropImageFilter filters an image source to extract a rectangular region. One situation in \nwhich this filter is valuable is where you want to use several small images from a single, \nlarger source image. Loading twenty 2K images takes much longer than loading a single 40K \nimage that has many frames of an animation tiled into it. If every subimage is the same size, \nthen you can easily extract these images by using CropImageFilter to disassemble the \n\n\nblock once your program starts. Here is an example that creates 16 images taken from a \nsingle image. The tiles are then scrambled by swapping a random pair from the 16 images \n32 times. \n\n\nFigure 27-5 shows the flowers image scrambled by the TileImage applet. \n\n\nFigure 27-5    Sample output from TileImage \n\nRGBImageFilter",
    "The RGBImageFilter is used to convert one image to another, pixel by pixel, transforming \nthe colors along the way. This filter could be used to brighten an image, to increase its \ncontrast, or even to convert it to grayscale. \nTo demonstrate RGBImageFilter , we have developed a somewhat complicated example \nthat employs a dynamic plug-in strategy for image-processing filters. We\u2019ve created an",
    "interface for generalized image filtering so that an applet can simply load these filters based \non <param> tags without having to know about all of the ImageFilter s in advance. This \nexample consists of the main applet class called ImageFilterDemo , the interface called \nPlugInFilter , and a utility class called LoadedImage , which encapsulates some of the \nMediaTracker methods we\u2019ve been using in this chapter. Also included are three filters \n\u2014 Grayscale , Invert , and Contrast \u2014which simply manipulate the color space of the \nsource image using RGBImageFilter s, and two more classes\u2014 Blur and Sharpen \u2014which \ndo more complicated \"convolution\" filters that change pixel data based on the pixels \nsurrounding each pixel of source data. Blur and Sharpen are subclasses of an abstract",
    "helper class called Convolver . Let\u2019s look at each part of our example. \n\nImageFilterDemo.java \n\nThe ImageFilterDemo class is the applet framework for our sample image filters. It \nemploys a simple BorderLayout , with a Panel at the South position to hold the buttons \n\n\nthat will represent each filter. A Label object occupies the North slot for informational \nmessages about filter progress. The Center is where the image ( which is encapsulated in the \nLoadedImage Canvas subclass, described later ) is put. We parse the buttons/filters out of \nthe filters <param> tag, separating them with +\u2019s using a StringTokenizer . \nThe actionPerformed ( ) method is interesting because it uses the label from a button as \nthe name of a filter class that it tries to load with ( PlugInFilter ) \nClass.forName ( a ).newInstance ( ) . This method is robust and takes appropriate action \nif the button does not correspond to a proper class that implements PlugInFilter .",
    "Figure 27-6 shows what the applet looks like when it is first loaded using the applet tag \nshown at the top of this source file. \n\n\nFigure 27-6    Sample normal output from ImageFilterDemo \n\nPlugInFilter.java \n\nPlugInFilter is a simple interface used to abstract image filtering. It has only one method, \nfilter ( ) , which takes the applet and the source image and returns a new image that has \nbeen filtered in some way. \n\nLoadedImage.java \n\nLoadedImage is a convenient subclass of Canvas , which takes an image at construction \ntime and synchronously loads it using MediaTracker . LoadedImage then behaves \nproperly inside of LayoutManager control, because it overrides the getPreferredSize ( ) \nand getMinimumSize ( ) methods. Also, it has a method called set ( ) that can be used to \nset a new Image to be displayed in this Canvas . That is how the filtered image is displayed \nafter the plug-in is finished. \n\n\nGrayscale.java",
    "Grayscale.java \n\nThe Grayscale filter is a subclass of RGBImageFilter , which means that Grayscale can \nuse itself as the ImageFilter parameter to FilteredImageSource \u2019s constructor. Then all \nit needs to do is override filterRGB ( ) to change the incoming color values. It takes the \nred, green, and blue values and computes the brightness of the pixel, using the NTSC \n( National Television Standards Committee ) color-to-brightness conversion factor. It then \nsimply returns a gray pixel that is the same brightness as the color source. \n\n\nInvert.java \n\nThe Invert filter is also quite simple. It takes apart the red, green, and blue channels and \nthen inverts them by subtracting them from 255. These inverted values are packed back into \na pixel value and returned. \n\nFigure 27-7 shows the image after it has been run through the Invert filter. \n\n\nFigure 27-7    Using the Invert filter with ImageFilterDemo \n\nContrast.java",
    "Figure 27-7 shows the image after it has been run through the Invert filter. \n\n\nFigure 27-7    Using the Invert filter with ImageFilterDemo \n\nContrast.java \n\nThe Contrast filter is very similar to Grayscale , except its override of filterRGB ( ) is \nslightly more complicated. The algorithm it uses for contrast enhancement takes the red, \ngreen, and blue values separately and boosts them by 1.2 times if they are already brighter \nthan 128. If they are below 128, then they are divided by 1.2. The boosted values are \nproperly clamped at 255 by the multclamp ( ) method. \n\n\nFigure 27-8 shows the image after Contrast is pressed. \n\nConvolver.java",
    "Figure 27-8 shows the image after Contrast is pressed. \n\nConvolver.java \n\nThe abstract class Convolver handles the basics of a convolution filter by implementing the \nImageConsumer interface to move the source pixels into an array called imgpixels . It \nalso creates a second array called newimgpixels for the filtered data. Convolution filters \nsample a small rectangle of pixels around each pixel in an image, called the convolution \nkernel . This area, 3 x 3 pixels in this demo, is used to decide how to change the center pixel \nin the area. \n\nNOTE The reason that the filter can\u2019t modify the imgpixels array in \nplace is that the next pixel on a scan line would try to use the original \n\nvalue for the previous pixel, which would have just been filtered away. \n\n\nFigure 27-8    Using the Contrast filter with ImageFilterDemo",
    "value for the previous pixel, which would have just been filtered away. \n\n\nFigure 27-8    Using the Contrast filter with ImageFilterDemo \n\nThe two concrete subclasses, shown in the next section, simply implement the convolve ( ) \nmethod, using imgpixels for source data and newimgpixels to store the result. \n\n\n\n\n\n\nNOTE A built-in convolution filter called ConvolveOp is provided by \njava.awt.image . You may want to explore its capabilities on your own. \n\nBlur.java \n\nThe Blur filter is a subclass of Convolver and simply runs through every pixel in the \nsource image array, imgpixels , and computes the average of the 3 x 3 box surrounding it. \nThe corresponding output pixel in newimgpixels is that average value. \n\n\nFigure 27-9 shows the applet after Blur . \n\n\nFigure 27-9    Using the Blur filter with ImageFilterDemo \n\nSharpen.java",
    "Figure 27-9 shows the applet after Blur . \n\n\nFigure 27-9    Using the Blur filter with ImageFilterDemo \n\nSharpen.java \n\nThe Sharpen filter is also a subclass of Convolver and is ( more or less ) the inverse of \nBlur . It runs through every pixel in the source image array, imgpixels , and computes the \naverage of the 3 x 3 box surrounding it, not counting the center. The corresponding output \npixel in newimgpixels has the difference between the center pixel and the surrounding \naverage added to it. This basically says that if a pixel is 30 brighter than its surroundings, \nmake it another 30 brighter. If, however, it is 10 darker, then make it another 10 darker. \nThis tends to accentuate edges while leaving smooth areas unchanged. \n\n\nFigure 27-10 shows the applet after Sharpen . \n\n\nFigure 27-10    Using the Sharpen filter with ImageFilterDemo \n\nAdditional Imaging Classes",
    "Figure 27-10 shows the applet after Sharpen . \n\n\nFigure 27-10    Using the Sharpen filter with ImageFilterDemo \n\nAdditional Imaging Classes \n\nIn addition to the imaging classes described in this chapter, java.awt.image supplies \nseveral others that offer enhanced control over the imaging process and that support \nadvanced imaging techniques. Also available is the imaging package called javax.imageio . \nThis package supports plug-ins that handle various image formats. If sophisticated graphical \noutput is of special interest to you, then you will want to explore the additional classes \nfound in java.awt.image and javax.imageio . \n\n\uf709 \nPREV \nChapter 26: Using AWT Controls, Layout Manag\u2026 \n\u23ee \n\nNEXT \nChapter 28: The Concurrency Utilities \u23ed \n\n\nPREV \nChapter 27: Images \n\u23ee \n\nNEXT \nChapter 29: The Stream API \u23ed \n\nCHAPTER \n\n28 \nThe Concurrency Utilities",
    "From the start, Java has provided built-in support for multithreading and synchronization. \nFor example, new threads can be created by implementing Runnable or by extending \nThread ; synchronization is available by use of the synchronized keyword ; and \ninterthread communication is supported by the wait ( ) and notify ( ) methods that are \ndefined by Object . In general, this built-in support for multithreading was one of Java\u2019s \nmost important innovations and is still one of its major strengths. \nHowever, as conceptually pure as Java\u2019s original support for multithreading is, it is not ideal \nfor all applications\u2014especially those that make intensive use of multiple threads. For \nexample, the original multithreading support does not provide several high-level features, \nsuch as semaphores, thread pools, and execution managers, that facilitate the creation of \nintensively concurrent programs",
    ". \nIt is important to explain at the outset that many Java programs make use of multithreading \nand are, therefore, \u201cconcurrent.\u201d For example, many applets and servlets use \nmultithreading. However, as it is used in this chapter, the term concurrent program refers \nto a program that makes extensive, integral use of concurrently executing threads. An \nexample of such a program is one that uses separate threads to simultaneously compute the \npartial results of a larger computation. Another example is a program that coordinates the \nactivities of several threads, each of which seeks access to information in a database. In this \ncase, read-only accesses might be handled differently from those that require read/write \ncapabilities. \nTo begin to handle the needs of a concurrent program, JDK 5 added the concurrency \nutilities , also commonly referred to as the concurrent API",
    ". \nTo begin to handle the needs of a concurrent program, JDK 5 added the concurrency \nutilities , also commonly referred to as the concurrent API . The original set of concurrency \nutilities supplied many features that had long been wanted by programmers who develop",
    "concurrent applications. For example, it offered synchronizers ( such as the semaphore ), \nthread pools, execution managers, locks, several concurrent collections, and a streamlined \nway to use threads to obtain computational results. \nAlthough the original concurrent API was impressive in its own right, it was significantly \nexpanded by JDK 7. The most important addition was the Fork/Join Framework . The \nFork/Join Framework facilitates the creation of programs that make use of multiple \n\n\nprocessors ( such as those found in multicore systems ). Thus, it streamlines the development",
    "of programs in which two or more pieces execute with true simultaneity ( that is, true \nparallel execution ), not just time-slicing. As you can easily imagine, parallel execution can \ndramatically increase the speed of certain operations. Because multicore systems are now \ncommonplace, the inclusion of the Fork/Join Framework was as timely as it was powerful. \nWith the release of JDK 8, the Fork/Join Framework was further enhanced. \nIn addition, JDK 8 included some new features related to other parts of the concurrent API. \nThus, the concurrent API continues to evolve and expand to meet the needs of the \ncontemporary computing environment. \nThe original concurrent API was quite large, and the additions made by JDK 7 and JDK 8 \nhave increased its size substantially. As you might expect, many of the issues surrounding \nthe concurrency utilities are quite complex. It is beyond the scope of this book to discuss all \nof its facets",
    ". As you might expect, many of the issues surrounding \nthe concurrency utilities are quite complex. It is beyond the scope of this book to discuss all \nof its facets. The preceding notwithstanding, it is important for all programmers to have a \ngeneral, working knowledge of key aspects of the concurrent API. Even in programs that are \nnot intensively parallel, features such as synchronizers, callable threads, and executors, are \napplicable to a wide variety of situations. Perhaps most importantly, because of the rise of \nmulticore computers, solutions involving the Fork/Join Framework are becomming more \ncommon. For these reasons, this chapter presents an overview of several core features \ndefined by the concurrency utilities and shows a number of examples that demonstrate their \nuse. It concludes with an introduction to the Fork/Join Framework.",
    "The Concurrent API Packages \n\nThe concurrency utilities are contained in the java.util.concurrent package and in its two \nsubpackages: java.util.concurrent.atomic and java.util.concurrent.locks . A brief \noverview of their contents is given here. \n\njava.util.concurrent \n\njava.util.concurrent defines the core features that support alternatives to the built-in \napproaches to synchronization and interthread communication. It defines the following key \nfeatures: \n\n\u2022  Synchronizers \n\n\u2022  Executors \n\n\u2022  Concurrent collections \n\n\u2022  The Fork/Join Framework \n\nSynchronizers offer high-level ways of synchronizing the interactions between \nmultiple threads. The synchronizer classes defined by java.util.concurrent are \n\nSemaphore \nImplements the classic semaphore. \n\nCountDownLatch \nWaits until a specified number of events have occurred. \n\n\nCyclicBarrier \nEnables a group of threads to wait at a predefined execution point. \n\nExchanger \nExchanges data between two threads.",
    "CyclicBarrier \nEnables a group of threads to wait at a predefined execution point. \n\nExchanger \nExchanges data between two threads. \n\nPhaser \nSynchronizes threads that advance through multiple phases of an \noperation.",
    "Notice that each synchronizer provides a solution to a specific type of synchronization \nproblem. This enables each synchronizer to be optimized for its intended use. In the past, \nthese types of synchronization objects had to be crafted by hand. The concurrent API \nstandardizes them and makes them available to all Java programmers. \nExecutors manage thread execution. At the top of the executor hierarchy is the Executor \ninterface, which is used to initiate a thread. ExecutorService extends Executor and \nprovides methods that manage execution. There are three implementations of \nExecutorService : ThreadPoolExecutor , ScheduledThreadPoolExecutor , and \nForkJoinPool . java.util.concurrent also defines the Executors utility class, which \nincludes a number of static methods that simplify the creation of various executors. \nRelated to executors are the Future and Callable interfaces. A Future contains a value \nthat is returned by a thread after it executes",
    ". \nRelated to executors are the Future and Callable interfaces. A Future contains a value \nthat is returned by a thread after it executes. Thus, its value becomes defined \u201cin the \nfuture,\u201d when the thread terminates. Callable defines a thread that returns a value. \njava.util.concurrent defines several concurrent collection classes, including \nConcurrentHashMap , ConcurrentLinkedQueue , and CopyOnWriteArrayList . \nThese offer concurrent alternatives to their related classes defined by the Collections \nFramework. \nThe Fork/Join Framework supports parallel programming. Its main classes are \nForkJoinTask , ForkJoinPool , RecursiveTask , and RecursiveAction . \nFinally, to better handle thread timing, java.util.concurrent defines the TimeUnit \nenumeration.",
    "java.util.concurrent.atomic \n\njava.util.concurrent.atomic facilitates the use of variables in a concurrent environment. \nIt provides a means of efficiently updating the value of a variable without the use of locks. \nThis is accomplished through the use of classes, such as AtomicInteger and AtomicLong , \nand methods, such as compareAndSet ( ) , decrementAndGet ( ) , and getAndSet ( ) . \nThese methods execute as a single, non-interruptible operation. \n\njava.util.concurrent.locks \n\njava.util.concurrent.locks provides an alternative to the use of synchronized methods. \nAt the core of this alternative is the Lock interface, which defines the basic mechanism used \nto acquire and relinquish access to an object. The key methods are lock ( ) , tryLock ( ) , \nand unlock ( ) . The advantage to using these methods is greater control over \n\nsynchronization. \n\n\nThe remainder of this chapter takes a closer look at the constituents of the concurrent API. \n\nUsing Synchronization Objects",
    "synchronization. \n\n\nThe remainder of this chapter takes a closer look at the constituents of the concurrent API. \n\nUsing Synchronization Objects \n\nSynchronization objects are supported by the Semaphore , CountDownLatch , \nCyclicBarrier , Exchanger , and Phaser classes. Collectively, they enable you to handle \nseveral formerly difficult synchronization situations with ease. They are also applicable to a \nwide range of programs\u2014even those that contain only limited concurrency. Because the \nsynchronization objects will be of interest to nearly all Java programs, each is examined \nhere in some detail. \n\nSemaphore",
    "The synchronization object that many readers will immediately recognize is Semaphore , \nwhich implements a classic semaphore. A semaphore controls access to a shared resource \nthrough the use of a counter. If the counter is greater than zero, then access is allowed. If it \nis zero, then access is denied. What the counter is counting are permits that allow access to \nthe shared resource. Thus, to access the resource, a thread must be granted a permit from \nthe semaphore. \nIn general, to use a semaphore, the thread that wants access to the shared resource tries to \nacquire a permit. If the semaphore\u2019s count is greater than zero, then the thread acquires a \npermit, which causes the semaphore\u2019s count to be decremented. Otherwise, the thread will \nbe blocked until a permit can be acquired. When the thread no longer needs access to the \nshared resource, it releases the permit, which causes the semaphore\u2019s count to be \nincremented",
    ". When the thread no longer needs access to the \nshared resource, it releases the permit, which causes the semaphore\u2019s count to be \nincremented. If there is another thread waiting for a permit, then that thread will acquire a \npermit at that time. Java\u2019s Semaphore class implements this mechanism. \nSemaphore has the two constructors shown here:",
    "Semaphore ( int num ) \n\nSemaphore ( int num , boolean how ) \n\nHere, num specifies the initial permit count. Thus, num specifies the number of \nthreads that can access a shared resource at any one time. If num is one, then only \none thread can access the resource at any one time. By default, waiting threads are \ngranted a permit in an undefined order. By setting how to true , you can ensure \nthat waiting threads are granted a permit in the order in which they requested \naccess. \nTo acquire a permit, call the acquire ( ) method, which has these two forms: \n\nvoid acquire ( ) throws InterruptedException \nvoid acquire ( int num ) throws InterruptedException \n\nThe first form acquires one permit. The second form acquires num permits. Most \noften, the first form is used. If the permit cannot be granted at the time of the call, \nthen the invoking thread suspends until the permit is available. \nTo release a permit, call release ( ) , which has these two forms:",
    "void release ( ) \nvoid release ( int num ) \n\nThe first form releases one permit. The second form releases the number of \npermits specified by num . \nTo use a semaphore to control access to a resource, each thread that wants to use that \nresource must first call acquire ( ) before accessing the resource. When the thread is done \nwith the resource, it must call release ( ) . Here is an example that illustrates the use of a \nsemaphore: \n\n\n\n\nThe output from the program is shown here. ( The precise order in which the threads \nexecute may vary.)",
    "The program uses a semaphore to control access to the count variable, which is a static \nvariable within the Shared class. Shared.count is incremented five times by the run ( ) \nmethod of IncThread and decremented five times by DecThread . To prevent these two \nthreads from accessing Shared.count at the same time, access is allowed only after a \npermit is acquired from the controlling semaphore. After access is complete, the permit is \nreleased. In this way, only one thread at a time will access Shared.count , as the output \nshows. \nIn both IncThread and DecThread , notice the call to sleep ( ) within run ( ) . It is used \nto \u201cprove\u201d that accesses to Shared.count are synchronized by the semaphore. In run ( ) , \nthe call to sleep ( ) causes the invoking thread to pause between each access to \nShared.count . This would normally enable the second thread to run",
    ". In run ( ) , \nthe call to sleep ( ) causes the invoking thread to pause between each access to \nShared.count . This would normally enable the second thread to run. However, because of \nthe semaphore, the second thread must wait until the first has released the permit, which \nhappens only after all accesses by the first thread are complete. Thus, Shared.count is first \nincremented five times by IncThread and then decremented five times by DecThread . \nThe increments and decrements are not intermixed. \nWithout the use of the semaphore, accesses to Shared.count by both threads would have \noccurred simultaneously, and the increments and decrements would be intermixed. To \nconfirm this, try commenting out the calls to acquire ( ) and release ( ) . When you run the",
    "program, you will see that access to Shared.count is no longer synchronized, and each \nthread accesses it as soon as it gets a timeslice. \nAlthough many uses of a semaphore are as straightforward as that shown in the preceding \nprogram, more intriguing uses are also possible. Here is an example. The following program \nreworks the producer/consumer program shown in Chapter 11 so that it uses two \nsemaphores to regulate the producer and consumer threads, ensuring that each call to put ( \n\n\n) is followed by a corresponding call to get ( ) : \n\n\nA portion of the output is shown here:",
    "As you can see, the calls to put ( ) and get ( ) are synchronized. That is, each call to put ( ) is \nfollowed by a call to get ( ) and no values are missed. Without the semaphores, multiple \ncalls to put ( ) would have occurred without matching calls to get ( ) , resulting in values \nbeing missed. ( To prove this, remove the semaphore code and observe the results.) \nThe sequencing of put ( ) and get ( ) calls is handled by two semaphores: semProd and \nsemCon . Before put ( ) can produce a value, it must acquire a permit from semProd . \nAfter it has set the value, it releases semCon . Before get ( ) can consume a value, it must \nacquire a permit from semCon . After it consumes the value, it releases semProd . This \n\u201cgive and take\u201d mechanism ensures that each call to put ( ) must be followed by a call to \nget ( ) . \nNotice that semCon is initialized with no available permits. This ensures that put ( ) \nexecutes first",
    ". \nNotice that semCon is initialized with no available permits. This ensures that put ( ) \nexecutes first. The ability to set the initial synchronization state is one of the more powerful \naspects of a semaphore.",
    "CountDownLatch \n\nSometimes you will want a thread to wait until one or more events have occurred. To \n\nhandle such a situation, the concurrent API supplies CountDownLatch . A \nCountDownLatch is initially created with a count of the number of events that must occur \nbefore the latch is released. Each time an event happens, the count is decremented. When \nthe count reaches zero, the latch opens. \nCountDownLatch has the following constructor: \n\nCountDownLatch ( int num ) \n\nHere, num specifies the number of events that must occur in order for the latch to \nopen. \nTo wait on the latch, a thread calls await ( ) , which has the forms shown here: \n\nvoid await ( ) throws InterruptedException \n\nboolean await ( long wait , TimeUnit tu ) throws InterruptedException \n\nThe first form waits until the count associated with the invoking \nCountDownLatch reaches zero. The second form waits only for the period of \ntime specified by wait . The units represented by wait are specified by tu , which is",
    "an object the TimeUnit enumeration. ( TimeUnit is described later in this \nchapter.) It returns false if the time limit is reached and true if the countdown \nreaches zero \nTo signal an event, call the countDown ( ) method, shown next: \n\nvoid countDown ( ) \n\nEach call to countDown ( ) decrements the count associated with the invoking \nobject. \nThe following program demonstrates CountDownLatch . It creates a latch that requires \nfive events to occur before it opens. \n\n\nThe output produced by the program is shown here: \n\n\nInside main ( ) , a CountDownLatch called cdl is created with an initial count of five.",
    "The output produced by the program is shown here: \n\n\nInside main ( ) , a CountDownLatch called cdl is created with an initial count of five. \n\nNext, an instance of MyThread is created, which begins execution of a new thread. Notice \nthat cdl is passed as a parameter to MyThread \u2019s constructor and stored in the latch \ninstance variable. Then, the main thread calls await ( ) on cdl , which causes execution of \nthe main thread to pause until cdl \u2019s count has been decremented five times. \nInside the run ( ) method of MyThread , a loop is created that iterates five times. With \neach iteration, the countDown ( ) method is called on latch , which refers to cdl in main ( \n) . After the fifth iteration, the latch opens, which allows the main thread to resume. \nCountDownLatch is a powerful yet easy-to-use synchronization object that is appropriate \nwhenever a thread must wait for one or more events to occur. \n\nCyclicBarrier",
    "CyclicBarrier \n\nA situation not uncommon in concurrent programming occurs when a set of two or more \nthreads must wait at a predetermined execution point until all threads in the set have \nreached that point. To handle such a situation, the concurrent API supplies the \nCyclicBarrier class. It enables you to define a synchronization object that suspends until \nthe specified number of threads has reached the barrier point. \nCyclicBarrier has the following two constructors: \n\nCyclicBarrier ( int numThreads ) \nCyclicBarrier ( int numThreads , Runnable action )",
    "CyclicBarrier ( int numThreads ) \nCyclicBarrier ( int numThreads , Runnable action ) \n\nHere, numThreads specifies the number of threads that must reach the barrier \nbefore execution continues. In the second form, action specifies a thread that will \nbe executed when the barrier is reached. \nHere is the general procedure that you will follow to use CyclicBarrier . First, create a \nCyclicBarrier object, specifying the number of threads that you will be waiting for. Next, \nwhen each thread reaches the barrier, have it call await ( ) on that object. This will pause \nexecution of the thread until all of the other threads also call await ( ) . Once the specified \nnumber of threads has reached the barrier, await ( ) will return and execution will resume. \nAlso, if you have specified an action, then that thread is executed. \nThe await ( ) method has the following two forms:",
    "The first form waits until all the threads have reached the barrier point. The second form \nwaits only for the period of time specified by wait . The units represented by wait are \nspecified by tu . Both forms return a value that indicates the order that the threads arrive at \nthe barrier point. The first thread returns a value equal to the number of threads waited \nupon minus one. The last thread returns zero. \n\nHere is an example that illustrates CyclicBarrier . It waits until a set of three threads has \n\n\nreached the barrier. When that occurs, the thread specified by BarAction executes. \n\nThe output is shown here. ( The precise order in which the threads execute may vary.) \n\n\nA CyclicBarrier can be reused because it will release waiting threads each time the \nspecified number of threads calls await ( ) . For example, if you change main ( ) in the \npreceding program so that it looks like this:",
    "the following output will be produced. ( The precise order in which the threads execute may \nvary.) \n\nAs the preceding example shows, the CyclicBarrier offers a streamlined solution to what \nwas previously a complicated problem. \n\nExchanger \n\nPerhaps the most interesting of the synchronization classes is Exchanger . It is designed to \nsimplify the exchange of data between two threads. The operation of an Exchanger is \nastoundingly simple: it simply waits until two separate threads call its exchange ( ) \n\nmethod. When that occurs, it exchanges the data supplied by the threads. This mechanism is \nboth elegant and easy to use. Uses for Exchanger are easy to imagine. For example, one",
    "method. When that occurs, it exchanges the data supplied by the threads. This mechanism is \nboth elegant and easy to use. Uses for Exchanger are easy to imagine. For example, one \n\n\nthread might prepare a buffer for receiving information over a network connection. Another \nthread might fill that buffer with the information from the connection. The two threads \nwork together so that each time a new buffer is needed, an exchange is made. \nExchanger is a generic class that is declared as shown here: \n\nExchanger<V> \n\nHere, V specifies the type of the data being exchanged. \nThe only method defined by Exchanger is exchange ( ) , which has the two forms shown \nhere:",
    "Exchanger<V> \n\nHere, V specifies the type of the data being exchanged. \nThe only method defined by Exchanger is exchange ( ) , which has the two forms shown \nhere: \n\nHere, objRef is a reference to the data to exchange. The data received from the other thread \nis returned. The second form of exchange ( ) allows a time-out period to be specified. The \nkey point about exchange ( ) is that it won\u2019t succeed until it has been called on the same \nExchanger object by two separate threads. Thus, exchange ( ) synchronizes the exchange \nof the data. \nHere is an example that demonstrates Exchanger . It creates two threads. One thread \ncreates an empty buffer that will receive the data put into it by the second thread. In this \ncase, the data is a string. Thus, the first thread exchanges an empty string for a full one. \n\n\n\n\nHere is the output produced by the program: \n\nIn the program, the main ( ) method creates an Exchanger for strings. This object is then",
    "Here is the output produced by the program: \n\nIn the program, the main ( ) method creates an Exchanger for strings. This object is then \n\nused to synchronize the exchange of strings between the MakeString and UseString \nclasses. The MakeString class fills a string with data. The UseString exchanges an empty \nstring for a full one. It then displays the contents of the newly constructed string. The \nexchange of empty and full buffers is synchronized by the exchange ( ) method, which is \ncalled by both classes\u2019 run ( ) method. \n\n\nPhaser",
    "Another synchronization class is called Phaser . Its primary purpose is to enable the \nsynchronization of threads that represent one or more phases of activity. For example, you \nmight have a set of threads that implement three phases of an order-processing application. \nIn the first phase, separate threads are used to validate customer information, check \ninventory, and confirm pricing. When that phase is complete, the second phase has two \nthreads that compute shipping costs and all applicable tax. After that, a final phase confirms \npayment and determines estimated shipping time. In the past, to synchronize the multiple \nthreads that comprise this scenario would require a bit of work on your part. With the \ninclusion of Phaser , the process is now much easier. \nTo begin, it helps to know that a Phaser works a bit like a CyclicBarrier , described \nearlier, except that it supports multiple phases",
    ". \nTo begin, it helps to know that a Phaser works a bit like a CyclicBarrier , described \nearlier, except that it supports multiple phases. As a result, Phaser lets you define a \nsynchronization object that waits until a specific phase has completed. It then advances to \nthe next phase, again waiting until that phase concludes. It is important to understand that \nPhaser can also be used to synchronize only a single phase. In this regard, it acts much like \na CyclicBarrier . However, its primary use is to synchronize multiple phases. \nPhaser defines four constructors. Here are the two used in this section:",
    "The first creates a phaser that has a registration count of zero. The second sets the \nregistration count to numParties . The term party is often applied to the objects \nthat register with a phaser. Although often there is a one-to-correspondence \nbetween the number of registrants and the number of threads being synchronized, \nthis is not required. In both cases, the current phase is zero. That is, when a \nPhaser is created, it is initially at phase zero. \nIn general, here is how you use Phaser . First, create a new instance of Phaser . Next, \nregister one or more parties with the phaser, either by calling register ( ) or by specifying \nthe number of parties in the constructor. For each registered party, have the phaser wait \nuntil all registered parties complete a phase. A party signals this by calling one of a variety \nof methods supplied by Phaser , such as arrive ( ) or arriveAndAwaitAdvance ( )",
    ". A party signals this by calling one of a variety \nof methods supplied by Phaser , such as arrive ( ) or arriveAndAwaitAdvance ( ) . After \nall parties have arrived, the phase is complete, and the phaser can move on to the next \nphase ( if there is one ), or terminate. The following sections explain the process in detail. \nTo register parties after a Phaser has been constructed, call register ( ) . It is shown here:",
    "int register () \n\nIt returns the phase number of the phase to which it is registered. \n\nTo signal that a party has completed a phase, it must call arrive ( ) or some variation of \narrive ( ) . When the number of arrivals equals the number of registered parties, the phase \nis completed and the Phaser moves on to the next phase ( if there is one ). The arrive ( ) \n\n\nmethod has this general form: \n\nint arrive ( )",
    "method has this general form: \n\nint arrive ( ) \n\nThis method signals that a party ( normally a thread of execution ) has completed \nsome task ( or portion of a task ). It returns the current phase number. If the phaser \nhas been terminated, then it returns a negative value. The arrive ( ) method does \nnot suspend execution of the calling thread. This means that it does not wait for \nthe phase to be completed. This method should be called only by a registered \nparty. \nIf you want to indicate the completion of a phase and then wait until all other registrants \nhave also completed that phase, use arriveAndAwaitAdvance ( ) . It is shown here: \n\nint arriveAndAwaitAdvance ( ) \n\nIt waits until all parties have arrived. It returns the next phase number or a \nnegative value if the phaser has been terminated. This method should be called \nonly by a registered party. \nA thread can arrive and then deregister itself by calling arriveAndDeregister ( ) . It is \nshown here:",
    "int arriveAndDeregister ( ) \n\nIt returns the current phase number or a negative value if the phaser has been \nterminated. It does not wait until the phase is complete. This method should be \ncalled only by a registered party. \nTo obtain the current phase number, call getPhase ( ) , which is shown here: \n\nfinal int getPhase ( ) \n\nWhen a Phaser is created, the first phase will be 0, the second phase 1, the third \nphase 2, and so on. A negative value is returned if the invoking Phaser has been \nterminated. \nHere is an example that shows Phaser in action. It creates three threads, each of which \nhave three phases. It uses a Phaser to synchronize each phase. \n\n\n\n\nThe output is shown here:",
    "Let\u2019s look closely at the key sections of the program. First, in main ( ) , a Phaser called \nphsr is created with an initial party count of 1 ( which corresponds to the main thread ). \nThen three threads are started by creating three MyThread objects. Notice that \nMyThread is passed a reference to phsr ( the phaser ). The MyThread objects use this \nphaser to synchronize their activities. Next, main ( ) calls getPhase ( ) to obtain the current \nphase number ( which is initially zero ) and then calls arriveAndAwaitAdvance ( ) . This \ncauses main ( ) to suspend until phase zero has completed. This won\u2019t happen until all \nMyThread s also call arriveAndAwaitAdvance ( ) . When this occurs, main ( ) will \nresume execution, at which point it displays that phase zero has completed, and it moves on \nto the next phase. This process repeats until all three phases have finished. Then, main ( ) \ncalls arriveAndDeregister ( ) . At that point, all three MyThread s have also deregistered",
    ". This process repeats until all three phases have finished. Then, main ( ) \ncalls arriveAndDeregister ( ) . At that point, all three MyThread s have also deregistered. \nSince this results in there being no registered parties when the phaser advances to the next \nphase, the phaser is terminated. \nNow look at MyThread . First, notice that the constructor is passed a reference to the \nphaser that it will use and then registers with the new thread as a party on that phaser. \nThus, each new MyThread becomes a party registered with the passed-in phaser. Also \nnotice that each thread has three phases. In this example, each phase consists of a \nplaceholder that simply displays the name of the thread and what it is doing. Obviously, in \nreal-world code, the thread would be performing more meaningful actions. Between the first \ntwo phases, the thread calls arriveAndAwaitAdvance ( ) . Thus, each thread waits until all \nthreads have completed the phase ( and the main thread is ready )",
    ". Between the first \ntwo phases, the thread calls arriveAndAwaitAdvance ( ) . Thus, each thread waits until all \nthreads have completed the phase ( and the main thread is ready ). After all threads have \narrived ( including the main thread ), the phaser moves on to the next phase. After the third \nphase, each thread deregisters itself with a call to arriveAndDeregister ( ) . As the",
    "comments in MyThread explain, the calls to sleep ( ) are used for the purposes of \nillustration to ensure that the output is not jumbled because of the multithreading. They are \nnot needed to make the phaser work properly. If you remove them, the output may look a \nbit jumbled, but the phases will still be synchronized correctly. \nOne other point: Although the preceding example used three threads that were all of the \n\n\nsame type, this is not a requirement. Each party that uses a phaser can be unique, with each \n\nperforming some separate task. \nIt is possible to take control of precisely what happens when a phase advance occurs. To do \nthis, you must override the onAdvance ( ) method. This method is called by the run time \nwhen a Phaser advances from one phase to the next. It is shown here: \n\nprotected boolean onAdvance ( int phase , int numParties )",
    "Here, phase will contain the current phase number prior to being incremented and \nnumParties will contain the number of registered parties. To terminate the phaser, \nonAdvance ( ) must return true . To keep the phaser alive, onAdvance ( ) must \nreturn false . \nThe default version of onAdvance ( ) returns true ( thus terminating the phaser ) when \nthere are no registered parties. As a general rule, your override should also follow this \npractice. \nOne reason to override onAdvance ( ) is to enable a phaser to execute a specific number of \nphases and then stop. The following example gives you the flavor of this usage. It creates a",
    "class called MyPhaser that extends Phaser so that it will run a specified number of \nphases. It does this by overriding the onAdvance ( ) method. The MyPhaser constructor \naccepts one argument, which specifies the number of phases to execute. Notice that \nMyPhaser automatically registers one party. This behavior is useful in this example, but \nthe needs of your own applications may differ.",
    "The output from the program is shown here: \n\n\nInside main ( ) , one instance of Phaser is created. It is passed 4 as an argument, which \nmeans that it will execute four phases and then stop. Next, three threads are created and \nthen the following loop is entered: \n\nThis loop simply calls arriveAndAwaitAdvance ( ) until the phaser is terminated. The \nphaser won\u2019t terminate until the specified number of phases have been executed. In this \ncase, the loop continues to execute until four phases have run. Next, notice that the threads \nalso call arriveAndAwaitAdvance ( ) within a loop that runs until the phaser is \nterminated. This means that they will execute until the specified number of phases has been \ncompleted.",
    "Now, look closely at the code for onAdvance ( ) . Each time onAdvance ( ) is called, it is \npassed the current phase and the number of registered parties. If the current phase equals \nthe specified phase, or if the number of registered parties is zero, onAdvance ( ) returns \ntrue , thus stopping the phaser. This is accomplished with this line of code: \n\n\nAs you can see, very little code is needed to accommodate the desired outcome. \nBefore moving on, it is useful to point out that you don\u2019t necessarily need to explicitly \nextend Phaser as the previous example does to simply override onAdvance ( ) . In some \ncases, more compact code can be created by using an anonymous inner class to override \nonAdvance ( ) . \nPhaser has additional capabilities that may be of use in your applications. You can wait for \na specific phase by calling awaitAdvance ( ) , which is shown here: \n\nint awaitAdvance ( int phase )",
    "Here, phase indicates the phase number on which awaitAdvance ( ) will wait \nuntil a transition to the next phase takes place. It will return immediately if the \nargument passed to phase is not equal to the current phase. It will also return \nimmediately if the phaser is terminated. However, if phase is passed the current \nphase, then it will wait until the phase increments. This method should be called \nonly by a registered party. There is also an interruptible version of this method \ncalled awaitAdvanceInterruptibly ( ) . \nTo register more than one party, call bulkRegister ( ) . To obtain the number of registered \nparties, call getRegisteredParties ( ) . You can also obtain the number of arrived parties \nand unarrived parties by calling getArrivedParties ( ) and getUnarrivedParties ( ) , \nrespectively. To force the phaser to enter a terminated state, call forceTermination ( ) . \nPhaser also lets you create a tree of phasers",
    ". To force the phaser to enter a terminated state, call forceTermination ( ) . \nPhaser also lets you create a tree of phasers. This is supported by two additional \nconstructors, which let you specify the parent, and the getParent ( ) method.",
    "Using an Executor \n\nThe concurrent API supplies a feature called an executor that initiates and controls the \nexecution of threads. As such, an executor offers an alternative to managing threads through \nthe Thread class. \nAt the core of an executor is the Executor interface. It defines the following method: \n\nvoid execute ( Runnable thread ) \n\nThe thread specified by thread is executed. Thus, execute ( ) starts the specified \nthread. \nThe ExecutorService interface extends Executor by adding methods that help manage \nand control the execution of threads. For example, ExecutorService defines shutdown ( \n) , shown here, which stops the invoking ExecutorService . \n\nvoid shutdown ( ) \n\nExecutorService also defines methods that execute threads that return results, \n\nthat execute a set of threads, and that determine the shutdown status. We will look \nat several of these methods a little later. \n\nAlso defined is the interface ScheduledExecutorService , which extends",
    "ExecutorService to support the scheduling of threads. \nThe concurrent API defines three predefined executor classes: ThreadPoolExecutor and \nScheduledThreadPoolExecutor , and ForkJoinPool . ThreadPoolExecutor \nimplements the Executor and ExecutorService interfaces and provides support for a \nmanaged pool of threads. ScheduledThreadPoolExecutor also implements the \nScheduledExecutorService interface to allow a pool of threads to be scheduled. \nForkJoinPool implements the Executor and ExecutorService interfaces and is used by \nthe Fork/Join Framework. It is described later in this chapter. \nA thread pool provides a set of threads that is used to execute various tasks. Instead of each \ntask using its own thread, the threads in the pool are used. This reduces the overhead \nassociated with creating many separate threads",
    ". Instead of each \ntask using its own thread, the threads in the pool are used. This reduces the overhead \nassociated with creating many separate threads. Although you can use \nThreadPoolExecutor and ScheduledThreadPoolExecutor directly, most often you \nwill want to obtain an executor by calling one of the following static factory methods defined \nby the Executors utility class. Here are some examples:",
    "static ExecutorService newCachedThreadPool ( ) \nstatic ExecutorService newFixedThreadPool ( int numThreads ) \nstatic ScheduledExecutorService newScheduledThreadPool ( int numThreads ) \n\nnewCachedThreadPool ( ) creates a thread pool that adds threads as needed \nbut reuses threads if possible. newFixedThreadPool ( ) creates a thread pool \nthat consists of a specified number of threads. newScheduledThreadPool ( ) \ncreates a thread pool that supports thread scheduling. Each returns a reference to \nan ExecutorService that can be used to manage the pool. \n\nA Simple Executor Example \n\nBefore going any further, a simple example that uses an executor will be of value. The \nfollowing program creates a fixed thread pool that contains two threads. It then uses that \npool to execute four tasks. Thus, four tasks share the two threads that are in the pool. After \nthe tasks finish, the pool is shut down and the program ends.",
    "The output from the program is shown here. ( The precise order in which the threads \nexecute may vary.) \n\n\nAs the output shows, even though the thread pool contains only two threads, all four tasks \nare still executed. However, only two can run at the same time. The others must wait until \none of the pooled threads is available for use. \nThe call to shutdown ( ) is important. If it were not present in the program, then the \nprogram would not terminate because the executor would remain active. To try this for \nyourself, simply comment out the call to shutdown ( ) and observe the result. \n\nUsing Callable and Future",
    "Using Callable and Future \n\nOne of the most interesting features of the concurrent API is the Callable interface. This \ninterface represents a thread that returns a value. An application can use Callable objects \nto compute results that are then returned to the invoking thread. This is a powerful \nmechanism because it facilitates the coding of many types of numerical computations in \nwhich partial results are computed simultaneously. It can also be used to run a thread that \nreturns a status code that indicates the successful completion of the thread. \nCallable is a generic interface that is defined like this: \n\ninterface Callable<V> \n\nHere, V indicates the type of data returned by the task. Callable defines only one \nmethod, call ( ) , which is shown here: \n\nV call ( ) throws Exception \n\nInside call ( ) , you define the task that you want performed. After that task",
    "V call ( ) throws Exception \n\nInside call ( ) , you define the task that you want performed. After that task \n\n\ncompletes, you return the result. If the result cannot be computed, call ( ) must \nthrow an exception. \nA Callable task is executed by an ExecutorService , by calling its submit ( ) method. \nThere are three forms of submit ( ) , but only one is used to execute a Callable . It is shown \nhere: \n\n<T> Future<T> submit ( Callable<T> task ) \n\nHere, task is the Callable object that will be executed in its own thread. The result \nis returned through an object of type Future . \nFuture is a generic interface that represents the value that will be returned by a Callable \nobject. Because this value is obtained at some future time, the name Future is appropriate. \nFuture is defined like this: \n\ninterface Future<V> \n\nHere, V specifies the type of the result. \nTo obtain the returned value, you will call Future \u2019s get ( ) method, which has these two \nforms:",
    "interface Future<V> \n\nHere, V specifies the type of the result. \nTo obtain the returned value, you will call Future \u2019s get ( ) method, which has these two \nforms: \n\nThe first form waits for the result indefinitely. The second form allows you to specify a \ntimeout period in wait . The units of wait are passed in tu , which is an object of the \nTimeUnit enumeration, described later in this chapter. \nThe following program illustrates Callable and Future by creating three tasks that perform \nthree different computations. The first returns the summation of a value, the second \ncomputes the length of the hypotenuse of a right triangle given the length of its sides, and \nthe third computes the factorial of a value. All three computations occur simultaneously. \n\n\n\n\nThe output is shown here: \n\n\nThe TimeUnit Enumeration",
    "The output is shown here: \n\n\nThe TimeUnit Enumeration \n\nThe concurrent API defines several methods that take an argument of type TimeUnit , \nwhich indicates a time-out period. TimeUnit is an enumeration that is used to specify the \ngranularity ( or resolution ) of the timing. TimeUnit is defined within \njava.util.concurrent . It can be one of the following values: \n\nDAYS \nHOURS \nMINUTES \nSECONDS \nMICROSECONDS \nMILLISECONDS \nNANOSECONDS \n\nAlthough TimeUnit lets you specify any of these values in calls to methods that \ntake a timing argument, there is no guarantee that the system is capable of the \nspecified resolution. \nHere is an example that uses TimeUnit . The CallableDemo class, shown in the previous \nsection, is modified as shown next to use the second form of get ( ) that takes a TimeUnit \nargument.",
    "In this version, no call to get ( ) will wait more than 10 milliseconds. \nThe TimeUnit enumeration defines various methods that convert between units. These are \nshown here: \n\nlong convert ( long tval , TimeUnit tu ) \nlong toMicros ( long tval ) \nlong toMillis ( long tval ) \n\nlong toNanos ( long tval ) \nlong toSeconds ( long tval ) \nlong toDays ( long tval ) \n\n\nlong toHours ( long tval ) \nlong toMinutes ( long tval ) \n\nThe convert ( ) method converts tval into the specified unit and returns the result. \nThe to methods perform the indicated conversion and return the result. \nTimeUnit also defines the following timing methods: \n\nvoid sleep ( long delay ) throws InterruptedExecution \nvoid timedJoin ( Thread thrd , long delay ) throws InterruptedExecution \nvoid timedWait ( Object obj , long delay ) throws InterruptedExecution",
    "Here, sleep ( ) pauses execution for the specified delay period, which is specified \nin terms of the invoking enumeration constant. It translates into a call to \nThread.sleep ( ) . The timedJoin ( ) method is a specialized version of \nThread.join ( ) in which thrd pauses for the time period specified by delay , which \nis described in terms of the invoking time unit. The timedWait ( ) method is a \nspecialized version of Object.wait ( ) in which obj is waited on for the period of \ntime specified by delay , which is described in terms of the invoking time unit. \n\nThe Concurrent Collections \n\nAs explained, the concurrent API defines several collection classes that have been \nengineered for concurrent operation. They include:",
    "The Concurrent Collections \n\nAs explained, the concurrent API defines several collection classes that have been \nengineered for concurrent operation. They include: \n\nArrayBlockingQueue \nConcurrentHashMap \nConcurrentLinkedDeque \nConcurrentLinkedQueue \nConcurrentSkipListMap \nConcurrentSkipListSet \nCopyOnWriteArrayList \nCopyOnWriteArraySet \nDelayQueue \nLinkedBlockingDeque \nLinkedBlockingQueue \nLinkedTransferQueue \nPriorityBlockingQueue \nSynchronousQueue \n\nThese offer concurrent alternatives to their related classes defined by the \nCollections Framework. These collections work much like the other collections \n\nexcept that they provide concurrency support. Programmers familiar with the \nCollections Framework will have no trouble using these concurrent collections. \n\nLocks",
    "The java.util.concurrent.locks package provides support for locks , which are objects \nthat offer an alternative to using synchronized to control access to a shared resource. In \ngeneral, here is how a lock works. Before accessing a shared resource, the lock that protects \nthat resource is acquired. When access to the resource is complete, the lock is released. If a \nsecond thread attempts to acquire the lock when it is in use by another thread, the second \nthread will suspend until the lock is released. In this way, conflicting access to a shared \nresource is prevented. \nLocks are particularly useful when multiple threads need to access the value of shared data. \nFor example, an inventory application might have a thread that first confirms that an item is \nin stock and then decreases the number of items on hand as each sale occurs",
    ". \nFor example, an inventory application might have a thread that first confirms that an item is \nin stock and then decreases the number of items on hand as each sale occurs. If two or more \nof these threads are running, then without some form of synchronization, it would be \npossible for one thread to be in the middle of a transaction when the second thread begins \nits transaction. The result could be that both threads would assume that adequate inventory \nexists, even if there is only sufficient inventory on hand to satisfy one sale. In this type of \nsituation, a lock offers a convenient means of handling the needed synchronization. \nThe Lock interface defines a lock. The methods defined by Lock are shown in Table 28-1. \nIn general, to acquire a lock, call lock ( ) . If the lock is unavailable, lock ( ) will wait. To \nrelease a lock, call unlock ( ) . To see if a lock is available, and to acquire it if it is, call \ntryLock ( )",
    ". If the lock is unavailable, lock ( ) will wait. To \nrelease a lock, call unlock ( ) . To see if a lock is available, and to acquire it if it is, call \ntryLock ( ) . This method will not wait for the lock if it is unavailable. Instead, it returns \ntrue if the lock is acquired and false otherwise. The newCondition ( ) method returns a \nCondition object associated with the lock. Using a Condition , you gain detailed control of \nthe lock through methods such as await ( ) and signal ( ) , which provide functionality \nsimilar to Object.wait ( ) and Object.notify ( ) . \njava.util.concurrent.locks supplies an implementation of Lock called ReentrantLock . \nReentrantLock implements a reentrant lock , which is a lock that can be repeatedly \nentered by the thread that currently holds the lock. Of course, in the case of a thread \nreentering a lock, all calls to lock ( ) must be offset by an equal number of calls to unlock ( \n)",
    ". Of course, in the case of a thread \nreentering a lock, all calls to lock ( ) must be offset by an equal number of calls to unlock ( \n) . Otherwise, a thread seeking to acquire the lock will suspend until the lock is not in use.",
    "Table 28-1    The Lock Methods \n\nThe following program demonstrates the use of a lock. It creates two threads that access a \nshared resource called Shared.count . Before a thread can access Shared.count , it must \nobtain a lock. After obtaining the lock, Shared.count is incremented and then, before \nreleasing the lock, the thread sleeps. This causes the second thread to attempt to obtain the \nlock. However, because the lock is still held by the first thread, the second thread must wait \nuntil the first thread stops sleeping and releases the lock. The output shows that access to \nShared.count is, indeed, synchronized by the lock. \n\n\nThe output is shown here. ( The precise order in which the threads execute may vary.)",
    "The output is shown here. ( The precise order in which the threads execute may vary.) \n\n\njava.util.concurrent.locks also defines the ReadWriteLock interface. This interface \nspecifies a lock that maintains separate locks for read and write access. This enables \nmultiple locks to be granted for readers of a resource as long as the resource is not being \nwritten. ReentrantReadWriteLock provides an implementation of ReadWriteLock . \n\nNOTE JDK 8 adds a specialized lock called StampedLock . It does not \nimplement the Lock or ReadWriteLock interfaces. It does, however, \nprovide a mechanism that enables aspects of it to be used like a Lock or \nReadWriteLock . \n\nAtomic Operations \n\njava.util.concurrent.atomic offers an alternative to the other synchronization features",
    "Atomic Operations \n\njava.util.concurrent.atomic offers an alternative to the other synchronization features \n\nwhen reading or writing the value of some types of variables. This package offers methods \nthat get, set, or compare the value of a variable in one uninterruptible ( that is, atomic ) \noperation. This means that no lock or other synchronization mechanism is required. \nAtomic operations are accomplished through the use of classes, such as AtomicInteger \nand AtomicLong , and methods such as get ( ) , set ( ) , compareAndSet ( ) , \ndecrementAndGet ( ) , and getAndSet ( ) , which perform the action indicated by their \nnames. \n\nHere is an example that demonstrates how access to a shared integer can be synchronized \nby the use of AtomicInteger :",
    "Here is an example that demonstrates how access to a shared integer can be synchronized \nby the use of AtomicInteger : \n\n\nIn the program, a static AtomicInteger named ai is created by Shared . Then, three \nthreads of type AtomThread are created. Inside run ( ) , Shared.ai is modified by calling \ngetAndSet ( ) . This method returns the previous value and then sets the value to the one \npassed as an argument. The use of AtomicInteger prevents two threads from writing to ai \nat the same time. \nIn general, the atomic operations offer a convenient ( and possibly more efficient ) alternative \n\nto the other synchronization mechanisms when only a single variable is involved. Beginning \nwith JDK 8, java.util.concurrent.atomic also provides four classes that support lockfree cumulative operations. These are DoubleAccumulator , DoubleAdder , \nLongAccumulator , and LongAdder . The accumulator classes support a series of user-",
    "specified operations. The adder classes maintain a cumulative sum. \n\nParallel Programming via the Fork/Join Framework",
    "In recent years, an important new trend has emerged in software development: parallel \nprogramming . Parallel programming is the name commonly given to the techniques that \ntake advantage of computers that contain two or more processors ( multicore ). As most \nreaders will know, multicore computers are becoming commonplace. The advantage that \nmulti-processor environments offer is the ability to significantly increase program \nperformance. As a result, there has been a growing need for a mechanism that gives Java \nprogrammers a simple, yet effective way to make use of multiple processors in a clean, \nscalable manner. To answer this need, JDK 7 added several new classes and interfaces that \nsupport parallel programming. They are commonly referred to as the Fork/Join \nFramework . It is one of the more important additions that has recently been made to the \nJava class library. The Fork/Join Framework is defined in the java.util.concurrent \npackage",
    ". It is one of the more important additions that has recently been made to the \nJava class library. The Fork/Join Framework is defined in the java.util.concurrent \npackage. \nThe Fork/Join Framework enhances multithreaded programming in two important ways. \nFirst, it simplifies the creation and use of multiple threads. Second, it automatically makes \nuse of multiple processors. In other words, by using the Fork/Join Framework you enable \nyour applications to automatically scale to make use of the number of available processors. \nThese two features make the Fork/Join Framework the recommended approach to \nmultithreading when parallel processing is desired. \nBefore continuing, it is important to point out the distinction between traditional \nmultithreading and parallel programming. In the past, most computers had a single CPU \nand multithreading was primarily used to take advantage of idle time, such as when a \nprogram is waiting for user input",
    ". In the past, most computers had a single CPU \nand multithreading was primarily used to take advantage of idle time, such as when a \nprogram is waiting for user input. Using this approach, one thread can execute while \nanother is waiting. In other words, on a single-CPU system, multithreading is used to allow \ntwo or more tasks to share the CPU. This type of multithreading is typically supported by an \nobject of type Thread ( as described in Chapter 11 ). Although this type of multithreading \nwill always remain quite useful, it was not optimized for situations in which two or more \nCPUs are available ( multicore computers ). \nWhen multiple CPUs are present, a second type of multithreading capability that supports \ntrue parallel execution is required. With two or more CPUs, it is possible to execute portions \nof a program simultaneously, with each part executing on its own CPU. This can be used to \nsignificantly speed up the execution of some types of operations, such as sorting,",
    "transforming, or searching a large array. In many cases, these types of operations can be \nbroken down into smaller pieces ( each acting on a portion of the array ), and each piece can \nbe run on its own CPU. As you can imagine, the gain in efficiency can be enormous. Simply \nput: Parallel programming will be part of nearly every programmer\u2019s future because it offers \na way to dramatically improve program performance. \n\nThe Main Fork/Join Classes \n\n\nThe Fork/Join Framework is packaged in java.util.concurrent . At the core of the \n\nFork/Join Framework are the following four classes: \n\nForkJoinTask<V> \nAn abstract class that defines a task \n\nForkJoinPool \nManages the execution of ForkJoinTask s \n\nRecursiveAction \nA subclass of ForkJoinTask<V> for tasks that do not return \nvalues \n\nRecursiveTask<V> \nA subclass of ForkJoinTask<V> for tasks that return values",
    "RecursiveAction \nA subclass of ForkJoinTask<V> for tasks that do not return \nvalues \n\nRecursiveTask<V> \nA subclass of ForkJoinTask<V> for tasks that return values \n\nHere is how they relate. A ForkJoinPool manages the execution of ForkJoinTask s. \nForkJoinTask is an abstract class that is extended by the abstract classes \nRecursiveAction and RecursiveTask . Typically, your code will extend these classes to \ncreate a task. Before looking at the process in detail, an overview of the key aspects of each \nclass will be helpful. \n\nNOTE The class CountedCompleter ( added by JDK 8 ) also extends \nForkJoinTask . However, a discussion of CountedCompleter is \nbeyond the scope of this book. \n\nForkJoinTask<V> \n\nForkJoinTask<V> is an abstract class that defines a task that can be managed by a",
    "ForkJoinTask<V> \n\nForkJoinTask<V> is an abstract class that defines a task that can be managed by a \n\nForkJoinPool . The type parameter V specifies the result type of the task. ForkJoinTask \ndiffers from Thread in that ForkJoinTask represents lightweight abstraction of a task, \nrather than a thread of execution. ForkJoinTask s are executed by threads managed by a \nthread pool of type ForkJoinPool . This mechanism allows a large number of tasks to be \nmanaged by a small number of actual threads. Thus, ForkJoinTask s are very efficient \nwhen compared to threads. \nForkJoinTask defines many methods. At the core are fork ( ) and join ( ) , shown here: \n\nfinal ForkJoinTask<V> fork ( ) \n\nfinal V join ( )",
    "final ForkJoinTask<V> fork ( ) \n\nfinal V join ( ) \n\nThe fork ( ) method submits the invoking task for asynchronous execution of the \ninvoking task. This means that the thread that calls fork ( ) continues to run. The \nfork ( ) method returns this after the task is scheduled for execution. Prior to \nJDK 8, fork ( ) could be executed only from within the computational portion of",
    "another ForkJoinTask , which is running within a ForkJoinPool . ( You will see \nhow to create the computational portion of a task shortly.) However, with the \nadvent of JDK 8, if fork ( ) is not called while executing within a ForkJoinPool , \nthen a common pool is automatically used. The join ( ) method waits until the task \non which it is called terminates. The result of the task is returned. Thus, through \nthe use of fork ( ) and join ( ) , you can start one or more new tasks and then wait \nfor them to finish. \nAnother important ForkJoinTask method is invoke ( ) . It combines the fork and join \noperations into a single call because it begins a task and then waits for it to end. It is shown \nhere: \n\nfinal V invoke ( ) \n\nThe result of the invoking task is returned. \nYou can invoke more than one task at a time by using invokeAll ( ) . Two of its forms are \nshown here: \n\nstatic void invokeAll ( ForkJoinTask<?> taskA , ForkJoinTask<?> taskB )",
    "static void invokeAll ( ForkJoinTask<?> taskA , ForkJoinTask<?> taskB ) \n\nstatic void invokeAll ( ForkJoinTask<?> \u2026 taskList ) \n\nIn the first case, taskA and taskB are executed. In the second case, all specified \ntasks are executed. In both cases, the calling thread waits until all of the specified \ntasks have terminated. Prior to JDK 8, the invokeAll ( ) method could be executed \nonly from within the computational portion of another ForkJoinTask , which is \nrunning within a ForkJoinPool . JDK 8\u2019s inclusion of the common pool relaxed \nthis requirement. \n\nRecursiveAction",
    "RecursiveAction \n\nA subclass of ForkJoinTask is RecursiveAction . This class encapsulates a task that does \nnot return a result. Typically, your code will extend RecursiveAction to create a task that \nhas a void return type. RecursiveAction specifies four methods, but only one is usually of \ninterest: the abstract method called compute ( ) . When you extend RecursiveAction to \ncreate a concrete class, you will put the code that defines the task inside compute ( ) . The \ncompute ( ) method represents the computational portion of the task. \nThe compute ( ) method is defined by RecursiveAction like this: \n\nprotected abstract void compute ( ) \n\nNotice that compute ( ) is protected and abstract . This means that it must be \nimplemented by a subclass ( unless that subclass is also abstract ). \nIn general, RecursiveAction is used to implement a recursive, divide-and-conquer \nstrategy for tasks that don\u2019t return results. ( See \u201cThe Divide-and-Conquer Strategy\u201d later in \nthis chapter.)",
    "RecursiveTask<V> \n\n\nAnother subclass of ForkJoinTask is RecursiveTask<V> . This class encapsulates a task \nthat returns a result. The result type is specified by V . Typically, your code will extend \nRecursiveTask<V> to create a task that returns a value. Like RecursiveAction , it too \nspecifies four methods, but often only the abstract compute ( ) method is used, which \nrepresents the computational portion of the task. When you extend RecursiveTask<V> to \ncreate a concrete class, put the code that represents the task inside compute ( ) . This code \nmust also return the result of the task. \nThe compute ( ) method is defined by RecursiveTask<V> like this: \n\nprotected abstract V compute ( )",
    "protected abstract V compute ( ) \n\nNotice that compute ( ) is protected and abstract . This means that it must be \nimplemented by a subclass. When implemented, it must return the result of the \ntask. \nIn general, RecursiveTask is used to implement a recursive, divide-and-conquer strategy \nfor tasks that return results. ( See \u201cThe Divide-and-Conquer Strategy\u201d later in this chapter.) \n\nForkJoinPool",
    "ForkJoinPool \n\nThe execution of ForkJoinTask s takes place within a ForkJoinPool , which also manages \nthe execution of the tasks. Therefore, in order to execute a ForkJoinTask , you must first \nhave a ForkJoinPool . Beginning with JDK 8, there are two ways to acquire a \nForkJoinPool . First, you can explicitly create one by using a ForkJoinPool constructor. \nSecond, you can use what is referred to as the common pool . The common pool ( which was \nadded by JDK 8 ) is a static ForkJoinPool that is automatically available for your use. \nEach method is introduced here, beginning with manually constructing a pool. \nForkJoinPool defines several constructors. Here are two commonly used ones: \n\nForkJoinPool ( ) \n\nForkJoinPool ( int pLevel )",
    "ForkJoinPool ( ) \n\nForkJoinPool ( int pLevel ) \n\nThe first creates a default pool that supports a level of parallelism equal to the \nnumber of processors available in the system. The second lets you specify the level \nof parallelism. Its value must be greater than zero and not more than the limits of \nthe implementation. The level of parallelism determines the number of threads that \ncan execute concurrently. As a result, the level of parallelism effectively determines \nthe number of tasks that can be executed simultaneously. ( Of course, the number \nof tasks that can execute simultaneously cannot exceed the number of processors.) \n\nIt is important to understand that the level of parallelism does not , however, limit",
    "It is important to understand that the level of parallelism does not , however, limit \n\nthe number of tasks that can be managed by the pool. A ForkJoinPool can \nmanage many more tasks than its level of parallelism. Also, the level of parallelism \nis only a target. It is not a guarantee. \nAfter you have created an instance of ForkJoinPool , you can start a task in a number of \ndifferent ways. The first task started is often thought of as the main task. Frequently, the \n\n\nmain task begins subtasks that are also managed by the pool. One common way to begin a \nmain task is to call invoke ( ) on the ForkJoinPool . It is shown here: \n\n<T> T invoke ( ForkJoinTask<T> task ) \n\nThis method begins the task specified by task , and it returns the result of the task. \nThis means that the calling code waits until invoke ( ) returns. \nTo start a task without waiting for its completion, you can use execute ( ) . Here is one of its \nforms: \n\nvoid execute ( ForkJoinTask<?> task )",
    "void execute ( ForkJoinTask<?> task ) \n\nIn this case, task is started, but the calling code does not wait for its completion. \nRather, the calling code continues execution asynchronously. \nBeginning with JDK 8, it is not necessary to explicitly construct a ForkJoinPool because a \ncommon pool is available for your use. In general, if you are not using a pool that you \nexplicitly created, then the common pool will automatically be used. Although it won\u2019t \nalways be necessary, you can obtain a reference to the common pool by calling \ncommonPool ( ) , which is defined by ForkJoinPool . It is shown here: \n\nstatic ForkJoinPool commonPool ( )",
    "A reference to the common pool is returned. The common pool provides a default \nlevel of parallelism. It can be set by use of a system property. ( See the API \ndocumentation for details.) Typically, the default common pool is a good choice for \nmany applications. Of course, you can always construct your own pool. \nThere are two basic ways to start a task using the common pool. First, you can obtain a \nreference to the pool by calling commonPool ( ) and then use that reference to call \ninvoke ( ) or execute ( ) , as just described. Second, you can call ForkJoinTask methods \nsuch as fork ( ) or invoke ( ) on the task from outside its computational portion. In this \ncase, the common pool will automatically be used. In other words, fork ( ) and invoke ( ) \nwill start a task using the common pool if the task is not already running within a \nForkJoinPool . \nForkJoinPool manages the execution of its threads using an approach called workstealing",
    ". \nForkJoinPool manages the execution of its threads using an approach called workstealing . Each worker thread maintains a queue of tasks. If one worker thread\u2019s queue is \nempty, it will take a task from another worker thread. This adds to overall efficiency and \nhelps maintain a balanced load. ( Because of demands on CPU time by other processes in the \nsystem, even two worker threads with identical tasks in their respective queues may not \ncomplete at the same time.) \nOne other point: ForkJoinPool uses daemon threads. A daemon thread is automatically",
    "terminated when all user threads have terminated. Thus, there is no need to explicitly shut \ndown a ForkJoinPool . However, with the exception of the common pool, it is possible to \ndo so by calling shutdown ( ) . The shutdown ( ) method has no effect on the common \npool. \n\n\nThe Divide-and-Conquer Strategy",
    "As a general rule, users of the Fork/Join Framework will employ a divide-and-conquer \nstrategy that is based on recursion. This is why the two subclasses of ForkJoinTask are \ncalled RecursiveAction and RecursiveTask . It is anticipated that you will extend one of \nthese classes when creating your own fork/join task. \nThe divide-and-conquer strategy is based on recursively dividing a task into smaller \nsubtasks until the size of a subtask is small enough to be handled sequentially. For example, \na task that applies a transform to each element in an array of N integers can be broken \ndown into two subtasks in which each transforms half the elements in the array. That is, one \nsubtask transforms the elements 0 to N /2, and the other transforms the elements N /2 to N . \nIn turn, each subtask can be reduced to another set of subtasks, each transforming half of \nthe remaining elements",
    ". \nIn turn, each subtask can be reduced to another set of subtasks, each transforming half of \nthe remaining elements. This process of dividing the array will continue until a threshold is \nreached in which a sequential solution is faster than creating another division. \nThe advantage of the divide-and-conquer strategy is that the processing can occur in \nparallel. Therefore, instead of cycling through an entire array using a single thread, pieces of \nthe array can be processed simultaneously. Of course, the divide-and-conquer approach \nworks in many cases in which an array ( or collection ) is not present, but the most common \nuses involve some type of array, collection, or grouping of data. \nOne of the keys to best employing the divide-and-conquer strategy is correctly selecting the \nthreshold at which sequential processing ( rather than further division ) is used. Typically, an \noptimal threshold is obtained through profiling the execution characteristics",
    ". Typically, an \noptimal threshold is obtained through profiling the execution characteristics. However, very \nsignificant speed-ups will still occur even when a less-than-optimal threshold is used. It is, \nhowever, best to avoid overly large or overly small thresholds. At the time of this writing, \nthe Java API documentation for ForkJoinTask<T> states that, as a rule-of-thumb, a task \nshould perform somewhere between 100 and 10,000 computational steps. \nIt is also important to understand that the optimal threshold value is also affected by how \nmuch time the computation takes. If each computational step is fairly long, then smaller \nthresholds might be better. Conversely, if each computational step is quite short, then larger \nthresholds could yield better results. For applications that are to be run on a known system, \nwith a known number of processors, you can use the number of processors to make \ninformed decisions about the threshold value",
    ". For applications that are to be run on a known system, \nwith a known number of processors, you can use the number of processors to make \ninformed decisions about the threshold value. However, for applications that will be running \non a variety of systems, the capabilities of which are not known in advance, you can make \nno assumptions about the execution environment. \nOne other point: Although multiple processors may be available on a system, other tasks",
    "( and the operating system, itself ) will be competing with your application for CPU time. \n\nThus, it is important not to assume that your program will have unrestricted access to all \nCPUs. Furthermore, different runs of the same program may display different run time \ncharacteristics because of varying task loads. \n\nA Simple First Fork/Join Example \n\nAt this point, a simple example that demonstrates the Fork/Join Framework and the divide- \n\n\nand-conquer strategy will be helpful. Following is a program that transforms the elements \nin an array of double into their square roots. It does so via a subclass of \nRecursiveAction . Notice that it creates its own ForkJoinPool . \n\n\n\n\nThe output from the program is shown here:",
    "As you can see, the values of the array elements have been transformed into their square \nroots. \nLet\u2019s look closely at how this program works. First, notice that SqrtTransform is a class \nthat extends RecursiveAction . As explained, RecursiveAction extends ForkJoinTask \nfor tasks that do not return results. Next, notice the final variable seqThreshold . This is \nthe value that determines when sequential processing will take place. This value is set \n( somewhat arbitrarily ) to 1,000. Next, notice that a reference to the array to be processed is \nstored in data and that the fields start and end are used to indicate the boundaries of the \nelements to be accessed. \nThe main action of the program takes place in compute ( ) . It begins by checking if the \nnumber of elements to be processed is below the sequential processing threshold. If it is, \nthen those elements are processed ( by computing their square root in this example )",
    ". If it is, \nthen those elements are processed ( by computing their square root in this example ). If the \nsequential processing threshold has not been reached, then two new tasks are started by \ncalling invokeAll ( ) . In this case, each subtask processes half the elements. As explained \nearlier, invokeAll ( ) waits until both tasks return. After all of the recursive calls unwind,",
    "each element in the array will have been modified, with much of the action taking place in \nparallel ( if multiple processors are available ). \nAs mentioned, beginning with JDK 8, it is not necessary to explicitly construct a \nForkJoinPool because a common pool is available for your use. Furthermore, using the \ncommon pool is a simple matter. For example, you can obtain a reference to the common \n\n\npool by calling the static commonPool ( ) method defined by ForkJoinPool . Therefore, \nthe preceding program could be rewritten to use the common pool by replacing the call to \nthe ForkJoinPool constructor with a call to commonPool ( ) , as shown here:",
    "Alternatively, there is no need to explicitly obtain a reference to the common pool because \ncalling the ForkJoinTask methods invoke ( ) or fork ( ) on a task that is not already part \nof a pool will cause it to execute within the common pool automatically. For example, in the \npreceding program, you can eliminate the fjp variable entirely and start the task using this \nline: \n\nAs this discussion shows, the common pool is one of the enhancements JDK 8 made to the \nFork/Join Framework that improves its ease-of-use. Furthermore, in many cases, the \ncommon pool is the preferable approach, assuming that JDK 7 compatibility is not required. \n\nUnderstanding the Impact of the Level of Parallelism",
    "Understanding the Impact of the Level of Parallelism \n\nBefore moving on, it is important to understand the impact that the level of parallelism has \non the performance of a fork/join task and how the parallelism and the threshold interact. \nThe program shown in this section lets you experiment with different degrees of parallelism \nand threshold values. Assuming that you are using a multicore computer, you can \ninteractively observe the effect of these values. \nIn the preceding example, the default level of parallelism was used. However, you can \nspecify the level of parallelism that you want. One way is to specify it when you create a \nForkJoinPool using this constructor: \n\nForkJoinPool ( int pLevel )",
    "ForkJoinPool ( int pLevel ) \n\nHere, pLevel specifies the level of parallelism, which must be greater than zero and \nless than the implementation defined limit. \nThe following program creates a fork/join task that transforms an array of double s. The \ntransformation is arbitrary, but it is designed to consume several CPU cycles. This was done \nto ensure that the effects of changing the threshold or the level of parallelism would be more \nclearly displayed. To use the program, specify the threshold value and the level of \n\nparallelism on the command line. The program then runs the tasks. It also displays the \namount of time it takes the tasks to run. To do this, it uses System.nanoTime ( ) , which \nreturns the value of the JVM\u2019s high-resolution timer.",
    "To use the program, specify the level of parallelism followed by the threshold limit. You \nshould try experimenting with different values for each, observing the results. Remember, to \nbe effective, you must run the code on a computer with at least two processors. Also, \nunderstand that two different runs may ( almost certainly will ) produce different results \nbecause of the effect of other processes in the system consuming CPU time. \nTo give you an idea of the difference that parallelism makes, try this experiment. First, \nexecute the program like this: \n\nThis requests 1 level of parallelism ( essentially sequential execution ) with a threshold of \n1,000. Here is a sample run produced on a dual-core computer: \n\nNow, specify 2 levels of parallelism like this: \n\nHere is sample output from this run produced by the same dual-core computer:",
    "Now, specify 2 levels of parallelism like this: \n\nHere is sample output from this run produced by the same dual-core computer: \n\n\nAs is evident, adding parallelism substantially decreases execution time, thus increasing the \nspeed of the program. You should experiment with varying the threshold and parallelism on \nyour own computer. The results may surprise you. \nHere are two other methods that you might find useful when experimenting with the \nexecution characteristics of a fork/join program. First, you can obtain the level of \nparallelism by calling getParallelism ( ) , which is defined by ForkJoinPool . It is shown \nhere: \n\nint getParallelism ( )",
    "int getParallelism ( ) \n\nIt returns the parallelism level currently in effect. Recall that for pools that you \ncreate, by default, this value will equal the number of available processors. ( To \nobtain the parallelism level for the common pool, you can also use \ngetCommonPoolParallelism ( ) , which was added by JDK 8.) Second, you can \nobtain the number of processors available in the system by calling \navailableProcessors ( ) , which is defined by the Runtime class. It is shown \nhere: \n\nint availableProcessors ( ) \n\nThe value returned may change from one call to the next because of other system \ndemands. \n\nAn Example that Uses RecursiveTask<V>",
    "int availableProcessors ( ) \n\nThe value returned may change from one call to the next because of other system \ndemands. \n\nAn Example that Uses RecursiveTask<V> \n\nThe two preceding examples are based on RecursiveAction , which means that they \nconcurrently execute tasks that do not return results. To create a task that returns a result, \nuse RecursiveTask . In general, solutions are designed in the same manner as just shown. \nThe key difference is that the compute ( ) method returns a result. Thus, you must \naggregate the results, so that when the first invocation finishes, it returns the overall result. \nAnother difference is that you will typically start a subtask by calling fork ( ) and join ( ) \nexplicitly ( rather than implicitly by calling invokeAll ( ) , for example ). \nThe following program demonstrates RecursiveTask . It creates a task called Sum that \nreturns the summation of the values in an array of double . In this example, the array",
    "consists of 5,000 elements. However, every other value is negative. Thus, the first values in \nthe array are 0, \u20131, 2, \u20133, 4, and so on. ( So that this example will work with both JDK 7 and \nJDK 8, it creates its own pool. You might try changing it to use the common pool as an \nexercise.) \n\n\n\n\nHere\u2019s the output from the program: \n\nThere are a couple of interesting items in this program. First, notice that the two subtasks \nare executed by calling fork ( ) , as shown here: \n\n\nIn this case, fork ( ) is used because it starts a task but does not wait for it to finish. ( Thus, \nit asynchronously runs the task.) The result of each task is obtained by calling join ( ) , as \nshown here:",
    "This statement waits until each task ends. It then adds the results of each and assigns the \ntotal to sum . Thus, the summation of each subtask is added to the running total. Finally, \ncompute ( ) ends by returning sum , which will be the final total when the first invocation \nreturns. \nThere are other ways to approach the handling of the asynchronous execution of the \nsubtasks. For example, the following sequence uses fork ( ) to start subTaskA and uses \ninvoke ( ) to start and wait for subTaskB : \n\nAnother alternative is to have subTaskB call compute ( ) directly, as shown here: \n\nExecuting a Task Asynchronously",
    "Another alternative is to have subTaskB call compute ( ) directly, as shown here: \n\nExecuting a Task Asynchronously \n\nThe preceding programs have called invoke ( ) on a ForkJoinPool to initiate a task. This \napproach is commonly used when the calling thread must wait until the task has completed \n( which is often the case ) because invoke ( ) does not return until the task has terminated. \nHowever, you can start a task asynchronously. In this approach, the calling thread continues \nto execute. Thus, both the calling thread and the task execute simultaneously. To start a task \nasynchronously, use execute ( ) , which is also defined by ForkJoinPool . It has the two \nforms shown here: \n\nvoid execute ( ForkJoinTask<?> task ) \n\nvoid execute ( Runnable task ) \n\nIn both forms, task specifies the task to run. Notice that the second form lets you",
    "void execute ( ForkJoinTask<?> task ) \n\nvoid execute ( Runnable task ) \n\nIn both forms, task specifies the task to run. Notice that the second form lets you \n\nspecify a Runnable rather than a ForkJoinTask task. Thus, it forms a bridge \nbetween Java\u2019s traditional approach to multithreading and the new Fork/Join \nFramework. It is important to remember that the threads used by a \nForkJoinPool are daemon. Thus, they will end when the main thread ends. As a \nresult, you may need to keep the main thread alive until the tasks have finished. \n\n\nCancelling a Task \n\nA task can be cancelled by calling cancel ( ) , which is defined by ForkJoinTask . It has this \ngeneral form: \n\nboolean cancel ( boolean interuptOK )",
    "Cancelling a Task \n\nA task can be cancelled by calling cancel ( ) , which is defined by ForkJoinTask . It has this \ngeneral form: \n\nboolean cancel ( boolean interuptOK ) \n\nIt returns true if the task on which it was called is cancelled. It returns false if the \ntask has ended or can\u2019t be cancelled. At this time, the interruptOK parameter is \nnot used by the default implementation. In general, cancel ( ) is intended to be \ncalled from code outside the task because a task can easily cancel itself by \nreturning. \nYou can determine if a task has been cancelled by calling isCancelled ( ) , as shown here: \n\nfinal boolean isCancelled ( ) \n\nIt returns true if the invoking task has been cancelled prior to completion and \nfalse otherwise. \n\nDetermining a Task\u2019s Completion Status",
    "final boolean isCancelled ( ) \n\nIt returns true if the invoking task has been cancelled prior to completion and \nfalse otherwise. \n\nDetermining a Task\u2019s Completion Status \n\nIn addition to isCancelled ( ) , which was just described, ForkJoinTask includes two \nother methods that you can use to determine a task\u2019s completion status. The first is \nisCompletedNormally ( ) , which is shown here: \n\nfinal boolean isCompletedNormally ( ) \n\nIt returns true if the invoking task completed normally, that is, if it did not throw \nan exception and it was not cancelled via a call to cancel ( ) . It returns false \notherwise. \nThe second is isCompletedAbnormally ( ) , which is shown here: \n\nfinal boolean isCompletedAbnormally ( ) \n\nIt returns true if the invoking task completed because it was cancelled or because \nit threw an exception. It returns false otherwise. \n\nRestarting a Task",
    "final boolean isCompletedAbnormally ( ) \n\nIt returns true if the invoking task completed because it was cancelled or because \nit threw an exception. It returns false otherwise. \n\nRestarting a Task \n\nNormally, you cannot rerun a task. In other words, once a task completes, it cannot be \nrestarted. However, you can reinitialize the state of the task ( after it has completed ) so it can \nbe run again. This is done by calling reinitialize ( ) , as shown here: \n\nvoid reinitialize ( ) \n\nThis method resets the state of the invoking task. However, any modification made \nto any persistent data that is operated upon by the task will not be undone. For \n\nexample, if the task modifies an array, then those modifications are not undone by \ncalling reinitialize ( ) . \n\nThings to Explore",
    "example, if the task modifies an array, then those modifications are not undone by \ncalling reinitialize ( ) . \n\nThings to Explore \n\n\nThe preceding discussion presented the fundamentals of the Fork/Join Framework and \ndescribed several commonly used methods. However, Fork/Join is a rich framework that \nincludes additional capabilities that give you extended control over concurrency. Although it \nis far beyond the scope of this book to examine all of the issues and nuances surrounding \nparallel programming and the Fork/Join Framework, a sampling of the other features are \nmentioned here.",
    "A Sampling of Other ForkJoinTask Features \nIn some cases, you will want to ensure that methods such as invokeAll ( ) and fork ( ) are \ncalled only from within a ForkJoinTask . ( This may be especially important when using \nJDK 7, which does not support the common pool.) This is usually a simple matter, but \noccasionally, you may have code that can be executed from either inside or outside a task. \nYou can determine if your code is executing inside a task by calling inForkJoinPool ( ) . \nYou can convert a Runnable or Callable object into a ForkJoinTask by using the \nadapt ( ) method defined by ForkJoinTask . It has three forms, one for converting a \nCallable , one for a Runnable that does not return a result, and one for a Runnable that \ndoes return a result. In the case of a Callable , the call ( ) method is run. In the case of \nRunnable , the run ( ) method is run",
    ". In the case of a Callable , the call ( ) method is run. In the case of \nRunnable , the run ( ) method is run. \nYou can obtain an approximate count of the number of tasks that are in the queue of the \ninvoking thread by calling getQueuedTaskCount ( ) . You can obtain an approximate \ncount of how many tasks the invoking thread has in its queue that are in excess of the \nnumber of other threads in the pool that might \u201csteal\u201d them, by calling \ngetSurplusQueuedTaskCount ( ) . Remember, in the Fork/Join Framework, workstealing is one way in which a high level of efficiency is obtained. Although this process is \nautomatic, in some cases, the information may prove helpful in optimizing through-put. \nForkJoinTask defines the following variants of join ( ) and invoke ( ) that begin with the \nprefix quietly . They are shown here:",
    "final void quietlyJoin ( ) \nJoins a task, but does not return a result or throw an \nexception \n\nfinal void \nquietlyInvoke ( ) \nInvokes a task, but does not return a result or throw an \nexception. \n\nIn essence, these methods are similar to their non-quiet counterparts except they don\u2019t \nreturn values or throw exceptions. \nYou can attempt to \u201cun-invoke\u201d ( in other words, unschedule ) a task by calling tryUnfork ( \n) . \nJDK 8 adds several methods, such as getForkJoinTaskTag ( ) and \nsetForkJoinTaskTag ( ) , that support tags. Tags are short integer values that are linked \nwith a task. They may be useful in specialized applications. \n\n\nForkJoinTask implements Serializable . Thus, it can be serialized. However, serialization \nis not used during execution.",
    "ForkJoinTask implements Serializable . Thus, it can be serialized. However, serialization \nis not used during execution. \n\nA Sampling of Other ForkJoinPool Features \nOne method that is quite useful when tuning fork/join applications is ForkJoinPool \u2019s \noverride of toString ( ) . It displays a \u201cuser-friendly\u201d synopsis of the state of the pool. To see \nit in action, use this sequence to start and then wait for the task in the FJExperiment \nclass of the task experimenter program shown earlier: \n\nWhen you run the program, you will see a series of messages on the screen that describe the \nstate of the pool. Here is an example of one. Of course, your output may vary, based on the \nnumber of processors, threshold values, task load, and so on.",
    "You can determine if a pool is currently idle by calling isQuiescent ( ) . It returns true if \nthe pool has no active threads and false otherwise. \nYou can obtain the number of worker threads currently in the pool by calling getPoolSize ( \n) . You can obtain an approximate count of the active threads in the pool by calling \ngetActiveThreadCount ( ) . \nTo shut down a pool, call shutdown ( ) . Currently active tasks will still be executed, but no \nnew tasks can be started. To stop a pool immediately, call shutdownNow ( ) . In this case, \nan attempt is made to cancel currently active tasks. ( It is important to point out, however, \nthat neither of these methods affects the common pool.) You can determine if a pool is shut \ndown by calling isShutdown ( ) . It returns true if the pool has been shut down and false \notherwise. To determine if the pool has been shut down and all tasks have been completed, \ncall isTerminated ( ) . \n\nSome Fork/Join Tips",
    "Some Fork/Join Tips \n\nHere are a few tips to help you avoid some of the more troublesome pitfalls associated with \n\nusing the Fork/Join Framework. First, avoid using a sequential threshold that is too low. In \ngeneral, erring on the high side is better than erring on the low side. If the threshold is too \nlow, more time can be consumed generating and switching tasks than in processing the \ntasks. Second, usually it is best to use the default level of parallelism. If you specify a",
    "smaller number, it may significantly reduce the benefits of using the Fork/Join Framework. \nIn general, a ForkJoinTask should not use synchronized methods or synchronized blocks \nof code. Also, you will not normally want to have the compute ( ) method use other types of \nsynchronization, such as a semaphore. ( The new Phaser can, however, be used when \nappropriate because it is compatible with the fork/join mechanism.) Remember, the main \nidea behind a ForkJoinTask is the divide-and-conquer strategy. Such an approach does \nnot normally lend itself to situations in which outside synchronization is needed. Also, avoid \nsituations in which substantial blocking will occur through I/O. Therefore, in general, a \nForkJoinTask will not perform I/O. Simply put, to best utilize the Fork/Join Framework, \na task should perform a computation that can run without outside blocking or \nsynchronization",
    ". Simply put, to best utilize the Fork/Join Framework, \na task should perform a computation that can run without outside blocking or \nsynchronization. \nOne last point: Except under unusual circumstances, do not make assumptions about the \nexecution environment that your code will run in. This means you should not assume that \nsome specific number of processors will be available, or that the execution characteristics of \nyour program won\u2019t be affected by other processes running at the same time.",
    "The Concurrency Utilities Versus Java\u2019s Traditional Approach \n\nGiven the power and flexibility found in the concurrency utilities, it is natural to ask the \nfollowing question: Do they replace Java\u2019s traditional approach to multithreading and \nsynchronization? The answer is a resounding no! The original support for multithreading \nand the built-in synchronization features are still the mechanism that should be employed \nfor many, many Java programs, applets, and servlets. For example, synchronized , wait ( \n) , and notify ( ) offer elegant solutions to a wide range of problems. However, when extra \ncontrol is needed, the concurrency utilities are available to handle the chore. Furthermore, \nthe Fork/Join Framework offers a powerful way to integrate parallel programming \ntechniques into your more sophisticated applications. \n\n\uf709 \nPREV \nChapter 27: Images \n\u23ee \n\nNEXT \nChapter 29: The Stream API \u23ed \n\n\nPREV \nChapter 28: The Concurrency Utilities \n\u23ee",
    "\uf709 \nPREV \nChapter 27: Images \n\u23ee \n\nNEXT \nChapter 29: The Stream API \u23ed \n\n\nPREV \nChapter 28: The Concurrency Utilities \n\u23ee \n\nNEXT \nChapter 30: Regular Expressions and Other Pac\u2026 \n\u23ed \n\nCHAPTER \n\n29 \nThe Stream API",
    "Of the many new features added by JDK 8, the two that are, arguably, the most important \nare lambda expressions and the stream API. Lambda expressions were described in Chapter \n15. The stream API is described here. As you will see, the stream API is designed with \nlambda expressions in mind. Moreover, the stream API provides some of the most \nsignificant demonstrations of the power that lambdas bring to Java. \nAlthough its design compatibility with lambda expressions is impressive, the key aspect of \nthe stream API is its ability to perform very sophisticated operations that search, filter, map, \nor otherwise manipulate data. For example, using the stream API, you can construct \nsequences of actions that resemble, in concept, the type of database queries for which you \nmight use SQL. Furthermore, in many cases, such actions can be performed in parallel, thus \nproviding a high level of efficiency, especially when large data sets are involved",
    ". Furthermore, in many cases, such actions can be performed in parallel, thus \nproviding a high level of efficiency, especially when large data sets are involved. Put simply, \nthe stream API provides a powerful means of handling data in an efficient, yet easy to use \nway. \nBefore continuing, an important point needs to be made: The stream API uses some of \nJava\u2019s most advanced features. To fully understand and utilize it requires a solid \nunderstanding of generics and lambda expressions. The basic concepts of parallel execution \nand a working knowledge of the Collections Framework are also needed. ( See Chapters 14, \n15, 18, and 28.)",
    "Stream Basics \n\nLet\u2019s begin by defining the term stream as it applies to the stream API: a stream is a conduit \nfor data. Thus, a stream represents a sequence of objects. A stream operates on a data \nsource, such as an array or a collection. A stream, itself, never provides storage for the data. \n\nIt simply moves data, possibly filtering, sorting, or otherwise operating on that data in the \nprocess. As a general rule, however, a stream operation by itself does not modify the data \nsource. For example, sorting a stream does not change the order of the source. Rather, \nsorting a stream results in the creation of a new stream that produces the sorted result.",
    "NOTE It is necessary to state that the term stream as used here differs \nfrom the use of stream when the I/O classes were described earlier in this \nbook. Although an I/O stream can act conceptually much like one of the \nstreams defined by java.util.stream , they are not the same. Thus, \nthroughout this chapter, when the term stream is used, it refers to objects \nbased on one of the stream types described here. \n\nStream Interfaces \n\nThe stream API defines several stream interfaces, which are packaged in java.util.stream . \nAt the foundation is BaseStream , which defines the basic functionality available in all \nstreams. BaseStream is a generic interface declared like this: \n\ninterface BaseStream<T, S extends BaseStream<T, S>>",
    "interface BaseStream<T, S extends BaseStream<T, S>> \n\nHere, T specifies the type of the elements in the stream, and S specifies the type of \nstream that extends BaseStream . BaseStream extends the AutoCloseable \ninterface ; thus, a stream can be managed in a try -with-resources statement. In \ngeneral, however, only those streams whose data source requires closing ( such as \nthose connected to a file ) will need to be closed. In most cases, such as those in \nwhich the data source is a collection, there is no need to close the stream. The \nmethods declared by BaseStream are shown in Table 29-1. \n\nTable 29-1    The Methods Declared by BaseStream \n\n\nFrom BaseStream are derived several types of stream interfaces. The most general of these \nis Stream . It is declared as shown here: \n\ninterface Stream<T>",
    "From BaseStream are derived several types of stream interfaces. The most general of these \nis Stream . It is declared as shown here: \n\ninterface Stream<T> \n\nHere, T specifies the type of the elements in the stream. Because it is generic, \nStream is used for all reference types. In addition to the methods that it inherits \nfrom BaseStream , the Stream interface adds several of its own, a sampling of \nwhich is shown in Table 29-2. \n\n\nTable 29-2    A Sampling of Methods Declared by Stream",
    "In both tables, notice that many of the methods are notated as being either terminal or \nintermediate . The difference between the two is very important. A terminal operation \nconsumes the stream. It is used to produce a result, such as finding the minimum value in \nthe stream, or to execute some action, as is the case with the forEach ( ) method. Once a \nstream has been consumed, it cannot be reused. Intermediate operations produce another \nstream. Thus, intermediate operations can be used to create a pipeline that performs a \nsequence of actions. One other point: intermediate operations do not take place \nimmediately. Instead, the specified action is performed when a terminal operation is \nexecuted on the new stream created by an intermediate operation. This mechanism is \nreferred to as lazy behavior , and the intermediate operations are referred to as lazy . The \nuse of lazy behavior enables the stream API to perform more efficiently",
    ". This mechanism is \nreferred to as lazy behavior , and the intermediate operations are referred to as lazy . The \nuse of lazy behavior enables the stream API to perform more efficiently. \nAnother key aspect of streams is that some intermediate operations are stateless and some \nare stateful . In a stateless operation, each element is processed independently of the others. \nIn a stateful operation, the processing of an element may depend on aspects of the other \nelements. For example, sorting is a stateful operation because an element\u2019s order depends \non the values of the other elements. Thus, the sorted ( ) method is stateful. However, \nfiltering elements based on a stateless predicate is stateless because each element is handled \nindividually. Thus, filter ( ) can ( and should be ) stateless",
    ". However, \nfiltering elements based on a stateless predicate is stateless because each element is handled \nindividually. Thus, filter ( ) can ( and should be ) stateless. The difference between stateless \nand stateful operations is especially important when parallel processing of a stream is \ndesired because a stateful operation may require more than one pass to complete. \nBecause Stream operates on object references, it can\u2019t operate directly on primitive types. \nTo handle primitive type streams, the stream API defines the following interfaces:",
    "DoubleStream \n\nIntStream \n\nLongStream \n\nThese streams all extend BaseStream and have capabilities similar to Stream \nexcept that they operate on primitive types rather than reference types. They also \nprovide some convenience methods, such as boxed ( ) , that facilitate their use. \nBecause streams of objects are the most common, Stream is the primary focus of \nthis chapter, but the primitive type streams can be used in much the same way. \n\nHow to Obtain a Stream \n\nYou can obtain a stream in a number of ways. Perhaps the most common is when a stream \nis obtained for a collection. Beginning with JDK 8, the Collection interface has been \nexpanded to include two methods that obtain a stream from a collection. The first is \nstream ( ) , shown here: \n\ndefault Stream<E> stream ( ) \n\n\nIts default implementation returns a sequential stream. The second method is \nparallelStream ( ) , shown next: \n\ndefault Stream<E> parallelStream ( )",
    "default Stream<E> stream ( ) \n\n\nIts default implementation returns a sequential stream. The second method is \nparallelStream ( ) , shown next: \n\ndefault Stream<E> parallelStream ( ) \n\nIts default implementation returns a parallel stream, if possible. ( If a parallel \nstream can not be obtained, a sequential stream may be returned instead.) Parallel \nstreams support parallel execution of stream operations. Because Collection is \nimplemented by every collection, these methods can be used to obtain a stream \nfrom any collection class, such as ArrayList or HashSet . \nA stream can also be obtained from an array by use of the static stream ( ) method, which \nwas added to the Arrays class by JDK 8. One of its forms is shown here: \n\nstatic <T> Stream<T> stream ( T[ ] array ) \n\nThis method returns a sequential stream to the elements in array . For example, \ngiven an array called addresses of type Address , the following obtains a stream \nto it:",
    "This method returns a sequential stream to the elements in array . For example, \ngiven an array called addresses of type Address , the following obtains a stream \nto it: \n\nSeveral overloads of the stream ( ) method are also defined, such as those that handle \narrays of the primitive types. They return a stream of type IntStream , DoubleStream , or \nLongStream . \nStreams can be obtained in a variety of other ways. For example, many stream operations \nreturn a new stream, and a stream to an I/O source can be obtained by calling lines ( ) on a \nBufferedReader . However a stream is obtained, it can be used in the same way as any \nother stream. \n\nA Simple Stream Example",
    "A Simple Stream Example \n\nBefore going any further, let\u2019s work through an example that uses streams. The following \nprogram creates an ArrayList called myList that holds a collection of integers ( which are \nautomatically boxed into the Integer reference type ). Next, it obtains a stream that uses \nmyList as a source. It then demonstrates various stream operations. \n\n\nThe output is shown here: \n\n\nLet\u2019s look closely at each stream operation. After creating an ArrayList , the program \nobtains a stream for the list by calling stream ( ) , as shown here:",
    "Let\u2019s look closely at each stream operation. After creating an ArrayList , the program \nobtains a stream for the list by calling stream ( ) , as shown here: \n\nAs explained, the Collection interface now defines the stream ( ) method, which obtains a \nstream from the invoking collection. Because Collection is implemented by every collection \nclass, stream ( ) can be used to obtain stream for any type of collection, including the \nArrayList used here. In this case, a reference to the stream is assigned to myStream . \nNext, the program obtains the minimum value in the stream ( which is, of course, also the \nminimum value in the data source ) and displays it, as shown here: \n\nRecall from Table 29-2 that min ( ) is declared like this: \n\nOptional<T> min ( Comparator<? super T> comp ) \n\nFirst, notice that the type of min ( )\u2019 s parameter is a Comparator . This",
    "Recall from Table 29-2 that min ( ) is declared like this: \n\nOptional<T> min ( Comparator<? super T> comp ) \n\nFirst, notice that the type of min ( )\u2019 s parameter is a Comparator . This \n\ncomparator is used to compare two elements in the stream. In the example, min ( \n) is passed a method reference to Integer \u2019s compare ( ) method, which is used to \nimplement a Comparator capable of comparing two Integer s. Next, notice that \nthe return type of min ( ) is Optional . The Optional class is described in Chapter \n19, but briefly, here is how it works. Optional is a generic class packaged in \njava.util and declared like this: \n\nclass Optional<T> \n\nHere, T specifies the element type. An Optional instance can either contain a \nvalue of type T or be empty. You can use isPresent ( ) to determine if a value is",
    "class Optional<T> \n\nHere, T specifies the element type. An Optional instance can either contain a \nvalue of type T or be empty. You can use isPresent ( ) to determine if a value is \n\npresent. Assuming that a value is available, it can be obtained by calling get ( ) . In \nthis example, the object returned will hold the minimum value of the stream as an \nInteger object. \nOne other point about the preceding line: min ( ) is a terminal operation that consumes the \nstream. Thus, myStream cannot be used again after min ( ) executes. \nThe next lines obtain and display the maximum value in the stream:",
    "First, myStream is once again assigned the stream returned by myList.stream ( ) . As just \nexplained, this is necessary because the previous call to min ( ) consumed the previous \nstream. Thus, a new one is needed. Next, the max ( ) method is called to obtain the \nmaximum value. Like min ( ) , max ( ) returns an Optional object. Its value is obtained by \ncalling get ( ) . \nThe program then obtains a sorted stream through the use of this line: \n\nHere, the sorted ( ) method is called on the stream returned by myList.stream ( ) . \nBecause sorted ( ) is an intermediate operation, its result is a new stream, and this is the \nstream assigned to sortedStream . The contents of the sorted stream are displayed by use \nof forEach ( ) :",
    "Here, the forEach ( ) method executes an operation on each element in the stream. In this \ncase, it simply calls System.out.print ( ) for each element in sortedStream . This is \naccomplished by use of a lambda expression. The forEach ( ) method has this general form: \n\nvoid forEach ( Consumer<? super T> action ) \n\nConsumer is a generic functional interface declared in java.util.function . Its \nabstract method is accept ( ) , shown here: \n\nvoid accept ( T objRef ) \n\nThe lambda expression in the call to forEach ( ) provides the implementation of \naccept ( ) . The forEach ( ) method is a terminal operation. Thus, after it \ncompletes, the stream has been consumed. \nNext, a sorted stream is filtered by filter ( ) so that it contains only odd values: \n\nThe filter ( ) method filters a stream based on a predicate. It returns a new stream that \n\ncontains only those elements that satisfy the predicate. It is shown here: \n\nStream<T> filter ( Predicate<? super T> pred )",
    "contains only those elements that satisfy the predicate. It is shown here: \n\nStream<T> filter ( Predicate<? super T> pred ) \n\nPredicate is a generic functional interface defined in java.util.function . Its \nabstract method is test ( ) , which is shown here: \n\n\nboolean test ( T objRef ) \n\nIt returns true if the object referred to by objRef satisfies the predicate, and false \notherwise. The lambda expression passed to filter ( ) implements this method. \nBecause filter ( ) is an intermediate operation, it returns a new stream that \ncontains filtered values, which, in this case, are the odd numbers. These elements \nare then displayed via forEach ( ) as before. \nBecause filter ( ) , or any other intermediate operation, returns a new stream, it is possible \nto filter a filtered stream a second time. This is demonstrated by the following line, which \nproduces a stream that contains only those odd values greater than 5: \n\nNotice that lambda expressions are passed to both filters.",
    "Notice that lambda expressions are passed to both filters. \n\nReduction Operations",
    "Reduction Operations \n\nConsider the min ( ) and max ( ) methods in the preceding example program. Both are \nterminal operations that return a result based on the elements in the stream. In the \nlanguage of the stream API, they represent reduction operations because each reduces a \nstream to a single value\u2014in this case, the minimum and maximum. The stream API refers \nto these as special case reductions because they perform a specific function. In addition to \nmin ( ) and max ( ) , other special case reductions are also available, such as count ( ) , \nwhich counts the number of elements in a stream. However, the stream API generalizes this \nconcept by providing the reduce ( ) method. By using reduce ( ) , you can return a value \nfrom a stream based on any arbitrary criteria. By definition, all reduction operations are \nterminal operations. \nStream defines three versions of reduce ( ) . The two we will use first are shown here: \n\nOptional<T> reduce ( BinaryOperator<T> accumulator )",
    "Optional<T> reduce ( BinaryOperator<T> accumulator ) \n\nT reduce ( T identityVal , BinaryOperator<T> accumulator ) \n\nThe first form returns an object of type Optional , which contains the result. The \n\nsecond form returns an object of type T ( which is the element type of the stream ). \nIn both forms, accumulator is a function that operates on two values and produces \na result. In the second form, identityVal is a value such that an accumulator \n\noperation involving identityVal and any element of the stream yields that element, \nunchanged. For example, if the operation is addition, then the identity value will be \n0 because 0 + x is x. For multiplication, the value will be 1, because 1 * x is x. \nBinaryOperator is a functional interface declared in java.util.function that extends the \nBiFunction functional interface. BiFunction defines this abstract method: \n\nR apply ( T val , U val2 )",
    "R apply ( T val , U val2 ) \n\n\nHere, R specifies the result type, T is the type of the first operand, and U is the \ntype of second operand. Thus, apply ( ) applies a function to its two operands ( val \nand val2 ) and returns the result. When BinaryOperator extends BiFunction , it \nspecifies the same type for all the type parameters. Thus, as it relates to \nBinaryOperator , apply ( ) looks like this: \n\nT apply ( T val , T val2 ) \n\nFurthermore, as it relates to reduce ( ) , val will contain the previous result and \nval2 will contain the next element. In its first invocation, val will contain either the \nidentity value or the first element, depending on which version of reduce ( ) is \nused. \nIt is important to understand that the accumulator operation must satisfy three constraints. \nIt must be \n\n\u2022  Stateless \n\n\u2022  Non-interfering \n\n\u2022  Associative",
    "\u2022  Stateless \n\n\u2022  Non-interfering \n\n\u2022  Associative \n\nAs explained earlier, stateless means that the operation does not rely on any state \ninformation. Thus, each element is processed independently. Non-interfering \nmeans that the data source is not modified by the operation. Finally, the operation \nmust be associative . Here, the term associative is used in its normal, arithmetic \nsense, which means that, given an associative operator used in a sequence of \noperations, it does not matter which pair of operands are processed first. For \nexample, \n\n( 10 * 2 ) * 7 \n\nyields the same result as \n\n10 * ( 2 * 7 ) \n\nAssociativity is of particular importance to the use of reduction operations on \nparallel streams, discussed in the next section. \nThe following program demonstrates the versions of reduce ( ) just described: \n\n\nAs the output here shows, both uses of reduce ( ) produce the same result:",
    "As the output here shows, both uses of reduce ( ) produce the same result: \n\nIn the program, the first version of reduce ( ) uses the lambda expression to produce a \nproduct of two values. In this case, because the stream contains Integer values, the \nInteger objects are automatically unboxed for the multiplication and reboxed to return the \nresult. The two values represent the current value of the running result and the next element \nin the stream. The final result is returned in an object of type Optional . The value is \nobtained by calling get ( ) on the returned object. \nIn the second version, the identity value is explicitly specified, which for multiplication is 1. \nNotice that the result is returned as an object of the element type, which is Integer in this \ncase. \nAlthough simple reduction operations such as multiplication are useful for examples, \nreductions are not limited in this regard. For example, assuming the preceding program, the",
    "following obtains the product of only the even values: \n\n\nPay special attention to the lambda expression. If b is even, then a * b is returned. \nOtherwise, a is returned. This works because a holds the current result and b holds the next \nelement, as explained earlier. \n\nUsing Parallel Streams",
    "Using Parallel Streams \n\nBefore exploring any more of the stream API, it will be helpful to discuss parallel streams. \nAs has been pointed out previously in this book, the parallel execution of code via multicore \nprocessors can result in a substantial increase in performance. Because of this, parallel \nprogramming has become an important part of the modern programmer\u2019s job. However, \nparallel programming can be complex and error-prone. One of the benefits that the stream \nlibrary offers is the ability to easily\u2014and reliably\u2014parallel process certain operations. \nParallel processing of a stream is quite simple to request: just use a parallel stream. As \nmentioned earlier, one way to obtain a parallel stream is to use the parallelStream ( ) \nmethod defined by Collection . Another way to obtain a parallel stream is to call the \nparallel ( ) method on a sequential stream. The parallel ( ) method is defined by \nBaseStream , as shown here: \n\nS parallel ()",
    "S parallel () \n\nIt returns a parallel stream based on the sequential stream that invokes it. ( If it is \ncalled on a stream that is already parallel, then the invoking stream is returned.) \nUnderstand, of course, that even with a parallel stream, parallelism will be \nachieved only if the environment supports it. \nOnce a parallel stream has been obtained, operations on the stream can occur in parallel, \nassuming that parallelism is supported by the environment. For example, the first reduce ( \n) operation in the preceding program can be parallelized by substituting parallelStream ( ) \nfor the call to stream ( ) : \n\nThe results will be the same, but the multiplications can occur in different threads.",
    "The results will be the same, but the multiplications can occur in different threads. \n\nAs a general rule, any operation applied to a parallel stream must be stateless. It should also \nbe non-interfering and associative. This ensures that the results obtained by executing \noperations on a parallel stream are the same as those obtained from executing the same \noperations on a sequential stream. \n\nWhen using parallel streams, you might find the following version of reduce ( ) especially \nhelpful. It gives you a way to specify how partial results are combined: \n\nIn this version, combiner defines the function that combines two values that have been \nproduced by the accumulator function. Assuming the preceding program, the following \n\n\nstatement computes the product of the elements in myList by use of a parallel stream:",
    "statement computes the product of the elements in myList by use of a parallel stream: \n\nAs you can see, in this example, both the accumulator and combiner perform the same \nfunction. However, there are cases in which the actions of the accumulator must differ from \nthose of the combiner. For example, consider the following program. Here, myList contains \na list of double values. It then uses the combiner version of reduce ( ) to compute the \nproduct of the square roots of each element in the list. \n\nNotice that the accumulator function multiplies the square roots of two elements, but the \ncombiner multiplies the partial results. Thus, the two functions differ. Moreover, for this \ncomputation to work correctly, they must differ. For example, if you tried to obtain the \nproduct of the square roots of the elements by using the following statement, an error would \n\nresult: \n\nIn this version of reduce ( ) , the accumulator and the combiner function are one and the",
    "result: \n\nIn this version of reduce ( ) , the accumulator and the combiner function are one and the \n\n\nsame. This results in an error because when two partial results are combined, their square \nroots are multiplied together rather than the partial results, themselves. \nAs a point of interest, if the stream in the preceding call to reduce ( ) had been changed to \na sequential stream, then the operation would yield the correct answer because there would \nhave been no need to combine two partial results. The problem occurs when a parallel \nstream is used. \nYou can switch a parallel stream to sequential by calling the sequential ( ) method, which \nis specified by BaseStream . It is shown here: \n\nS sequential ( )",
    "S sequential ( ) \n\nIn general, a stream can be switched between parallel and sequential on an asneeded basis. \nThere is one other aspect of a stream to keep in mind when using parallel execution: the \norder of the elements. Streams can be either ordered or unordered. In general, if the data \nsource is ordered, then the stream will also be ordered. However, when using a parallel \nstream, a performance boost can sometimes be obtained by allowing a stream to be \nunordered. When a parallel stream is unordered, each partition of the stream can be \noperated on independently, without having to coordinate with the others. In cases in which \nthe order of the operations does not matter, it is possible to specify unordered behavior by \ncalling the unordered ( ) method, shown here: \n\nS unordered ( )",
    "S unordered ( ) \n\nOne other point: the forEach ( ) method may not preserve the ordering of a \nparallel stream. If you want to perform an operation on each element in a parallel \nstream while preserving the order, consider using forEachOrdered ( ) . It is used \njust like forEach ( ) . \n\nMapping \n\nOften it is useful to map the elements of one stream to another. For example, a stream that \ncontains a database of name, telephone, and e-mail address information might map only the \nname and e-mail address portions to another stream. As another example, you might want \nto apply some transformation to the elements in a stream. To do this, you could map the \ntransformed elements to a new stream. Because mapping operations are quite common, the \nstream API provides built-in support for them. The most general mapping method is map ( \n) . It is shown here: \n\n<R> Stream<R> map ( Function<? super T, ? extends R> mapFunc )",
    "<R> Stream<R> map ( Function<? super T, ? extends R> mapFunc ) \n\nHere, R specifies the type of elements of the new stream ; T is the type of elements \nof the invoking stream ; and mapFunc is an instance of Function , which does the \nmapping. The map function must be stateless and non-interfering. Since a new \nstream is returned, map ( ) is an intermediate method. \n\nFunction is a functional interface declared in java.util.function . It is declared as shown \n\n\nhere: \n\nFunction<T, R> \n\nAs it relates to map ( ) , T is the element type and R is the result of the mapping. \nFunction has the abstract method shown here: \n\nR apply ( T val )",
    "here: \n\nFunction<T, R> \n\nAs it relates to map ( ) , T is the element type and R is the result of the mapping. \nFunction has the abstract method shown here: \n\nR apply ( T val ) \n\nHere, val is a reference to the object being mapped. The mapped result is returned. \nThe following is a simple example of map ( ) . It provides a variation on the previous \nexample program. As before, the program computes the product of the square roots of the \nvalues in an ArrayList . In this version, however, the square roots of the elements are first \nmapped to a new stream. Then, reduce ( ) is employed to compute the product.",
    "The output is the same as before. The difference between this version and the previous is \nsimply that the transformation ( i.e., the computation of the square roots ) occurs during \nmapping, rather than during the reduction. Because of this, it is possible to use the twoparameter form of reduce ( ) to compute the product because it is no longer necessary to \nprovide a separate combiner function. \n\nHere is an example that uses map ( ) to create a new stream that contains only selected \nfields from the original stream. In this case, the original stream contains objects of type \nNamePhoneEmail , which contains names, phone numbers, and e-mail addresses. The \nprogram then maps only the names and phone numbers to a new stream of NamePhone \n\n\nobjects. The e-mail addresses are discarded. \n\nThe output, shown here, verifies the mapping:",
    "objects. The e-mail addresses are discarded. \n\nThe output, shown here, verifies the mapping: \n\n\nBecause you can pipeline more than one intermediate operation together, you can easily \ncreate very powerful actions. For example, the following statement uses filter ( ) and then \nmap ( ) to produce a new stream that contains only the name and phone number of the \nelements with the name \"James\": \n\nThis type of filter operation is very common when creating database-style queries. As you \ngain experience with the stream API, you will find that such chains of operations can be \nused to create very sophisticated queries, merges, and selections on a data stream. \nIn addition to the version just described, three other versions of map ( ) are provided. They \nreturn a primitive stream, as shown here: \n\nIntStream mapToInt ( ToIntFunction<? super T> mapFunc ) \n\nLongStream mapToLong ( ToLongFunction<? super T> mapFunc )",
    "IntStream mapToInt ( ToIntFunction<? super T> mapFunc ) \n\nLongStream mapToLong ( ToLongFunction<? super T> mapFunc ) \n\nDoubleStream mapToDouble ( ToDoubleFunction<? super T> mapFunc ) \n\nEach mapFunc must implement the abstract method defined by the specified \ninterface, returning a value of the indicated type. For example, \nToDoubleFunction specifies the applyAsDouble ( T val ) method, which must \nreturn the value of its parameter as a double . \nHere is an example that uses a primitive stream. It first creates an ArrayList of Double \nvalues. It then uses stream ( ) followed by mapToInt ( ) to create an IntStream that \ncontains the ceiling of each value. \n\n\nThe output is shown here: \n\nThe stream produced by mapToInt ( ) contains the ceiling values of the original elements in",
    "The output is shown here: \n\nThe stream produced by mapToInt ( ) contains the ceiling values of the original elements in \n\nmyList . \nBefore leaving the topic of mapping, it is necessary to point out that the stream API also \nprovides methods that support flat maps . These are flatMap ( ) , flatMapToInt ( ) , \nflatMapToLong ( ) , and flatMapToDouble ( ) . The flat map methods are designed to \n\nhandle situations in which each element in the original stream is mapped to more than one \nelement in the resulting stream. \n\nCollecting \n\nAs the preceding examples have shown, it is possible ( indeed, common ) to obtain a stream \nfrom a collection. Sometimes it is desirable to obtain the opposite: to obtain a collection \nfrom a stream. To perform such an action, the stream API provides the collect ( ) method. \n\n\nIt has two forms. The one we will use first is shown here: \n\n<R, A> R collect ( Collector<? super T, A, R> collectorFunc )",
    "It has two forms. The one we will use first is shown here: \n\n<R, A> R collect ( Collector<? super T, A, R> collectorFunc ) \n\nHere, R specifies the type of the result, and T specifies the element type of the \ninvoking stream. The internal accumulated type is specified by A . The \ncollectorFunc specifies how the collection process works. The collect ( ) method is \na terminal operation. \nThe Collector interface is declared in java.util.stream , as shown here: \n\ninterface Collector<T, A, R> \n\nT , A , and R have the same meanings as just described. Collector specifies several \nmethods, but for the purposes of this chapter, we won\u2019t need to implement them. \nInstead, we will use two of the predefined collectors that are provided by the \nCollectors class, which is packaged in java.util.stream . \nThe Collectors class defines a number of static collector methods that you can use as-is. \nThe two we will use are toList ( ) and toSet ( ) , shown here:",
    "static <T> Collector<T, ?, List<T>> toList ( ) \n\nstatic <T> Collector<T, ?, Set<T>> toSet ( ) \n\nThe toList ( ) method returns a collector that can be used to collect elements into \na List . The toSet ( ) method returns a collector that can be used to collect \nelements into a Set . For example, to collect elements into a List , you can call \ncollect ( ) like this: \n\nThe following program puts the preceding discussion into action. It reworks the example in \n\nthe previous section so that it collects the names and phone numbers into a List and a Set . \n\n\n\n\nThe output is shown here: \n\nIn the program, the following line collects the name and phone numbers into a List by \nusing toList ( ) : \n\nAfter this line executes, the collection referred to by npList can be used like any other List \ncollection. For example, it can be cycled through by using a for-each for loop, as shown in \nthe next line:",
    "The creation of a Set via collect ( Collectors.toSet ( )) works in the same way. The ability \n\nto move data from a collection to a stream, and then back to a collection again is a very \npowerful attribute of the stream API. It gives you the ability to operate on a collection \n\nthrough a stream, but then repackage it as a collection. Furthermore, the stream operations \ncan, if appropriate, occur in parallel. \nThe version of collect ( ) used by the previous example is quite convenient, and often the \none you want, but there is a second version that gives you more control over the collection \n\n\nprocess. It is shown here:",
    "Here, target specifies how the object that holds the result is created. For example, \nto use a LinkedList as the result collection, you would specify its constructor. The \naccumulator function adds an element to the result and combiner combines two \npartial results. Thus, these functions work similarly to the way they do in reduce ( \n) . For both, they must be stateless and non-interfering. They must also be \nassociative. \nNote that the target parameter is of type Supplier . It is a functional interface declared in \njava.util.function . It specifies only the get ( ) method, which has no parameters and, in \nthis case, returns an object of type R . Thus, as it relates to collect ( ) , get ( ) returns a \nreference to a mutable storage object, such as a collection. \nNote also that the types of accumulator and combiner are BiConsumer . This is a \nfunctional interface defined in java.util.function . It specifies the abstract method \naccept ( ) that is shown here:",
    "void accept ( T obj , U obj2 ) \n\nThis method performs some type of operation on obj and obj2 . As it relates to \naccumulator , obj specifies the target collection, and obj2 specifies the element to \nadd to that collection. As it relates to combiner, obj and obj2 specify two \ncollections that will be combined. \nUsing the version of collect ( ) just described, you could use a LinkedList as the target in \nthe preceding program, as shown here: \n\nNotice that the first argument to collect ( ) is a lambda expression that returns a new \nLinkedList . The second argument uses the standard collection method add ( ) to add an \nelement to the list. The third element uses addAll ( ) to combine two linked lists. As a point \nof interest, you can use any method defined by LinkedList to add an element to the list. \nFor example, you could use addFirst ( ) to add elements to the start of the list, as shown \nhere:",
    "As you may have guessed, it is not always necessary to specify a lambda expression for the \narguments to collect ( ) . Often, method and/or constructor references will suffice. For \nexample, again assuming the preceding program, this statement creates a HashSet that \n\n\ncontains all of the elements in the nameAndPhone stream: \n\nNotice that the first argument specifies the HashSet constructor reference. The second and \nthird specify method references to HashSet \u2019s add ( ) and addAll ( ) methods. \nOne last point: In the language of the stream API, the collect ( ) method performs what is \ncalled a mutable reduction . This is because the result of the reduction is a mutable ( i.e., \nchangeable ) storage object, such as a collection. \n\nIterators and Streams",
    "Iterators and Streams \n\nAlthough a stream is not a data storage object, you can still use an iterator to cycle through \nits elements in much the same way as you would use an iterator to cycle through the \nelements of a collection. The stream API supports two types of iterators. The first is the \ntraditional Iterator . The second is Spliterator , which was added by JDK 8. It provides \nsignificant advantages in certain situations when used with parallel streams. \n\nUse an Iterator with a Stream \n\nAs just mentioned, you can use an iterator with a stream in just the same way that you do \nwith a collection. Iterators are discussed in Chapter 18, but a brief review will be useful \nhere. Iterators are objects that implement the Iterator interface declared in java.util . Its \ntwo key methods are hasNext ( ) and next ( ) . If there is another element to iterate, \nhasNext ( ) returns true , and false otherwise. The next ( ) method returns the next \nelement in the iteration.",
    "NOTE JDK 8 adds additional iterator types that handle the primitive \nstreams: PrimitiveIterator , PrimitiveIterator.OfDouble , \nPrimitiveIterator.OfLong , and PrimitiveIterator.OfInt . These \niterators all extend the Iterator interface and work in the same general \nway as those based directly on Iterator . \n\nTo obtain an iterator to a stream, call iterator ( ) on the stream. The version used by \nStream is shown here. \n\nIterator<T> iterator ( ) \n\nHere, T specifies the element type. ( The primitive streams return iterators of the \nappropriate primitive type.) \n\n\nThe following program shows how to iterate through the elements of a stream. In this case, \nthe strings in an ArrayList are iterated, but the process is the same for any type of stream. \n\nThe output is shown here: \n\nUse Spliterator",
    "The output is shown here: \n\nUse Spliterator \n\nSpliterator offers an alternative to Iterator , especially when parallel processing is \ninvolved. In general, Spliterator is more sophisticated than Iterator , and a discussion of \nSpliterator is found in Chapter 18. However, it will be useful to review its key features \nhere. Spliterator defines several methods, but we only need to use three. The first is \n\n\ntryAdvance ( ) . It performs an action on the next element and then advances the iterator. \nIt is shown here: \n\nboolean tryAdvance ( Consumer<? super T> action )",
    "tryAdvance ( ) . It performs an action on the next element and then advances the iterator. \nIt is shown here: \n\nboolean tryAdvance ( Consumer<? super T> action ) \n\nHere, action specifies the action that is executed on the next element in the \niteration. tryAdvance ( ) returns true if there is a next element. It returns false if \nno elements remain. As discussed earlier in this chapter, Consumer declares one \nmethod called accept ( ) that receives an element of type T as an argument and \nreturns void . \nBecause tryAdvance ( ) returns false when there are no more elements to process, it \nmakes the iteration loop construct very simple, for example:",
    "As long as tryAdvance ( ) returns true , the action is applied to the next element. When \ntryAdvance ( ) returns false , the iteration is complete. Notice how tryAdvance ( ) \nconsolidates the purposes of hasNext ( ) and next ( ) provided by Iterator into a single \nmethod. This improves the efficiency of the iteration process. \nThe following version of the preceding program substitutes a Spliterator for the Iterator : \n\n\nThe output is the same as before. \nIn some cases, you might want to perform some action on each element collectively, rather \nthan one at a time. To handle this type of situation, Spliterator provides the \nforEachRemaining ( ) method, shown here: \n\ndefault void forEachRemaining ( Consumer<? super T> action ) \n\nThis method applies action to each unprocessed element and then returns. For \nexample, assuming the preceding program, the following displays the strings \nremaining in the stream:",
    "This method applies action to each unprocessed element and then returns. For \nexample, assuming the preceding program, the following displays the strings \nremaining in the stream: \n\nNotice how this method eliminates the need to provide a loop to cycle through the elements \none at a time. This is another advantage of Spliterator . \nOne other Spliterator method of particular interest is trySplit ( ) . It splits the elements \nbeing iterated in two, returning a new Spliterator to one of the partitions. The other \npartition remains accessible by the original Spliterator . It is shown here: \n\nSpliterator<T> trySplit ( ) \n\n\nIf it is not possible to split the invoking Spliterator , null is returned. Otherwise, \na reference to the partition is returned. For example, here is another version of the \npreceding program that demonstrates trySplit ( ) : \n\nThe output is shown here:",
    "The output is shown here: \n\n\nAlthough splitting the Spliterator in this simple illustration is of no practical value, \nsplitting can be of great value when parallel processing over large data sets. However, in \nmany cases, it is better to use one of the other Stream methods in conjunction with a \nparallel stream, rather than manually handling these details with Spliterator . Spliterator \nis primarily for the cases in which none of the predefined methods seems appropriate. \n\nMore to Explore in the Stream API \n\nThis chapter has discussed several key aspects of the stream API and introduced the \ntechniques required to use them, but the stream API has much more to offer. To begin, here \nare a few of the other methods provided by Stream that you will find helpful: \n\n\u2022  To determine if one or more elements in a stream satisfy a specified \npredicate, use allMatch ( ) , anyMatch ( ) , or noneMatch ( ) . \n\n\u2022  To obtain the number of elements in the stream, call count ( ) .",
    "\u2022  To obtain the number of elements in the stream, call count ( ) . \n\n\u2022  To obtain a stream that contains only unique elements, use distinct ( ) . \n\n\u2022  To create a stream that contains a specified set of elements, use of ( ) . \n\nOne last point: the stream API is a powerful addition to Java. It is likely that it will \n\nbe enhanced over time to include even more functionality. Therefore, a periodic \nperusal of its API documentation is advised. \n\n\uf709 \nPREV \nChapter 28: The Concurrency Utilities \n\u23ee \n\nNEXT \nChapter 30: Regular Expressions and Other Pac\u2026 \n\u23ed \n\n\nPREV \nChapter 29: The Stream API \n\u23ee \n\nNEXT \nPart III: Introducing GUI Programming with Swing \u23ed \n\nCHAPTER \n\n30 \nRegular Expressions and Other Packages",
    "When Java was originally released, it included a set of eight packages, called the core API . \nEach subsequent release added to the API. Today, the Java API contains a very large \nnumber of packages. Many of the packages support areas of specialization that are beyond \nthe scope of this book. However, several packages warrant an examination here. Four are \njava.util.regex , java.lang.reflect , java.rmi , and java.text . They support regular \nexpression processing, reflection, Remote Method Invocation ( RMI ), and text formatting, \nrespectively. The chapter ends by introducing the new date and time API in java.time and \nits subpackages. \nThe regular expression package lets you perform sophisticated pattern matching operations. \nThis chapter provides an in-depth introduction to this package along with extensive \nexamples. Reflection is the ability of software to analyze itself. It is an essential part of the \nJava Beans technology that is covered in Chapter 37",
    ". Reflection is the ability of software to analyze itself. It is an essential part of the \nJava Beans technology that is covered in Chapter 37. Remote Method Invocation ( RMI ) \nallows you to build Java applications that are distributed among several machines. This \nchapter provides a simple client/server example that uses RMI. The text formatting \ncapabilities of java.text have many uses. The one examined here formats date and time \nstrings. The new date and time API supplies an up-to-date approach to handling date and \ntime.",
    "The Core Java API Packages \n\nAt the time of this writing, Table 30-1 lists all of the core API packages defined by Java \n( those in the java namespace ) and summarizes their functions. \n\n\n\n\nTable 30-1    The Core Java API Packages \n\nRegular Expression Processing",
    "Table 30-1    The Core Java API Packages \n\nRegular Expression Processing \n\nThe java.util.regex package supports regular expression processing. As the term is used \nhere, a regular expression is a string of characters that describes a character sequence. This \ngeneral description, called a pattern , can then be used to find matches in other character \nsequences. Regular expressions can specify wildcard characters, sets of characters, and \nvarious quantifiers. Thus, you can specify a regular expression that represents a general \nform that can match several different specific character sequences. \nThere are two classes that support regular expression processing: Pattern and Matcher . \nThese classes work together. Use Pattern to define a regular expression. Match the pattern \nagainst another sequence using Matcher . \n\nPattern",
    "Pattern \n\nThe Pattern class defines no constructors. Instead, a pattern is created by calling the \ncompile ( ) factory method. One of its forms is shown here: \n\nstatic Pattern compile ( String pattern ) \n\nHere, pattern is the regular expression that you want to use. The compile ( ) \n\nmethod transforms the string in pattern into a pattern that can be used for pattern \nmatching by the Matcher class. It returns a Pattern object that contains the \n\npattern. \n\n\nOnce you have created a Pattern object, you will use it to create a Matcher . This is done \nby calling the matcher ( ) factory method defined by Pattern . It is shown here: \n\nMatcher matcher ( CharSequence str ) \n\nHere str is the character sequence that the pattern will be matched against. This is \ncalled the input sequence . CharSequence is an interface that defines a read-only \nset of characters. It is implemented by the String class, among others. Thus, you \ncan pass a string to matcher ( ) . \n\nMatcher",
    "Matcher \n\nThe Matcher class has no constructors. Instead, you create a Matcher by calling the \nmatcher ( ) factory method defined by Pattern , as just explained. Once you have created a \nMatcher , you will use its methods to perform various pattern matching operations. \nThe simplest pattern matching method is matches ( ) , which simply determines whether \nthe character sequence matches the pattern. It is shown here: \n\nboolean matches ( ) \n\nIt returns true if the sequence and the pattern match, and false otherwise. \nUnderstand that the entire sequence must match the pattern, not just a \nsubsequence of it. \nTo determine if a subsequence of the input sequence matches the pattern, use find ( ) . One \nversion is shown here: \n\nboolean find ( )",
    "boolean find ( ) \n\nIt returns true if there is a matching subsequence and false otherwise. This \nmethod can be called repeatedly, allowing it to find all matching subsequences. \nEach call to find ( ) begins where the previous one left off. \nYou can obtain a string containing the last matching sequence by calling group ( ) . One of \nits forms is shown here: \n\nString group ( ) \n\nThe matching string is returned. If no match exists, then an \nIllegalStateException is thrown. \nYou can obtain the index within the input sequence of the current match by calling start ( ) . \nThe index one past the end of the current match is obtained by calling end ( ) . The forms \n\nused in this chapter are shown here: \n\nint start ( ) \nint end ( ) \n\nBoth throw IllegalStateException if no match exists. \nYou can replace all occurrences of a matching sequence with another sequence by calling \nreplaceAll ( ) , shown here: \n\n\nString replaceAll ( String newStr )",
    "String replaceAll ( String newStr ) \n\nHere, newStr specifies the new character sequence that will replace the ones that \nmatch the pattern. The updated input sequence is returned as a string. \n\nRegular Expression Syntax",
    "Before demonstrating Pattern and Matcher , it is necessary to explain how to construct a \nregular expression. Although no rule is complicated by itself, there are a large number of \nthem, and a complete discussion is beyond the scope of this chapter. However, a few of the \nmore commonly used constructs are described here. \nIn general, a regular expression is comprised of normal characters, character classes ( sets of \ncharacters ), wildcard characters, and quantifiers. A normal character is matched as-is. Thus, \nif a pattern consists of \"xy\", then the only input sequence that will match it is \"xy\". \nCharacters such as newline and tab are specified using the standard escape sequences, \nwhich begin with a \\ . For example, a newline is specified by \\n . In the language of regular \nexpressions, a normal character is also called a literal . \nA character class is a set of characters. A character class is specified by putting the \ncharacters in the class between brackets",
    ". \nA character class is a set of characters. A character class is specified by putting the \ncharacters in the class between brackets. For example, the class [wxyz] matches w, x, y, or z. \nTo specify an inverted set, precede the characters with a ^ . For example, [^wxyz] matches \nany character except w, x, y, or z. You can specify a range of characters using a hyphen. For \nexample, to specify a character class that will match the digits 1 through 9, use [1-9]. \nThe wildcard character is the . ( dot ) and it matches any character. Thus, a pattern that \nconsists of \".\" will match these ( and other ) input sequences: \"A\", \"a\", \"x\", and so on. \nA quantifier determines how many times an expression is matched. The quantifiers are \nshown here:",
    "+ \nMatch one or more. \n\n* \nMatch zero or more. \n\n? \nMatch zero or one. \n\nFor example, the pattern \"x+\" will match \"x\", \"xx\", and \"xxx\", among others. \nOne other point: In general, if you specify an invalid expression, a \nPatternSyntaxException will be thrown. \n\nDemonstrating Pattern Matching \n\nThe best way to understand how regular expression pattern matching operates is to work \nthrough some examples. The first, shown here, looks for a match with a literal pattern: \n\n\nThe output from the program is shown here: \n\nLet\u2019s look closely at this program. The program begins by creating the pattern that contains \nthe sequence \"Java\". Next, a Matcher is created for that pattern that has the input \nsequence \"Java\". Then, the matches ( ) method is called to determine if the input sequence \nmatches the pattern. Because the sequence and the pattern are the same, matches ( ) \nreturns true . Next, a new Matcher is created with the input sequence \"Java 8\" and",
    "matches ( ) is called again. In this case, the pattern and the input sequence differ, and no \nmatch is found. Remember, the matches ( ) function returns true only when the input \nsequence precisely matches the pattern. It will not return true just because a subsequence \nmatches. \nYou can use find ( ) to determine if the input sequence contains a subsequence that matches \n\n\nthe pattern. Consider the following program: \n\nThe output is shown here: \n\nIn this case, find ( ) finds the subsequence \"Java\". \nThe find ( ) method can be used to search the input sequence for repeated occurrences of \nthe pattern because each call to find ( ) picks up where the previous one left off. For \nexample, the following program finds two occurrences of the pattern \"test\": \n\nThe output is shown here: \n\nAs the output shows, two matches were found. The program uses the start ( ) method to \nobtain the index of each match. \n\n\nUsing Wildcards and Quantifiers",
    "The output is shown here: \n\nAs the output shows, two matches were found. The program uses the start ( ) method to \nobtain the index of each match. \n\n\nUsing Wildcards and Quantifiers \n\nAlthough the preceding programs show the general technique for using Pattern and \nMatcher , they don\u2019t show their power. The real benefit of regular expression processing is \nnot seen until wildcards and quantifiers are used. To begin, consider the following example \nthat uses the + quantifier to match any arbitrarily long sequence of Ws: \n\nThe output from the program is shown here: \n\nAs the output shows, the regular expression pattern \"W+\" matches any arbitrarily long \nsequence of Ws. \nThe next program uses a wildcard to create a pattern that will match any sequence that \nbegins with e and ends with d . To do this, it uses the dot wildcard character along with the \n+ quantifier. \n\nYou might be surprised by the output produced by the program, which is shown here:",
    "You might be surprised by the output produced by the program, which is shown here: \n\n\nOnly one match is found, and it is the longest sequence that begins with e and ends with d . \nYou might have expected two matches: \"extend\" and \"end\". The reason that the longer \nsequence is found is that, by default, find ( ) matches the longest sequence that fits the \npattern. This is called greedy behavior . You can specify reluctant behavior by adding the ? \nquantifier to the pattern, as shown in this version of the program. It causes the shortest \nmatching pattern to be obtained. \n\nThe output from the program is shown here: \n\nAs the output shows, the pattern \"e.+?d\" will match the shortest sequence that begins with e \n\nand ends with d . Thus, two matches are found. \n\nWorking with Classes of Characters",
    "As the output shows, the pattern \"e.+?d\" will match the shortest sequence that begins with e \n\nand ends with d . Thus, two matches are found. \n\nWorking with Classes of Characters \n\nSometimes you will want to match any sequence that contains one or more characters, in \nany order, that are part of a set of characters. For example, to match whole words, you want \nto match any sequence of the letters of the alphabet. One of the easiest ways to do this is to \nuse a character class, which defines a set of characters. Recall that a character class is \ncreated by putting the characters you want to match between brackets. For example, to \nmatch the lowercase characters a through z, use [a-z] . The following program demonstrates \nthis technique: \n\n\nThe output is shown here: \n\nUsing replaceAll ( )",
    "The output is shown here: \n\nUsing replaceAll ( ) \n\nThe replaceAll ( ) method supplied by Matcher lets you perform powerful search and \nreplace operations that use regular expressions. For example, the following program \nreplaces all occurrences of sequences that begin with \"Jon\" with \"Eric\": \n\nThe output is shown here: \n\n\nBecause the regular expression \"Jon.*?\" matches any string that begins with Jon followed by \nzero or more characters, ending in a space, it can be used to match and replace both Jon \nand Jonathan with the name Eric. Such a substitution is not easily accomplished without \npattern matching capabilities. \n\nUsing split ( ) \n\nYou can reduce an input sequence into its individual tokens by using the split ( ) method \ndefined by Pattern . One form of the split ( ) method is shown here: \n\nString[ ] split ( CharSequence str )",
    "String[ ] split ( CharSequence str ) \n\nIt processes the input sequence passed in str , reducing it into tokens based on the \ndelimiters specified by the pattern. \nFor example, the following program finds tokens that are separated by spaces, commas, \nperiods, and exclamation points: \n\nThe output is shown here: \n\nAs the output shows, the input sequence is reduced to its individual tokens. Notice that the \ndelimiters are not included. \n\n\nTwo Pattern-Matching Options \n\nAlthough the pattern-matching techniques described in the foregoing offer the greatest \nflexibility and power, there are two alternatives which you might find useful in some \ncircumstances. If you only need to perform a one-time pattern match, you can use the \nmatches ( ) method defined by Pattern . It is shown here: \n\nstatic boolean matches ( String pattern , CharSequence str )",
    "static boolean matches ( String pattern , CharSequence str ) \n\nIt returns true if pattern matches str and false otherwise. This method \nautomatically compiles pattern and then looks for a match. If you will be using the \nsame pattern repeatedly, then using matches ( ) is less efficient than compiling \nthe pattern and using the pattern-matching methods defined by Matcher , as \ndescribed previously. \nYou can also perform a pattern match by using the matches ( ) method implemented by \nString . It is shown here: \n\nboolean matches ( String pattern ) \n\nIf the invoking string matches the regular expression in pattern , then matches ( ) \nreturns true . Otherwise, it returns false . \n\nExploring Regular Expressions",
    "If the invoking string matches the regular expression in pattern , then matches ( ) \nreturns true . Otherwise, it returns false . \n\nExploring Regular Expressions \n\nThe overview of regular expressions presented in this section only hints at their power. \nSince text parsing, manipulation, and tokenization are a large part of programming, you will \nlikely find Java\u2019s regular expression subsystem a powerful tool that you can use to your \nadvantage. It is, therefore, wise to explore the capabilities of regular expressions. \nExperiment with several different types of patterns and input sequences. Once you \nunderstand how regular expression pattern matching works, you will find it useful in many \nof your programming endeavors. \n\nReflection",
    "Reflection \n\nReflection is the ability of software to analyze itself. This is provided by the \njava.lang.reflect package and elements in Class . Reflection is an important capability, \nespecially when using components called Java Beans. It allows you to analyze a software \ncomponent and describe its capabilities dynamically, at run time rather than at compile \ntime. For example, by using reflection, you can determine what methods, constructors, and \nfields a class supports. Reflection was introduced in Chapter 12. It is examined further here. \nThe package java.lang.reflect includes several interfaces. Of special interest is Member , \n\nwhich defines methods that allow you to get information about a field, constructor, or \nmethod of a class. There are also ten classes in this package. These are listed in Table 30-2. \n\n\nTable 30-2    Classes Defined in java.lang.reflect",
    "Table 30-2    Classes Defined in java.lang.reflect \n\nThe following application illustrates a simple use of the Java reflection capabilities. It prints \nthe constructors, fields, and methods of the class java.awt.Dimension . The program \nbegins by using the forName ( ) method of Class to get a class object for \njava.awt.Dimension . Once this is obtained, getConstructors ( ) , getFields ( ) , and \ngetMethods ( ) are used to analyze this class object. They return arrays of Constructor , \nField , and Method objects that provide the information about the object. The \nConstructor , Field , and Method classes define several methods that can be used to \nobtain information about an object. You will want to explore these on your own. However, \neach supports the toString ( ) method. Therefore, using Constructor , Field , and \nMethod objects as arguments to the println ( ) method is straightforward, as shown in the \nprogram.",
    "Here is the output from this program. ( The precise order may differ slightly from that \nshown.)",
    "The next example uses Java\u2019s reflection capabilities to obtain the public methods of a class. \nThe program begins by instantiating class A . The getClass ( ) method is applied to this \nobject reference, and it returns the Class object for class A . The getDeclaredMethods ( ) \nmethod returns an array of Method objects that describe only the methods declared by this \nclass. Methods inherited from superclasses such as Object are not included. \nEach element of the methods array is then processed. The getModifiers ( ) method \nreturns an int containing flags that describe which modifiers apply for this element. The \nModifier class provides a set of is X methods, shown in Table 30-3, that can be used to \nexamine this value. For example, the static method isPublic ( ) returns true if its argument \nincludes the public modifier. Otherwise, it returns false",
    ". For example, the static method isPublic ( ) returns true if its argument \nincludes the public modifier. Otherwise, it returns false . In the following program, if the \nmethod supports public access, its name is obtained by the getName ( ) method and is then \nprinted.",
    "Table 30-3    The \u201cis\u201d Methods Defined by Modifier That Determine \nModifiers \n\n\nHere is the output from this program: \n\nModifier also includes a set of static methods that return the type of modifiers that can be \napplied to a specific type of program element. These methods are \n\nstatic int classModifiers ( ) \n\nstatic int constructorModifiers ( ) \n\nstatic int fieldModifiers ( ) \n\n\nstatic int interfaceModifiers ( ) \n\nstatic int methodModifiers ( ) \n\nstatic int parameterModifiers ( ) ( Added by JDK 8.) \n\nFor example, methodModifiers ( ) returns the modifiers that can be applied to a \nmethod. Each method returns flags, packed into an int , that indicate which \nmodifiers are legal. The modifier values are defined by constants in Modifier , \nwhich include PROTECTED , PUBLIC , PRIVATE , STATIC , FINAL , and so on. \n\nRemote Method Invocation ( RMI )",
    "Remote Method Invocation ( RMI ) \n\nRemote Method Invocation ( RMI ) allows a Java object that executes on one machine to \ninvoke a method of a Java object that executes on another machine. This is an important \nfeature, because it allows you to build distributed applications. While a complete discussion \nof RMI is outside the scope of this book, the following simplified example describes the basic \nprinciples involved. \n\nA Simple Client/Server Application Using RMI \n\nThis section provides step-by-step directions for building a simple client/server application \nby using RMI. The server receives a request from a client, processes it, and returns a result. \nIn this example, the request specifies two numbers. The server adds these together and \nreturns the sum. \n\nStep One: Enter and Compile the Source Code",
    "Step One: Enter and Compile the Source Code \n\nThis application uses four source files. The first file, AddServerIntf.java , defines the \nremote interface that is provided by the server. It contains one method that accepts two \ndouble arguments and returns their sum. All remote interfaces must extend the Remote \ninterface, which is part of java.rmi . Remote defines no members. Its purpose is simply to \nindicate that an interface uses remote methods. All remote methods can throw a \nRemoteException . \n\nThe second source file, AddServerImpl.java , implements the remote interface. The \nimplementation of the add ( ) method is straightforward. Remote objects typically extend \nUnicastRemoteObject , which provides functionality that is needed to make objects \navailable from remote machines.",
    "The third source file, AddServer.java , contains the main program for the server machine. \nIts primary function is to update the RMI registry on that machine. This is done by using the \nrebind ( ) method of the Naming class ( found in java.rmi ). That method associates a \nname with an object reference. The first argument to the rebind ( ) method is a string that \nnames the server as \"AddServer\". Its second argument is a reference to an instance of \nAddServerImpl . \n\nThe fourth source file, AddClient.java , implements the client side of this distributed \napplication. AddClient.java requires three command-line arguments. The first is the IP \naddress or name of the server machine. The second and third arguments are the two \nnumbers that are to be summed.",
    "The application begins by forming a string that follows the URL syntax. This URL uses the \nrmi protocol. The string includes the IP address or name of the server and the string \n\"AddServer\". The program then invokes the lookup ( ) method of the Naming class. This \nmethod accepts one argument, the rmi URL, and returns a reference to an object of type \nAddServerIntf . All remote method invocations can then be directed to this object. \nThe program continues by displaying its arguments and then invokes the remote add ( ) \n\nmethod. The sum is returned from this method and is then printed. \n\n\nAfter you enter all the code, use javac to compile the four source files that you created. \n\nStep Two: Manually Generate a Stub if Required",
    "In the context of RMI, a stub is a Java object that resides on the client machine. Its function \nis to present the same interfaces as the remote server. Remote method calls initiated by the \nclient are actually directed to the stub. The stub works with the other parts of the RMI \nsystem to formulate a request that is sent to the remote machine. \nA remote method may accept arguments that are simple types or objects. In the latter case, \nthe object may have references to other objects. All of this information must be sent to the \nremote machine. That is, an object passed as an argument to a remote method call must be \nserialized and sent to the remote machine. Recall from Chapter 20 that the serialization \nfacilities also recursively process all referenced objects. \nIf a response must be returned to the client, the process works in reverse. Note that the \nserialization and deserialization facilities are also used if objects are returned to a client",
    ". \nIf a response must be returned to the client, the process works in reverse. Note that the \nserialization and deserialization facilities are also used if objects are returned to a client. \nPrior to Java 5, stubs needed to be built manually by using rmic . This step is not required \nfor modern versions of Java. However, if you are working in a legacy environment, then you \ncan use the rmic compiler, as shown here, to build a stub:",
    "rmic AddServerImpl \n\nThis command generates the file AddServerImpl_Stub.class . When using \nrmic , be sure that CLASSPATH is set to include the current directory. \n\nStep Three: Install Files on the Client and Server Machines \n\nCopy AddClient.class , AddServerImpl_Stub.class ( if needed ), and \nAddServerIntf.class to a directory on the client machine. Copy AddServerIntf.class , \nAddServerImpl.class , AddServerImpl_Stub.class ( if needed ), and AddServer.class \n\n\nto a directory on the server machine. \n\nNOTE RMI has techniques for dynamic class loading, but they are not \nused by the example at hand. Instead, all of the files that are used by the \nclient and server applications must be installed manually on those \nmachines. \n\nStep Four: Start the RMI Registry on the Server Machine",
    "Step Four: Start the RMI Registry on the Server Machine \n\nThe JDK provides a program called rmiregistry , which executes on the server machine. It \nmaps names to object references. First, check that the CLASSPATH environment variable \nincludes the directory in which your files are located. Then, start the RMI Registry from the \ncommand line, as shown here: \n\nstart rmiregistry \n\nWhen this command returns, you should see that a new window has been created. \nYou need to leave this window open until you are done experimenting with the \nRMI example. \n\nStep Five: Start the Server \n\nThe server code is started from the command line, as shown here: \n\njava AddServer \n\nRecall that the AddServer code instantiates AddServerImpl and registers that \nobject with the name \"AddServer\". \n\nStep Six: Start the Client",
    "java AddServer \n\nRecall that the AddServer code instantiates AddServerImpl and registers that \nobject with the name \"AddServer\". \n\nStep Six: Start the Client \n\nThe AddClient software requires three arguments: the name or IP address of the server \nmachine and the two numbers that are to be summed together. You may invoke it from the \ncommand line by using one of the two formats shown here: \n\njava AddClient server1 8 9 \njava AddClient 11.12.13.14 8 9 \n\nIn the first line, the name of the server is provided. The second line uses its IP \naddress ( 11.12.13.14 ). \nYou can try this example without actually having a remote server. To do so, simply install all \nof the programs on the same machine, start rmiregistry , start AddServer , and then \nexecute AddClient using this command line: \n\njava AddClient 127.0.0.1 8 9",
    "java AddClient 127.0.0.1 8 9 \n\n\nHere, the address 127.0.0.1 is the \u201cloop back\u201d address for the local machine. Using \nthis address allows you to exercise the entire RMI mechanism without actually \nhaving to install the server on a remote computer. ( If you are using a firewall, then \nthis approach may not work.) \nIn either case, sample output from this program is shown here: \n\nNOTE When working with RMI in the real world, it may be necessary for \nthe server to install a security manager. \n\nFormatting Date and Time with java.text",
    "NOTE When working with RMI in the real world, it may be necessary for \nthe server to install a security manager. \n\nFormatting Date and Time with java.text \n\nThe package java.text allows you to format, parse, search, and manipulate text. This \nsection examines two of its most commonly used classes: those that format date and time \ninformation. However, it is important to state at the outset that the new date and time API \ndescribed later in this chapter offers a modern approach to handling date and time that also \nsupports formatting. Of course, legacy code will continue to use the classes shown here for \nsome time. \n\nDateFormat Class \n\nDateFormat is an abstract class that provides the ability to format and parse dates and \ntimes. The getDateInstance ( ) method returns an instance of DateFormat that can \nformat date information. It is available in these forms:",
    "static final DateFormat getDateInstance ( ) \nstatic final DateFormat getDateInstance ( int style ) \nstatic final DateFormat getDateInstance ( int style , Locale locale ) \n\nThe argument style is one of the following values: DEFAULT , SHORT , \n\nMEDIUM , LONG , or FULL . These are int constants defined by DateFormat . \nThey cause different details about the date to be presented. The argument locale is \n\none of the static references defined by Locale ( refer to Chapter 19 for details ). If \nthe style and/or locale is not specified, defaults are used. \nOne of the most commonly used methods in this class is format ( ) . It has several \noverloaded forms, one of which is shown here: \n\nfinal String format ( Date d )",
    "final String format ( Date d ) \n\n\nThe argument is a Date object that is to be displayed. The method returns a string \ncontaining the formatted information. \nThe following listing illustrates how to format date information. It begins by creating a Date \nobject. This captures the current date and time information. Then it outputs the date \ninformation by using different styles and locales. \n\nSample output from this program is shown here: \n\nThe getTimeInstance ( ) method returns an instance of DateFormat that can format \ntime information. It is available in these versions: \n\nstatic final DateFormat getTimeInstance ( ) \n\nstatic final DateFormat getTimeInstance ( int style ) \nstatic final DateFormat getTimeInstance ( int style , Locale locale )",
    "static final DateFormat getTimeInstance ( ) \n\nstatic final DateFormat getTimeInstance ( int style ) \nstatic final DateFormat getTimeInstance ( int style , Locale locale ) \n\nThe argument style is one of the following values: DEFAULT , SHORT , \nMEDIUM , LONG , or FULL . These are int constants defined by DateFormat . \nThey cause different details about the time to be presented. The argument locale is \none of the static references defined by Locale . If the style and/or locale is not \nspecified, defaults are used. \nThe following listing illustrates how to format time information. It begins by creating a \n\n\nDate object. This captures the current date and time information. Then it outputs the time \ninformation by using different styles and locales. \n\nSample output from this program is shown here: \n\nThe DateFormat class also has a getDateTimeInstance ( ) method that can format both \ndate and time information. You may wish to experiment with it on your own.",
    "The DateFormat class also has a getDateTimeInstance ( ) method that can format both \ndate and time information. You may wish to experiment with it on your own. \n\nSimpleDateFormat Class \n\nSimpleDateFormat is a concrete subclass of DateFormat . It allows you to define your \nown formatting patterns that are used to display date and time information. \nOne of its constructors is shown here: \n\nSimpleDateFormat ( String formatString ) \n\nThe argument formatString describes how date and time information is displayed. \nAn example of its use is given here: \n\nThe symbols used in the formatting string determine the information that is displayed. \nTable 30-4 lists these symbols and gives a description of each. \n\n\nTable 30-4    Formatting String Symbols for SimpleDateFormat",
    "Table 30-4    Formatting String Symbols for SimpleDateFormat \n\nIn most cases, the number of times a symbol is repeated determines how that data is \npresented. Text information is displayed in an abbreviated form if the pattern letter is \nrepeated less than four times. Otherwise, the unabbreviated form is used. For example, a \nzzzz pattern can display Pacific Daylight Time, and a zzz pattern can display PDT. \nFor numbers, the number of times a pattern letter is repeated determines how many digits \nare presented. For example, hh:mm:ss can present 01:51:15, but h:m:s displays the same \ntime value as 1:51:15. \nFinally, M or MM causes the month to be displayed as one or two digits. However, three or \nmore repetitions of M cause the month to be displayed as a text string. \nThe following program shows how this class is used: \n\n\nSample output from this program is shown here: \n\nThe Time and Date API Added by JDK 8",
    "Sample output from this program is shown here: \n\nThe Time and Date API Added by JDK 8 \n\nIn Chapter 19, Java\u2019s long-standing approach to handling date and time through the use of \nclasses such as Calendar and GregorianCalendar was discussed. At the time of this \nwriting, this traditional approach is still in widespread use and is something that all Java \nprogrammers need to be familiar with. However, with the release of JDK 8, Java now \nincludes another approach to handling time and date. This new approach is defined in the \nfollowing packages: \n\nPackage \nDescription \n\njava.time \nProvides top-level classes that support time and date. \n\njava.time.chrono \nSupports alternative, non-Gregorian calendars. \n\njava.time.format \nSupports time and date formatting. \n\njava.time.temporal \nSupports extended date and time functionality. \n\njava.time.zone \nSupports time zones.",
    "java.time.format \nSupports time and date formatting. \n\njava.time.temporal \nSupports extended date and time functionality. \n\njava.time.zone \nSupports time zones. \n\nThese new packages define a large number of classes, interfaces, and enumerations that \nprovide extensive, finely grained support for time and date operations. Because of the \nnumber of elements that comprise the new time and date API, it can seem fairly \n\n\nintimidating at first. However, it is well organized and logically structured. Its size reflects \nthe detail of control and flexibility that it provides. Although it is far beyond the scope of \nthis book to examine each element in this extensive API, we will look at several of its main \nclasses. As you will see, these classes are sufficient for many uses. \n\nTime and Date Fundamentals",
    "In java.time are defined several top-level classes that give you easy access to the time and \ndate. Three of these are LocalDate , LocalTime , and LocalDateTime . As their names \nsuggest, they encapsulate the local date, time, and date and time. Using these classes, it is \neasy to obtain the current date and time, format the date and time, and compare dates and \ntimes, among other operations. \nLocalDate encapsulates a date that uses the default Gregorian calendar as specified by ISO \n8601. LocalTime encapsulates a time, as specified by ISO 8601. LocalDateTime \nencapsulates both date and time. These classes contain a large number of methods that give \nyou access to the date and time components, allow you to compare dates and times, add or \nsubtract date or time components, and so on. Because a common naming convention for \nmethods is employed, once you know how to use one of these classes, the others are easy to \nmaster",
    ". Because a common naming convention for \nmethods is employed, once you know how to use one of these classes, the others are easy to \nmaster. \nLocalDate , LocalTime , and LocalDateTime do not define public constructors. Rather, \nto obtain an instance, you will use a factory method. One very convenient method is now ( \n) , which is defined for all three classes. It returns the current date and/or time of the \nsystem. Each class defines several versions, but we will use its simplest form. Here is the \nversion we will use as defined by LocalDate :",
    "static LocalDate now ( ) \n\nThe version for LocalTime is shown here: \n\nstatic LocalTime now ( ) \n\nThe version for LocalDateTime is shown here: \n\nstatic LocalDateTime now ( ) \n\nAs you can see, in each case, an appropriate object is returned. The object returned \n\nby now ( ) can be displayed in its default, human-readable form by use of a \nprintln ( ) statement, for example. However, it is also possible to take full control \nover the formatting of date and time. \n\nThe following program uses LocalDate and LocalTime to obtain the current date and \ntime and then displays them. Notice how now ( ) is called to retrieve the current date and \ntime. \n\n\nSample output is shown here:",
    "Sample output is shown here: \n\nThe output reflects the default format that is given to the date and time. ( The next section \nshows how to specify a different format.) \nBecause the preceding program displays both the current date and the current time, it could \nhave been more easily written using the LocalDateTime class. In this approach, only a \nsingle instance needs to be created and only a single call to now ( ) is required, as shown \nhere: \n\nUsing this approach, the default output includes both date and time. Here is a sample: \n\nOne other point: from a LocalDateTime instance, it is possible to obtain a reference to the \ndate or time component by using the toLocalDate ( ) and toLocalTime ( ) methods, \nshown here: \n\nLocalDate toLocalDate ( ) \n\nLocalTime toLocalTime ( ) \n\nEach returns a reference to the indicated element. \n\nFormatting Date and Time",
    "LocalDate toLocalDate ( ) \n\nLocalTime toLocalTime ( ) \n\nEach returns a reference to the indicated element. \n\nFormatting Date and Time \n\nAlthough the default formats shown in the preceding examples will be adequate for some \nuses, often you will want to specify a different format. Fortunately, this is easy to do because \nLocalDate , LocalTime , and LocalDateTime all provide the format ( ) method, shown \n\n\nhere: \n\nString format ( DateTimeFormatter fmtr ) \n\nHere, fmtr specifies the instance of DateTimeFormatter that will provide the \nformat. \nDateTimeFormatter is packaged in java.time.format . To obtain a \nDateTimeFormatter instance, you will typically use one of its factory methods. Three are \nshown here:",
    "Of course, the type of DateTimeFormatter that you create will be based on the type of \nobject it will be operating on. For example, if you want to format the date in a LocalDate \ninstance, then use ofLocalizedDate ( ) . The specific format is specified by the \nFormatStyle parameter. \nFormatStyle is an enumeration that is packaged in java.time.format . It defines the \nfollowing constants: \n\n  FULL \n\n  LONG \n\n  MEDIUM \n\n  SHORT \n\nThese specify the level of detail that will be displayed. ( Thus, this form of \n\nDateTimeFormatter works similarly to java.text.DateFormat , described \nearlier in this chapter.) \nHere is an example that uses DateTimeFormatter to display the current date and time: \n\n\nSample output is shown here:",
    "Sample output is shown here: \n\nIn some situations, you may want a format different from the ones you can specify by use of \nFormatStyle . One way to accomplish this is to use a predefined formatter, such as \nISO_DATE or ISO_TIME , provided by DateTimeFormatter . Another way is to create a \ncustom format by specifying a pattern. To do this, you can use the ofPattern ( ) factory \nmethod of DateTimeFormatter . One version is shown here: \n\nstatic DateTimeFormatter ofPattern ( String fmtPattern ) \n\nHere, fmtPattern specifies a string that contains the date and time pattern that you",
    "static DateTimeFormatter ofPattern ( String fmtPattern ) \n\nHere, fmtPattern specifies a string that contains the date and time pattern that you \n\nwant. It returns a DateTimeFormatter that will format according to that \npattern. The default locale is used. \nIn general, a pattern consists of format specifiers, called pattern letters . A pattern letter will \nbe replaced by the date or time component that it specifies. The full list of pattern letters is \nshown in the API documentation for ofPattern ( ) . Here is a sampling. Note that the \npattern letters are case-sensitive. \n\na \nAM/PM indicator \n\nd \nDay in month \n\nE \nDay in week \n\nh \nHour, 12-hour clock \n\nH \nHour, 24-hour clock \n\nM \nMonth \n\n\nm \nMinutes \n\ns \nSeconds \n\ny \nYear",
    "a \nAM/PM indicator \n\nd \nDay in month \n\nE \nDay in week \n\nh \nHour, 12-hour clock \n\nH \nHour, 24-hour clock \n\nM \nMonth \n\n\nm \nMinutes \n\ns \nSeconds \n\ny \nYear \n\nIn general, the precise output that you see will be determined by how many times a pattern \nletter is repeated. ( Thus, DateTimeFormatter works a bit like \njava.text.SimpleDateFormat , described earlier in this chapter.) For example, assuming \nthat the month is April, the patterns: \n\nproduce the following formatted output: \n\nFrankly, experimentation is the best way to understand what each pattern letter does and \nhow various repetitions affect the output. \nWhen you want to output a pattern letter as text, enclose the text between single quotation \nmarks. In general, it is a good idea to enclose all non-pattern characters within single \nquotation marks to avoid problems if the set of pattern letters changes in subsequent \nversions of Java. \nThe following program demonstrates the use of a date and time pattern:",
    "Sample output is shown here: \n\nOne other point about creating custom date and time output: LocalDate , LocalTime , and \nLocalDateTime define methods that let you obtain various date and time components. For \nexample, getHour ( ) returns the hour as an int ; getMonth ( ) returns the month in the \nform of a Month enumeration value ; and getYear ( ) returns the year as an int . Using \n\n\nthese, and other methods, you can manually construct output. You can also use these values \nfor other purposes, such as when creating specialized timers. \n\nParsing Date and Time Strings",
    "these, and other methods, you can manually construct output. You can also use these values \nfor other purposes, such as when creating specialized timers. \n\nParsing Date and Time Strings \n\nLocalDate , LocalTime , and LocalDateTime provide the ability to parse date and/or \ntime strings. To do this, call parse ( ) on an instance of one of those classes. It has two \nforms. The first uses the default formatter that parses the date and/or time formatted in the \nstandard ISO fashion, such as 03:31 for time and 2014-08-02 for date. The form of this \nversion of parse ( ) for LocalDateTime is shown here. ( Its form for the other classes is \nsimilar except for the type of object returned.) \n\nstatic LocalDateTime parse ( CharSequence dateTimeStr )",
    "static LocalDateTime parse ( CharSequence dateTimeStr ) \n\nHere, dateTimeStr is a string that contains the date and time in the proper format. \nIf the format is invalid, an error will result. \nIf you want to parse a date and/or time string that is in a format other than ISO format, you \ncan use a second form of parse ( ) that lets you specify your own formatter. The version \nspecified by LocalDateTime is shown next. ( The other classes provide a similar form \nexcept for the return type.) \n\nHere, dateTimeFmtr specifies the formatter that you want to use. \nHere is a simple example that parses a date and time string by use of a custom formatter: \n\nSample output is shown here: \n\nOther Things to Explore in java.time \n\nAlthough you will want to explore all of the date and time packages, a good place to start is",
    "Sample output is shown here: \n\nOther Things to Explore in java.time \n\nAlthough you will want to explore all of the date and time packages, a good place to start is \n\n\nwith java.time . It contains a great deal of functionality that you may find useful. Begin by \nexamining the methods defined by LocalDate , LocalTime , and LocalDateTime . Each \nhas methods that let you add or subtract dates and/or times, adjust dates and/or times by a \ngiven component, compare dates and/or times, and create instances based on date and/or \ntime components, among others. Other classes in java.time that you may find of particular \ninterest include Instant , Duration , and Period . Instant encapsulates an instant in time. \nDuration encapsulates a length of time. Period encapsulates a length of date. \n\n\uf709 \nPREV \nChapter 29: The Stream API \n\u23ee \n\nNEXT \nPart III: Introducing GUI Programming with Swing \u23ed \n\n\nPREV \nChapter 30: Regular Expressions and Other Pa\u2026 \n\u23ee",
    "\uf709 \nPREV \nChapter 29: The Stream API \n\u23ee \n\nNEXT \nPart III: Introducing GUI Programming with Swing \u23ed \n\n\nPREV \nChapter 30: Regular Expressions and Other Pa\u2026 \n\u23ee \n\nNEXT \nChapter 31: Introducing Swing \u23ed \n\nPART \n\nIII \nIntroducing GUI Programming with Swing \n\nCHAPTER 31 \n\nIntroducing Swing \n\nCHAPTER 32 \n\nExploring Swing \n\nCHAPTER 33 \n\nIntroducing Swing \nMenus \n\n\uf709 \nPREV \nChapter 30: Regular Expressions and Other Pa\u2026 \n\u23ee \n\nNEXT \nChapter 31: Introducing Swing \u23ed \n\n\nPREV \nPart III: Introducing GUI Programming with Swing \n\u23ee \n\nNEXT \nChapter 32: Exploring Swing \u23ed \n\nCHAPTER \n\n31 \nIntroducing Swing",
    "In Part II, you saw how to build very simple user interfaces with the AWT classes. Although \nthe AWT is still a crucial part of Java, its component set is no longer widely used to create \ngraphical user interfaces. Today, most programmers use Swing or JavaFX for this purpose. \nJavaFX is discussed in Part IV. Here, Swing is introduced. Swing is a framework that \nprovides more powerful and flexible GUI components than does the AWT. As a result, it is \nthe GUI that has been widely used by Java programmers for more than a decade. \nCoverage of Swing is divided between three chapters. This chapter introduces Swing. It \nbegins by describing Swing\u2019s core concepts. It then shows the general form of a Swing \nprogram, including both applications and applets. It concludes by explaining how painting \nis accomplished in Swing. The next chapter presents several commonly used Swing \ncomponents. The third chapter introduces Swing-based menus",
    ". It concludes by explaining how painting \nis accomplished in Swing. The next chapter presents several commonly used Swing \ncomponents. The third chapter introduces Swing-based menus. It is important to \nunderstand that the number of classes and interfaces in the Swing packages is quite large, \nand they can\u2019t all be covered in this book. ( In fact, full coverage of Swing requires an entire \nbook of its own.) However, these three chapters will give you a basic understanding of this \nimportant topic.",
    "NOTE For a comprehensive introduction to Swing, see my book Swing: \nA Beginner's Guide published by McGraw-Hill Professional ( 2007 ). \n\nThe Origins of Swing \n\nSwing did not exist in the early days of Java. Rather, it was a response to deficiencies \npresent in Java\u2019s original GUI subsystem: the Abstract Window Toolkit. The AWT defines a \nbasic set of controls, windows, and dialog boxes that support a usable, but limited graphical \ninterface. One reason for the limited nature of the AWT is that it translates its various visual \ncomponents into their corresponding, platform-specific equivalents, or peers . This means \n\nthat the look and feel of a component is defined by the platform, not by Java. Because the",
    "AWT components use native code resources, they are referred to as heavyweight . \nThe use of native peers led to several problems. First, because of variations between \noperating systems, a component might look, or even act, differently on different platforms. \nThis potential variability threatened the overarching philosophy of Java: write once, run \nanywhere. Second, the look and feel of each component was fixed ( because it is defined by \nthe platform ) and could not be ( easily ) changed. Third, the use of heavyweight components \ncaused some frustrating restrictions. For example, a heavyweight component was always \nopaque. \nNot long after Java\u2019s original release, it became apparent that the limitations and \nrestrictions present in the AWT were sufficiently serious that a better approach was needed. \nThe solution was Swing. Introduced in 1997, Swing was included as part of the Java \nFoundation Classes ( JFC )",
    ". \nThe solution was Swing. Introduced in 1997, Swing was included as part of the Java \nFoundation Classes ( JFC ). Swing was initially available for use with Java 1.1 as a separate \nlibrary. However, beginning with Java 1.2, Swing ( and the rest of the JFC ) was fully \nintegrated into Java.",
    "Swing Is Built on the AWT \n\nBefore moving on, it is necessary to make one important point: although Swing eliminates a \nnumber of the limitations inherent in the AWT, Swing does not replace it. Instead, Swing is \nbuilt on the foundation of the AWT. This is why the AWT is still a crucial part of Java. \nSwing also uses the same event handling mechanism as the AWT. Therefore, a basic \nunderstanding of the AWT and of event handling is required to use Swing. ( The AWT is \ncovered in Chapters 25 and 26. Event handling is described in Chapter 24.) \n\nTwo Key Swing Features \n\nAs just explained, Swing was created to address the limitations present in the AWT. It does \nthis through two key features: lightweight components and a pluggable look and feel. \nTogether they provide an elegant, yet easy-to-use solution to the problems of the AWT. \nMore than anything else, it is these two features that define the essence of Swing. Each is \nexamined here. \n\nSwing Components Are Lightweight",
    "Swing Components Are Lightweight \n\nWith very few exceptions, Swing components are lightweight . This means that they are \nwritten entirely in Java and do not map directly to platform-specific peers. Thus, \nlightweight components are more efficient and more flexible. Furthermore, because \nlightweight components do not translate into native peers, the look and feel of each \n\ncomponent is determined by Swing, not by the underlying operating system. As a result, \neach component will work in a consistent manner across all platforms. \n\nSwing Supports a Pluggable Look and Feel \n\nSwing supports a pluggable look and feel ( PLAF ). Because each Swing component is \nrendered by Java code rather than by native peers, the look and feel of a component is \n\nunder the control of Swing. This fact means that it is possible to separate the look and feel",
    "of a component from the logic of the component, and this is what Swing does. Separating \nout the look and feel provides a significant advantage: it becomes possible to change the \nway that a component is rendered without affecting any of its other aspects. In other words, \nit is possible to \u201cplug in\u201d a new look and feel for any given component without creating any \nside effects in the code that uses that component. Moreover, it becomes possible to define \nentire sets of look-and-feels that represent different GUI styles. To use a specific style, its \nlook and feel is simply \u201cplugged in.\u201d Once this is done, all components are automatically \nrendered using that style. \nPluggable look-and-feels offer several important advantages. It is possible to define a look \nand feel that is consistent across all platforms. Conversely, it is possible to create a look and \nfeel that acts like a specific platform",
    ". It is possible to define a look \nand feel that is consistent across all platforms. Conversely, it is possible to create a look and \nfeel that acts like a specific platform. For example, if you know that an application will be \nrunning only in a Windows environment, it is possible to specify the Windows look and feel. \nIt is also possible to design a custom look and feel. Finally, the look and feel can be changed \ndynamically at run time. \nJava 8 provides look-and-feels, such as metal and Nimbus, that are available to all Swing \nusers. The metal look and feel is also called the Java look and feel . It is platformindependent and available in all Java execution environments. It is also the default look and \nfeel. Windows environments also have access to the Windows look and feel. This book uses \nthe default Java look and feel ( metal ) because it is platform independent.",
    "The MVC Connection \n\nIn general, a visual component is a composite of three distinct aspects: \n\n\u2022  The way that the component looks when rendered on the screen \n\n\u2022  The way that the component reacts to the user \n\n\u2022  The state information associated with the component",
    "\u2022  The way that the component reacts to the user \n\n\u2022  The state information associated with the component \n\nNo matter what architecture is used to implement a component, it must implicitly \ncontain these three parts. Over the years, one component architecture has proven \nitself to be exceptionally effective: Model-View-Controller , or MVC for short. \nThe MVC architecture is successful because each piece of the design corresponds to an \naspect of a component. In MVC terminology, the model corresponds to the state information \nassociated with the component. For example, in the case of a check box, the model contains \na field that indicates if the box is checked or unchecked. The view determines how the \ncomponent is displayed on the screen, including any aspects of the view that are affected by \nthe current state of the model. The controller determines how the component reacts to the \nuser. For example, when the user clicks a check box, the controller reacts by changing the",
    "model to reflect the user\u2019s choice ( checked or unchecked ). This then results in the view \nbeing updated. By separating a component into a model, a view, and a controller, the \nspecific implementation of each can be changed without affecting the other two. For \ninstance, different view implementations can render the same component in different ways",
    "without affecting the model or the controller. \nAlthough the MVC architecture and the principles behind it are conceptually sound, the \nhigh level of separation between the view and the controller is not beneficial for Swing \ncomponents. Instead, Swing uses a modified version of MVC that combines the view and the \ncontroller into a single logical entity called the UI delegate . For this reason, Swing\u2019s \napproach is called either the Model-Delegate architecture or the Separable Model \narchitecture. Therefore, although Swing\u2019s component architecture is based on MVC, it does \nnot use a classical implementation of it. \nSwing\u2019s pluggable look and feel is made possible by its Model-Delegate architecture. \nBecause the view ( look ) and controller ( feel ) are separate from the model, the look and feel \ncan be changed without affecting how the component is used within a program",
    ". \nBecause the view ( look ) and controller ( feel ) are separate from the model, the look and feel \ncan be changed without affecting how the component is used within a program. Conversely, \nit is possible to customize the model without affecting the way that the component appears \non the screen or responds to user input. \nTo support the Model-Delegate architecture, most Swing components contain two objects. \nThe first represents the model. The second represents the UI delegate. Models are defined \nby interfaces. For example, the model for a button is defined by the ButtonModel \ninterface. UI delegates are classes that inherit ComponentUI . For example, the UI \ndelegate for a button is ButtonUI . Normally, your programs will not interact directly with \nthe UI delegate.",
    "Components and Containers \n\nA Swing GUI consists of two key items: components and containers . However, this \ndistinction is mostly conceptual because all containers are also components. The difference \nbetween the two is found in their intended purpose: As the term is commonly used, a \ncomponent is an independent visual control, such as a push button or slider. A container \nholds a group of components. Thus, a container is a special type of component that is \ndesigned to hold other components. Furthermore, in order for a component to be displayed, \nit must be held within a container. Thus, all Swing GUIs will have at least one container. \nBecause containers are components, a container can also hold other containers. This \nenables Swing to define what is called a containment hierarchy , at the top of which must be \na top-level container . \nLet\u2019s look a bit more closely at components and containers. \n\nComponents",
    "Components \n\nIn general, Swing components are derived from the JComponent class. ( The only \nexceptions to this are the four top-level containers, described in the next section.) \n\nJComponent provides the functionality that is common to all components. For example, \nJComponent supports the pluggable look and feel. JComponent inherits the AWT \nclasses Container and Component . Thus, a Swing component is built on and compatible \nwith an AWT component. \nAll of Swing\u2019s components are represented by classes defined within the package \n\n\njavax.swing . The following table shows the class names for Swing components ( including \nthose used as containers ). \n\nNotice that all component classes begin with the letter J. For example, the class for a label is \nJLabel ; the class for a push button is JButton ; and the class for a scroll bar is \nJScrollBar . \n\nContainers",
    "Swing defines two types of containers. The first are top-level containers: JFrame , JApplet , \nJWindow , and JDialog . These containers do not inherit JComponent . They do, \nhowever, inherit the AWT classes Component and Container . Unlike Swing\u2019s other \ncomponents, which are lightweight, the top-level containers are heavyweight. This makes \nthe top-level containers a special case in the Swing component library. \nAs the name implies, a top-level container must be at the top of a containment hierarchy. A \ntop-level container is not contained within any other container. Furthermore, every \ncontainment hierarchy must begin with a top-level container. The one most commonly used \nfor applications is JFrame . The one used for applets is JApplet . \nThe second type of containers supported by Swing are lightweight containers. Lightweight \ncontainers do inherit JComponent . An example of a lightweight container is JPanel , \nwhich is a general-purpose container",
    ". Lightweight \ncontainers do inherit JComponent . An example of a lightweight container is JPanel , \nwhich is a general-purpose container. Lightweight containers are often used to organize and \nmanage groups of related components because a lightweight container can be contained \nwithin another container. Thus, you can use lightweight containers such as JPanel to create",
    "subgroups of related controls that are contained within an outer container. \n\nThe Top-Level Container Panes \n\nEach top-level container defines a set of panes . At the top of the hierarchy is an instance of \nJRootPane . JRootPane is a lightweight container whose purpose is to manage the other \npanes. It also helps manage the optional menu bar. The panes that comprise the root pane \n\nare called the glass pane , the content pane , and the layered pane .",
    "The glass pane is the top-level pane. It sits above and completely covers all other panes. By \ndefault, it is a transparent instance of JPanel . The glass pane enables you to manage mouse \nevents that affect the entire container ( rather than an individual control ) or to paint over \nany other component, for example. In most cases, you won\u2019t need to use the glass pane \ndirectly, but it is there if you need it. \nThe layered pane is an instance of JLayeredPane . The layered pane allows components to \nbe given a depth value. This value determines which component overlays another. ( Thus, the \nlayered pane lets you specify a Z-order for a component, although this is not something that \nyou will usually need to do.) The layered pane holds the content pane and the ( optional ) \nmenu bar. \nAlthough the glass pane and the layered panes are integral to the operation of a top-level \ncontainer and serve important purposes, much of what they provide occurs behind the \nscene",
    ". \nAlthough the glass pane and the layered panes are integral to the operation of a top-level \ncontainer and serve important purposes, much of what they provide occurs behind the \nscene. The pane with which your application will interact the most is the content pane, \nbecause this is the pane to which you will add visual components. In other words, when you \nadd a component, such as a button, to a top-level container, you will add it to the content \npane. By default, the content pane is an opaque instance of JPanel .",
    "The Swing Packages \n\nSwing is a very large subsystem and makes use of many packages. At the time of this \nwriting, these are the packages defined by Swing. \n\nThe main package is javax.swing . This package must be imported into any program that \nuses Swing. It contains the classes that implement the basic Swing components, such as \npush buttons, labels, and check boxes. \n\nA Simple Swing Application \n\nSwing programs differ from both the console-based programs and the AWT-based programs \nshown earlier in this book. For example, they use a different set of components and a",
    "Swing programs differ from both the console-based programs and the AWT-based programs \nshown earlier in this book. For example, they use a different set of components and a \n\ndifferent container hierarchy than does the AWT. Swing programs also have special \nrequirements that relate to threading. The best way to understand the structure of a Swing \nprogram is to work through an example. There are two types of Java programs in which \nSwing is typically used. The first is a desktop application. The second is the applet. This \nsection shows how to create a Swing application. The creation of a Swing applet is described \nlater in this chapter. \n\nAlthough quite short, the following program shows one way to write a Swing application. In",
    "Although quite short, the following program shows one way to write a Swing application. In \n\n\nthe process, it demonstrates several key features of Swing. It uses two Swing components: \nJFrame and JLabel . JFrame is the top-level container that is commonly used for Swing \napplications. JLabel is the Swing component that creates a label, which is a component \nthat displays information. The label is Swing\u2019s simplest component because it is passive. \nThat is, a label does not respond to user input. It just displays output. The program uses a \nJFrame container to hold an instance of a JLabel . The label displays a short text message. \n\nSwing programs are compiled and run in the same way as other Java applications. Thus, to \n\ncompile this program, you can use this command line: \n\nTo run the program, use this command line:",
    "Swing programs are compiled and run in the same way as other Java applications. Thus, to \n\ncompile this program, you can use this command line: \n\nTo run the program, use this command line: \n\n\nWhen the program is run, it will produce a window similar to that shown in Figure 31-1. \nBecause the SwingDemo program illustrates several core Swing concepts, we will examine \nit carefully, line by line. The program begins by importing javax.swing . As mentioned, this \npackage contains the components and models defined by Swing. For example, javax.swing \ndefines classes that implement labels, buttons, text controls, and menus. It will be included \nin all programs that use Swing. \n\nFigure 31-1    The window produced by the SwingDemo program \n\nNext, the program declares the SwingDemo class and a constructor for that class. The \nconstructor is where most of the action of the program occurs. It begins by creating a \nJFrame , using this line of code:",
    "This creates a container called jfrm that defines a rectangular window complete with a title \nbar ; close, minimize, maximize, and restore buttons ; and a system menu. Thus, it creates a \nstandard, top-level window. The title of the window is passed to the constructor. \nNext, the window is sized using this statement: \n\nThe setSize ( ) method ( which is inherited by JFrame from the AWT class Component ) \nsets the dimensions of the window, which are specified in pixels. Its general form is shown \nhere: \n\nvoid setSize ( int width , int height )",
    "void setSize ( int width , int height ) \n\nIn this example, the width of the window is set to 275 and the height is set to 100. \nBy default, when a top-level window is closed ( such as when the user clicks the close box ), \nthe window is removed from the screen, but the application is not terminated. While this \ndefault behavior is useful in some situations, it is not what is needed for most applications. \nInstead, you will usually want the entire application to terminate when its top-level window \n\nis closed. There are a couple of ways to achieve this. The easiest way is to call \nsetDefaultCloseOperation ( ) , as the program does: \n\n\nAfter this call executes, closing the window causes the entire application to terminate. The \ngeneral form of setDefaultCloseOperation ( ) is shown here: \n\nvoid setDefaultCloseOperation ( int what )",
    "void setDefaultCloseOperation ( int what ) \n\nThe value passed in what determines what happens when the window is closed. \nThere are several other options in addition to JFrame.EXIT_ON_CLOSE . They \nare shown here: \n\nDISPOSE_ON_CLOSE \n\nHIDE_ON_CLOSE \n\nDO_NOTHING_ON_CLOSE \n\nTheir names reflect their actions. These constants are declared in \nWindowConstants , which is an interface declared in javax.swing that is \nimplemented by JFrame . \nThe next line of code creates a Swing JLabel component: \n\nJLabel is the simplest and easiest-to-use component because it does not accept user input. \nIt simply displays information, which can consist of text, an icon, or a combination of the \ntwo. The label created by the program contains only text, which is passed to its constructor. \nThe next line of code adds the label to the content pane of the frame:",
    "As explained earlier, all top-level containers have a content pane in which components are \nstored. Thus, to add a component to a frame, you must add it to the frame\u2019s content pane. \nThis is accomplished by calling add ( ) on the JFrame reference ( jfrm in this case ). The \ngeneral form of add ( ) is shown here: \n\nComponent add ( Component comp ) \n\nThe add ( ) method is inherited by JFrame from the AWT class Container. \nBy default, the content pane associated with a JFrame uses border layout. The version of",
    "Component add ( Component comp ) \n\nThe add ( ) method is inherited by JFrame from the AWT class Container. \nBy default, the content pane associated with a JFrame uses border layout. The version of \n\nadd ( ) just shown adds the label to the center location. Other versions of add ( ) enable you \nto specify one of the border regions. When a component is added to the center, its size is \nadjusted automatically to fit the size of the center. \nBefore continuing, an important historical point needs to be made. Prior to JDK 5, when \nadding a component to the content pane, you could not invoke the add ( ) method directly \non a JFrame instance. Instead, you needed to call add ( ) on the content pane of the \nJFrame object. The content pane can be obtained by calling getContentPane ( ) on a \n\n\nJFrame instance. The getContentPane ( ) method is shown here: \n\nContainer getContentPane ( )",
    "JFrame instance. The getContentPane ( ) method is shown here: \n\nContainer getContentPane ( ) \n\nIt returns a Container reference to the content pane. The add ( ) method was \nthen called on that reference to add a component to a content pane. Thus, in the \npast, you had to use the following statement to add jlab to jfrm :",
    "Here, getContentPane ( ) first obtains a reference to content pane, and then add ( ) adds \nthe component to the container linked to this pane. This same procedure was also required \nto invoke remove ( ) to remove a component and setLayout ( ) to set the layout manager \nfor the content pane. You will see explicit calls to getContentPane ( ) frequently \nthroughout pre-5.0 code. Today, the use of getContentPane ( ) is no longer necessary. You \ncan simply call add ( ) , remove ( ) , and setLayout ( ) directly on JFrame because these \nmethods have been changed so that they operate on the content pane automatically. \nThe last statement in the SwingDemo constructor causes the window to become visible:",
    "The setVisible ( ) method is inherited from the AWT Component class. If its argument is \ntrue , the window will be displayed. Otherwise, it will be hidden. By default, a JFrame is \ninvisible, so setVisible ( true ) must be called to show it. \nInside main ( ) , a SwingDemo object is created, which causes the window and the label to \nbe displayed. Notice that the SwingDemo constructor is invoked using these lines of code: \n\nThis sequence causes a SwingDemo object to be created on the event dispatching thread \n\nrather than on the main thread of the application. Here\u2019s why. In general, Swing programs \nare event-driven. For example, when a user interacts with a component, an event is \ngenerated. An event is passed to the application by calling an event handler defined by the",
    "application. However, the handler is executed on the event dispatching thread provided by \nSwing and not on the main thread of the application. Thus, although event handlers are \ndefined by your program, they are called on a thread that was not created by your program. \nTo avoid problems ( including the potential for deadlock ), all Swing GUI components must \nbe created and updated from the event dispatching thread, not the main thread of the \napplication. However, main ( ) is executed on the main thread. Thus, main ( ) cannot \n\n\ndirectly instantiate a SwingDemo object. Instead, it must create a Runnable object that \nexecutes on the event dispatching thread and have this object create the GUI. \nTo enable the GUI code to be created on the event dispatching thread, you must use one of \ntwo methods that are defined by the SwingUtilities class. These methods are \ninvokeLater ( ) and invokeAndWait ( ) . They are shown here:",
    "Here, obj is a Runnable object that will have its run ( ) method called by the event \ndispatching thread. The difference between the two methods is that invokeLater ( ) returns \nimmediately, but invokeAndWait ( ) waits until obj.run ( ) returns. You can use one of \nthese methods to call a method that constructs the GUI for your Swing application, or \nwhenever you need to modify the state of the GUI from code not executed by the event \ndispatching thread. You will normally want to use invokeLater ( ) , as the preceding \nprogram does. However, when constructing the initial GUI for an applet, you will need to \nuse invokeAndWait ( ) . \n\nEvent Handling",
    "The preceding example showed the basic form of a Swing program, but it left out one \nimportant part: event handling. Because JLabel does not take input from the user, it does \nnot generate events, so no event handling was needed. However, the other Swing \ncomponents do respond to user input and the events generated by those interactions need \nto be handled. Events can also be generated in ways not directly related to user input. For \nexample, an event is generated when a timer goes off. Whatever the case, event handling is \na large part of any Swing-based application. \nThe event handling mechanism used by Swing is the same as that used by the AWT. This \napproach is called the delegation event model , and it is described in Chapter 24. In many \ncases, Swing uses the same events as does the AWT, and these events are packaged in \njava.awt.event . Events specific to Swing are stored in javax.swing.event",
    ". In many \ncases, Swing uses the same events as does the AWT, and these events are packaged in \njava.awt.event . Events specific to Swing are stored in javax.swing.event . \nAlthough events are handled in Swing in the same way as they are with the AWT, it is still \nuseful to work through a simple example. The following program handles the event \ngenerated by a Swing push button. Sample output is shown in Figure 31-2.",
    "Figure 31-2    Output from the EventDemo program \n\n\n\n\nFirst, notice that the program now imports both the java.awt and java.awt.event \npackages. The java.awt package is needed because it contains the FlowLayout class, \nwhich supports the standard flow layout manager used to lay out components in a frame. \n( See Chapter 26 for coverage of layout managers.) The java.awt.event package is needed \nbecause it defines the ActionListener interface and the ActionEvent class. \nThe EventDemo constructor begins by creating a JFrame called jfrm . It then sets the \nlayout manager for the content pane of jfrm to FlowLayout. Recall that, by default, the \ncontent pane uses BorderLayout as its layout manager. However, for this example, \nFlowLayout is more convenient. Notice that FlowLayout is assigned using this \nstatement:",
    "As explained, in the past you had to explicitly call getContentPane ( ) to set the layout \nmanager for the content pane. This requirement was removed as of JDK 5. \nAfter setting the size and default close operation, EventDemo ( ) creates two push buttons, \nas shown here: \n\nThe first button will contain the text \"Alpha\" and the second will contain the text \"Beta\". \nSwing push buttons are instances of JButton . JButton supplies several constructors. The \none used here is \n\nJButton ( String msg ) \n\nThe msg parameter specifies the string that will be displayed inside the button. \nWhen a push button is pressed, it generates an ActionEvent. Thus, JButton provides the",
    "JButton ( String msg ) \n\nThe msg parameter specifies the string that will be displayed inside the button. \nWhen a push button is pressed, it generates an ActionEvent. Thus, JButton provides the \n\naddActionListener ( ) method, which is used to add an action listener. ( JButton also \nprovides removeActionListener ( ) to remove a listener, but this method is not used by \nthe program.) As explained in Chapter 24, the ActionListener interface defines only one \nmethod: actionPerformed ( ) . It is shown again here for your convenience: \n\nvoid actionPerformed ( ActionEvent ae ) \n\n\nThis method is called when a button is pressed. In other words, it is the event \nhandler that is called when a button press event has occurred. \nNext, event listeners for the button\u2019s action events are added by the code shown here:",
    "Here, anonymous inner classes are used to provide the event handlers for the two buttons. \nEach time a button is pressed, the string displayed in jlab is changed to reflect which \nbutton was pressed. \nBeginning with JDK 8, lambda expressions can also be used to implement event handlers. \nFor example, the event handler for the Alpha button could be written like this: \n\nAs you can see, this code is shorter. For the benefit of readers using versions of Java prior to \nJDK 8, subsequent examples will not use lambda expressions, but you should consider using \nthem for new code that you create. \nNext, the buttons are added to the content pane of jfrm : \n\nFinally, jlab is added to the content pane and window is made visible. When you run the \nprogram, each time you press a button, a message is displayed in the label that indicates \nwhich button was pressed.",
    "One last point: Remember that all event handlers, such as actionPerformed ( ) , are called \non the event dispatching thread. Therefore, an event handler must return quickly in order to \navoid slowing down the application. If your application needs to do something time \nconsuming as the result of an event, it must use a separate thread. \n\nCreate a Swing Applet",
    "The second type of program that commonly uses Swing is the applet. Swing-based applets \nare similar to AWT-based applets, but with an important difference: A Swing applet extends \nJApplet rather than Applet . JApplet is derived from Applet . Thus, JApplet includes all \nof the functionality found in Applet and adds support for Swing. JApplet is a top-level \nSwing container, which means that it is not derived from JComponent . Because JApplet \nis a top-level container, it includes the various panes described earlier. This means that all \ncomponents are added to JApplet \u2019s content pane in the same way that components are \nadded to JFrame \u2019s content pane. \nSwing applets use the same four life-cycle methods as described in Chapter 23: init ( ) , \nstart ( ) , stop ( ) , and destroy ( ) . Of course, you need override only those methods that \nare needed by your applet",
    ". Of course, you need override only those methods that \nare needed by your applet. Painting is accomplished differently in Swing than it is in the \nAWT, and a Swing applet will not normally override the paint ( ) method. ( Painting in \nSwing is described later in this chapter.)",
    "Figure 31-3    Output from the example Swing applet \n\nOne other point: All interaction with components in a Swing applet must take place on the \nevent dispatching thread, as described in the previous section. This threading issue applies \nto all Swing programs. \nHere is an example of a Swing applet. It provides the same functionality as the previous \napplication, but does so in applet form. Figure 31-3 shows the program when executed by \nappletviewer . \n\n\n\n\nThere are two important things to notice about this applet. First, MySwingApplet extends \nJApplet. As explained, all Swing-based applets extend JApplet rather than Applet . \nSecond, the init ( ) method initializes the Swing components on the event dispatching \nthread by setting up a call to makeGUI ( ) . Notice that this is accomplished through the use",
    "of invokeAndWait ( ) rather than invokeLater ( ) . Applets must use invokeAndWait ( ) \nbecause the init ( ) method must not return until the entire initialization process has been \ncompleted. In essence, the start ( ) method cannot be called until after initialization, which \nmeans that the GUI must be fully constructed. \n\n\nInside makeGUI ( ) , the two buttons and label are created, and the action listeners are \nadded to the buttons. Finally, the components are added to the content pane. Although this \nexample is quite simple, this same general approach must be used when building any Swing \nGUI that will be used by an applet. \n\nPainting in Swing",
    "Painting in Swing \n\nAlthough the Swing component set is quite powerful, you are not limited to using it because \nSwing also lets you write directly into the display area of a frame, panel, or one of Swing\u2019s \nother components, such as JLabel. Although many ( perhaps most ) uses of Swing will not \ninvolve drawing directly to the surface of a component, it is available for those applications \nthat need this capability. To write output directly to the surface of a component, you will use \none or more drawing methods defined by the AWT, such as drawLine ( ) or drawRect ( ) . \nThus, most of the techniques and methods described in Chapter 25 also apply to Swing. \nHowever, there are also some very important differences, and the process is discussed in \ndetail in this section. \n\nPainting Fundamentals",
    "Swing\u2019s approach to painting is built on the original AWT-based mechanism, but Swing\u2019s \nimplementation offers more finally grained control. Before examining the specifics of Swingbased painting, it is useful to review the AWT-based mechanism that underlies it. \nThe AWT class Component defines a method called paint ( ) that is used to draw output \ndirectly to the surface of a component. For the most part, paint ( ) is not called by your \nprogram. ( In fact, only in the most unusual cases should it ever be called by your program.) \nRather, paint ( ) is called by the run-time system whenever a component must be rendered. \nThis situation can occur for several reasons. For example, the window in which the \ncomponent is displayed can be overwritten by another window and then uncovered. Or, the \nwindow might be minimized and then restored. The paint ( ) method is also called when a \nprogram begins running",
    ". Or, the \nwindow might be minimized and then restored. The paint ( ) method is also called when a \nprogram begins running. When writing AWT-based code, an application will override \npaint ( ) when it needs to write output directly to the surface of the component. \nBecause JComponent inherits Component , all Swing\u2019s lightweight components inherit \nthe paint ( ) method. However, you will not override it to paint directly to the surface of a \ncomponent. The reason is that Swing uses a bit more sophisticated approach to painting \nthat involves three distinct methods: paintComponent ( ) , paintBorder ( ) , and \npaintChildren ( ) . These methods paint the indicated portion of a component and divide \nthe painting process into its three distinct, logical actions. In a lightweight component, the \noriginal AWT method paint ( ) simply executes calls to these methods, in the order just",
    "shown. \nTo paint to the surface of a Swing component, you will create a subclass of the component \nand then override its paintComponent ( ) method. This is the method that paints the \ninterior of the component. You will not normally override the other two painting methods. \nWhen overriding paintComponent ( ) , the first thing you must do is call \n\n\nsuper.paintComponent ( ) , so that the superclass portion of the painting process takes \nplace. ( The only time this is not required is when you are taking complete, manual control \nover how a component is displayed.) After that, write the output that you want to display. \nThe paintComponent ( ) method is shown here: \n\nprotected void paintComponent ( Graphics g )",
    "protected void paintComponent ( Graphics g ) \n\nThe parameter g is the graphics context to which output is written. \nTo cause a component to be painted under program control, call repaint ( ) . It works in \nSwing just as it does for the AWT. The repaint ( ) method is defined by Component . \nCalling it causes the system to call paint ( ) as soon as it is possible to do so. Because \npainting is a time-consuming operation, this mechanism allows the run-time system to \ndefer painting momentarily until some higher-priority task has completed, for example. Of \ncourse, in Swing the call to paint ( ) results in a call to paintComponent ( ) . Therefore, to \noutput to the surface of a component, your program will store the output until \npaintComponent ( ) is called. Inside the overridden paintComponent ( ) , you will draw \nthe stored output. \n\nCompute the Paintable Area",
    "Compute the Paintable Area \n\nWhen drawing to the surface of a component, you must be careful to restrict your output to \nthe area that is inside the border. Although Swing automatically clips any output that will \nexceed the boundaries of a component, it is still possible to paint into the border, which will \nthen get overwritten when the border is drawn. To avoid this, you must compute the \npaintable area of the component. This is the area defined by the current size of the \ncomponent minus the space used by the border. Therefore, before you paint to a \ncomponent, you must obtain the width of the border and then adjust your drawing \naccordingly. \nTo obtain the border width, call getInsets ( ) , shown here: \n\nInsets getInsets ( ) \n\nThis method is defined by Container and overridden by JComponent . It returns \nan Insets object that contains the dimensions of the border. The inset values can \nbe obtained by using these fields: \n\nint top ; \n\nint bottom ; \n\nint left ; \n\nint right ;",
    "int top ; \n\nint bottom ; \n\nint left ; \n\nint right ; \n\nThese values are then used to compute the drawing area given the width and the \nheight of the component. You can obtain the width and height of the component by \n\ncalling getWidth ( ) and getHeight ( ) on the component. They are shown here: \n\n\nint getWidth ( ) \n\nint getHeight ( ) \n\nBy subtracting the value of the insets, you can compute the usable width and \nheight of the component. \n\nA Paint Example \n\nHere is a program that puts into action the preceding discussion. It creates a class called \nPaintPanel that extends JPanel. The program then uses an object of that class to display \nlines whose endpoints have been generated randomly. Sample output is shown in Figure 314. \n\nFigure 31-4    Sample output from the PaintPanel program",
    "Figure 31-4    Sample output from the PaintPanel program \n\n\n\n\nLet\u2019s examine this program closely. The PaintPanel class extends JPanel . JPanel is one \nof Swing\u2019s lightweight containers, which means that it is a component that can be added to \nthe content pane of a JFrame . To handle painting, PaintPanel overrides the \npaintComponent ( ) method. This enables PaintPanel to write directly to the surface of \nthe component when painting takes place. The size of the panel is not specified because the \nprogram uses the default border layout and the panel is added to the center. This results in \n\n\nthe panel being sized to fill the center. If you change the size of the window, the size of the \npanel will be adjusted accordingly. \nNotice that the constructor also specifies a 5-pixel wide, red border. This is accomplished by \nsetting the border by using the setBorder ( ) method, shown here: \n\nvoid setBorder ( Border border )",
    "void setBorder ( Border border ) \n\nBorder is the Swing interface that encapsulates a border. You can obtain a border \nby calling one of the factory methods defined by the BorderFactory class. The \none used in the program is createLineBorder ( ) , which creates a simple line \nborder. It is shown here: \n\nstatic Border createLineBorder ( Color clr , int width )",
    "Here, clr specifies the color of the border and width specifies its width in pixels. \nInside the override of paintComponent ( ) , notice that it first calls \nsuper.paintComponent ( ) . As explained, this is necessary to ensure that the component \nis properly drawn. Next, the width and height of the panel are obtained along with the \ninsets. These values are used to ensure the lines lie within the drawing area of the panel. \nThe drawing area is the overall width and height of a component less the border width. The \ncomputations are designed to work with differently sized PaintPanel s and borders. To \nprove this, try changing the size of the window. The lines will still all lie within the borders \nof the panel. \nThe PaintDemo class creates a PaintPanel and then adds the panel to the content pane. \nWhen the application is first displayed, the overridden paintComponent ( ) method is \ncalled, and the lines are drawn",
    ". \nWhen the application is first displayed, the overridden paintComponent ( ) method is \ncalled, and the lines are drawn. Each time you resize or hide and restore the window, a new \nset of lines are drawn. In all cases, the lines fall within the paintable area.",
    "\uf709 \nPREV \nPart III: Introducing GUI Programming with Swing \n\u23ee \n\nNEXT \nChapter 32: Exploring Swing \u23ed \n\n\nPREV \nChapter 31: Introducing Swing \n\u23ee \n\nNEXT \nChapter 33: Introducing Swing Menus \u23ed \n\nCHAPTER \n\n32 \nExploring Swing \n\nThe previous chapter described several of the core concepts relating to Swing and showed \nthe general form of both a Swing application and a Swing applet. This chapter continues the \ndiscussion of Swing by presenting an overview of several Swing components, such as \nbuttons, check boxes, trees, and tables. The Swing components provide rich functionality \nand allow a high level of customization. Because of space limitations, it is not possible to \ndescribe all of their features and attributes. Rather, the purpose of this overview is to give \nyou a feel for the capabilities of the Swing component set. \nThe Swing component classes described in this chapter are shown here: \n\nThese components are all lightweight, which means that they are all derived from",
    "These components are all lightweight, which means that they are all derived from \n\nJComponent . \nAlso discussed is the ButtonGroup class, which encapsulates a mutually exclusive set of \nSwing buttons, and ImageIcon , which encapsulates a graphics image. Both are defined by \nSwing and packaged in javax.swing . \nOne other point: The Swing components are demonstrated in applets because the code for \nan applet is more compact than it is for a desktop application. However, the same \ntechniques apply to both applets and applications. \n\nJLabel and ImageIcon \n\nJLabel is Swing\u2019s easiest-to-use component. It creates a label and was introduced in the \npreceding chapter. Here, we will look at JLabel a bit more closely. JLabel can be used to \ndisplay text and/or an icon. It is a passive component in that it does not respond to user \ninput. JLabel defines several constructors. Here are three of them: \n\nJLabel ( Icon icon ) \n\nJLabel ( String str )",
    "JLabel ( Icon icon ) \n\nJLabel ( String str ) \n\n\nJLabel ( String str , Icon icon , int align )",
    "JLabel ( String str ) \n\n\nJLabel ( String str , Icon icon , int align ) \n\nHere, str and icon are the text and icon used for the label. The align argument \nspecifies the horizontal alignment of the text and/or icon within the dimensions of \nthe label. It must be one of the following values: LEFT , RIGHT, CENTER , \nLEADING , or TRAILING . These constants are defined in the SwingConstants \ninterface, along with several others used by the Swing classes. \nNotice that icons are specified by objects of type Icon , which is an interface defined by \nSwing. The easiest way to obtain an icon is to use the ImageIcon class. ImageIcon \nimplements Icon and encapsulates an image. Thus, an object of type ImageIcon can be \npassed as an argument to the Icon parameter of JLabel \u2019s constructor. There are several \nways to provide the image, including reading it from a file or downloading it from a URL. \nHere is the ImageIcon constructor used by the example in this section:",
    "ImageIcon ( String filename ) \n\nIt obtains the image in the file named filename . \nThe icon and text associated with the label can be obtained by the following methods: \n\nIcon getIcon ( ) \nString getText ( ) \n\nThe icon and text associated with a label can be set by these methods: \n\nvoid setIcon ( Icon icon ) \nvoid setText ( String str ) \n\nHere, icon and str are the icon and text, respectively. Therefore, using setText ( ) \nit is possible to change the text inside a label during program execution. \nThe following applet illustrates how to create and display a label containing both an icon \nand a string. It begins by creating an ImageIcon object for the file hourglass.png , which \ndepicts an hourglass. This is used as the second argument to the JLabel constructor. The \nfirst and last arguments for the JLabel constructor are the label text and the alignment. \nFinally, the label is added to the content pane. \n\n\nOutput from the label example is shown here:",
    "Output from the label example is shown here: \n\n\nJTextField \n\nJTextField is the simplest Swing text component. It is also probably its most widely used \ntext component. JTextField allows you to edit one line of text. It is derived from \nJTextComponent , which provides the basic functionality common to Swing text \ncomponents. JTextField uses the Document interface for its model. Three of \nJTextField \u2019s constructors are shown here: \n\nJTextField ( int cols ) \nJTextField ( String str , int cols ) \nJTextField ( String str ) \n\nHere, str is the string to be initially presented, and cols is the number of columns \nin the text field. If no string is specified, the text field is initially empty. If the \nnumber of columns is not specified, the text field is sized to fit the specified string. \nJTextField generates events in response to user interaction. For example, an \nActionEvent is fired when the user presses ENTER . A CaretEvent is fired each time the",
    "caret ( i.e., the cursor ) changes position. ( CaretEvent is packaged in javax.swing.event .) \nOther events are also possible. In many cases, your program will not need to handle these \nevents. Instead, you will simply obtain the string currently in the text field when it is \nneeded. To obtain the text currently in the text field, call getText ( ) . \nThe following example illustrates JTextField . It creates a JTextField and adds it to the \ncontent pane. When the user presses ENTER , an action event is generated. This is handled by \n\ndisplaying the text in the status window. \n\n\nOutput from the text field example is shown here: \n\n\nThe Swing Buttons",
    "displaying the text in the status window. \n\n\nOutput from the text field example is shown here: \n\n\nThe Swing Buttons \n\nSwing defines four types of buttons: JButton , JToggleButton , JCheckBox , and \nJRadioButton . All are subclasses of the AbstractButton class, which extends \nJComponent . Thus, all buttons share a set of common traits. \nAbstractButton contains many methods that allow you to control the behavior of buttons. \nFor example, you can define different icons that are displayed for the button when it is \ndisabled, pressed, or selected. Another icon can be used as a rollover icon, which is \ndisplayed when the mouse is positioned over a button. The following methods set these \nicons: \n\nvoid setDisabledIcon ( Icon di ) \nvoid setPressedIcon ( Icon pi ) \nvoid setSelectedIcon ( Icon si ) \nvoid setRolloverIcon ( Icon ri )",
    "void setDisabledIcon ( Icon di ) \nvoid setPressedIcon ( Icon pi ) \nvoid setSelectedIcon ( Icon si ) \nvoid setRolloverIcon ( Icon ri ) \n\nHere, di, pi, si , and ri are the icons to be used for the indicated purpose. \nThe text associated with a button can be read and written via the following methods: \n\nString getText ( ) \nvoid setText ( String str ) \n\nHere, str is the text to be associated with the button. \n\nThe model used by all buttons is defined by the ButtonModel interface. A button \ngenerates an action event when it is pressed. Other events are possible. Each of the concrete \nbutton classes is examined next. \n\nJButton \n\nThe JButton class provides the functionality of a push button. You have already seen a \nsimple form of it in the preceding chapter. JButton allows an icon, a string, or both to be \nassociated with the push button. Three of its constructors are shown here: \n\nJButton ( Icon icon ) \nJButton ( String str ) \n\nJButton ( String str , Icon icon )",
    "JButton ( Icon icon ) \nJButton ( String str ) \n\nJButton ( String str , Icon icon ) \n\nHere, str and icon are the string and icon used for the button. \nWhen the button is pressed, an ActionEvent is generated. Using the ActionEvent object \npassed to the actionPerformed ( ) method of the registered ActionListener , you can \n\n\nobtain the action command string associated with the button. By default, this is the string \ndisplayed inside the button. However, you can set the action command by calling \nsetActionCommand ( ) on the button. You can obtain the action command by calling \ngetActionCommand ( ) on the event object. It is declared like this: \n\nString getActionCommand ( )",
    "String getActionCommand ( ) \n\nThe action command identifies the button. Thus, when using two or more buttons \nwithin the same application, the action command gives you an easy way to \ndetermine which button was pressed. \nIn the preceding chapter, you saw an example of a text-based button. The following \ndemonstrates an icon-based button. It displays four push buttons and a label. Each button \ndisplays an icon that represents a timepiece. When a button is pressed, the name of that \ntimepiece is displayed in the label. \n\n\n\n\nOutput from the button example is shown here: \n\nJToggleButton \n\nA useful variation on the push button is called a toggle button . A toggle button looks just \nlike a push button, but it acts differently because it has two states: pushed and released.",
    "A useful variation on the push button is called a toggle button . A toggle button looks just \nlike a push button, but it acts differently because it has two states: pushed and released. \n\nThat is, when you press a toggle button, it stays pressed rather than popping back up as a \nregular push button does. When you press the toggle button a second time, it releases ( pops \nup ). Therefore, each time a toggle button is pushed, it toggles between its two states. \nToggle buttons are objects of the JToggleButton class. JToggleButton implements \nAbstractButton . In addition to creating standard toggle buttons, JToggleButton is a \nsuperclass for two other Swing components that also represent two-state controls. These are \n\nJCheckBox and JRadioButton , which are described later in this chapter. Thus, \n\n\nJToggleButton defines the basic functionality of all two-state components. \nJToggleButton defines several constructors. The one used by the example in this section is \nshown here:",
    "JToggleButton defines the basic functionality of all two-state components. \nJToggleButton defines several constructors. The one used by the example in this section is \nshown here: \n\nJToggleButton ( String str )",
    "This creates a toggle button that contains the text passed in str . By default, the \nbutton is in the off position. Other constructors enable you to create toggle buttons \nthat contain images, or images and text. \nJToggleButton uses a model defined by a nested class called JToggleButton.ToggleButtonModel . Normally, you won\u2019t need to interact directly with the model to use a \nstandard toggle button. \nLike JButton , JToggleButton generates an action event each time it is pressed. Unlike \nJButton , however, JToggleButton also generates an item event. This event is used by \nthose components that support the concept of selection. When a JToggleButton is pressed \nin, it is selected. When it is popped out, it is deselected. \nTo handle item events, you must implement the ItemListener interface. Recall from \nChapter 24, that each time an item event is generated, it is passed to the \nitemStateChanged ( ) method defined by ItemListener",
    ". Recall from \nChapter 24, that each time an item event is generated, it is passed to the \nitemStateChanged ( ) method defined by ItemListener . Inside itemStateChanged ( ) , \nthe getItem ( ) method can be called on the ItemEvent object to obtain a reference to the \nJToggleButton instance that generated the event. It is shown here:",
    "Object getItem ( ) \n\nA reference to the button is returned. You will need to cast this reference to \nJToggleButton . \nThe easiest way to determine a toggle button\u2019s state is by calling the isSelected ( ) method \n( inherited from AbstractButton ) on the button that generated the event. It is shown here: \n\nboolean isSelected ( ) \n\nIt returns true if the button is selected and false otherwise. \nHere is an example that uses a toggle button. Notice how the item listener works. It simply \ncalls isSelected ( ) to determine the button\u2019s state. \n\n\n\n\nThe output from the toggle button example is shown here: \n\nCheck Boxes \n\nThe JCheckBox class provides the functionality of a check box. Its immediate superclass is \nJToggleButton , which provides support for two-state buttons, as just described. \n\nJCheckBox defines several constructors. The one used here is \n\n\nJCheckBox ( String str )",
    "It creates a check box that has the text specified by str as a label. Other \nconstructors let you specify the initial selection state of the button and specify an \nicon. \nWhen the user selects or deselects a check box, an ItemEvent is generated. You can obtain \na reference to the JCheckBox that generated the event by calling getItem ( ) on the \nItemEvent passed to the itemStateChanged ( ) method defined by ItemListener . The \neasiest way to determine the selected state of a check box is to call isSelected ( ) on the \nJCheckBox instance. \nThe following example illustrates check boxes. It displays four check boxes and a label. \nWhen the user clicks a check box, an ItemEvent is generated. Inside the \nitemStateChanged ( ) method, getItem ( ) is called to obtain a reference to the \nJCheckBox object that generated the event. Next, a call to isSelected ( ) determines if the \nbox was selected or cleared",
    ". Next, a call to isSelected ( ) determines if the \nbox was selected or cleared. The getText ( ) method gets the text for that check box and \nuses it to set the text inside the label.",
    "Output from this example is shown here: \n\nRadio Buttons \n\nRadio buttons are a group of mutually exclusive buttons, in which only one button can be \n\nselected at any one time. They are supported by the JRadioButton class, which extends \nJToggleButton . JRadioButton provides several constructors. The one used in the \nexample is shown here: \n\nJRadioButton ( String str ) \n\nHere, str is the label for the button. Other constructors let you specify the initial \nselection state of the button and specify an icon. \nIn order for their mutually exclusive nature to be activated, radio buttons must be \nconfigured into a group. Only one of the buttons in the group can be selected at any time. \nFor example, if a user presses a radio button that is in a group, any previously selected \nbutton in that group is automatically deselected. A button group is created by the",
    "ButtonGroup class. Its default constructor is invoked for this purpose. Elements are then \nadded to the button group via the following method: \n\nvoid add ( AbstractButton ab )",
    "Here, ab is a reference to the button to be added to the group. \nA JRadioButton generates action events, item events, and change events each time the \nbutton selection changes. Most often, it is the action event that is handled, which means \nthat you will normally implement the ActionListener interface. Recall that the only \nmethod defined by ActionListener is actionPerformed ( ) . Inside this method, you can \nuse a number of different ways to determine which button was selected. First, you can check \nits action command by calling getActionCommand ( ) . By default, the action command is \nthe same as the button label, but you can set the action command to something else by \ncalling setActionCommand ( ) on the radio button. Second, you can call getSource ( ) on \nthe ActionEvent object and check that reference against the buttons. Third, you can check \neach radio button to find out which one is currently selected by calling isSelected ( ) on \neach button",
    ". Third, you can check \neach radio button to find out which one is currently selected by calling isSelected ( ) on \neach button. Finally, each button could use its own action event handler implemented as \neither an anonymous inner class or a lambda expression. Remember, each time an action \nevent occurs, it means that the button being selected has changed and that one and only one \nbutton will be selected. \nThe following example illustrates how to use radio buttons. Three radio buttons are created. \nThe buttons are then added to a button group. As explained, this is necessary to cause their \nmutually exclusive behavior. Pressing a radio button generates an action event, which is \nhandled by actionPerformed ( ) . Within that handler, the getActionCommand ( ) \nmethod gets the text that is associated with the radio button and uses it to set the text \nwithin a label.",
    "Output from the radio button example is shown here: \n\nJTabbedPane \n\nJTabbedPane encapsulates a tabbed pane . It manages a set of components by linking \n\nthem with tabs. Selecting a tab causes the component associated with that tab to come to \nthe forefront. Tabbed panes are very common in the modern GUI, and you have no doubt \nused them many times. Given the complex nature of a tabbed pane, they are surprisingly \n\neasy to create and use. \nJTabbedPane defines three constructors. We will use its default constructor, which creates \nan empty control with the tabs positioned across the top of the pane. The other two \nconstructors let you specify the location of the tabs, which can be along any of the four sides. \nJTabbedPane uses the SingleSelectionModel model. \nTabs are added by calling addTab ( ) . Here is one of its forms: \n\n\nvoid addTab ( String name , Component comp )",
    "void addTab ( String name , Component comp ) \n\nHere, name is the name for the tab, and comp is the component that should be \nadded to the tab. Often, the component added to a tab is a JPanel that contains a \ngroup of related components. This technique allows a tab to hold a set of \ncomponents. \nThe general procedure to use a tabbed pane is outlined here: \n\n1.  Create an instance of JTabbedPane . \n\n2.  Add each tab by calling addTab ( ) . \n\n3.  Add the tabbed pane to the content pane. \n\nThe following example illustrates a tabbed pane. The first tab is titled \"Cities\" and \ncontains four buttons. Each button displays the name of a city. The second tab is \ntitled \"Colors\" and contains three check boxes. Each check box displays the name \nof a color. The third tab is titled \"Flavors\" and contains one combo box. This \nenables the user to select one of three flavors. \n\n\n\n\nOutput from the tabbed pane example is shown in the following three illustrations:",
    "Output from the tabbed pane example is shown in the following three illustrations: \n\nJScrollPane",
    "JScrollPane is a lightweight container that automatically handles the scrolling of another \ncomponent. The component being scrolled can be either an individual component, such as a \ntable, or a group of components contained within another lightweight container, such as a \nJPanel . In either case, if the object being scrolled is larger than the viewable area, \nhorizontal and/or vertical scroll bars are automatically provided, and the component can be \nscrolled through the pane. Because JScrollPane automates scrolling, it usually eliminates \nthe need to manage individual scroll bars. \nThe viewable area of a scroll pane is called the viewport . It is a window in which the \ncomponent being scrolled is displayed. Thus, the viewport displays the visible portion of the \ncomponent being scrolled. The scroll bars scroll the component through the viewport. In its \ndefault behavior, a JScrollPane will dynamically add or remove a scroll bar as needed",
    ". The scroll bars scroll the component through the viewport. In its \ndefault behavior, a JScrollPane will dynamically add or remove a scroll bar as needed. For \nexample, if the component is taller than the viewport, a vertical scroll bar is added. If the \ncomponent will completely fit within the viewport, the scroll bars are removed. \nJScrollPane defines several constructors. The one used in this chapter is shown here:",
    "JScrollPane ( Component comp ) \n\nThe component to be scrolled is specified by comp . Scroll bars are automatically \ndisplayed when the content of the pane exceeds the dimensions of the viewport. \nHere are the steps to follow to use a scroll pane: \n\n1.  Create the component to be scrolled. \n\n2.  Create an instance of JScrollPane , passing to it the object to scroll. \n\n3.  Add the scroll pane to the content pane. \n\nThe following example illustrates a scroll pane. First, a JPanel object is created, \nand 400 buttons are added to it, arranged into 20 columns. This panel is then \nadded to a scroll pane, and the scroll pane is added to the content pane. Because \nthe panel is larger than the viewport, vertical and horizontal scroll bars appear \nautomatically. You can use the scroll bars to scroll the buttons into view. \n\n\nOutput from the scroll pane example is shown here: \n\n\nJList",
    "Output from the scroll pane example is shown here: \n\n\nJList \n\nIn Swing, the basic list class is called JList . It supports the selection of one or more items \nfrom a list. Although the list often consists of strings, it is possible to create a list of just \nabout any object that can be displayed. JList is so widely used in Java that it is highly \nunlikely that you have not seen one before. \nIn the past, the items in a JList were represented as Object references. However, beginning \nwith JDK 7, JList was made generic and is now declared like this: \n\nclass JList<E> \n\nHere, E represents the type of the items in the list. \nJList provides several constructors. The one used here is \n\nJList ( E[ ] items )",
    "class JList<E> \n\nHere, E represents the type of the items in the list. \nJList provides several constructors. The one used here is \n\nJList ( E[ ] items ) \n\nThis creates a JList that contains the items in the array specified by items . \nJList is based on two models. The first is ListModel . This interface defines how access to \nthe list data is achieved. The second model is the ListSelectionModel interface, which \ndefines methods that determine what list item or items are selected. \nAlthough a JList will work properly by itself, most of the time you will wrap a JList inside \na JScrollPane . This way, long lists will automatically be scrollable, which simplifies GUI \ndesign. It also makes it easy to change the number of entries in a list without having to",
    "change the size of the JList component. \nA JList generates a ListSelectionEvent when the user makes or changes a selection. This \nevent is also generated when the user deselects an item. It is handled by implementing \nListSelectionListener . This listener specifies only one method, called valueChanged ( ) , \nwhich is shown here: \n\nvoid valueChanged ( ListSelectionEvent le ) \n\n\nHere, le is a reference to the event. Although ListSelectionEvent does provide \n\nsome methods of its own, normally you will interrogate the JList object itself to \ndetermine what has occurred. Both ListSelectionEvent and \nListSelectionListener are packaged in javax.swing.event . \nBy default, a JList allows the user to select multiple ranges of items within the list, but you \ncan change this behavior by calling setSelectionMode ( ) , which is defined by JList . It is \nshown here: \n\nvoid setSelectionMode ( int mode )",
    "void setSelectionMode ( int mode ) \n\nHere, mode specifies the selection mode. It must be one of these values defined by \nListSelectionModel : \n\nSINGLE_SELECTION \n\nSINGLE_INTERVAL_SELECTION \n\nMULTIPLE_INTERVAL_SELECTION \n\nThe default, multiple-interval selection, lets the user select multiple ranges of items \nwithin a list. With single-interval selection, the user can select one range of items. \nWith single selection, the user can select only a single item. Of course, a single \nitem can be selected in the other two modes, too. It\u2019s just that they also allow a \nrange to be selected. \nYou can obtain the index of the first item selected, which will also be the index of the only \nselected item when using single-selection mode, by calling getSelectedIndex ( ) , shown \nhere: \n\nint getSelectedIndex ( )",
    "int getSelectedIndex ( ) \n\nIndexing begins at zero. So, if the first item is selected, this method will return 0. If \nno item is selected, \u20131 is returned. \nInstead of obtaining the index of a selection, you can obtain the value associated with the \nselection by calling getSelectedValue ( ) : \n\nE getSelectedValue ( ) \n\nIt returns a reference to the first selected value. If no value has been selected, it \nreturns null . \nThe following applet demonstrates a simple JList , which holds a list of cities. Each time a \ncity is selected in the list, a ListSelectionEvent is generated, which is handled by the \n\nvalueChanged ( ) method defined by ListSelectionListener . It responds by obtaining \nthe index of the selected item and displaying the name of the selected city in a label. \n\n\n\n\nOutput from the list example is shown here: \n\n\nJComboBox",
    "Output from the list example is shown here: \n\n\nJComboBox \n\nSwing provides a combo box ( a combination of a text field and a drop-down list ) through \nthe JComboBox class. A combo box normally displays one entry, but it will also display a \ndrop-down list that allows a user to select a different entry. You can also create a combo box \nthat lets the user enter a selection into the text field. \nIn the past, the items in a JComboBox were represented as Object references. However, \nbeginning with JDK 7, JComboBox was made generic and is now declared like this: \n\nclass JComboBox<E> \n\nHere, E represents the type of the items in the combo box. \nThe JComboBox constructor used by the example is shown here: \n\nJComboBox ( E[ ] items )",
    "class JComboBox<E> \n\nHere, E represents the type of the items in the combo box. \nThe JComboBox constructor used by the example is shown here: \n\nJComboBox ( E[ ] items ) \n\nHere, items is an array that initializes the combo box. Other constructors are \navailable. \nJComboBox uses the ComboBoxModel . Mutable combo boxes ( those whose entries can \nbe changed ) use the MutableComboBoxModel . \nIn addition to passing an array of items to be displayed in the drop-down list, items can be \ndynamically added to the list of choices via the addItem ( ) method, shown here: \n\nvoid addItem ( E obj ) \n\nHere, obj is the object to be added to the combo box. This method must be used \nonly with mutable combo boxes. \nJComboBox generates an action event when the user selects an item from the list. \nJComboBox also generates an item event when the state of selection changes, which \noccurs when an item is selected or deselected. Thus, changing a selection means that two",
    "item events will occur: one for the deselected item and another for the selected item. Often, \nit is sufficient to simply listen for action events, but both event types are available for your \n\nuse. \nOne way to obtain the item selected in the list is to call getSelectedItem ( ) on the combo \nbox. It is shown here: \n\nObject getSelectedItem ( ) \n\n\nYou will need to cast the returned value into the type of object stored in the list. \nThe following example demonstrates the combo box. The combo box contains entries for \n\"Hourglass\", \"Analog\", \"Digital\", and \"Stopwatch\". When a timepiece is selected, an iconbased label is updated to display it. You can see how little code is required to use this \npowerful component. \n\n\nOutput from the combo box example is shown here: \n\n\nTrees",
    "Output from the combo box example is shown here: \n\n\nTrees \n\nA tree is a component that presents a hierarchical view of data. The user has the ability to \nexpand or collapse individual subtrees in this display. Trees are implemented in Swing by \nthe JTree class. A sampling of its constructors is shown here: \n\nJTree ( Object obj [ ]) \nJTree ( Vector<?> v ) \nJTree ( TreeNode tn )",
    "JTree ( Object obj [ ]) \nJTree ( Vector<?> v ) \nJTree ( TreeNode tn ) \n\nIn the first form, the tree is constructed from the elements in the array obj . The \nsecond form constructs the tree from the elements of vector v . In the third form, \nthe tree whose root node is specified by tn specifies the tree. \nAlthough JTree is packaged in javax.swing , its support classes and interfaces are \npackaged in javax.swing.tree . This is because the number of classes and interfaces needed \nto support JTree is quite large. \nJTree relies on two models: TreeModel and TreeSelectionModel . A JTree generates a \nvariety of events, but three relate specifically to trees: TreeExpansionEvent , \nTreeSelectionEvent , and TreeModelEvent . TreeExpansionEvent events occur when \na node is expanded or collapsed. A TreeSelectionEvent is generated when the user selects \nor deselects a node within the tree. A TreeModelEvent is fired when the data or structure",
    "of the tree changes. The listeners for these events are TreeExpansionListener , \nTreeSelectionListener , and TreeModelListener , respectively. The tree event classes \nand listener interfaces are packaged in javax.swing.event . \nThe event handled by the sample program shown in this section is TreeSelectionEvent . \nTo listen for this event, implement TreeSelectionListener . It defines only one method, \ncalled valueChanged ( ) , which receives the TreeSelectionEvent object. You can obtain \n\n\nthe path to the selected object by calling getPath ( ) , shown here, on the event object: \n\nTreePath getPath ( )",
    "the path to the selected object by calling getPath ( ) , shown here, on the event object: \n\nTreePath getPath ( ) \n\nIt returns a TreePath object that describes the path to the changed node. The \nTreePath class encapsulates information about a path to a particular node in a \ntree. It provides several constructors and methods. In this book, only the \ntoString ( ) method is used. It returns a string that describes the path. \nThe TreeNode interface declares methods that obtain information about a tree node. For \nexample, it is possible to obtain a reference to the parent node or an enumeration of the \nchild nodes. The MutableTreeNode interface extends TreeNode . It declares methods \nthat can insert and remove child nodes or change the parent node. \nThe DefaultMutableTreeNode class implements the MutableTreeNode interface. It \nrepresents a node in a tree. One of its constructors is shown here: \n\nDefaultMutableTreeNode ( Object obj )",
    "DefaultMutableTreeNode ( Object obj ) \n\nHere, obj is the object to be enclosed in this tree node. The new tree node doesn\u2019t \nhave a parent or children. \nTo create a hierarchy of tree nodes, the add ( ) method of DefaultMutableTreeNode can \nbe used. Its signature is shown here: \n\nvoid add ( MutableTreeNode child ) \n\nHere, child is a mutable tree node that is to be added as a child to the current \nnode. \nJTree does not provide any scrolling capabilities of its own. Instead, a JTree is typically \nplaced within a JScrollPane . This way, a large tree can be scrolled through a smaller \nviewport. \nHere are the steps to follow to use a tree: \n\n1.  Create an instance of JTree . \n\n2.  Create a JScrollPane and specify the tree as the object to be scrolled. \n\n3.  Add the tree to the scroll pane. \n\n4.  Add the scroll pane to the content pane.",
    "1.  Create an instance of JTree . \n\n2.  Create a JScrollPane and specify the tree as the object to be scrolled. \n\n3.  Add the tree to the scroll pane. \n\n4.  Add the scroll pane to the content pane. \n\nThe following example illustrates how to create a tree and handle selections. The \nprogram creates a DefaultMutableTreeNode instance labeled \"Options\". This is \nthe top node of the tree hierarchy. Additional tree nodes are then created, and the \nadd ( ) method is called to connect these nodes to the tree. A reference to the top \nnode in the tree is provided as the argument to the JTree constructor. The tree is \nthen provided as the argument to the JScrollPane constructor. This scroll pane is \n\nthen added to the content pane. Next, a label is created and added to the content \npane. The tree selection is displayed in this label. To receive selection events from \nthe tree, a TreeSelectionListener is registered for the tree. Inside the",
    "valueChanged ( ) method, the path to the current selection is obtained and \ndisplayed. \n\n\n\n\nOutput from the tree example is shown here: \n\nThe string presented in the text field describes the path from the top tree node to the \nselected node. \n\nJTable",
    "JTable is a component that displays rows and columns of data. You can drag the cursor on \ncolumn boundaries to resize columns. You can also drag a column to a new position. \nDepending on its configuration, it is also possible to select a row, column, or cell within the \ntable, and to change the data within a cell. JTable is a sophisticated component that offers \nmany more options and features than can be discussed here. ( It is perhaps Swing\u2019s most \ncomplicated component.) However, in its default configuration, JTable still offers \nsubstantial functionality that is easy to use\u2014especially if you simply want to use the table to \npresent data in a tabular format. The brief overview presented here will give you a general \nunderstanding of this powerful component. \nLike JTree , JTable has many classes and interfaces associated with it. These are packaged \nin javax.swing.table . \nAt its core, JTable is conceptually simple",
    ". \nLike JTree , JTable has many classes and interfaces associated with it. These are packaged \nin javax.swing.table . \nAt its core, JTable is conceptually simple. It is a component that consists of one or more \ncolumns of information. At the top of each column is a heading. In addition to describing \nthe data in a column, the heading also provides the mechanism by which the user can \nchange the size of a column or change the location of a column within the table. JTable \ndoes not provide any scrolling capabilities of its own. Instead, you will normally wrap a \nJTable inside a JScrollPane . \nJTable supplies several constructors. The one used here is",
    "JTable ( Object data [ ][ ], Object colHeads [ ]) \n\nHere, data is a two-dimensional array of the information to be presented, and \ncolHeads is a one-dimensional array with the column headings. \n\nJTable relies on three models. The first is the table model, which is defined by the",
    "TableModel interface. This model defines those things related to displaying data in a twodimensional format. The second is the table column model, which is represented by \nTableColumnModel . JTable is defined in terms of columns, and it is \nTableColumnModel that specifies the characteristics of a column. These two models are \npackaged in javax.swing.table . The third model determines how items are selected, and it \nis specified by the ListSelectionModel , which was described when JList was discussed. \nA JTable can generate several different events. The two most fundamental to a table\u2019s \noperation are ListSelectionEvent and TableModelEvent . A ListSelectionEvent is \ngenerated when the user selects something in the table. By default, JTable allows you to \nselect one or more complete rows, but you can change this behavior to allow one or more \ncolumns, or one or more individual cells to be selected. A TableModelEvent is fired when \nthat table\u2019s data changes in some way",
    ". A TableModelEvent is fired when \nthat table\u2019s data changes in some way. Handling these events requires a bit more work than \nit does to handle the events generated by the previously described components and is \nbeyond the scope of this book. However, if you simply want to use JTable to display data \n( as the following example does ), then you don\u2019t need to handle any events. \nHere are the steps required to set up a simple JTable that can be used to display data:",
    "1.  Create an instance of JTable . \n\n2.  Create a JScrollPane object, specifying the table as the object to scroll. \n\n3.  Add the table to the scroll pane. \n\n4.  Add the scroll pane to the content pane. \n\nThe following example illustrates how to create and use a simple table. A onedimensional array of strings called colHeads is created for the column headings. \nA two-dimensional array of strings called data is created for the table cells. You \ncan see that each element in the array is an array of three strings. These arrays are \npassed to the JTable constructor. The table is added to a scroll pane, and then the \nscroll pane is added to the content pane. The table displays the data in the data \narray. The default table configuration also allows the contents of a cell to be edited. \nChanges affect the underlying array, which is data in this case. \n\n\nOutput from this example is shown here: \n\n\n\uf709 \nPREV \nChapter 31: Introducing Swing \n\u23ee",
    "Output from this example is shown here: \n\n\n\uf709 \nPREV \nChapter 31: Introducing Swing \n\u23ee \n\nNEXT \nChapter 33: Introducing Swing Menus \u23ed \n\n\nPREV \nChapter 32: Exploring Swing \n\u23ee \n\nNEXT \nPart IV: Introducing GUI Programming with Java\u2026 \u23ed \n\nCHAPTER \n\n33 \nIntroducing Swing Menus \n\nThis chapter introduces another fundamental aspect of the Swing GUI environment: the \nmenu. Menus form an integral part of many applications because they present the \nprogram\u2019s functionality to the user. Because of their importance, Swing provides extensive \nsupport for menus. They are an area in which Swing\u2019s power is readily apparent. \nThe Swing menu system supports several key elements, including \n\n\u2022  The menu bar, which is the main menu for an application. \n\n\u2022  The standard menu, which can contain either items to be selected or other \nmenus ( submenus ). \n\n\u2022  The popup menu, which is usually activated by right-clicking the mouse.",
    "\u2022  The standard menu, which can contain either items to be selected or other \nmenus ( submenus ). \n\n\u2022  The popup menu, which is usually activated by right-clicking the mouse. \n\n\u2022  The toolbar, which provides rapid access to program functionality, often \nparalleling menu items. \n\n\u2022  The action, which enables two or more different components to be \n\nmanaged by a single object. Actions are commonly used with menus and \ntoolbars. \n\nSwing menus also support accelerator keys, which enable menu items to be \nselected without having to activate the menu, and mnemonics, which allow a menu \nitem to be selected by the keyboard once the menu options are displayed. \n\nMenu Basics",
    "Menu Basics \n\nThe Swing menu system is supported by a group of related classes. The ones used in this \nchapter are shown in Table 33-1, and they represent the core of the menu system. Although \nthey may seem a bit confusing at first, Swing menus are quite easy to use. Swing allows a \nhigh degree of customization, if desired ; however, you will normally use the menu classes \nas-is because they support all of the most needed options. For example, you can easily add \nimages and keyboard shortcuts to a menu. \n\n\nTable 33-1    The Core Swing Menu Classes",
    "Here is a brief overview of how the classes fit together. To create the top-level menu for an \napplication, you first create a JMenuBar object. This class is, loosely speaking, a container \nfor menus. To the JMenuBar instance, you will add instances of JMenu . Each JMenu \nobject defines a menu. That is, each JMenu object contains one or more selectable items. \nThe items displayed by a JMenu are objects of JMenuItem . Thus, a JMenuItem defines \na selection that can be chosen by the user. \nAs an alternative or adjunct to menus that descend from the menu bar, you can also create \nstand-alone, popup menus. To create a popup menu, first create an object of type \nJPopupMenu . Then, add JMenuItem s to it. A popup menu is normally activated by \nclicking the right mouse button when the mouse is over a component for which a popup \nmenu has been defined. \nIn addition to \u201cstandard\u201d menu items, you can also include check boxes and radio buttons \nin a menu",
    ". \nIn addition to \u201cstandard\u201d menu items, you can also include check boxes and radio buttons \nin a menu. A check box menu item is created by JCheckBoxMenuItem . A radio button \nmenu item is created by JRadioButtonMenuItem . Both of these classes extend \nJMenuItem . They can be used in standard menus and popup menus. \nJToolBar creates a stand-alone component that is related to the menu. It is often used to \nprovide fast access to functionality contained within the menus of the application. For \nexample, a toolbar might provide fast access to the formatting commands supported by a \nword processor. \nJSeparator is a convenience class that creates a separator line in a menu. \nOne key point to understand about Swing menus is that each menu item extends \nAbstractButton . Recall that AbstractButton is also the superclass of all of Swing\u2019s \nbutton components, such as JButton . Thus, all menu items are, essentially, buttons",
    ". Recall that AbstractButton is also the superclass of all of Swing\u2019s \nbutton components, such as JButton . Thus, all menu items are, essentially, buttons. \nObviously, they won\u2019t actually look like buttons when used in a menu, but they will, in \nmany ways, act like buttons. For example, selecting a menu item generates an action event \nin the same way that pressing a button does. \nAnother key point is that JMenuItem is a superclass of JMenu . This allows the creation of",
    "submenus, which are, essentially, menus within menus. To create a submenu, you first \ncreate and populate a JMenu object and then add it to another JMenu object. You will see \nthis process in action in the following section.",
    "As mentioned in passing previously, when a menu item is selected, an action event is \ngenerated. The action command string associated with that action event will, by default, be \nthe name of the selection. Thus, you can determine which item was selected by examining \nthe action command. Of course, you can also use separate anonymous inner classes or \nlambda expressions to handle each menu item\u2019s action events. In this case, the menu \nselection is already known, and there is no need to examine the action command string to \ndetermine which item was selected. \nMenus can also generate other types of events. For example, each time that a menu is \nactivated, selected, or canceled, a MenuEvent is generated that can be listened for via a \nMenuListener . Other menu-related events include MenuKeyEvent , \nMenuDragMouseEvent , and PopupMenuEvent . In many cases, however, you need \nonly watch for action events, and in this chapter, we will use only action events.",
    "An Overview of JMenuBar, JMenu, and JMenuItem \n\nBefore you can create a menu, you need to know something about the three core menu \nclasses: JMenuBar , JMenu , and JMenuItem . These form the minimum set of classes \nneeded to construct a main menu for an application. JMenu and JMenuItem are also \nused by popup menus. Thus, these classes form the foundation of the menu system. \n\nJMenuBar \n\nAs mentioned, JMenuBar is essentially a container for menus. Like all components, it \ninherits JComponent ( which inherits Container and Component ). It has only one \nconstructor, which is the default constructor. Therefore, initially the menu bar will be \nempty, and you will need to populate it with menus prior to use. Each application has one \nand only one menu bar. \nJMenuBar defines several methods, but often you will only need to use one: add ( ) . The \nadd ( ) method adds a JMenu to the menu bar. It is shown here: \n\nJMenu add ( JMenu menu )",
    "JMenu add ( JMenu menu ) \n\nHere, menu is a JMenu instance that is added to the menu bar. A reference to the \nmenu is returned. Menus are positioned in the bar from left to right, in the order \nin which they are added. If you want to add a menu at a specific location, then use \nthis version of add ( ) , which is inherited from Container : \n\nComponent add ( Component menu , int idx ) \n\nHere, menu is added at the index specified by idx . Indexing begins at 0, with 0 \nbeing the left-most menu. \nIn some cases, you might want to remove a menu that is no longer needed. You can do this \nby calling remove ( ) , which is inherited from Container . It has these two forms: \n\nvoid remove ( Component menu ) \n\nvoid remove ( int idx ) \n\n\nHere, menu is a reference to the menu to remove, and idx is the index of the menu \nto remove. Indexing begins at zero. \nAnother method that is sometimes useful is getMenuCount ( ) , shown here: \n\nint getMenuCount ( )",
    "int getMenuCount ( ) \n\nIt returns the number of elements contained within the menu bar. \nJMenuBar defines some other methods that you might find helpful in specialized \napplications. For example, you can obtain an array of references to the menus in the bar by \ncalling getSubElements ( ) . You can determine if a menu is selected by calling \nisSelected ( ) . \nOnce a menu bar has been created and populated, it is added to a JFrame by calling \nsetJMenuBar ( ) on the JFrame instance. ( Menu bars are not added to the content \npane.) The setJMenuBar ( ) method is shown here: \n\nvoid setJMenuBar ( JMenuBar mb ) \n\nHere, mb is a reference to the menu bar. The menu bar will be displayed in a \nposition determined by the look and feel. Usually, this is at the top of the window. \n\nJMenu",
    "Here, mb is a reference to the menu bar. The menu bar will be displayed in a \nposition determined by the look and feel. Usually, this is at the top of the window. \n\nJMenu \n\nJMenu encapsulates a menu, which is populated with JMenuItem s. As mentioned, it is \nderived from JMenuItem . This means that one JMenu can be a selection in another \nJMenu . This enables one menu to be a submenu of another. JMenu defines a number of \nconstructors. For example, here is the one used in the examples in this chapter: \n\nJMenu ( String name ) \n\nThis constructor creates a menu that has the title specified by name . Of course, \n\nyou don\u2019t have to give a menu a name. To create an unnamed menu, you can use \nthe default constructor: \n\nJMenu ( )",
    "you don\u2019t have to give a menu a name. To create an unnamed menu, you can use \nthe default constructor: \n\nJMenu ( ) \n\nOther constructors are also supported. In each case, the menu is empty until menu \nitems are added to it. \nJMenu defines many methods. Here is a brief description of some commonly used ones. To \nadd an item to the menu, use the add ( ) method, which has a number of forms, including \nthe two shown here: \n\nJMenuItem add ( JMenuItem item ) \n\nJMenuItem add ( Component item , int idx ) \n\nHere, item is the menu item to add. The first form adds the item to the end of the \n\nmenu. The second form adds the item at the index specified by idx . As expected, \nindexing starts at zero. Both forms return a reference to the item added. As a point \nof interest, you can also use insert ( ) to add menu items to a menu. \n\n\nYou can add a separator ( an object of type JSeparator ) to a menu by calling \naddSeparator ( ) , shown here: \n\nvoid addSeparator ( )",
    "You can add a separator ( an object of type JSeparator ) to a menu by calling \naddSeparator ( ) , shown here: \n\nvoid addSeparator ( ) \n\nThe separator is added onto the end of the menu. You can insert a separator into a \nmenu by calling insertSeparator ( ) , shown next: \n\nvoid insertSeparator ( int idx ) \n\nHere, idx specifies the zero-based index at which the separator will be added. \nYou can remove an item from a menu by calling remove ( ) . Two of its forms are shown \nhere: \n\nvoid remove ( JMenuItem menu ) \n\nvoid remove ( int idx ) \n\nIn this case, menu is a reference to the item to remove and idx is the index of the \nitem to remove. \nYou can obtain the number of items in the menu by calling getMenuComponentCount ( \n) , shown here: \n\nint getMenuComponentCount ( ) \n\nYou can get an array of the items in the menu by calling getMenuComponents ( \n) , shown next: \n\nComponent[ ] getMenuComponents ( ) \n\nAn array containing the components is returned. \n\nJMenuItem",
    "You can get an array of the items in the menu by calling getMenuComponents ( \n) , shown next: \n\nComponent[ ] getMenuComponents ( ) \n\nAn array containing the components is returned. \n\nJMenuItem \n\nJMenuItem encapsulates an element in a menu. This element can be a selection linked to \nsome program action, such as Save or Close, or it can cause a submenu to be displayed. As \nmentioned, JMenuItem is derived from AbstractButton , and every item in a menu can \nbe thought of as a special kind of button. Therefore, when a menu item is selected, an action \nevent is generated. ( This is similar to the way a JButton fires an action event when it is \npressed.) JMenuItem defines many constructors. The ones used in this chapter are shown \nhere: \n\nJMenuItem ( String name ) \n\nJMenuItem ( Icon image ) \n\nJMenuItem ( String name , Icon image ) \n\nJMenuItem ( String name , int mnem ) \n\nJMenuItem ( Action action ) \n\nThe first constructor creates a menu item with the name specified by name . The",
    "JMenuItem ( String name , Icon image ) \n\nJMenuItem ( String name , int mnem ) \n\nJMenuItem ( Action action ) \n\nThe first constructor creates a menu item with the name specified by name . The \n\n\nsecond creates a menu item that displays the image specified by image . The third \ncreates a menu item with the name specified by name and the image specified by \nimage . The fourth creates a menu item with the name specified by name and uses \nthe keyboard mnemonic specified by mnem . This mnemonic enables you to select \nan item from the menu by pressing the specified key. The last constructor creates a \nmenu item using the information specified in action . A default constructor is also \nsupported. \nBecause menu items inherit AbstractButton , you have access to the functionality provided \nby AbstractButton . One such method that is often useful with menus is setEnabled ( ) , \nwhich you can use to enable or disable a menu item. It is shown here: \n\nvoid setEnabled ( boolean enable )",
    "void setEnabled ( boolean enable ) \n\nIf enable is true , the menu item is enabled. If enable is false , the item is disabled \nand cannot be selected. \n\nCreate a Main Menu",
    "Traditionally, the most commonly used menu is the main menu . This is the menu defined \nby the menu bar, and it is the menu that defines all ( or nearly all ) of the functionality of an \napplication. Fortunately, Swing makes creating and managing the main menu easy. This \nsection shows you how to construct a basic main menu. Subsequent sections will show you \nhow to add options to it. \nConstructing the main menu requires several steps. First, create the JMenuBar object that \nwill hold the menus. Next, construct each menu that will be in the menu bar. In general, a \nmenu is constructed by first creating a JMenu object and then adding JMenuItem s to it. \nAfter the menus have been created, add them to the menu bar. The menu bar, itself, must \nthen be added to the frame by calling setJMenuBar ( ) . Finally, for each menu item, you \nmust add an action listener that handles the action event fired when the menu item is \nselected",
    ". Finally, for each menu item, you \nmust add an action listener that handles the action event fired when the menu item is \nselected. \nA good way to understand the process of creating and managing menus is to work through \nan example. Here is a program that creates a simple menu bar that contains three menus. \nThe first is a standard File menu that contains Open, Close, Save, and Exit selections. The \nsecond menu is called Options, and it contains two submenus called Colors and Priority. The \nthird menu is called Help, and it has one item: About. When a menu item is selected, the \nname of the selection is displayed in a label in the content pane. Sample output is shown in",
    "Figure 33-1. \n\n\n\n\n\n\n\n\nFigure 33-1    Sample output from the MenuDemo program \n\nLet\u2019s examine, in detail, how the menus in this program are created, beginning with the \nMenuDemo constructor. It starts by creating a JFrame and setting its layout manager, \nsize, and default close operation. ( These operations are described in Chapter 31.) A JLabel \nis then constructed. It will be used to display a menu selection. Next, the menu bar is \nconstructed and a reference to it is assigned to jmb by this statement: \n\nThen, the File menu jmFile and its menu entries are created by this sequence: \n\nThe names Open, Close, Save, and Exit will be shown as selections in the menu. Next, the \nmenu entries are added to the file menu by this sequence: \n\nFinally, the File menu is added to the menu bar with this line:",
    "Finally, the File menu is added to the menu bar with this line: \n\nOnce the preceding code sequence completes, the menu bar will contain one entry: File. The \nFile menu will contain four selections in this order: Open, Close, Save, and Exit. However,",
    "notice that a separator has been added before Exit. This visually separates Exit from the \npreceding three selections. \nThe Options menu is constructed using the same basic process as the File menu. However, \nthe Options menu consists of two submenus, Colors and Priority, and a Reset entry. The \nsubmenus are first constructed individually and then added to the Options menu. The Reset \nitem is added last. Then, the Options menu is added to the menu bar. The Help menu is \nconstructed using the same process. \nNotice that MenuDemo implements the ActionListener interface and action events \ngenerated by a menu selection are handled by the actionPerformed ( ) method defined by \nMenuDemo . Therefore, the program adds this as the action listener for the menu items. \nNotice that no listeners are added to the Colors or Priority items because they are not \nactually selections. They simply activate submenus. \nFinally, the menu bar is added to the frame by the following line:",
    "As mentioned, menu bars are not added to the content pane. They are added directly to the \nJFrame . \nThe actionPerformed ( ) method handles the action events generated by the menu. It \nobtains the action command string associated with the selection by calling \ngetActionCommand ( ) on the event. It stores a reference to this string in comStr . Then, \nit tests the action command against \"Exit\", as shown here:",
    "If the action command is \"Exit\", then the program terminates by calling System.exit ( ) . \nThis method causes the immediate termination of a program and passes its argument as a \nstatus code to the calling process, which is usually the operating system or the browser. By \nconvention, a status code of zero means normal termination. Anything else indicates that \nthe program terminated abnormally. For all other menu selections, the choice is displayed. \nAt this point, you might want to experiment a bit with the MenuDemo program. Try \nadding another menu or adding additional items to an existing menu. It is important that \nyou understand the basic menu concepts before moving on because this program will evolve \nthroughout the course of this chapter. \n\nAdd Mnemonics and Accelerators to Menu Items",
    "Add Mnemonics and Accelerators to Menu Items \n\nThe menu created in the preceding example is functional, but it is possible to make it better. \nIn real applications, a menu usually includes support for keyboard shortcuts because they \ngive an experienced user the ability to select menu items rapidly. Keyboard shortcuts come \nin two forms: mnemonics and accelerators. As it applies to menus, a mnemonic defines a \nkey that lets you select an item from an active menu by typing the key. Thus, a mnemonic \n\n\nallows you to use the keyboard to select an item from a menu that is already being \n\ndisplayed. An accelerator is a key that lets you select a menu item without having to first \nactivate the menu. \nA mnemonic can be specified for both JMenuItem and JMenu objects. There are two \nways to set the mnemonic for JMenuItem . First, it can be specified when an object is \nconstructed using this constructor: \n\nJMenuItem ( String name , int mnem )",
    "JMenuItem ( String name , int mnem ) \n\nIn this case, the name is passed in name and the mnemonic is passed in mnen . \nSecond, you can set the mnemonic by calling setMnemonic ( ) . To specify a \nmnemonic for JMenu , you must call setMnemonic ( ) . This method is inherited \nby both classes from AbstractButton and is shown next: \n\nvoid setMnemonic ( int mnem )",
    "void setMnemonic ( int mnem ) \n\nHere, mnem specifies the mnemonic. It should be one of the constants defined in \njava.awt.event.KeyEvent , such as KeyEvent.VK_F or KeyEvent.VK_Z . \n( There is another version of setMnemonic ( ) that takes a char argument, but it \nis considered obsolete.) Mnemonics are not case sensitive, so in the case of VK_A , \ntyping either a or A will work. \nBy default, the first matching letter in the menu item will be underscored. In cases in which \nyou want to underscore a letter other than the first match, specify the index of the letter as \nan argument to setDisplayedMnemonicIndex ( ) , which is inherited by both JMenu \nand JMenuItem from AbstractButton . It is shown here: \n\nvoid setDisplayedMnemonicIndex ( int idx ) \n\nThe index of the letter to underscore is specified by idx . \n\nAn accelerator can be associated with a JMenuItem object. It is specified by calling \nsetAccelerator ( ) , shown next: \n\nvoid setAccelerator ( KeyStroke ks )",
    "An accelerator can be associated with a JMenuItem object. It is specified by calling \nsetAccelerator ( ) , shown next: \n\nvoid setAccelerator ( KeyStroke ks ) \n\nHere, ks is the key combination that is pressed to select the menu item. \nKeyStroke is a class that contains several factory methods that construct various \ntypes of keystroke accelerators. The following are three examples: \n\nstatic KeyStroke getKeyStroke ( char ch ) \n\nstatic KeyStroke getKeyStroke ( Character ch , int modifier ) \n\nstatic KeyStroke getKeyStroke ( int ch , int modifier ) \n\nHere, ch specifies the accelerator character. In the first version, the character is \nspecified as a char value. In the second, it is specified as an object of type \nCharacter . In the third, it is a value of type KeyEvent , previously described. The \nvalue of modifier must be one or more of the following constants, defined in the \n\n\njava.awt.event.InputEvent class: \n\nInputEvent.ALT_DOWN_MASK \nInputEvent.ALT_GRAPH_DOWN_MASK",
    "java.awt.event.InputEvent class: \n\nInputEvent.ALT_DOWN_MASK \nInputEvent.ALT_GRAPH_DOWN_MASK \n\nInputEvent.CTRL_DOWN_MASK \nInputEvent.META_DOWN_MASK \n\nInputEvent.SHIFT_DOWN_MASK \n\nTherefore, if you pass VK_A for the key character and \nInputEvent.CTRL_DOWN_MASK for the modifier, the accelerator key combination is \n\nCTRL-A . \n\nThe following sequence adds both mnemonics and accelerators to the File menu created by \nthe MenuDemo program in the previous section. After making this change, you can select \nthe File menu by typing ALT-F . Then, you can use the mnemonics O , C , S , or E to select an \n\noption. Alternatively, you can directly select a File menu option by pressing CTRL-O , CTRL-C , \n\nCTRL-S , or CTRL-E . Figure 33-2 shows how this menu looks when activated. \n\n\nFigure 33-2    The File menu after adding mnemonics and accelerators \n\nAdd Images and Tooltips to Menu Items",
    "CTRL-S , or CTRL-E . Figure 33-2 shows how this menu looks when activated. \n\n\nFigure 33-2    The File menu after adding mnemonics and accelerators \n\nAdd Images and Tooltips to Menu Items \n\nYou can add images to menu items or use images instead of text. The easiest way to add an \nimage is to specify it when the menu item is being constructed using one of these \nconstructors: \n\nJMenuItem ( Icon image ) \n\nJMenuItem ( String name , Icon image ) \n\nThe first creates a menu item that displays the image specified by image . The \nsecond creates a menu item with the name specified by name and the image \nspecified by image . For example, here the About menu item is associated with an \nimage when it is created. \n\nAfter this addition, the icon specified by icon will be displayed next to the text \n\"About\" when the Help menu is displayed. This is shown in Figure 33-3. You can",
    "After this addition, the icon specified by icon will be displayed next to the text \n\"About\" when the Help menu is displayed. This is shown in Figure 33-3. You can \n\nalso add an icon to a menu item after the item has been created by calling \nsetIcon ( ) , which is inherited from AbstractButton . You can specify the \nhorizontal alignment of the image relative to the text by calling \nsetHorizontalTextPosition ( ) . \n\n\nFigure 33-3    The About item with the addition of an icon",
    "Figure 33-3    The About item with the addition of an icon \n\nYou can specify a disabled icon, which is shown when the menu item is disabled, by calling \nsetDisabledIcon ( ) . Normally, when a menu item is disabled, the default icon is shown in \ngray. If a disabled icon is specified, then that icon is displayed when the menu item is \ndisabled. \nA tooltip is a small message that describes an item. It is automatically displayed if the \nmouse remains over the item for a moment. You can add a tooltip to a menu item by calling \nsetToolTipText ( ) on the item, specifying the text you want displayed. It is shown here: \n\nvoid setToolTipText ( String msg ) \n\nIn this case, msg is the string that will be displayed when the tooltip is activated. \nFor example, this creates a tooltip for the About item:",
    "void setToolTipText ( String msg ) \n\nIn this case, msg is the string that will be displayed when the tooltip is activated. \nFor example, this creates a tooltip for the About item: \n\nAs a point of interest, setToolTipText ( ) is inherited by JMenuItem from \nJComponent . This means you can add a tooltip to other types of components, such as a \npush button. You might want to try this on your own. \n\nUse JRadioButtonMenuItem and JCheckBoxMenuItem \n\nAlthough the type of menu items used by the preceding examples are, as a general rule, the \nmost commonly used, Swing defines two others: check boxes and radio buttons. These items \ncan streamline a GUI by allowing a menu to provide functionality that would otherwise \nrequire additional, stand-alone components. Also, sometimes, including check boxes or",
    "radio buttons in a menu simply seems the most natural place for a specific set of features. \nWhatever your reason, Swing makes it easy to use check boxes and radio buttons in menus, \nand both are examined here. \nTo add a check box to a menu, create a JCheckBoxMenuItem . It defines several \nconstructors. This is the one used in this chapter: \n\nJCheckBoxMenuItem ( String name ) \n\n\nHere, name specifies the name of the item. The initial state of the check box is \n\nunchecked. If you want to specify the initial state, you can use this constructor: \n\nJCheckBoxMenuItem ( String name , boolean state ) \n\nIn this case, if state is true , the box is initially checked. Otherwise, it is cleared. \nJCheckBoxMenuItem also provides constructors that let you specify an icon. \nHere is one example: \n\nJCheckBoxMenuItem ( String name , Icon icon )",
    "JCheckBoxMenuItem ( String name , Icon icon ) \n\nIn this case, name specifies the name of the item and the image associated with the \nitem is passed in icon . The item is initially unchecked. Other constructors are also \nsupported. \nCheck boxes in menus work like stand-alone check boxes. For example, they generate action \nevents and item events when their state changes. Check boxes are especially useful in menus \nwhen you have options that can be selected and you want to display their selected/ \ndeselected status. \nA radio button can be added to a menu by creating an object of type \nJRadioButtonMenuItem . JRadioButtonMenuItem inherits JMenuItem . It provides \na rich assortment of constructors. The ones used in this chapter are shown here: \n\nJRadioButtonMenuItem ( String name ) \n\nJRadioButtonMenuItem ( String name , boolean state )",
    "JRadioButtonMenuItem ( String name ) \n\nJRadioButtonMenuItem ( String name , boolean state ) \n\nThe first constructor creates an unselected radio button menu item that is \nassociated with the name passed in name . The second lets you specify the initial \nstate of the button. If state is true , the button is initially selected. Otherwise, it is \ndeselected. Other constructors let you specify an icon. Here is one example: \n\nJRadioButtonMenuItem ( String name , Icon icon , boolean state )",
    "JRadioButtonMenuItem ( String name , Icon icon , boolean state ) \n\nThis creates a radio button menu item that is associated with the name passed in \nname and the image passed in icon . If state is true , the button is initially selected. \nOtherwise, it is deselected. Several other constructors are supported. \nA JRadioButtonMenuItem works like a stand-alone radio button, generating item and \naction events. Like stand-alone radio buttons, menu-based radio buttons must be put into a \nbutton group in order for them to exhibit mutually exclusive selection behavior. \nBecause both JCheckBoxMenuItem and JRadioButtonMenuItem inherit",
    "JMenuItem , each has all of the functionality provided by JMenuItem . Aside from having \nthe extra capabilities of check boxes and radio buttons, they act like and are used like other \nmenu items. \nTo try check box and radio button menu items, first remove the code that creates the \nOptions menu in the MenuDemo example program. Then substitute the following code \nsequence, which uses check boxes for the Colors submenu and radio buttons for the Priority \n\n\nsubmenu. After making the substitution, the Options menu will look like those shown in \nFigure 33-4. \n\nFigure 33-4    The effects of check box ( a ) and radio button ( b ) \nmenu items \n\n\nCreate a Popup Menu",
    "Figure 33-4    The effects of check box ( a ) and radio button ( b ) \nmenu items \n\n\nCreate a Popup Menu \n\nA popular alternative or addition to the menu bar is the popup menu. Typically, a popup \nmenu is activated by clicking the right mouse button when over a component. Popup menus \nare supported in Swing by the JPopupMenu class. JPopupMenu has two constructors. \nIn this chapter, only the default constructor is used: \n\nJPopupMenu ( ) \n\n\nIt creates a default popup menu. The other constructor lets you specify a title for \nthe menu. Whether this title is displayed is subject to the look and feel. \nIn general, popup menus are constructed like regular menus. First, create a JPopupMenu \nobject, and then add menu items to it. Menu item selections are also handled in the same \nway: by listening for action events. The main difference between a popup menu and regular \nmenu is the activation process. \nActivating a popup menu requires three steps.",
    "1.  You must register a listener for mouse events. \n\n2.  Inside the mouse event handler, you must watch for the popup trigger. \n\n3.  When a popup trigger is received, you must show the popup menu by \ncalling show ( ) . \n\nLet\u2019s examine each of these steps closely. \nA popup menu is normally activated by clicking the right mouse button when the mouse \npointer is over a component for which a popup menu is defined. Thus, the popup trigger is \nusually caused by right-clicking the mouse on a popup menu\u2013enabled component. To listen \nfor the popup trigger, implement the MouseListener interface and then register the \nlistener by calling the addMouseListener ( ) method. As described in Chapter 24, \nMouseListener defines the methods shown here: \n\nvoid mouseClicked ( MouseEvent me ) \n\nvoid mouseEntered ( MouseEvent me ) \n\nvoid mouseExited ( MouseEvent me ) \n\nvoid mousePressed ( MouseEvent me ) \n\nvoid mouseReleased ( MouseEvent me )",
    "void mouseClicked ( MouseEvent me ) \n\nvoid mouseEntered ( MouseEvent me ) \n\nvoid mouseExited ( MouseEvent me ) \n\nvoid mousePressed ( MouseEvent me ) \n\nvoid mouseReleased ( MouseEvent me ) \n\nOf these, two are very important relative to the popup menu: mousePressed ( ) \nand mouseReleased ( ) . Depending on the installed look and feel, either of these \ntwo events can trigger a popup menu. For this reason, it is often easier to use a \nMouseAdapter to implement the MouseListener interface and simply override \nmousePressed ( ) and mouseReleased ( ) . \nThe MouseEvent class defines several methods, but only four are commonly needed when \nactivating a popup menu. They are shown here: \n\nint getX ( ) \n\nint getY ( ) \n\nboolean isPopupTrigger ( ) \n\nComponent getComponent ( )",
    "int getX ( ) \n\nint getY ( ) \n\nboolean isPopupTrigger ( ) \n\nComponent getComponent ( ) \n\n\nThe current X,Y location of the mouse relative to the source of the event is found \nby calling getX ( ) and getY ( ) . These are used to specify the upper-left corner of \nthe popup menu when it is displayed. The isPopupTrigger ( ) method returns \ntrue if the mouse event represents a popup trigger and false otherwise. You will \nuse this method to determine when to pop up the menu. To obtain a reference to \nthe component that generated the mouse event, call getComponent ( ) . \nTo actually display the popup menu, call the show ( ) method defined by JPopupMenu , \nshown next: \n\nvoid show ( Component invoker , int upperX , int upperY )",
    "void show ( Component invoker , int upperX , int upperY ) \n\nHere, invoker is the component relative to which the menu will be displayed. The \nvalues of upperX and upperY define the X,Y location of the upper-left corner of the \nmenu, relative to invoker . A common way to obtain the invoker is to call \ngetComponent ( ) on the event object passed to the mouse event handler. \nThe preceding theory can be put into practice by adding a popup Edit menu to the \nMenuDemo program shown at the start of this chapter. This menu will have three items \ncalled Cut, Copy, and Paste. Begin by adding the following instance variable to \nMenuDemo : \n\nThe jpu variable will hold a reference to the popup menu. \nNext, add the following code sequence to the MenuDemo constructor:",
    "This sequence begins by constructing an instance of JPopupMenu and storing it in jpu . \nThen, it creates the three menu items, Cut, Copy, and Paste, in the usual way, and adds \nthem to jpu . This finishes the construction of the popup Edit menu. Popup menus are not \nadded to the menu bar or any other object. \nNext, a MouseListener is added by creating an anonymous inner class. This class is based \non the MouseAdapter class, which means that the listener need only override those \nmethods that are relevant to the popup menu: mousePressed ( ) and mouseReleased ( \n) . The adapter provides default implementations of the other MouseListener methods. \nNotice that the mouse listener is added to jfrm . This means that a right-button click inside \nany part of the content pane will trigger the popup menu. \nThe mousePressed ( ) and mouseReleased ( ) methods call isPopupTrigger ( ) to \ndetermine if the mouse event is a popup trigger event",
    ". \nThe mousePressed ( ) and mouseReleased ( ) methods call isPopupTrigger ( ) to \ndetermine if the mouse event is a popup trigger event. If it is, the popup menu is displayed \nby calling show ( ) . The invoker is obtained by calling getComponent ( ) on the mouse \nevent. In this case, the invoker will be the content pane. The X,Y coordinates of the upperleft corner are obtained by calling getX ( ) and getY ( ) . This makes the menu pop up with \nits upper-left corner directly under the mouse pointer.",
    "Finally, you also need to add these action listeners to the program. They handle the action \nevents fired when the user selects an item from the popup menu. \n\n\nAfter you have made these additions, the popup menu can be activated by clicking the right \nmouse button anywhere inside the content pane of the application. Figure 33-5 shows the \nresult. \nOne other point about the preceding example. Because the invoker of the popup menu is \nalways jfrm , in this case, you could pass it explicitly rather than calling getComponent ( \n) . To do so, you must make jfrm into an instance variable of the MenuDemo class ( rather \nthan a local variable ) so that it is accessible to the inner class. Then you can use this call to \nshow ( ) to display the popup menu:",
    "Although this works in this example, the advantage of using getComponent ( ) is that the \npopup menu will automatically pop up relative to the invoking component. Thus, the same \ncode could be used to display any popup menu relative to its invoking object. \n\nFigure 33-5    A popup Edit menu \n\nCreate a Toolbar \n\nA toolbar is a component that can serve as both an alternative and as an adjunct to a menu. \nA toolbar contains a list of buttons ( or other components ) that give the user immediate \naccess to various program options. For example, a toolbar might contain buttons that select",
    "various font options, such as bold, italics, highlight, or underline. These options can be \nselected without needing to drop through a menu. Typically, toolbar buttons show icons \nrather than text, although either or both are allowed. Furthermore, tooltips are often \nassociated with icon-based toolbar buttons. Toolbars can be positioned on any side of a \nwindow by dragging the toolbar, or they can be dragged out of the window entirely, in which \ncase they become free floating. \n\nIn Swing, toolbars are instances of the JToolBar class. Its constructors enable you to create \n\n\na toolbar with or without a title. You can also specify the layout of the toolbar, which will be \neither horizontal or vertical. The JToolBar constructors are shown here: \n\nJToolBar ( ) \n\nJToolBar ( String title ) \n\nJToolBar ( int how ) \n\nJToolBar ( String title , int how )",
    "The first constructor creates a horizontal toolbar with no title. The second creates a \nhorizontal toolbar with the title specified by title . The title will show only when the \ntoolbar is dragged out of its window. The third creates a toolbar that is oriented as \nspecified by how . The value of how must be either JToolBar.VERTICAL or \nJToolBar.HORIZONTAL . The fourth constructor creates a toolbar that has the \ntitle specified by title and is oriented as specified by how . \nA toolbar is typically used with a window that uses a border layout. There are two reasons \nfor this. First, it allows the toolbar to be initially positioned along one of the four border \npositions. Frequently, the top position is used. Second, it allows the toolbar to be dragged to \nany side of the window. \nIn addition to dragging the toolbar to different locations within a window, you can also drag \nit out of the window. Doing so creates an undocked toolbar",
    ". \nIn addition to dragging the toolbar to different locations within a window, you can also drag \nit out of the window. Doing so creates an undocked toolbar. If you specify a title when you \ncreate the toolbar, then that title will be shown when the toolbar is undocked. \nYou add buttons ( or other components ) to a toolbar in much the same way that you add \nthem to a menu bar. Simply call add ( ) . The components are shown in the toolbar in the \norder in which they are added. \nOnce you have created a toolbar, you do not add it to the menu bar ( if one exists ). Instead, \nyou add it to the window container. As mentioned, typically you will add a toolbar to the top \n( that is, north ) position of a border layout, using a horizontal orientation. The component \nthat will be affected is added to the center of the border layout. Using this approach causes \nthe program to begin running with the toolbar in the expected location. However, you can \ndrag the toolbar to any of the other positions",
    ". Using this approach causes \nthe program to begin running with the toolbar in the expected location. However, you can \ndrag the toolbar to any of the other positions. Of course, you can also drag the toolbar out of \nthe window. \nTo illustrate the toolbar, we will add one to the MenuDemo program. The toolbar will \npresent three debugging options: set a breakpoint, clear a breakpoint, and resume program \nexecution. Three steps are needed to add the toolbar. \nFirst, remove this line from the program.",
    "By removing this line, the JFrame automatically uses a border layout. \nSecond, because BorderLayout is being used, change the line that adds the label jlab to \nthe frame, as shown next: \n\n\nThis line explicitly adds jlab to the center of the border layout. ( Explicitly specifying the \ncenter position is technically not necessary because, by default, components are added to \nthe center when a border layout is used. However, explicitly specifying the center makes it \nclear to anyone reading the code that a border layout is being used and that jlab goes in the \ncenter.) \nNext, add the following code, which creates the Debug toolbar. \n\nLet\u2019s look at this code closely. First, a JToolBar is created and given the title \"Debug\". \nThen, a set of ImageIcon objects are created that hold the images for the toolbar buttons.",
    "Let\u2019s look at this code closely. First, a JToolBar is created and given the title \"Debug\". \nThen, a set of ImageIcon objects are created that hold the images for the toolbar buttons. \n\nNext, three toolbar buttons are created. Notice that each has an image, but no text. Also, \neach is explicitly given an action command and a tooltip. The action commands are set \nbecause the buttons are not given names when they are constructed. Tooltips are especially \nuseful when applied to icon-based toolbar components because sometimes it\u2019s hard to \n\n\ndesign images that are intuitive to all users. The buttons are then added to the toolbar, and \nthe toolbar is added to the north side of the border layout of the frame. \nFinally, add the action listeners for the toolbar, as shown here: \n\nEach time the user presses a toolbar button, an action event is fired, and it is \nhandled in the same way as the other menu-related events. Figure 33-6 shows the \ntoolbar in action. \n\nUse Actions",
    "Often, a toolbar and a menu item contain items in common. For example, the same \nfunctions provided by the Debug toolbar in the preceding example might also be offered \nthrough a menu selection. In such a case, selecting an option ( such as setting a breakpoint ) \ncauses the same action to occur, independently of whether the menu or the toolbar was \nused. Also, both the toolbar button and the menu item would ( most likely ) use the same \nicon. Furthermore, when a toolbar button is disabled, the corresponding menu item would \nalso need to be disabled. Such a situation would normally lead to a fair amount of \nduplicated, interdependent code, which is less than optimal. Fortunately, Swing provides a \nsolution: the action . \nAn action is an instance of the Action interface. Action extends the ActionListener",
    "interface and provides a means of combining state information with the \nactionPerformed ( ) event handler. This combination allows one action to manage two or \nmore components. For example, an action lets you centralize the control and handling of a \ntoolbar button and a menu item. Instead of having to duplicate code, your program need \nonly create an action that automatically handles both components. \nBecause Action extends ActionListener , an action must provide an implementation of the \nactionPerformed ( ) method. This handler will process the action events generated by the \nobjects linked to the action.",
    "Figure 33-6    The Debug toolbar in action \n\nIn addition to the inherited actionPerformed ( ) method, Action defines several methods \nof its own. One of particular interest is putValue ( ) . It sets the value of the various \nproperties associated with an action and is shown here: \n\nvoid putValue ( String key , Object val ) \n\nIt assigns val to the property specified by key that represents the desired property. \nAlthough not used by the example that follows, it is helpful to note that Action \nalso supplies the getValue ( ) method that obtains a specified property. It is \nshown here: \n\nObject getValue ( String key ) \n\nIt returns a reference to the property specified by key . \nThe key values used by putValue ( ) and getValue ( ) include those shown here: \n\nKey Value \nDescription \n\nstatic final String \nACCELERATOR_KEY \nRepresents the accelerator property. Accelerators \nare specified as KeyStroke objects.",
    "Key Value \nDescription \n\nstatic final String \nACCELERATOR_KEY \nRepresents the accelerator property. Accelerators \nare specified as KeyStroke objects. \n\nstatic final String \nACTION_COMMAND_KEY \nRepresents the action command property. An \naction command is specified as a string. \n\nstatic final String \nDISPLAYED_ \nMNEMONIC_INDEX_KEY \n\nRepresents the index of the character displayed \nas the mnemonic. This is an Integer value. \n\nstatic final String \nRepresents the large icon associated with the \naction. The icon is specified as an object of type \n\n\nLARGE_ICON_KEY \nIcon . \n\nstatic final String LONG_ \nDESCRIPTION \nRepresents a long description of the action. This \ndescription is specified as a string. \n\nstatic final String \nMNEMONIC_KEY \nRepresents the mnemonic property. A mnemonic \nis specified as a KeyEvent constant. \n\nstatic final String NAME",
    "static final String \nMNEMONIC_KEY \nRepresents the mnemonic property. A mnemonic \nis specified as a KeyEvent constant. \n\nstatic final String NAME \n\nRepresents the name of the action ( which also \nbecomes the name of the button or menu item to \nwhich the action is linked ). The name is specified \nas a string. \n\nstatic final String \nSELECTED_KEY \n\nRepresents the selection status. If set, the item is \nselected. The state is represented by a Boolean \nvalue. \n\nstatic final String \nSHORT_ DESCRIPTION \nRepresents the tooltip text associated with the \naction. The tooltip text is specified as a string. \n\nstatic final String \nSMALL_ICON \nRepresents the icon associated with the action. \nThe icon is specified as an object of type Icon . \n\nFor example, to set the mnemonic to the letter X , use this call to putValue ( ) :",
    "For example, to set the mnemonic to the letter X , use this call to putValue ( ) : \n\nOne Action property that is not accessible through putValue ( ) and getValue ( ) is the \nenabled/disabled status. For this, you use the setEnabled ( ) and isEnabled ( ) methods. \nThey are shown here: \n\nvoid setEnabled ( boolean enabled ) \n\nboolean isEnabled ( ) \n\nFor setEnabled ( ) , if enabled is true , the action is enabled. Otherwise, it is \n\n\ndisabled. If the action is enabled, isEnabled ( ) returns true . Otherwise, it returns \nfalse . \nAlthough you can implement all of the Action interface yourself, you won\u2019t usually need to. \nInstead, Swing provides a partial implementation called AbstractAction that you can \nextend. By extending AbstractAction , you need implement only one method: \nactionPerformed ( ) . The other Action methods are provided for you. AbstractAction \nprovides three constructors. The one used in this chapter is shown here:",
    "AbstractAction ( String name , Icon image ) \n\nIt constructs an AbstractAction that has the name specified by name and the \nicon specified by image . \nOnce you have created an action, it can be added to a JToolBar and used to construct a \nJMenuItem . To add an action to a JToolBar , use this version of add ( ) : \n\nvoid add ( Action actObj ) \n\nHere, actObj is the action that is being added to the toolbar. The properties \ndefined by actObj are used to create a toolbar button. To create a menu item from \nan action, use this JMenuItem constructor: \n\nJMenuItem ( Action actObj ) \n\nHere, actObj is the action used to construct a menu item according to its \nproperties. \n\nNOTE In addition to JToolBar and JMenuItem , actions are also \nsupported by several other Swing components, such as JPopupMenu , \nJButton , JRadioButton , and JCheckBox . \nJRadioButtonMenuItem and JCheckBoxMenuItem also support \nactions.",
    "To illustrate the benefit of actions, we will use them to manage the Debug toolbar created in \nthe previous section. We will also add a Debug submenu under the Options main menu. The \n\nDebug submenu will contain the same selections as the Debug toolbar: Set Breakpoint, \nClear Breakpoint, and Resume. The same actions that support these items in the toolbar will \nalso support these items in the menu. Therefore, instead of having to create duplicate code \nto handle both the toolbar and menu, both are handled by the actions. \nBegin by creating an inner class called DebugAction that extends AbstractAction , as \nshown here: \n\n\nDebugAction extends AbstractAction . It creates an action class that will be used to \ndefine the properties associated with the Debug menu and toolbar. Its constructor has five \nparameters that let you specify the following items: \n\n\u2022  Name \n\n\u2022  Icon \n\n\u2022  Mnemonic \n\n\u2022  Accelerator \n\n\u2022  Tooltip",
    "\u2022  Name \n\n\u2022  Icon \n\n\u2022  Mnemonic \n\n\u2022  Accelerator \n\n\u2022  Tooltip \n\nThe first two are passed to AbstractAction \u2019s constructor via super . The other \nthree properties are set through calls to putValue ( ) . \nThe actionPerformed ( ) method of DebugAction handles events for the action. This \nmeans that when an instance of DebugAction is used to create a toolbar button and a \nmenu item, events generated by either of those components are handled by the \nactionPerformed ( ) method in DebugAction . Notice that this handler displays the",
    "selection in jlab . In addition, if the Set Breakpoint option is selected, then the Clear \nBreakpoint option is enabled and the Set Breakpoint option is disabled. If the Clear \nBreakpoint option is selected, then the Set Breakpoint option is enabled and the Clear \nBreakpoint option is disabled. This illustrates how an action can be used to enable or \ndisable a component. When an action is disabled, it is disabled for all uses of that action. In \nthis case, if Set Breakpoint is disabled, then it is disabled both in the toolbar and in the \nmenu. \nNext, add these DebugAction instance variables to MenuDemo : \n\nNext, create three ImageIcon s that represent the Debug options, as shown here: \n\nNow, create the actions that manage the Debug options, as shown here:",
    "Next, create three ImageIcon s that represent the Debug options, as shown here: \n\nNow, create the actions that manage the Debug options, as shown here: \n\n\nNotice that the accelerator for Set Breakpoint is B and the accelerator for Clear Breakpoint \nis L. The reason these keys are used rather than S and C is that these keys are already \nallocated by the File menu for Save and Close. However, they can still be used as mnemonics \nbecause each mnemonic is localized to its own menu. Also notice that the action that \nrepresents Clear Breakpoint is initially disabled. It will be enabled only after a breakpoint \nhas been set. \nNext, use the actions to create buttons for the toolbar and then add those buttons to the \ntoolbar, as shown here: \n\nFinally, create the Debug menu, as shown next:",
    "Finally, create the Debug menu, as shown next: \n\nAfter making these changes and additions, the actions that you created will be used to \nmanage both the Debug menu and the toolbar. Thus, changing a property in the action \n( such as disabling it ) will affect all uses of that action. The program will now look as shown \nin Figure 33-7. \n\n\nFigure 33-7    Using actions to manage the Debug toolbar and menu \n\nPut the Entire MenuDemo Program Together",
    "Figure 33-7    Using actions to manage the Debug toolbar and menu \n\nPut the Entire MenuDemo Program Together \n\nThroughout the course of this discussion, many changes and additions have been made to \nthe MenuDemo program shown at the start of the chapter. Before concluding, it will be \nhelpful to assemble all the pieces. Doing so not only eliminates any ambiguity about the way \nthe pieces fit together, but it also gives you a complete menu demonstration program that \nyou can experiment with. \nThe following version of MenuDemo includes all of the additions and enhancements \ndescribed in this chapter. For clarity, the program has been reorganized, with separate \nmethods being used to construct the various menus and toolbar. Notice that several of the \nmenu-related variables, such as jmb , jmFile , and jtb , have been made into instance \nvariables. \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nContinuing Your Exploration of Swing",
    "Continuing Your Exploration of Swing \n\nSwing defines a very large GUI toolkit. It has many more features that you will want to \n\nexplore on your own. For example, it supplies dialog classes, such as JOptionPane and \nJDialog , that you can use to streamline the construction of dialog windows. It also provides \nadditional controls beyond those introduced in Chapter 31. Two you will want to explore are \nJSpinner ( which creates a spin control ) and JFormattedTextField ( which supports \nformatted text ). You will also want to experiment with defining your own models for the \nvarious components. Frankly, the best way to become familiar with Swing\u2019s capabilities is to \n\nexperiment with it. \n\n\uf709 \nPREV \nChapter 32: Exploring Swing \n\u23ee \n\nNEXT \nPart IV: Introducing GUI Programming with Java\u2026 \u23ed \n\n\n\n\nPREV \nChapter 33: Introducing Swing Menus \n\u23ee",
    "experiment with it. \n\n\uf709 \nPREV \nChapter 32: Exploring Swing \n\u23ee \n\nNEXT \nPart IV: Introducing GUI Programming with Java\u2026 \u23ed \n\n\n\n\nPREV \nChapter 33: Introducing Swing Menus \n\u23ee \n\nNEXT \nChapter 34: Introducing JavaFX GUI Programming \u23ed \n\nPART \n\nIV \nIntroducing GUI Programming with JavaFX \n\nCHAPTER 34 \n\nIntroducing \nJavaFX GUI \nProgramming \n\nCHAPTER 35 \n\nExploring JavaFX \nControls \n\nCHAPTER 36 \n\nIntroducing \n\nJavaFX Menus \n\n\uf709 \nPREV \nChapter 33: Introducing Swing Menus \n\u23ee \n\nNEXT \nChapter 34: Introducing JavaFX GUI Programming \u23ed \n\n\nPREV \nPart IV: Introducing GUI Programming with Java\u2026 \n\u23ee \n\nNEXT \nChapter 35: Exploring JavaFX Controls \u23ed \n\nCHAPTER \n\n34 \nIntroducing JavaFX GUI Programming",
    "Like all successful languages, Java continues to evolve and improve. This also applies to its \nlibraries. One of the most important examples of this evolutionary process is found in its \nGUI frameworks. As explained earlier in the book, the original GUI framework was the \nAWT. Because of its several limitations, it was soon followed by Swing, which offered a far \nsuperior approach to creating GUIs. Swing was so successful that it has remained the \nprimary Java GUI framework for over a decade. ( And a decade is a long time in the fastmoving world of programming!) However, Swing was designed when the enterprise \napplication dominated software development. Today, consumer applications, and especially \nmobile apps, have risen in importance, and such applications often demand a GUI that has \n\u201cvisual sparkle.\u201d Furthermore, no matter the type of application, the trend is toward more \nexciting visual effects",
    ". To better handle these types of GUIs, a new approach was needed, \nand this lead to the creation of JavaFX. JavaFX is Java\u2019s next-generation client platform and \nGUI framework. \nJavaFX provides a powerful, streamlined, flexible framework that simplifies the creation of \nmodern, visually exciting GUIs. As such, it is a very large system, and, as was the case with \nSwing discussed in Part III, it is not possible to describe it fully in this book. Instead, the \npurpose of this and the next two chapters is to introduce several of its key features and \ntechniques. Once you understand the fundamentals, you will find it easy to explore other \naspects of JavaFX on your own. \nOne question that naturally arises relating to JavaFX is this: Is JavaFX designed as a \nreplacement for Swing? The answer is a qualified Yes. However, given the large amount of \nSwing legacy code and the legions of programmers who know how to program for Swing, \nSwing will be in use for a very long time",
    ". However, given the large amount of \nSwing legacy code and the legions of programmers who know how to program for Swing, \nSwing will be in use for a very long time. This is especially true for enterprise applications.",
    "Nevertheless, JavaFX has clearly been positioned as the platform of the future. It is expected \nthat, over the next few years, JavaFX will supplant Swing for new projects. JavaFX is \nsomething that no Java programmer can afford to ignore. \nBefore continuing, it is important to mention that the development of JavaFX occurred in \ntwo main phases. The original JavaFX was based on a scripting language called JavaFX \nScript . However, JavaFX Script has been discontinued. Beginning with the release of \n\n\nJavaFX 2.0, JavaFX has been programmed in Java itself and provides a comprehensive API.",
    "JavaFX 2.0, JavaFX has been programmed in Java itself and provides a comprehensive API. \n\nJavaFX also supports FXML, which can be ( but is not required to be ) used to specify the \nuser interface. JavaFX has been bundled with Java since JDK 7, update 4. The latest version \nof JavaFX is JavaFX 8, which is bundled with JDK 8. ( The version number is 8 to align with \nthe JDK version. Thus, the numbers 3 through 7 were skipped.) Because, at the time of this \nwriting, JavaFX 8 represents the latest version of JavaFX, it is the version of JavaFX \ndiscussed here. Furthermore, when the term JavaFX is used in this and the following \nchapters, it refers to JavaFX 8. \n\nNOTE This and the following two chapters assume that you have a basic \nunderstanding of event handling as introduced in Chapter 24, and Swing \nfundamentals, as described by the preceding three chapters. \n\nJavaFX Basic Concepts",
    "In general, the JavaFX framework has all of the good features of Swing. For example, \nJavaFX is lightweight. It can also support an MVC architecture. Much of what you already \nknow about creating GUIs using Swing is conceptually applicable to JavaFX. That said, \nthere are significant differences between the two. \nFrom a programmer\u2019s point of view, the first differences you notice between JavaFX and \nSwing are the organization of the framework and the relationship of the main components. \nSimply put, JavaFX offers a more streamlined, easier-to-use, updated approach. JavaFX \nalso greatly simplifies the rendering of objects because it handles repainting automatically. \nIt is no longer necessary for your program to handle this task manually. The preceding is \nnot intended to imply that Swing is poorly designed. It is not. It is just that the art and \nscience of programming has moved forward, and JavaFX has received the benefits of that \nevolution",
    ". It is not. It is just that the art and \nscience of programming has moved forward, and JavaFX has received the benefits of that \nevolution. Simply put, JavaFX facilitates a more visually dynamic approach to GUIs.",
    "The JavaFX Packages \n\nThe JavaFX elements are contained in packages that begin with the javafx prefix. At the \ntime of this writing, there are more than 30 JavaFX packages in its API library. Here are \n\nfour examples: javafx.application , javafx.stage , javafx.scene , and \njavafx.scene.layout . Although we will only use a few of these packages in this chapter, \nyou will want to spend some time browsing their capabilities. JavaFX offers a wide array of \nfunctionality. \n\nThe Stage and Scene Classes \n\nThe central metaphor implemented by JavaFX is the stage . As in the case of an actual stage \n\nplay, a stage contains a scene . Thus, loosely speaking, a stage defines a space and a scene",
    "defines what goes in that space. Or, put another way, a stage is a container for scenes and a \nscene is a container for the items that comprise the scene. As a result, all JavaFX \napplications have at least one stage and one scene. These elements are encapsulated in the \nJavaFX API by the Stage and Scene classes. To create a JavaFX application, you will, at \nminimum, add at least one Scene object to a Stage . Let\u2019s look a bit more closely at these \ntwo classes. \nStage is a top-level container. All JavaFX applications automatically have access to one \nStage , called the primary stage . The primary stage is supplied by the run-time system \nwhen a JavaFX application is started. Although you can create other stages, for many \napplications, the primary stage will be the only one required. \nAs mentioned, Scene is a container for the items that comprise the scene. These can consist \nof controls, such as push buttons and check boxes, text, and graphics",
    ". \nAs mentioned, Scene is a container for the items that comprise the scene. These can consist \nof controls, such as push buttons and check boxes, text, and graphics. To create a scene, you \nwill add those elements to an instance of Scene .",
    "The individual elements of a scene are called nodes . For example, a push button control is a \nnode. However, nodes can also consist of groups of nodes. Furthermore, a node can have a \nchild node. In this case, a node with a child is called a parent node or branch node . Nodes \nwithout children are terminal nodes and are called leaves. The collection of all nodes in a \nscene creates what is referred to as a scene graph , which comprises a tree . \nThere is one special type of node in the scene graph, called the root node . This is the toplevel node and is the only node in the scene graph that does not have a parent. Thus, with \nthe exception of the root node, all other nodes have parents, and all nodes either directly or \nindirectly descend from the root node. \nThe base class for all nodes is Node . There are several other classes that are, either directly \nor indirectly, subclasses of Node . These include Parent , Group , Region , and Control , \nto name a few. \n\nLayouts",
    "Layouts \n\nJavaFX provides several layout panes that manage the process of placing elements in a \nscene. For example, the FlowPane class provides a flow layout and the GridPane class \nsupports a row/column grid-based layout. Several other layouts, such as BorderPane \n( which is similar to the AWT\u2019s BorderLayout ), are available. The layout panes are \npackaged in javafx.scene.layout . \n\nThe Application Class and the Life-cycle Methods \n\nA JavaFX application must be a subclass of the Application class, which is packaged in \njavafx.application . Thus, your application class will extend Application . The \nApplication class defines three life-cycle methods that your application can override. \nThese are called init ( ) , start ( ) , and stop ( ) , and are shown here, in the order in which \n\nthey are called: \n\n\nvoid init ( ) \n\nabstract void start ( Stage primaryStage ) \n\nvoid stop ( )",
    "The init ( ) method is called when the application begins execution. It is used to \nperform various initializations. As will be explained, however, it cannot be used to \ncreate a stage or build a scene. If no initializations are required, this method need \nnot be overridden because an empty, default version is provided. \nThe start ( ) method is called after init ( ) . This is where your application begins and it can \nbe used to construct and set the scene. Notice that it is passed a reference to a Stage object. \nThis is the stage provided by the run-time system and is the primary stage. ( You can also \ncreate other stages, but you won\u2019t need to for simple applications.) Notice that this method \nis abstract. Thus, it must be overridden by your application. \nWhen your application is terminated, the stop ( ) method is called. It is here that you can \nhandle any cleanup or shutdown chores. In cases in which no such actions are needed, an \nempty, default version is provided.",
    "Launching a JavaFX Application \n\nTo start a free-standing JavaFX application, you must call the launch ( ) method defined by \nApplication . It has two forms. Here is the one used in this chapter: \n\npublic static void launch ( String \u2026 args )",
    "public static void launch ( String \u2026 args ) \n\nHere, args is a possibly empty list of strings that typically specify command-line \narguments. When called, launch ( ) causes the application to be constructed, \nfollowed by calls to init ( ) and start ( ) . The launch ( ) method will not return \nuntil after the application has terminated. This version of launch ( ) starts the \nsubclass of Application from which launch ( ) is called. The second form of \nlaunch ( ) lets you specify a class other than the enclosing class to start. \nBefore moving on, it is necessary to make an important point: JavaFX applications that \nhave been packaged by using the javafxpackager tool ( or its equivalent in an IDE ) do not \nneed to include a call to launch ( ) . However, its inclusion often simplifies the test/debug \ncycle, and it lets the program be used without the creation of a JAR file. Thus, it is included \nin all of the JavaFX programs in this book. \n\nA JavaFX Application Skeleton",
    "A JavaFX Application Skeleton \n\nAll JavaFX applications share the same basic skeleton. Therefore, before looking at any \n\nmore JavaFX features, it will be useful to see what that skeleton looks like. In addition to \nshowing the general form of a JavaFX application, the skeleton also illustrates how to \nlaunch the application and demonstrates when the life-cycle methods are called. A message \nnoting when each life-cycle method is called is displayed on the console. The complete \nskeleton is shown here: \n\n\n\n\nAlthough the skeleton is quite short, it can be compiled and run. It produces the window \nshown here: \n\n\nIt also produces the following output on the console: \n\nWhen you close the window, this message is displayed on the console:",
    "Of course, in a real program, the life-cycle methods would not normally output anything to \nSystem.out . They do so here simply to illustrate when each method is called. Furthermore, \nas explained earlier, you will need to override the init ( ) and stop ( ) methods only if your \napplication must perform special startup or shutdown actions. Otherwise, you can use the \ndefault implementations of these methods provided by the Application class. \nLet\u2019s examine this program in detail. It begins by importing four packages. The first is \njavafx.application , which contains the Application class. The Scene class is packaged \nin javafx.scene , and Stage is packaged in javafx.stage . The javafx.scene.layout \npackage provides several layout panes. The one used by the program is FlowPane . \nNext, the application class JavaFXSkel is created. Notice that it extends Application . As \nexplained, Application is the class from which all JavaFX applications are derived. \nJavaFXSkel contains two methods",
    ". Notice that it extends Application . As \nexplained, Application is the class from which all JavaFX applications are derived. \nJavaFXSkel contains two methods. The first is main ( ) . It is used to launch the \napplication via a call to launch ( ) . Notice that the args parameter to main ( ) is passed to \nthe launch ( ) method. Although this is a common approach, you can pass a different set of \nparameters to launch ( ) , or none at all. One other point: As explained earlier, launch ( ) is \nrequired by a free-standing application, but not in other cases. When it is not needed, \nmain ( ) is also not needed. However, for reasons already explained, both main ( ) and \nlaunch ( ) are included in the JavaFX programs in this book. \nWhen the application begins, the init ( ) method is called first by the JavaFX run-time \nsystem. For the sake of illustration, it simply displays a message on System.out , but it \nwould normally be used to initialize some aspect of the application",
    ". For the sake of illustration, it simply displays a message on System.out , but it \nwould normally be used to initialize some aspect of the application. Of course, if no \ninitialization is required, it is not necessary to override init ( ) because an empty, default \nimplementation is provided. It is important to emphasize that init ( ) cannot be used to \ncreate the stage or scene portions of a GUI. Rather, these items should be constructed and \ndisplayed by the start ( ) method.",
    "After init ( ) finishes, the start ( ) method executes. It is here that the initial scene is created \nand set to the primary stage. Let\u2019s look at this method line-by-line. First, notice that start ( \n) has a parameter of type Stage . When start ( ) is called, this parameter will receive a \nreference to the primary stage of the application. It is to this stage that you will set a scene \nfor the application. \nAfter displaying a message on the console that start ( ) has begun execution, it sets the title \nof the stage using this call to setTitle ( ) : \n\n\nAlthough this step is not necessarily required, it is customary for stand-alone applications. \nThis title becomes the name of the main application window. \nNext, a root node for a scene is created. The root node is the only node in a scene graph that \ndoes not have a parent. In this case, a FlowPane is used for the root node, but there are \nseveral other classes that can be used for the root.",
    "As mentioned, a FlowPane is a layout manager that uses a flow layout. This is a layout in \nwhich elements are positioned line-by-line, with lines wrapping as needed. ( Thus, it works \nmuch like the FlowLayout class used by the AWT and Swing.) In this case, a horizontal \nflow is used, but it is possible to specify a vertical flow. Although not needed by this skeletal \napplication, it is also possible to specify other layout properties, such as a vertical and \nhorizontal gap between elements, and an alignment. You will see an example of this later in \nthis chapter. \nThe following line uses the root node to construct a Scene : \n\nScene provides several versions of its constructor. The one used here creates a scene that \nhas the specified root with the specified width and height. It is shown here: \n\nScene ( Parent rootnode , double width , double height )",
    "Scene ( Parent rootnode , double width , double height ) \n\nNotice that the type of rootnode is Parent . It is a subclass of Node and \nencapsulates nodes that can have children. Also notice that the width and the \nheight are double values. This lets you pass fractional values, if needed. In the \nskeleton, the root is rootNode , the width is 300 and the height is 200. \nThe next line in the program sets myScene as the scene for myStage : \n\nHere, setScene ( ) is a method defined by Stage that sets the scene to that specified by its \nargument. \nIn cases in which you don\u2019t make further use of the scene, you can combine the previous two \n\nsteps, as shown here: \n\nBecause of its compactness, this form will be used by most of the subsequent examples. \n\n\nThe last line in start ( ) displays the stage and its scene:",
    "steps, as shown here: \n\nBecause of its compactness, this form will be used by most of the subsequent examples. \n\n\nThe last line in start ( ) displays the stage and its scene: \n\nIn essence, show ( ) shows the window that was created by the stage and screen. \nWhen you close the application, its window is removed from the screen and the stop ( ) \nmethod is called by the JavaFX run-time system. In this case, stop ( ) simply displays a \nmessage on the console, illustrating when it is called. However, stop ( ) would not normally \ndisplay anything. Furthermore, if your application does not need to handle any shutdown \nactions, there is no reason to override stop ( ) because an empty, default implementation is \nprovided. \n\nCompiling and Running a JavaFX Program",
    "One important advantage of JavaFX is that the same program can be run in a variety of \ndifferent execution environments. For example, you can run a JavaFX program as a standalone desktop application, inside a web browser, or as a Web Start application. However, \ndifferent ancillary files may be needed in some cases, for example, an HTML file or a Java \nNetwork Launch Protocol ( JNLP ) file. \nIn general, a JavaFX program is compiled like any other Java program. However, because of \nthe need for additional support for various execution environments, the easiest way to \ncompile a JavaFX application is to use an Integrated Development Environment ( IDE ) that \nfully supports JavaFX programming, such as NetBeans. Just follow the instructions for the \nIDE you are using. \nAlternatively, if you want to compile and test a JavaFX application using the command-line \ntools, you can easily do so. Just compile and run the application in the normal way, using \njavac and java",
    ". Just compile and run the application in the normal way, using \njavac and java . Be aware that using the command-line compiler neither creates any HTML \nor JNLP files that would be needed if you want to run the application in a way other than as \na stand-alone application, nor does it create a JAR file for the program. To create these \nfiles, you need to use a tool such as javafxpackager .",
    "The Application Thread \n\nIn the preceding discussion, it was mentioned that you cannot use the init ( ) method to \nconstruct a stage or scene. You also cannot create these items inside the application\u2019s \nconstructor. The reason is that a stage or scene must be constructed on the application \nthread . However, the application\u2019s constructor and the init ( ) method are called on the \n\nmain thread, also called the launcher thread . Thus, they can\u2019t be used to construct a stage \nor scene. Instead, you must use the start ( ) method, as the skeleton demonstrates, to create \nthe initial GUI because start ( ) is called on the application thread. \nFurthermore, any changes to the GUI currently displayed must be made from the \napplication thread. Fortunately, in JavaFX, events are sent to your program on the \napplication thread. Therefore, event handlers can be used to interact with the GUI. The \n\n\nstop ( ) method is also called on the application thread.",
    "stop ( ) method is also called on the application thread. \n\nA Simple JavaFX Control: Label \n\nThe primary ingredient in most user interfaces is the control because a control enables the \nuser to interact with the application. As you would expect, JavaFX supplies a rich \nassortment of controls. The simplest control is the label because it just displays a message, \nwhich, in this example, is text. Although quite easy to use, the label is a good way to \nintroduce the techniques needed to begin building a scene graph. \nThe JavaFX label is an instance of the Label class, which is packaged in \njavafx.scene.control . Label inherits Labeled and Control , among other classes. The \nLabeled class defines several features that are common to all labeled elements ( that is, \nthose that can contain text ), and Control defines features related to all controls. \nLabel defines three constructors. The one we will use here is \n\nLabel ( String str )",
    "Label ( String str ) \n\nHere, str is the string that is displayed. \nOnce you have created a label ( or any other control ), it must be added to the scene\u2019s \ncontent, which means adding it to the scene graph. To do this, you will first call \ngetChildren ( ) on the root node of the scene graph. It returns a list of the child nodes in \nthe form of an ObservableList<Node> . ObservableList is packaged in \njavafx.collections , and it inherits java.util.List , which means that it supports all of the \nfeatures available to a list as defined by the Collections Framework. Using the returned list \nof child nodes, you can add the label to the list by calling add ( ) , passing in a reference to \nthe label. \nThe following program puts the preceding discussion into action by creating a simple \nJavaFX application that displays a label: \n\n\nThis program produces the following window: \n\n\nIn the program, pay special attention to this line:",
    "This program produces the following window: \n\n\nIn the program, pay special attention to this line: \n\nIt adds the label to the list of children for which rootNode is the parent. Although this line \ncould be separated into its individual pieces if necessary, you will often see it as shown here. \nBefore moving on, it is useful to point out that ObservableList provides a method called \naddAll ( ) that can be used to add two or more children to the scene graph in a single call. \n( You will see an example of this shortly.) To remove a control from the scene graph, call \nremove ( ) on the ObservableList . For example, \n\nremoves myLabel from the scene. \n\nUsing Buttons and Events",
    "removes myLabel from the scene. \n\nUsing Buttons and Events \n\nAlthough the program in the preceding section presents a simple example of using a JavaFX \ncontrol and constructing a scene graph, it does not show how to handle events. As you \nknow, most GUI controls generate events that are handled by your program. For example, \nbuttons, check boxes, and lists all generate events when they are used. In many ways, event \nhandling in JavaFX is similar to event handling in Swing or the AWT, but it\u2019s more \nstreamlined. Therefore, if you already are proficient at handling events for these other two \nGUIs, you will have no trouble using the event handling system provided by JavaFX. \nOne commonly used control is the button. This makes button events one of the most \nfrequently handled. Therefore, a button is a good way to demonstrate the fundamentals of \nevent handling in JavaFX. For this reason, the fundamentals of event handling and the \nbutton are introduced together. \n\nEvent Basics",
    "Event Basics \n\nThe base class for JavaFX events is the Event class, which is packaged in javafx.event . \nEvent inherits java.util.EventObject , which means that JavaFX events share the same \n\n\nbasic functionality as other Java events. Several subclasses of Event are defined. The one \n\nthat we will use here is ActionEvent . It handles action events generated by a button. \nIn general, JavaFX uses what is, in essence, the delegation event model approach to event \nhandling. To handle an event, you must first register the handler that acts as a listener for \nthe event. When the event occurs, the listener is called. It must then respond to the event \nand return. In this regard, JavaFX events are managed much like Swing events, for example. \nEvents are handled by implementing the EventHandler interface, which is also in \njavafx.event . It is a generic interface with the following form: \n\ninterface EventHandler<T extends Event>",
    "interface EventHandler<T extends Event> \n\nHere, T specifies the type of event that the handler will handle. It defines one \nmethod, called handle ( ) , which receives the event object as a parameter. It is \nshown here: \n\nvoid handle ( T eventObj ) \n\nHere, eventObj is the event that was generated. Typically, event handlers are \nimplemented through anonymous inner classes or lambda expressions, but you can \nuse stand-alone classes for this purpose if it is more appropriate to your \napplication ( for example, if one event handler will handle events from more than \none source ). \nAlthough not required by the examples in this chapter, it is sometimes useful to know the \nsource of an event. This is especially true if you are using one handler to handle events from \ndifferent sources. You can obtain the source of the event by calling getSource ( ) , which is \ninherited from java.util.EventObject . It is shown here: \n\nObject getSource ( )",
    "Object getSource ( ) \n\nOther methods in Event let you obtain the event type, determine if the event has \nbeen consumed, consume an event, fire an event, and obtain the target of the \nevent. When an event is consumed, it stops the event from being passed to a \nparent handler. \nOne last point: In JavaFX, events are processed via an event dispatch chain . When an event \nis generated, it is passed to the root node of the chain. The event is then passed down the \nchain to the target of the event. After the target node processes the event, the event is passed \nback up the chain, thus allowing parent nodes a chance to process the event, if necessary. \nThis is called event bubbling . It is possible for a node in the chain to consume an event, \n\nwhich prevents it from being further processed. \n\nNOTE Although not used in this introduction to JavaFX, an application \ncan also implement an event filter , which can be used to manage events.",
    "which prevents it from being further processed. \n\nNOTE Although not used in this introduction to JavaFX, an application \ncan also implement an event filter , which can be used to manage events. \n\n\nA filter is added to a node by calling addEventFilter ( ) , which is defined \nby Node . A filter can consume an event, thus preventing further \nprocessing. \n\nIntroducing the Button Control",
    "Introducing the Button Control \n\nIn JavaFX, the push button control is provided by the Button class, which is in \njavafx.scene. - control . Button inherits a fairly long list of base classes that include \nButtonBase , Labeled , Region , Control , Parent , and Node . If you examine the API \ndocumentation for Button , you will see that much of its functionality comes from its base \nclasses. Furthermore, it supports a wide array of options. However, here we will use its \ndefault form. Buttons can contain text, graphics, or both. In this chapter, we will use textbased buttons. An example of a graphics-based button is shown in the next chapter. \nButton defines three constructors. The one we will use is shown here: \n\nButton ( String str )",
    "Button ( String str ) \n\nIn this case, str is the message that is displayed in the button. \nWhen a button is pressed, an ActionEvent is generated. ActionEvent is packaged in \njavafx.event . You can register a listener for this event by using setOnAction ( ) , which \nhas this general form: \n\nfinal void setOnAction ( EventHandler<ActionEvent> handler ) \n\nHere, handler is the handler being registered. As mentioned, often you will use an \nanonymous inner class or lambda expression for the handler. The setOnAction ( ) \nmethod sets the property onAction , which stores a reference to the handler. As \nwith all other Java event handling, your handler must respond to the event as fast \nas possible and then return. If your handler consumes too much time, it will \nnoticeably slow down the application. For lengthy operations, you must use a \nseparate thread of execution. \n\nDemonstrating Event Handling and the Button",
    "Demonstrating Event Handling and the Button \n\nThe following program demonstrates event handling. It uses two buttons and a label. Each \ntime a button is pressed, the label is set to display which button was pressed. \n\n\n\n\nSample output from this program is shown here: \n\n\nLet\u2019s examine a few key portions of this program. First, notice how buttons are created by \nthese two lines: \n\nThis creates two text-based buttons. The first displays the string Alpha ; the second displays \nBeta. \nNext, an action event handler is set for each of these buttons. The sequence for the Alpha \nbutton is shown here:",
    "As explained, buttons respond to events of type ActionEvent . To register a handler for \nthese events, the setOnAction ( ) method is called on the button. It uses an anonymous \ninner class to implement the EventHandler interface. ( Recall that EventHandler defines \nonly the handle ( ) method.) Inside handle ( ) , the text in the response label is set to \nreflect the fact that the Alpha button was pressed. Notice that this is done by calling the \nsetText ( ) method on the label. Events are handled by the Beta button in the same way. \nNote that response is declared as a field within FXEventDemo , rather than as a local \nvariable. This is because it is accessed within the button event handlers, which are \nanonymous inner classes. \nAfter the event handlers have been set, the response label and the buttons btnAlpha and \nbtnBeta are added to the scene graph by using a call to addAll ( ) :",
    "The addAll ( ) method adds a list of nodes to the invoking parent node. Of course, these \nnodes could have been added by three separate calls to add ( ) , but the addAll ( ) method is \nmore convenient to use in this situation. \nThere are two other things of interest in this program that relate to the way the controls are \n\ndisplayed in the window. First, when the root node is created, this statement is used: \n\nHere, the FlowPane constructor is passed two values. These specify the horizontal and \nvertical gap that will be left around elements in the scene. If these gaps are not specified, \n\n\nthen two elements ( such as two buttons ) would be positioned in such a way that no space is \nbetween them. Thus, the controls would run together, creating a very unappealing user \ninterface. Specifying gaps prevents this. \nThe second point of interest is the following line, which sets the alignment of the elements \nin the FlowPane :",
    "Here, the alignment of the elements is centered. This is done by calling setAlignment ( ) \non the FlowPane . The value Pos.CENTER specifies that both a vertical and horizontal \ncenter will be used. Other alignments are possible. Pos is an enumeration that specifies \nalignment constants. It is packaged in javafx.geometry . \nBefore moving on, one more point needs to be made. The preceding program used \nanonymous inner classes to handle button events. However, because the EventHandler \ninterface defines only one abstract method, handle ( ) , a lambda expression could have \npassed to setOnAction ( ) , instead. In this case, the parameter type of setOnAction ( ) \nwould supply the target context for the lambda expression. For example, here is the handler \nfor the Alpha button, rewritten to use a lambda:",
    "Notice that the lambda expression is more compact than the anonymous inner class. \nBecause lambda expressions are a new feature just recently added to Java, but the \nanonymous inner class is a widely used construct, readily understood by nearly all Java \nprogrammers, the event handlers in subsequent examples will use anonymous inner classes. \nThis will also allow the examples to be compiled by readers using JDK 7 ( which does not \nsupport lambdas ). However, on your own, you might want to experiment with converting \nthem to lambda expressions. It is a good way to gain experience using lambdas in your own \ncode. \n\nDrawing Directly on a Canvas \n\nAs mentioned early on, JavaFX handles rendering tasks for you automatically, rather than \nyou handling them manually. This is one of the most important ways that JavaFX improves",
    "As mentioned early on, JavaFX handles rendering tasks for you automatically, rather than \nyou handling them manually. This is one of the most important ways that JavaFX improves \n\non Swing. As you may know, in Swing or the AWT, you must call the repaint ( ) method to \ncause a window to be repainted. Furthermore, your application needs to store the window \ncontents, redrawing them when painting is requested. JavaFX eliminates this tedious \nmechanism because it keeps track of what you display in a scene and redisplays that scene \nas needed. This is called retained mode . With this approach, there is no need to call a \nmethod like repaint ( ) . Rendering is automatic. \nOne place that JavaFX\u2019s approach to rendering is especially helpful is when displaying",
    "graphics objects, such as lines, circles, and rectangles. JavaFX\u2019s graphics methods are found \nin the GraphicsContext class, which is part of java.scene.canvas . These methods can \nbe used to draw directly on the surface of a canvas, which is encapsulated by the Canvas \nclass in java.scene.canvas . When you draw something, such as a line, on a canvas, \nJavaFX automatically renders it whenever it needs to be redisplayed. \nBefore you can draw on a canvas, you must perform two steps. First, you must create a \nCanvas instance. Second, you must obtain a GraphicsContext object that refers to that \ncanvas. You can then use the GraphicsContext to draw output on the canvas. \nThe Canvas class is derived from Node ; thus it can be used as a node in a scene graph. \nCanvas defines two constructors. One is the default constructor, and the other is the one \nshown here: \n\nCanvas ( double width , double height )",
    "Canvas ( double width , double height ) \n\nHere, width and height specify the dimensions of the canvas. \nTo obtain a GraphicsContext that refers to a canvas, call getGraphicsContext2D ( ) . \nHere is its general form: \n\nGraphicsContext getGraphicsContext2D ( ) \n\nThe graphics context for the canvas is returned. \nGraphicsContext defines a large number of methods that draw shapes, text, and images, \nand support effects and transforms. If sophisticated graphics programming is in your future, \nyou will definitely want to study its capabilities closely. For our purposes, we will use only a \nfew of its methods, but they will give you a sense of its power. They are described here. \nYou can draw a line using strokeLine ( ) , shown here: \n\nvoid strokeLine ( double startX , double startY , double endX , double endY )",
    "void strokeLine ( double startX , double startY , double endX , double endY ) \n\nIt draws a line from startX , startY to endX , endY , using the current stroke, which \ncan be a solid color or some more complex style. \nTo draw a rectangle, use either strokeRect ( ) or fillRect ( ) , shown here: \n\nvoid strokeRect ( double topX , double topY , double width , double height ) \n\nvoid fillRect ( double topX , double topY , double width , double height ) \n\nThe upper-left corner of the rectangle is at topX , topY . The width and height \n\nparameters specify its width and height. The strokeRect ( ) method draws the \noutline of a rectangle using the current stroke, and fillRect ( ) fills the rectangle \n\nwith the current fill. The current fill can be as simple as a solid color or something \nmore complex. \nTo draw an ellipse, use either strokeOval ( ) or fillOval ( ) , shown next: \n\nvoid strokeOval ( double topX , double topY , double width , double height )",
    "void strokeOval ( double topX , double topY , double width , double height ) \n\nvoid fillOval ( double topX , double topY , double width , double height ) \n\n\nThe upper-left corner of the rectangle that bounds the ellipse is at topX , topY . The \nwidth and height parameters specify its width and height. The strokeOval ( ) \nmethod draws the outline of an ellipse using the current stroke, and fillOval ( ) \nfills the oval with the current fill. To draw a circle, pass the same value for width \nand height . \nYou can draw text on a canvas by using the strokeText ( ) and fillText ( ) methods. We will \nuse this version of fillText ( ) : \n\nvoid fillText ( String str , double topX , double topY )",
    "void fillText ( String str , double topX , double topY ) \n\nIt displays str starting at the location specified by topX , topY , filling the text with \nthe current fill. \nYou can set the font and font size of the text being displayed by using setFont ( ) . You can \nobtain the font used by the canvas by calling getFont ( ) . By default, the system font is \nused. You can create a new font by constructing a Font object. Font is packaged in \njavafx.scene. - text . For example, you can create a default font of a specified size by using \nthis constructor: \n\nFont ( double fontSize ) \n\nHere, fontSize specifies the size of the font. \nYou can specify the fill and stroke using these two methods defined by Canvas : \n\nvoid setFill ( Paint newFill ) \n\nvoid setStroke ( Paint newStroke )",
    "Notice that the parameter of both methods is of type Paint . This is an abstract \nclass packaged in javafx.scene.paint . Its subclasses define fills and strokes. The \none we will use is Color , which simply describes a solid color. Color defines \nseveral static fields that specify a wide array of colors, such as Color.BLUE , \nColor.RED , Color.GREEN , and so on. \nThe following program uses the aforementioned methods to demonstrate drawing on a \ncanvas. It first displays a few graphic objects on the canvas. Then, each time the Change \nColor button is pressed, the color of three of the objects changes color. If you run the \nprogram, you will see that the shapes whose color is not changed are unaffected by the \nchange in color of the other objects. Furthermore, if you try covering and then uncovering \nthe window, you will see that the canvas is automatically repainted, without any other \nactions on the part of your program. Sample output is shown here:",
    "It is important to emphasize that GraphicsContext supports many more operations than \nthose demonstrated by the preceding program. For example, you can apply various \ntransforms, rotations, and effects. Despite its power, its various features are easy to master \nand use. One other point: A canvas is transparent. Therefore, if you stack canvases, the \ncontents of both will show. This may be useful in some situations. \n\nNOTE javafx.scene.shape contains several classes that can also be \nused to draw various types of graphical shapes, such as circles, arcs, and \nlines. These are represented by nodes and can, therefore, be directly part \nof the scene graph. You will want to explore these on your own. \n\n\uf709 \nPREV \nPart IV: Introducing GUI Programming with Java\u2026 \n\u23ee \n\nNEXT \nChapter 35: Exploring JavaFX Controls \u23ed \n\n\n\n\nPREV \nChapter 34: Introducing JavaFX GUI Programming \n\u23ee \n\nNEXT \nChapter 36: Introducing JavaFX Menus \u23ed \n\nCHAPTER",
    "NEXT \nChapter 35: Exploring JavaFX Controls \u23ed \n\n\n\n\nPREV \nChapter 34: Introducing JavaFX GUI Programming \n\u23ee \n\nNEXT \nChapter 36: Introducing JavaFX Menus \u23ed \n\nCHAPTER \n\n35 \nExploring JavaFX Controls \n\nThe previous chapter described several of the core concepts relating to the JavaFX GUI \nframework. In the process, it introduced two controls: the label and the button. This chapter \ncontinues the discussion of JavaFX controls. It begins by describing how to include images \nin a label and button. It then presents an overview of several more JavaFX controls, \nincluding check boxes, lists, and trees. Keep in mind that JavaFX is a rich and powerful \nframework. The purpose of this chapter is to introduce a representative sampling of the \nJavaFX controls and to describe several common techniques. Once you understand the \nbasics, you will be able to easily learn the other controls. \nThe JavaFX control classes discussed in this chapter are shown here:",
    "These and the other JavaFX controls are packaged in javafx.scene.control . \nAlso discussed are the Image and ImageView classes, which provide support for images \nin controls ; Tooltip , which is used to add tooltips to a control ; as well as various effects and \ntransforms. \n\nUsing Image and ImageView \n\nSeveral of JavaFX\u2019s controls let you include an image. For example, in addition to text, you \ncan specify an image in a label or a button. Furthermore, you can embed stand-alone images \nin a scene directly. At the foundation for JavaFX\u2019s support for images are two classes: \nImage and ImageView . Image encapsulates the image, itself, and ImageView manages \nthe display of an image. Both classes are packaged in javafx.scene.image . \n\nThe Image class loads an image from either an InputStream , a URL, or a path to the \nimage file. Image defines several constructors ; this is the one we will use: \n\nImage ( String url )",
    "The Image class loads an image from either an InputStream , a URL, or a path to the \nimage file. Image defines several constructors ; this is the one we will use: \n\nImage ( String url ) \n\nHere, url specifies a URL or a path to a file that supplies the image. The argument \n\n\nis assumed to refer to a path if it does not constitute a properly formed URL. \n\nOtherwise, the image is loaded from the URL. The examples that follow will load \nimages from files on the local file system. Other constructors let you specify \nvarious options, such as the image\u2019s width and height. One other point: Image is \nnot derived from Node . Thus, it cannot, itself, be part of a scene graph. \nOnce you have an Image , you will use ImageView to display it. ImageView is derived \nfrom Node , which means that it can be part of a scene graph. ImageView defines three \nconstructors. The first one we will use is shown here: \n\nImageView ( Image image )",
    "ImageView ( Image image ) \n\nThis constructor creates an ImageView that uses image for its image. \nPutting the preceding discussion into action, here is a program that loads an image of an \nhourglass and displays it via ImageView . The hourglass image is contained in a file called \nhourglass.png , which is assumed to be in the local directory. \n\n\n\n\nSample output from the program is shown here: \n\nIn the program, pay close attention to the following sequence that loads the image and then \ncreates an ImageView that uses that image: \n\nAs explained, an image by itself cannot be added to the scene graph. It must first be \nembedded in an ImageView . \nIn cases in which you won\u2019t make further use of the image, you can specify a URL or \nfilename when creating an ImageView . In this case, there is no need to explicitly create an \nImage . Instead, an Image instance containing the specified image is constructed",
    "automatically and embedded in the ImageView . Here is the ImageView constructor that \ndoes this: \n\nHere, url specifies the URL or the path to a file that contains the image. \n\nAdding an Image to a Label \n\nAs explained in the previous chapter, the Label class encapsulates a label. It can display a \ntext message, a graphic, or both. So far, we have used it to display only text, but it is easy to \nadd an image. To do so, use this form of Label \u2019s constructor: \n\nLabel ( String str , Node image ) \n\nHere, str specifies the text message and image specifies the image. Notice that the \nimage is of type Node . This allows great flexibility in the type of image added to \nthe label, but for our purposes, the image type will be ImageView . \nHere is a program that demonstrates a label that includes a graphic. It creates a label that \ndisplays the string \"Hourglass\" and shows the image of an hourglass that is loaded from the \nhourglass.png file.",
    "Here is the window produced by the program: \n\nAs you can see, both the image and the text are displayed. Notice that the text is to the right \nof the image. This is the default. You can change the relative positions of the image and text \nby calling setContentDisplay ( ) on the label. It is shown here: \n\nfinal void setContentDisplay ( ContentDisplay position ) \n\nThe value passed to position determines how the text and image is displayed. It \nmust be one of these values, which are defined by the ContentDisplay \nenumeration: \n\nBOTTOM \nRIGHT \n\nCENTER \nTEXT_ONLY \n\nGRAPHIC_ONLY \nTOP \n\nLEFT \n\nWith the exception of TEXT_ONLY and GRAPHIC_ONLY , the values specify the \nlocation of the image. For example, if you add this line to the preceding program: \n\nthe image of the hourglass will be above the text, as shown here:",
    "the image of the hourglass will be above the text, as shown here: \n\n\nThe other two values let you display either just the text or just the image. This might be \nuseful if your application wants to use an image at some times, and not at others, for \nexample. ( If you want only an image, you can simply display it without using a label, as \ndescribed in the previous section.) \nYou can also add an image to a label after it has been constructed by using the \nsetGraphic ( ) method. It is shown here: \n\nfinal void setGraphic ( Node image ) \n\nHere, image specifies the image to add. \n\nUsing an Image with a Button",
    "final void setGraphic ( Node image ) \n\nHere, image specifies the image to add. \n\nUsing an Image with a Button \n\nButton is JavaFX\u2019s class for push buttons. The preceding chapter introduced the Button \nclass. There, you saw an example of a button that contained text. Although such buttons are \ncommon, you are not limited to this approach because you can include an image. You can \nalso use only the image if you choose. The procedure for adding an image to a button is \nsimilar to that used to add an image to a label. First obtain an ImageView of the image. \nThen add it to the button. One way to add the image is to use this constructor: \n\nButton ( String str , Node image )",
    "Button ( String str , Node image ) \n\nHere, str specifies the text that is displayed within the button and image specifies \nthe image. You can specify the position of the image relative to the text by using \nsetContentDisplay ( ) in the same way as just described for Label . \nHere is an example that displays two buttons that contain images. The first shows an \nhourglass. The second shows an analog clock. When a button is pressed, the selected \ntimepiece is reported. Notice that the text is displayed beneath the image. \n\n\n\n\nThe output produced by this program is shown here: \n\nIf you want a button that contains only the image, pass a null string for the text when \nconstructing the button and then call setContentDisplay ( ) , passing in the parameter \nContentDisplay.GRAPHIC_ONLY . For example, if you make these modifications to the \n\nprevious program, the output will look like this: \n\n\nToggleButton",
    "previous program, the output will look like this: \n\n\nToggleButton \n\nA useful variation on the push button is called the toggle button . A toggle button looks just \nlike a push button, but it acts differently because it has two states: pushed and released. \nThat is, when you press a toggle button, it stays pressed rather than popping back up as a \nregular push button does. When you press the toggle button a second time, it releases ( pops \nup ). Therefore, each time a toggle button is pushed, it toggles between these two states. In \nJavaFX, a toggle button is encapsulated in the ToggleButton class. Like Button , \nToggleButton is also derived from ButtonBase . It implements the Toggle interface, \nwhich defines functionality common to all types of two-state buttons. \nToggleButton defines three constructors. This is the one we will use: \n\nToggleButton ( String str )",
    "ToggleButton ( String str ) \n\nHere, str is the text displayed in the button. Another constructor allows you to \ninclude an image. Like other buttons, a ToggleButton generates an action event \nwhen it is pressed. \n\nBecause ToggleButton defines a two-state control, it is commonly used to let the user \nselect an option. When the button is pressed, the option is selected. When the button is \nreleased, the option is deselected. For this reason, a program usually needs to determine the \n\ntoggle button\u2019s state. To do this, use the isSelected ( ) method, shown here: \n\n\nfinal boolean isSelected ( ) \n\nIt returns true if the button is pressed and false otherwise. \nHere is a short program that demonstrates ToggleButton : \n\n\nSample output produced by the program is shown here, with the button pressed: \n\nIn the program, notice how the pressed/released state of the toggle button is determined by \nthe following lines of code inside the button\u2019s action event handler.",
    "In the program, notice how the pressed/released state of the toggle button is determined by \nthe following lines of code inside the button\u2019s action event handler. \n\nWhen the button is pressed, isSelected ( ) returns true . When the button is released, \nisSelected ( ) returns false . \nOne other point: It is possible to use two or more toggle buttons in a group. In this case, \nonly one button can be in its pressed state at any one time. The process of creating and \nusing a group of toggle buttons is similar to that required to use radio buttons. It is \ndescribed in the following section. \n\nRadioButton \n\nAnother type of button provided by JavaFX is the radio button . Radio buttons are a group",
    "RadioButton \n\nAnother type of button provided by JavaFX is the radio button . Radio buttons are a group \n\nof mutually exclusive buttons, in which only one button can be selected at any one time. \nThey are supported by the RadioButton class, which extends both ButtonBase and \nToggleButton . It also implements the Toggle interface. Thus, a radio button is a \nspecialized form of a toggle button. You have almost certainly seen radio buttons in action \nbecause they are the primary control employed when the user must select only one option \n\n\namong several alternatives. \nTo create a radio button, we will use the following constructor: \n\nRadioButton ( String str )",
    "among several alternatives. \nTo create a radio button, we will use the following constructor: \n\nRadioButton ( String str ) \n\nHere, str is the label for the button. Like other buttons, when a RadioButton is \nused, an action event is generated. \nFor their mutually exclusive nature to be activated, radio buttons must be configured into a \ngroup. Only one of the buttons in the group can be selected at any time. For example, if a \nuser presses a radio button that is in a group, any previously selected button in that group is \nautomatically deselected. A button group is created by the ToggleGroup class, which is \npackaged in javafx.scene.control . ToggleGroup provides only a default constructor. \nRadio buttons are added to the toggle group by calling the setToggleGroup ( ) method, \ndefined by ToggleButton , on the button. It is shown here: \n\nfinal void setToggleGroup ( ToggleGroup tg )",
    "final void setToggleGroup ( ToggleGroup tg ) \n\nHere, tg is a reference to the toggle button group to which the button is added. \nAfter all radio buttons have been added to the same group, their mutually \nexclusive behavior will be enabled. \nIn general, when radio buttons are used in a group, one of the buttons is selected when the \ngroup is first displayed in the GUI. Here are two ways to do this. \nFirst, you can call setSelected ( ) on the button that you want to select. It is defined by \nToggleButton ( which is a superclass of RadioButton ). It is shown here: \n\nfinal void setSelected ( boolean state ) \n\nIf state is true , the button is selected. Otherwise, it is deselected. Although the \nbutton is selected, no action event is generated. \nA second way to initially select a radio button is to call fire ( ) on the button. It is shown \nhere: \n\nvoid fire ( )",
    "void fire ( ) \n\nThis method results in an action event being generated for the button if the button \nwas previously not selected. \nThere are a number of different ways to use radio buttons. Perhaps the simplest is to simply \nrespond to the action event that is generated when one is selected. The following program \nshows an example of this approach. It uses radio buttons to allow the user to select a type of \n\ntransportation. \n\n\n\n\n\n\nSample output is shown here: \n\nIn the program, pay special attention to how the radio buttons and the toggle group are \ncreated. First, the buttons are created using this sequence: \n\nNext, a ToggleGroup is constructed: \n\nFinally, each radio button is added to the toggle group: \n\nAs explained, radio buttons must be part of a toggle group in order for their mutually \nexclusive behavior to be activated. \nAfter the event handlers for each radio button have been defined, the rbTrain button is",
    "selected by calling fire ( ) on it. This causes that button to be selected and an action event to \n\n\nbe generated for it. This causes the button to be initialized with the default selection. \n\nHandling Change Events in a Toggle Group \n\nAlthough there is nothing wrong, per se, with managing radio buttons by handling action \nevents, as just shown, sometimes it is more appropriate ( and easier ) to listen to the entire \ntoggle group for changes. When a change takes place, the event handler can easily determine \nwhich radio button has been selected and take action accordingly. To use this approach, you \nmust register a ChangeListener on the toggle group. When a change event occurs, you can \nthen determine which button was selected. To try this approach, remove the action event \nhandlers and the call to fire ( ) from the preceding program and substitute the following: \n\nYou will also need to add this import statement:",
    "You will also need to add this import statement: \n\nIt supports the ChangeListener interface. \nThe output from this program is the same as before ; each time a selection is made, the \nresponse label is updated. However, in this case, only one event handler is needed for the \nenter group, rather than three ( one for each button ). Let\u2019s now look at this code more \nclosely. \nFirst, a change event listener is registered for the toggle group. To listen for change events, \nyou must implement the ChangeListener interface. This is done by calling addListener ( \n) on the object returned by selectedToggleProperty ( ) . The ChangeListener interface \ndefines only one method, called changed ( ) . It is shown here: \n\nvoid changed ( ObservableValue<? extends T> changed , T oldVal , T newVal )",
    "void changed ( ObservableValue<? extends T> changed , T oldVal , T newVal ) \n\nIn this case, changed is the instance of ObservableValue<T> , which \nencapsulates an object that can be watched for changes. The oldVal and newVal \nparameters pass the previous value and the new value, respectively. Thus, in this \n\n\ncase, newVal holds a reference to the radio button that has just been selected. \n\nIn this example, the setSelected ( ) method, rather than fire ( ) , is called to set the initial \nselection. Because setting the initial selection causes a change to the toggle group, it results \nin a change event being generated when the program first begins. You can also use fire ( ) , \nbut setSelected ( ) was used to demonstrate that any change to the toggle group generates \na change event. \n\nAn Alternative Way to Handle Radio Buttons",
    "An Alternative Way to Handle Radio Buttons \n\nAlthough handling events generated by radio buttons is often useful, sometimes it is more \nappropriate to ignore those events and simply obtain the currently selected button when \nthat information is needed. This approach is demonstrated by the following program. It \nadds a button called Confirm Transport Selection. When this button is pressed, the \ncurrently selected radio button is obtained and then the selected transport is displayed in a \nlabel. When you try the program, notice that changing the selected radio button does not \ncause the confirmed transport to change until you press the Confirm Transport Selection \nbutton. \n\n\n\n\nThe output from the program is shown here: \n\n\nMost of the program is easy to understand, but two key points are of special interest. First, \ninside the action event handler for the btnConfirm button, notice that the selected radio \nbutton is obtained by the following line:",
    "Here, the getSelectedToggle ( ) method ( defined by ToggleGroup ) obtains the current \nselection for the toggle group ( which, in this case, is a group of radio buttons ). It is shown \nhere: \n\nfinal Toggle getSelectedToggle ( ) \n\nIt returns a reference to the Toggle that is selected. In this case, the return value \nis cast to RadioButton because this is the type of button in the group. \nThe second thing to notice is the use of a visual separator, which is created by this sequence: \n\nThe Separator class creates a line, which can be either vertical or horizontal. By default, it \ncreates a horizontal line. ( A second constructor lets you choose a vertical separator.) \nSeparator helps visually organize the layout of controls. It is packaged in \njavafx.scene.control . Next, the width of the separator line is set by calling \nsetPrefWidth ( ) , passing in the width. \n\nCheckBox",
    "CheckBox \n\nThe CheckBox class encapsulates the functionality of a check box. Its immediate superclass \nis ButtonBase . Although you are no doubt familiar with check boxes because they are \n\nwidely used controls, the JavaFX check box is a bit more sophisticated than you may at first \nthink. This is because CheckBox supports three states. The first two are checked or \nunchecked, as you would expect, and this is the default behavior. The third state is \nindeterminate ( also called undefined ). It is typically used to indicate that the state of the \ncheck box has not been set or that it is not relevant to a specific situation. If you need the \nindeterminate state, you will need to explicitly enable it. \n\n\nCheckBox defines two constructors. The first is the default constructor. The second lets you \nspecify a string that identifies the box. It is shown here: \n\nCheckBox ( String str )",
    "CheckBox defines two constructors. The first is the default constructor. The second lets you \nspecify a string that identifies the box. It is shown here: \n\nCheckBox ( String str ) \n\nIt creates a check box that has the text specified by str as a label. As with other \nbuttons, a CheckBox generates an action event when it is selected. \nHere is a program that demonstrates check boxes. It displays check boxes that let the user \nselect various deployment options, which are Web, Desktop, and Mobile. Each time a check \nbox state changes, an action event is generated and handled by displaying the new state \n( selected or cleared ) and by displaying a list of all selected boxes. \n\n\n\n\n\n\nSample output is shown here:",
    "Sample output is shown here: \n\nThe operation of this program is straightforward. Each time a check box is changed, an \naction command is generated. To determine if the box is checked or unchecked, the \nisSelected ( ) method is called. \nAs mentioned, by default, CheckBox implements two states: checked and unchecked. If you \nwant to add the indeterminate state, it must be explicitly enabled. To do this, call \nsetAllowIndeterminate ( ) , shown here: \n\nfinal void setAllowIndeterminate ( boolean enable ) \n\nIn this case, if enable is true , the indeterminate state is enabled. Otherwise, it is \ndisabled. When the indeterminate state is enabled, the user can select between \nchecked, unchecked, and indeterminate. \nYou can determine if a check box is in the indeterminate state by calling isIndeterminate ( \n) , shown here: \n\nfinal boolean isIndeterminate ( )",
    "final boolean isIndeterminate ( ) \n\nIt returns true if the checkbox state is indeterminate and false otherwise. \nYou can see the effect of a three-state check box by modifying the preceding program. First, \nenable the indeterminate state on the check boxes by calling setAllowIndeterminate ( ) \non each check box, as shown here: \n\nNext, handle the indeterminate state inside the action event handlers. For example, here is \n\nthe modified handler for cbWeb : \n\n\nNow, all three states are tested. Update the other two handlers in the same way. After \nmaking these changes, the indeterminate state can be selected, as this sample output shows: \n\nHere, the Web check box is indeterminate. \n\nListView",
    "Here, the Web check box is indeterminate. \n\nListView \n\nAnother commonly used control is the list view, which in JavaFX is encapsulated by \nListView . List views are controls that display a list of entries from which you can select one \nor more. Because of their ability to make efficient use of limited screen space, list views are \npopular alternatives to other types of selection controls. \nListView is a generic class that is declared like this: \n\nclass ListView<T> \n\nHere, T specifies the type of entries stored in the list view. Often, these are entries \nof type String , but other types are also allowed. \n\nListView defines two constructors. The first is the default constructor, which creates an \nempty ListView . The second lets you specify the list of entries in the list. It is shown here: \n\nListView ( ObservableList<T> list )",
    "ListView ( ObservableList<T> list ) \n\nHere, list specifies a list of the items that will be displayed. It is an object of type \nObservableList , which defines a list of observable objects. It inherits \njava.util.List . Thus, it supports the standard collection methods. \n\n\nObservableList is packaged in javafx.collections . \nProbably the easiest way to create an ObservableList for use in a ListView is to use the \nfactory method observableArrayList ( ) , which is a static method defined by the \nFXCollections class ( which is also packaged in javafx.collections ). The version we will \nuse is shown here: \n\nstatic <E> ObservableList<E> observableArrayList ( E \u2026 elements )",
    "static <E> ObservableList<E> observableArrayList ( E \u2026 elements ) \n\nIn this case, E specifies the type of elements, which are passed via elements . \nBy default, a ListView allows only one item in the list to be selected at any one time. \nHowever, you can allow multiple selections by changing the selection mode. For now, we \nwill use the default, single-selection model. \nAlthough ListView provides a default size, sometimes you will want to set the preferred \nheight and/or width to best match your needs. One way to do this is to call the \nsetPrefHeight ( ) and setPrefWidth ( ) methods, shown here: \n\nfinal void setPrefHeight ( double height ) \n\nfinal void setPrefWidth ( double width ) \n\nAlternatively, you can use a single call to set both dimensions at the same time by \nuse of setPrefSize ( ) , shown here: \n\nvoid setPrefSize ( double width , double height )",
    "Alternatively, you can use a single call to set both dimensions at the same time by \nuse of setPrefSize ( ) , shown here: \n\nvoid setPrefSize ( double width , double height ) \n\nThere are two basic ways in which you can use a ListView . First, you can ignore \nevents generated by the list and simply obtain the selection in the list when your \nprogram needs it. Second, you can monitor the list for changes by registering a \nchange listener. This lets you respond each time the user changes a selection in the \nlist. This is the approach used here. \nTo listen for change events, you must first obtain the selection model used by the ListView . \nThis is done by calling getSelectionModel ( ) on the list. It is shown here: \n\nfinal MultipleSelectionModel<T> getSelectionModel ( )",
    "final MultipleSelectionModel<T> getSelectionModel ( ) \n\nIt returns a reference to the model. MultipleSelectionModel is a class that \ndefines the model used for multiple selections, and it inherits SelectionModel . \nHowever, multiple selections are allowed in a ListView only if multiple-selection \nmode is turned on. \nUsing the model returned by getSelectionModel ( ) , you will obtain a reference to the \n\nselected item property that defines what takes place when an element in the list is selected. \nThis is done by calling selectedItemProperty ( ) , shown next: \n\nfinal ReadOnlyObjectProperty<T> selectedItemProperty ( ) \n\nYou will add the change listener to this property. \nThe following example puts the preceding discussion into action. It creates a list view that \ndisplays various types of transportation, allowing the user to select one. When one is \n\n\nchosen, the selection is displayed. \n\n\n\n\nSample output is shown here:",
    "chosen, the selection is displayed. \n\n\n\n\nSample output is shown here: \n\nIn the program, pay special attention to how the ListView is constructed. First, an \nObservableList is created by this line: \n\nIt uses the observableArrayList ( ) method to create a list of strings. Then, the \nObservableList is used to initialize a ListView , as shown here: \n\nThe program then sets the preferred width and height of the control. \nNow, notice how the selection model is obtained for lvTransport : \n\nAs explained, ListView uses MultipleSelectionModel , even when only a single selection \nis allowed. The selectedItemProperty ( ) method is then called on the model and a \nchange listener is registered to the returned item. \n\nListView Scrollbars",
    "ListView Scrollbars \n\nOne very useful feature of ListView is that when the number of items in the list exceeds the \nnumber that can be displayed within its dimensions, scrollbars are automatically added. For \nexample, if you change the declaration of transportTypes so that it includes \"Bicycle\" and \n\"Walking\", as shown here: \n\nthe lvTransport control now looks like the one shown here: \n\n\nEnabling Multiple Selections \n\nIf you want to allow more than one item to be selected, you must explicitly request it. To do \nso, you must set the selection mode to SelectionMode.MULTIPLE by calling \nsetSelectionMode ( ) on the ListView model. It is shown here: \n\nfinal void setSelectionMode ( SelectionMode mode )",
    "final void setSelectionMode ( SelectionMode mode ) \n\nIn this case, mode must be either SelectionMode.MULTIPLE or \nSelectionMode.SINGLE . \nWhen multiple-selection mode is enabled, you can obtain the list of the selections two ways: \nas a list of selected indices or as a list of selected items. We will use a list of selected items, \nbut the procedure is similar when using a list of the indices of the selected items. ( Note, \nindexing of items in a ListView begins at zero.) \nTo get a list of the selected items, call getSelectedItems ( ) on the selection model. It is \nshown here: \n\nObservableList<T> getSelectedItems ( )",
    "ObservableList<T> getSelectedItems ( ) \n\nIt returns an ObservableList of the items. Because ObservableList extends \njava.util.List , you can access the items in the list just as you would any other \nList collection. \nTo experiment with multiple selections, you can modify the preceding program as follows. \nFirst, make lvTransport final so it can be accessed within the change event handler. Next, \nadd this line: \n\nIt enables multiple-selection mode for lvTransport . Finally, replace the change event \nhandler with the one shown here: \n\n\nAfter making these changes, the program will display all selected forms of transports, as the \nfollowing output shows: \n\nComboBox \n\nA control related to the list view is the combo box, which is implemented in JavaFX by the",
    "ComboBox \n\nA control related to the list view is the combo box, which is implemented in JavaFX by the \n\nComboBox class. A combo box displays one selection, but it will also display a drop-down \nlist that allows the user to select a different item. You can also allow the user to edit a \nselection. ComboBox inherits ComboBoxBase , which provides much of its functionality. \nUnlike the ListView , which can allow multiple selections, ComboBox is designed for \nsingle-selection. \nComboBox is a generic class that is declared like this: \n\nclass ComboBox<T> \n\nHere, T specifies the type of entries. Often, these are entries of type String , but \nother types are also allowed. \nComboBox defines two constructors. The first is the default constructor, which creates an \nempty ComboBox . The second lets you specify the list of entries. It is shown here: \n\nComboBox ( ObservableList<T> list )",
    "ComboBox ( ObservableList<T> list ) \n\n\nIn this case, list specifies a list of the items that will be displayed. It is an object of \ntype ObservableList , which defines a list of observable objects. As explained in \nthe previous section, ObservableList inherits java.util.List . As also previously \nexplained, an easy way to create an ObservableList is to use the factory method \nobservableArrayList ( ) , which is a static method defined by the \nFXCollections class. \nA ComboBox generates an action event when its selection changes. It will also generate a \nchange event. Alternatively, it is also possible to ignore events and simply obtain the current \nselection when needed. \nYou can obtain the current selection by calling getValue ( ) , shown here: \n\nfinal T getValue ( ) \n\nIf the value of a combo box has not yet been set ( by the user or under program \ncontrol ), then getValue ( ) will return null . To set the value of a ComboBox \nunder program control, call setValue ( ) :",
    "final void setValue ( T newVal ) \n\nHere, newVal becomes the new value. \nThe following program demonstrates a combo box by reworking the previous list view \nexample. It handles the action event generated by the combo box. \n\n\n\n\nSample output is shown here: \n\nAs mentioned, ComboBox can be configured to allow the user to edit a selection. \nAssuming that it contains only entries of type String , it is easy to enable editing \ncapabilities. Simply call setEditable ( ) , shown here: \n\nfinal void setEditable ( boolean enable ) \n\nIf enable is true , editing is enabled. Otherwise, it is disabled. To see the effects of \nediting, add this line to the preceding program:",
    "final void setEditable ( boolean enable ) \n\nIf enable is true , editing is enabled. Otherwise, it is disabled. To see the effects of \nediting, add this line to the preceding program: \n\n\nAfter making this addition, you will be able to edit the selection. \nComboBox supports many additional features and functionality beyond those mentioned \nhere. You might find it interesting to explore further. Also, an alternative to a combo box in \nsome cases is the ChoiceBox control. You will find it easy to use because it is has \nsimilarities to both ListView and ComboBox . \n\nTextField",
    "Although the controls discussed earlier are quite useful and are frequently found in a user \ninterface, they all implement a means of selecting a predetermined option or action. \nHowever, sometimes you will want the user to enter a string of his or her own choosing. To \naccommodate this type of input, JavaFX includes several text-based controls. The one we \nwill look at is TextField . It allows one line of text to be entered. Thus, it is useful for \nobtaining names, ID strings, addresses, and the like. Like all text controls, TextField \ninherits TextInputControl , which defines much of its functionality. \nTextField defines two constructors. The first is the default constructor, which creates an \nempty text field that has the default size. The second lets you specify the initial contents of \nthe field. Here, we will use the default constructor. \nAlthough the default size is sometimes adequate, often you will want to specify its size",
    ". The second lets you specify the initial contents of \nthe field. Here, we will use the default constructor. \nAlthough the default size is sometimes adequate, often you will want to specify its size. This \nis done by calling setPrefColumnCount ( ) , shown here:",
    "final void setPrefColumnCount ( int columns ) \n\nThe columns value is used by TextField to determine its size. \nYou can set the text in a text field by calling setText ( ) . You can obtain the current text by \ncalling getText ( ) . In addition to these fundamental operations, TextField supports \nseveral other capabilities that you might want to explore, such as cut, paste, and append. \nYou can also select a portion of the text under program control. \nOne especially useful TextField option is the ability to set a prompting message inside the \ntext field when the user attempts to use a blank field. To do this, call setPromptText ( ) , \nshown here: \n\nfinal void setPromptText ( String str ) \n\nIn this case, str is the string displayed in the text field when no text has been \nentered. It is displayed using low-intensity ( such as a gray tone ). \nWhen the user presses enter while inside a TextField , an action event is generated.",
    "Although handling this event is often helpful, in some cases, your program will simply \nobtain the text when it is needed, rather than handling action events. Both approaches are \ndemonstrated by the following program. It creates a text field that requests a search string. \nWhen the user presses enter while the text field has input focus, or presses the Get Search \nString button, the string is obtained and displayed. Notice that a prompting message is also \nincluded. \n\n\n\n\nSample output is shown here: \n\nOther text controls that you will want to examine include TextArea , which supports \nmultiline text, and PasswordField , which can be used to input passwords. You might also \n\nfind HTMLEditor helpful. \n\nScrollPane \n\nSometimes, the contents of a control will exceed the amount of screen space that you want \nto give to it. Here are two examples: A large image may not fit within reasonable",
    "ScrollPane \n\nSometimes, the contents of a control will exceed the amount of screen space that you want \nto give to it. Here are two examples: A large image may not fit within reasonable \n\nboundaries, or you might want to display text that is longer than will fit within a small \n\n\nwindow. Whatever the reason, JavaFX makes it easy to provide scrolling capabilities to any \nnode in a scene graph. This is accomplished by wrapping the node in a ScrollPane . When \na ScrollPane is used, scrollbars are automatically implemented that scroll the contents of \nthe wrapped node. No further action is required on your part. Because of the versatility of \nScrollPane , you will seldom need to use individual scrollbar controls. \nScrollPane defines two constructors. The first is the default constructor. The second lets \nyou specify a node that you want to scroll. It is shown here: \n\nScrollPane ( Node content )",
    "ScrollPane ( Node content ) \n\nIn this case, content specifies the information to be scrolled. When using the \ndefault constructor, you will add the node to be scrolled by calling setContent ( ) . \nIt is shown here: \n\nfinal void setContent ( Node content ) \n\nAfter you have set the content, add the scroll pane to the scene graph. When \ndisplayed, the content can be scrolled. \n\nNOTE You can also use setContent ( ) to change the content being \nscrolled by the scroll pane. Thus, what is being scrolled can be changed \nduring the execution of your program.",
    "NOTE You can also use setContent ( ) to change the content being \nscrolled by the scroll pane. Thus, what is being scrolled can be changed \nduring the execution of your program. \n\nAlthough a default size is provided, as a general rule, you will want to set the dimensions of \nthe viewport . The viewport is the viewable area of a scroll pane. It is the area in which the \ncontent being scrolled is displayed. Thus, the viewport displays the visible portion of the \ncontent. The scrollbars scroll the content through the viewport. Thus, by moving a scrollbar, \nyou change what part of the content is visible. \nYou can set the viewport dimensions by using these two methods: \n\nfinal void setPrefViewportHeight ( double height ) \n\nfinal void setPrefViewportWidth ( double width )",
    "final void setPrefViewportHeight ( double height ) \n\nfinal void setPrefViewportWidth ( double width ) \n\nIn its default behavior, a ScrollPane will dynamically add or remove a scrollbar \nas needed. For example, if the component is taller than the viewport, a vertical \nscrollbar is added. If the component will completely fit within the viewport, the \nscrollbars are removed. \n\nOne nice feature of ScrollPane is its ability to pan the contents by dragging the mouse. By \ndefault, this feature is off. To turn it on, use setPannable ( ) , shown here: \n\nfinal void setPannable ( boolean enable ) \n\n\nIf enable is true , then panning is allowed. Otherwise, it is disabled. \nYou can set the position of the scrollbars under program control using setHvalue ( ) and \nsetVvalue ( ) , shown here: \n\nfinal void setHvalue ( double newHval ) \n\nfinal void setVvalue ( double newVval )",
    "final void setHvalue ( double newHval ) \n\nfinal void setVvalue ( double newVval ) \n\nThe new horizontal position is specified by newHval , and the new vertical position \nis specified by newVval . Be default, scrollbar positions start at zero. \nScrollPane supports various other options. For example, it is possible to set the minimum \nand maximum scrollbar positions. You can also specify when and if the scrollbars are shown \nby setting a scrollbar policy. The current position of the scrollbars can be obtained by calling \ngetHvalue ( ) and getVvalue ( ) . \nThe following program demonstrates ScrollPane by using one to scroll the contents of a \nmultiline label. Notice that it also enables panning. \n\n\n\n\nSample output is shown here: \n\nTreeView \n\nOne of JavaFX\u2019s most powerful controls is the TreeView . It presents a hierarchical view of",
    "data in a tree-like format. In this context, the term hierarchical means some items are \nsubordinate to others. For example, a tree is commonly used to display the contents of a file \nsystem. In this case, the individual files are subordinate to the directory that contains them. \nIn a TreeView , branches can be expanded or collapsed on demand by the user. This allows \nhierarchical data to be presented in a compact, yet expandable form. Although TreeView \nsupports many customization options, you will often find that the default tree style and \ncapabilities are suitable. Therefore, even though trees support a sophisticated structure, they \nare still quite easy to work with. \nTreeView implements a conceptually simple, tree-based data structure. A tree begins with \na single root node that indicates the start of the tree",
    ". \nTreeView implements a conceptually simple, tree-based data structure. A tree begins with \na single root node that indicates the start of the tree. Under the root are one or more child \nnodes There are two types of child nodes: leaf nodes ( also called terminal nodes ), which \nhave no children, and branch nodes , which form the root nodes of subtrees . A subtree is \nsimply a tree that is part of a larger tree. The sequence of nodes that leads from the root to a \nspecific node is called a path . \nOne very useful feature of TreeView is that it automatically provides scrollbars when the \nsize of the tree exceeds the dimensions of the view. Although a fully collapsed tree might be \nquite small, its expanded form may be quite large. By automatically adding scrollbars as \nneeded, TreeView lets you use a smaller space than would ordinarily be possible. \nTreeView is a generic class that is defined like this:",
    "class TreeView<T> \n\nHere, T specifies the type of value held by an item in the tree. Often, this will be of \ntype String . TreeView defines two constructors. This is the one we will use: \n\nTreeView ( TreeItem<T> rootNode ) \n\nHere, rootNode specifies the root of the tree. Because all nodes descend from the \n\nroot, it is the only one that needs to be passed to TreeView . \nThe items that form the tree are objects of type TreeItem . At the outset, it is important to \nstate that TreeItem does not inherit Node . Thus, TreeItem s are not general-purpose \nobjects. They can be used in a TreeView , but not as stand-alone controls. TreeItem is a \ngeneric class, as shown here: \n\nclass TreeItem<T>",
    "class TreeItem<T> \n\nHere, T specifies the type of value held by the TreeItem . \nBefore you can use a TreeView , you must construct the tree that it will display. To do this, \nyou must first create the root. Next, add other nodes to that root. You do this by calling \neither add ( ) or addAll ( ) on the list returned by getChildren ( ) . These other nodes can \nbe leaf nodes or subtrees. After the tree has been constructed, you create the TreeView by \n\npassing the root node to its constructor. \nYou can handle selection events in the TreeView in a way similar to the way that you \nhandle them in a ListView , through the use of a change listener. To do so, first, obtain the",
    "selection model by calling getSelectionModel ( ) . Then, call selectedItemProperty ( ) to \nobtain the property for the selected item. On that return value, call addListener ( ) to add \na change listener. Each time a selection is made, a reference to the new selection will be \npassed to the changed ( ) handler as the new value. ( See ListView for more details on \nhandling change events.) \nYou can obtain the value of a TreeItem by calling getValue ( ) . You can also follow the \ntree path of an item in either the forward or backward direction. To obtain the parent, call \ngetParent ( ) . To obtain the children, call getChildren ( ) . \nThe following example shows how to build and use a TreeView . The tree presents a \nhierarchy of food. The type of items stored in the tree are strings. The root is labeled Food. \nUnder it are three direct descendent nodes: Fruit, Vegetables, and Nuts. Under Fruit are \nthree child nodes: Apples, Pears, and Oranges",
    ". The root is labeled Food. \nUnder it are three direct descendent nodes: Fruit, Vegetables, and Nuts. Under Fruit are \nthree child nodes: Apples, Pears, and Oranges. Under Apples are three leaf nodes: Fuji, \nWinesap, and Jonathan. Each time a selection is made, the name of the item is displayed. \nAlso, the path from the root to the item is shown. This is done by the repeated use of \ngetParent ( ) .",
    "Sample output is shown here: \n\n\nThere are two things to pay special attention to in this program. First, notice how the tree is \nconstructed. First, the root node is created by this statement: \n\nNext, the nodes under the root are constructed. These nodes consist of the root nodes of \nsubtrees: one for fruit, one for vegetables, and one for nuts. Next, the leaves are added to \nthese subtrees. However, one of these, the fruit subtree, consists of another subtree that \ncontains varieties of apples. The point here is that each branch in a tree leads either to a leaf \nor to the root of a subtree. After all of the nodes have been constructed, the root nodes of \neach subtree are added to the root node of the tree. This is done by calling add ( ) on the \nroot node. For example, this is how the Nuts subtree is added to tiRoot .",
    "The process is the same for adding any child node to its parent node. \nThe second thing to notice in the program is the way the path from the root to the selected \nnode is constructed within the change event handler. It is shown here:",
    "The code works like this: First, the value of the newly selected node is obtained. In this \nexample, the value will be a string, which is the node\u2019s name. This string is assigned to the \npath string. Then, a temporary variable of type TreeItem<String> is created and \ninitialized to refer to the parent of the newly selected node. If the newly selected node does \nnot have a parent, then tmp will be null. Otherwise, the loop is entered, within which each \nparent\u2019s value ( which is its name in this case ) is added to path . This process continues until \nthe root node of the tree ( which has no parent ) is found. \nAlthough the preceding shows the basic mechanism required to handle a TreeView , it is \nimportant to point out that several customizations and options are supported. TreeView is \na powerful control that you will want to examine fully on your own. \n\nIntroducing Effects and Transforms",
    "Introducing Effects and Transforms \n\nA principal advantage of JavaFX is its ability to alter the precise look of a control ( or any \nnode in the scene graph ) through the application of an effect and/or a transform . Both \neffects and transforms help give your GUI the sophisticated, modern look that users have \ncome to expect. Although it is beyond the scope of this book to examine each effect and \ntransform supported by JavaFX, the following introduction will give you an idea of the \nbenefits they provide. \n\nEffects \n\nEffects are supported by the abstract Effect class and its concrete subclasses, which are \npackaged in javafx.scene.effect . Using these effects, you can customize the way a node in \na scene graph looks. Several built-in effects are provided. Here is a sampling: \n\nBloom \nIncreases the brightness of the brighter parts of a node. \n\nBoxBlur \nBlurs a node. \n\nDropShadow \nDisplays a shadow that appears behind the node. \n\nGlow \nProduces a glowing effect.",
    "Bloom \nIncreases the brightness of the brighter parts of a node. \n\nBoxBlur \nBlurs a node. \n\nDropShadow \nDisplays a shadow that appears behind the node. \n\nGlow \nProduces a glowing effect. \n\nInnerShadow \nDisplays a shadow inside a node. \n\nLighting \nCreates shadow effects of a light source. \n\nReflection \nDisplays a reflection. \n\n\nThese, and the other effects, are easy to use and are available for use by any Node , \nincluding controls. Of course, depending on the control, some effects will be more \nappropriate than others. \nTo set an effect on a node, call setEffect ( ) , which is defined by Node . It is shown here: \n\nfinal void setEffect ( Effect effect )",
    "final void setEffect ( Effect effect ) \n\nHere, effect is the effect that will be applied. To specify no effect, pass null . Thus, \nto add an effect to a node, first create an instance of that effect and then pass it to \nsetEffect ( ) . Once this has been done, the effect will be used whenever the node is \nrendered ( as long as the effect is supported by the environment ). To demonstrate \nthe power of effects, we will use two of them: Glow and InnerShadow . However, \nthe process of adding an effect is essentially the same no matter what effect you \nchoose. \nGlow produces an effect that gives a node a glowing appearance. The amount of glow is \nunder your control. To use a glow effect, you must first create a Glow instance. This is the \nconstructor that we will use: \n\nGlow ( double glowLevel )",
    "Glow ( double glowLevel ) \n\nHere, glowLevel specifies the amount of glowing, which must be a value between \n0.0 and 1.0. \nAfter a Glow instance has been created, the glow level can be changed by using setLevel ( \n) , shown here: \n\nfinal void setLevel ( double glowLevel ) \n\nAs before, glowLevel specifies the glow level, which must be between 0.0 and 1.0. \n\nInnerShadow produces an effect that simulates a shadow on the inside of the node. It \nsupports various constructors. This is the one we will use: \n\nInnerShadow ( double radius , Color shadowColor ) \n\nHere, radius specifies the radius of the shadow inside the node. In essence, the \nradius describes the size of the shadow. The color of the shadow is specified by \nshadowColor . Here, the type Color is the JavaFX type \njavafx.scene.paint.Color . It defines a large number of constants, such as \nColor.GREEN , Color.RED , and Color.BLUE , which makes it easy to use. \n\nTransforms",
    "Transforms \n\nTransforms are supported by the abstract Transform class, which is packaged in \njavafx. - scene.transform . Four of its subclasses are Rotate , Scale , Shear , and \nTranslate . Each does what its name suggests. ( Another subclass is Affine , but typically \nyou will use one or more of the preceding transform classes.) It is possible to perform more \nthan one transform on a node. For example, you could rotate it and scale it. Transforms are \nsupported by the Node class as described next. \n\n\nOne way to add a transform to a node is to add it to the list of transforms maintained by the \nnode. This list is obtained by calling getTransforms ( ) , which is defined by Node . It is \nshown here: \n\nfinal ObservableList<Transform> getTransforms ( )",
    "final ObservableList<Transform> getTransforms ( ) \n\nIt returns a reference to the list of transforms. To add a transform, simply add it to \nthis list by calling add ( ) . You can clear the list by calling clear ( ) . You can use \nremove ( ) to remove a specific element. \nIn some cases, you can specify a transform directly, by setting one of Node \u2019s properties. For \nexample, you can set the rotation angle of a node, with the pivot point being at the center of \nthe node, by calling setRotate ( ) , passing in the desired angle. You can set a scale by using \nsetScaleX ( ) and setScaleY ( ) , and you can translate a node by using setTranslateX ( ) \nand setTranslateY ( ) . ( Z axis translations may also be supported by the platform.) \nHowever, using the transforms list offers the greatest flexibility, and that is the approach \ndemonstrated here. \n\nNOTE Any transforms specified on a node directly will be applied after \nall transforms in the transforms list.",
    "NOTE Any transforms specified on a node directly will be applied after \nall transforms in the transforms list. \n\nTo demonstrate the use of transforms, we will use the Rotate and Scale classes. The other \ntransforms are used in the same general way. Rotate rotates a node around a specified \npoint. It defines several constructors. Here is one example: \n\nRotate ( double angle , double x , double y ) \n\nHere, angle specifies the number of degrees to rotate. The center of rotation, called \nthe pivot point , is specified by x and y . It is also possible to use the default \nconstructor and set these values after a Rotate object has been created, which is \nwhat the following demonstration program will do. This is done by using the \nsetAngle ( ) , setPivotX ( ) , and setPivotY ( ) methods, shown here: \n\nfinal void setAngle ( double angle ) \n\nfinal void setPivotX ( double x ) \n\nfinal void setPivotY ( double y )",
    "final void setAngle ( double angle ) \n\nfinal void setPivotX ( double x ) \n\nfinal void setPivotY ( double y ) \n\nAs before, angle specifies the number of degrees to rotate and the center of \nrotation is specified by x and y . \nScale scales a node as specified by a scale factor. Scale defines several constructors. This is \nthe one we will use: \n\n\nScale ( double widthFactor , double heightFactor ) \n\nHere, widthFactor specifies the scaling factor applied to the node\u2019s width, and \nheightFactor specifies the scaling factor applied to the node\u2019s height. These factors \ncan be changed after a Scale instance has been created by using setX ( ) and \nsetY ( ) , shown here: \n\nfinal void setX ( double widthFactor ) \n\nfinal void setY ( double heightFactor ) \n\nAs before, widthFactor specifies the scaling factor applied to the node\u2019s width, and \nheightFactor specifies the scaling factor applied to the node\u2019s height. \n\nDemonstrating Effects and Transforms",
    "As before, widthFactor specifies the scaling factor applied to the node\u2019s width, and \nheightFactor specifies the scaling factor applied to the node\u2019s height. \n\nDemonstrating Effects and Transforms \n\nThe following program demonstrates the use of effects and transforms. It does so by \ncreating four buttons called Rotate, Scale, Glow, and Shadow. Each time one of these \nbuttons is pressed, the corresponding effect or transform is applied to the button. Sample \noutput is shown here: \n\nWhen you examine the program, you will see how easy it is to customize the look of your \nGUI. You might find it interesting to experiment with it, trying different transforms or \neffects, or trying the effects on different types of nodes other than buttons. \n\n\n\n\nBefore leaving the topic of effects and transforms, it is useful to mention that several of",
    "Before leaving the topic of effects and transforms, it is useful to mention that several of \n\n\nthem are particularly pleasing when used on a Text node. Text is a class packaged in \njavafx.scene.text . It creates a node that consists of text. Because it is a node, the text can \nbe easily manipulated as a unit and various effects and transforms can be applied. \n\nAdding Tooltips \n\nOne very popular element in the modern GUI is the tooltip . A tooltip is a short message that \nis displayed when the mouse hovers over a control. In JavaFX, a tooltip can be easily added \nto any control. Frankly, because of the benefits that tooltips offer and the ease by which they \ncan be incorporated into your GUI, there is virtually no reason not to use them where \nappropriate. \nTo add a tooltip, you call the setTooltip ( ) method defined by Control . ( Control is a \nbase class for all controls.) The setTooltip ( ) method is shown here:",
    "final void setTooltip ( Tooltip tip ) \n\nIn this case, tip is an instance of Tooltip , which specifies the tooltip. Once a \ntooltip has been set, it is automatically displayed when the mouse hovers over the \ncontrol. No other action is required on your part. \nThe Tooltip class encapsulates a tooltip. This is the constructor that we will use: \n\nTooltip ( String str ) \n\nHere, str specifies the message that will be displayed by the tooltip. \nTo see tooltips in action, try adding the following statements to the CheckboxDemo \nprogram shown earlier. \n\nAfter these additions, the tooltips will be displayed for each check box. \n\nDisabling a Control \n\nBefore leaving the subject of controls, it is useful to describe one more feature. Any node in \nthe scene graph, including a control, can be disabled under program control. To disable a \ncontrol, use setDisable ( ) , defined by Node . It is shown here: \n\nfinal void setDisable ( boolean disable )",
    "final void setDisable ( boolean disable ) \n\nIf disable is true , the control is disabled ; otherwise, it is enabled. Thus, using \nsetDisable ( ) , you can disable a control and then enable it later. \n\n\uf709 \nPREV \n\u23ee \n\nNEXT \nChapter 36: Introducing JavaFX Menus \u23ed \n\n\nChapter 34: Introducing JavaFX GUI Programming \n\n\nPREV \nChapter 35: Exploring JavaFX Controls \n\u23ee \n\nNEXT \nPart V: Applying Java \u23ed \n\nCHAPTER \n\n36 \nIntroducing JavaFX Menus",
    "PREV \nChapter 35: Exploring JavaFX Controls \n\u23ee \n\nNEXT \nPart V: Applying Java \u23ed \n\nCHAPTER \n\n36 \nIntroducing JavaFX Menus \n\nMenus are an important part of many GUIs because they give the user access to a program\u2019s \ncore functionally. Furthermore, the proper implementation of an application\u2019s menus is a \nnecessary part of creating a successful GUI. Because of the key role they play in many \napplications, JavaFX provides extensive support for menus. Fortunately, JavaFX\u2019s approach \nto menus is both powerful and streamlined. \nAs you will see throughout the course of this chapter, JavaFX menus have several parallels \nwith Swing menus, which were described in Chapter 33. As a result, if you already know \nhow to create Swing menus, learning how to create menus in JavaFX is easy. That said, \nthere are also several differences, so it is important not to jump to conclusions about the \nJavaFX menu system. \nThe JavaFX menu system supports several key elements, including",
    "\u2022  The menu bar, which is the main menu for an application. \n\n\u2022  The standard menu, which can contain either items to be selected or other \nmenus ( submenus ). \n\n\u2022  The context menu, which is often activated by right-clicking the mouse. \n\nContext menus are also called popup menus. \n\nJavaFX menus also support accelerator keys , which enable menu items to be \nselected without having to activate the menu, and mnemonics , which allow a menu \nitem to be selected by the keyboard once the menu options are displayed. In \naddition to \u201cnormal\u201d menus, JavaFX also supports the toolbar , which provides \nrapid access to program functionality, often paralleling menu items. \n\nMenu Basics",
    "Menu Basics \n\nThe JavaFX menu system is supported by a group of related classes packaged in \njavafx.scene.control . The ones used in this chapter are shown in Table 36-1, and they \nrepresent the core of the menu system. Although JavaFX allows a high degree of \ncustomization if desired, normally you will simply use the menu classes as-is because their \ndefault look and feel is generally what you will want. \n\n\nTable 36-1    The Core JavaFX Menu Classes",
    "Here is brief overview of how the classes fit together. To create a main menu for an \napplication, you first need an instance of MenuBar . This class is, loosely speaking, a \ncontainer for menus. To the MenuBar you add instances of Menu . Each Menu object \ndefines a menu. That is, each Menu object contains one or more selectable items. The items \ndisplayed by a Menu are objects of type MenuItem . Thus, a MenuItem defines a \nselection that can be chosen by the user. \nIn addition to \u201cstandard\u201d menu items, you can also include check and radio menu items in a \nmenu. Their operation parallels check box and radio button controls. A check menu item is \ncreated by CheckMenuItem . A radio menu item is created by RadioMenuItem . Both of \nthese classes extend MenuItem . \nSeparatorMenuItem is a convenience class that creates a separator line in a menu. It \ninherits CustomMenuItem , which is a class that facilitates embedding other types of \ncontrols in a menu item",
    ". \nSeparatorMenuItem is a convenience class that creates a separator line in a menu. It \ninherits CustomMenuItem , which is a class that facilitates embedding other types of \ncontrols in a menu item. CustomMenuItem extends MenuItem . \nOne key point about JavaFX menus is that MenuItem does not inherit Node . Thus, \ninstances of MenuItem can only be used in a menu. They cannot be otherwise \nincorporated into a scene graph. However, MenuBar does inherit Node , which does allow \nthe menu bar to be added to the scene graph. \nAnother key point is that MenuItem is a superclass of Menu . This allows the creation of \nsubmenus, which are, essentially, menus within menus. To create a submenu, you first \ncreate and populate a Menu object with MenuItem s and then add it to another Menu \nobject. You will see this process in action in the examples that follow. \nWhen a menu item is selected, an action event is generated. The text associated with the \nselection will be the name of the selection",
    ". \nWhen a menu item is selected, an action event is generated. The text associated with the \nselection will be the name of the selection. Thus, when using one action event handler to \nprocess all menu selections, one way you can determine which item was selected is by",
    "examining the name. Of course, you can also use separate anonymous inner classes or \n\nlambda expressions to handle each menu item\u2019s action events. In this case, the menu \nselection is already known and there is no need to examine the name to determine which \nitem was selected. \nAs an alternative or adjunct to menus that descend from the menu bar, you can also create \nstand-alone, context menus, which pop up when activated. To create a context menu, first",
    "create an object of type ContextMenu . Then, add MenuItem s to it. A context menu is \noften activated by clicking the right mouse button when the mouse is over a control for \nwhich a context menu has been defined. It is important to point out that ContextMenu is \nnot derived from MenuItem . Rather, it inherits PopupControl . \nA feature related to the menu is the toolbar . In JavaFX, toolbars are supported by the \nToolBar class. It creates a stand-alone component that is often used to provide fast access \nto functionality contained within the menus of the application. For example, a toolbar might \nprovide fast access to the formatting commands supported by a word processor. \n\nAn Overview of MenuBar, Menu, and MenuItem",
    "An Overview of MenuBar, Menu, and MenuItem \n\nBefore you can create a menu, you need to know some specifics about MenuBar , Menu , \nand MenuItem . These form the minimum set of classes needed to construct a main menu \nfor an application. MenuItem s are also used by context ( i.e., popup ) menus. Thus, these \nclasses form the foundation of the menu system. \n\nMenuBar",
    "MenuBar \n\nMenuBar is essentially a container for menus. It is the control that supplies the main \nmenu of an application. Like all JavaFX controls, it inherits Node . Thus, it can be added to \na scene graph. MenuBar has only one constructor, which is the default constructor. \nTherefore, initially, the menu bar will be empty, and you will need to populate it with menus \nprior to use. As a general rule, an application has one and only one menu bar. \nMenuBar defines several methods, but often you will use only one: getMenus ( ) . It \nreturns a list of the menus managed by the menu bar. It is to this list that you will add the \nmenus that you create. The getMenus ( ) method is shown here: \n\nfinal ObservableList<Menu> getMenus ( )",
    "final ObservableList<Menu> getMenus ( ) \n\nA Menu instance is added to this list of menus by calling add ( ) . You can also use \naddAll ( ) to add two or more Menu instances in a single call. The added menus \nare positioned in the bar from left to right, in the order in which they are added. If \nyou want to add a menu at a specific location, then use this version of add ( ) : \n\nvoid add ( int idx , Menu menu ) \n\nHere, menu is added at the index specified by idx . Indexing begins at 0, with 0 \nbeing the left-most menu. \nIn some cases, you might want to remove a menu that is no longer needed. You can do this \nby calling remove ( ) on the ObservableList returned by getMenus ( ) . Here are two of \nits forms: \n\nvoid remove ( Menu menu ) \n\nvoid remove ( int idx ) \n\nHere, menu is a reference to the menu to remove, and idx is the index of the menu \nto remove. Indexing begins at zero.",
    "void remove ( Menu menu ) \n\nvoid remove ( int idx ) \n\nHere, menu is a reference to the menu to remove, and idx is the index of the menu \nto remove. Indexing begins at zero. \n\n\nIt is sometimes useful to obtain a count of the number of items in a menu bar. To do this, \ncall size ( ) on the list returned by getMenus ( ) . \n\nNOTE Recall that ObservableList implements the List collections \ninterface, which gives you access to all the methods defined by List . \n\nOnce a menu bar has been created and populated, it is added to the scene graph in the \nnormal way. \n\nMenu \n\nMenu encapsulates a menu, which is populated with MenuItem s. As mentioned, Menu is \nderived from MenuItem . This means that one Menu can be a selection in another Menu . \nThis enables one menu to be submenu of another. Menu defines three constructors. \nPerhaps the most commonly used is shown here: \n\nMenu ( String name )",
    "Menu ( String name ) \n\nIt creates a menu that has the name specified by name . You can specify an image \nalong with text with this constructor: \n\nMenu ( String name , Node image ) \n\nHere, image specifies the image that is displayed. In all cases, the menu is empty \nuntil menu items are added to it. Finally, you don\u2019t have to give a menu a name \nwhen it is constructed. To create an unnamed menu, you can use the default \nconstructor: \n\nMenu ( ) \n\nIn this case, you can add a name and/or image after the fact by calling setText ( ) \nor setGraphic ( ) . \nEach menu maintains a list of menu items that it contains. To add an item to the menu, add \nitems to this list. To do so, first call getItems ( ) , shown here: \n\nfinal ObservableList<MenuItem> getItems ( )",
    "final ObservableList<MenuItem> getItems ( ) \n\nIt returns the list of items currently associated with the menu. To this list, add \nmenu items by calling either add ( ) or addAll ( ) . Among other actions, you can \nremove an item by calling remove ( ) and obtain the size of the list by calling \nsize ( ) . \nOne other point: You can add a menu separator to the list of menu items, which is an object \nof type SeparatorMenuItem . Separators help organize long menus by allowing you to \n\n\ngroup related items together. A separator can also help set off an important item, such as \nthe Exit selection in a menu. \n\nMenuItem \n\nMenuItem encapsulates an element in a menu. This element can be either a selection \nlinked to some program action, such as Save or Close, or it can cause a submenu to be \ndisplayed. MenuItem defines the following three constructors. \n\nMenuItem ( ) \n\nMenuItem ( String name ) \n\nMenuItem ( String name , Node image )",
    "MenuItem ( ) \n\nMenuItem ( String name ) \n\nMenuItem ( String name , Node image ) \n\nThe first creates an empty menu item. The second lets you specify the name of the \nitem, and the third enables you to include an image. \nA MenuItem generates an action event when selected. You can register an action event \nhandler for such an event by calling setOnAction ( ) , just as you did when handling button \nevents. It is shown again for your convenience: \n\nfinal void setOnAction ( EventHandler<ActionEvent> handler ) \n\nHere, handler specifies the event handler. You can fire an action event on a menu \nitem by calling fire ( ) . \nMenuItem defines several methods. One that is often useful is setDisable ( ) , which you \ncan use to enable or disable a menu item. It is shown here: \n\nfinal void setDisable ( boolean disable ) \n\nIf disable is true , the menu item is disabled and cannot be selected. If disable is",
    "final void setDisable ( boolean disable ) \n\nIf disable is true , the menu item is disabled and cannot be selected. If disable is \n\nfalse , the item is enabled. Using setDisable ( ) , you can turn menu items on or \noff, depending on program conditions. \n\nCreate a Main Menu \n\nAs a general rule, the most commonly used menu is the main menu . This is the menu \ndefined by the menu bar, and it is the menu that defines all ( or nearly all ) of the \nfunctionality of an application. As you will see, JavaFX streamlines the process of creating \nand managing the main menu. Here, you will see how to construct a simple main menu. \nSubsequent sections will show various options. \n\nNOTE As a way of clearly illustrating the similarities and differences \nbetween the Swing and JavaFX menu systems, the examples in this \nchapter rework the menu examples from Chapter 33. If you already know \n\nSwing, you might find it helpful to compare the two different approaches.",
    "Constructing the main menu requires several steps. First, create the MenuBar instance \nthat will hold the menus. Next, construct each menu that will be in the menu bar. In \ngeneral, a menu is constructed by first creating a Menu object and then adding \nMenuItem s to it. After the menus have been created, add them to the menu bar. Then, the \nmenu bar, itself, must be added to the scene graph. Finally, for each menu item, you must \nadd an action event handler that responds to the action event fired when a menu item is \nselected. \nA good way to understand the process of creating and managing menus is to work through \nan example. Here is a program that creates a simple menu bar that contains three menus. \nThe first is a standard File menu that contains Open, Close, Save, and Exit selections. The \nsecond menu is called Options, and it contains two submenus called Colors and Priority. The \nthird menu is called Help, and it has one item: About",
    ". The \nsecond menu is called Options, and it contains two submenus called Colors and Priority. The \nthird menu is called Help, and it has one item: About. When a menu item is selected, the \nname of the selection is displayed in a label.",
    "Sample output is shown here: \n\nLet\u2019s examine, in detail, how the menus in this program are created. First, note that \nMenuDemo uses a BorderPane instance for the root node. BorderPane is similar to \nthe AWT\u2019s BorderLayout discussed in Chapter 26. It defines a window that has five areas: \ntop, bottom, left, right, and center. The following methods set the node assigned to these \nareas: \n\nfinal void setTop ( Node node ) \n\nfinal void setBottom ( Node node ) \n\nfinal void setLeft ( Node node ) \n\nfinal void setRight ( Node node ) \n\nfinal void setCenter ( Node node ) \n\nHere, node specifies the element, such as a control, that will be shown in each \n\nlocation. Later in the program, the menu bar is positioned in the top location and a \nlabel that displays the menu selection is set to the center position. Setting the \nmenu bar to the top position ensures that it will be shown at the top of the",
    "application and will automatically be resized to fit the horizontal width of the \nwindow. This is why BorderPane is used in the menu examples. Of course, other \napproaches, such as using a VBox , are also valid. \nMuch of the code in the program is used to construct the menu bar, its menus, and menu \nitems, and this code warrants a close inspection. First, the menu bar is constructed and a \nreference to it is assigned to mb by this statement: \n\nAt this point, the menu bar is empty. It will be populated by the menus that follow. \nNext, the File menu and its menu entries are created by this sequence: \n\nThe names Open, Close, Save, and Exit will be shown as selections in the menu. The menu \nentries are added to the File menu by this call to addAll ( ) on the list of menu items \nreturned by getItems ( ) :",
    "Recall that getItems ( ) returns the menu items associated with a Menu instance. To add \nmenu items to a menu, you will add them to this list. Notice that a separator is used to \nseparate visually the Exit entry from the others. \nFinally, the File menu is added to the menu bar by this line: \n\nOnce the preceding code sequence completes, the menu bar will contain one entry: File. The \nFile menu will contain four selections in this order: Open, Close, Save, and Exit. \nThe Options menu is constructed using the same basic process as the File menu. However, \nthe Options menu consists of two submenus, Colors and Priority, and a Reset entry. The \nsubmenus are first constructed individually and then added to the Options menu. As \nexplained, because Menu inherits MenuItem , a Menu can be added as an entry into \nanother Menu . This is the way the submenus are created. The Reset item is added last. \n\nThen, the Options menu is added to the menu bar. The Help menu is constructed using the",
    "Then, the Options menu is added to the menu bar. The Help menu is constructed using the \n\n\nsame process. \n\nAfter all of the menus have been constructed, an ActionEvent handler called MEHandler \nis created that will process menu selections. For demonstration purposes, a single handler \nwill process all selections, but in a real-world application, it is often easier to specify a \nseparate handler for each individual selection by using anonymous inner classes or lambda \nexpressions. The ActionEvent handler for the menu items is shown here:",
    "Inside handle ( ) , the target of the event is obtained by calling getTarget ( ) . The returned \nreference is cast to MenuItem , and its name is returned by calling getText ( ) . This string \nis then assigned to name . If name contains the string \"Exit\", the application is terminated \nby calling Platform.exit ( ) . Otherwise, the name is displayed in the response label. \nBefore continuing, it must be pointed out that a JavaFX application must call \nPlatform.exit ( ) , not System.exit ( ) . The Platform class is defined by JavaFX and \npackaged in javafx.application . Its exit ( ) method causes the stop ( ) life-cycle method \nto be called. System.exit ( ) does not. \nFinally, MEHandler is registered as the action event handler for each menu item by the \nfollowing statements: \n\nNotice that no listeners are added to the Colors or Priority items because they are not \nactually selections. They simply activate submenus. \nFinally, the menu bar is added to the root node by the following line:",
    "This causes the menu bar to be placed at the top of the window. \nAt this point, you might want to experiment a bit with the MenuDemo program. Try \nadding another menu or adding additional items to an existing menu. It is important that \nyou understand the basic menu concepts before moving on because this program will evolve \nthroughout the remainder of this chapter. \n\nAdd Mnemonics and Accelerators to Menu Items",
    "Add Mnemonics and Accelerators to Menu Items \n\nThe menu created in the preceding example is functional, but it is possible to make it better. \nIn real applications, a menu usually includes support for keyboard shortcuts. These come in \ntwo forms: accelerators and mnemonics. An accelerator is a key combination that lets you \nselect a menu item without having to first activate the menu. As it applies to menus, a \nmnemonic defines a key that lets you select an item from an active menu by typing the key. \nThus, a mnemonic allows you to use the keyboard to select an item from a menu that is \nalready being displayed. \nAn accelerator can be associated with a Menu or MenuItem . It is specified by calling \nsetAccelerator ( ) , shown next: \n\nfinal void setAccelerator ( KeyCombination keyComb ) \n\nHere, keyComb is the key combination that is pressed to select the menu item. \nKeyCombination is class that encapsulates a key combination, such as CTRL-S . It is",
    "Here, keyComb is the key combination that is pressed to select the menu item. \nKeyCombination is class that encapsulates a key combination, such as CTRL-S . It is \n\npackaged in javafx.scene.input . \nKeyCombination defines two protected constructors, but often you will use the \nkeyCombination ( ) factory method, shown here: \n\nstatic KeyCombination keyCombination ( String keys ) \n\nIn this case, keys is a string that specifies the key combination. It typically consists \nof a modifier, such as CTRL , ALT , SHIFT , or META , and a letter, such as s. There is a \n\nspecial value, called shortcut , which can be used to specify the CTRL key in a \n\nWindows system and the META key on a Mac. ( It also maps to the typically used \n\nshortcut key on other types of systems.) Therefore, if you want to specify CTRL-S as \n\nthe key combination for Save, then use the string \"shortcut+S\". This way, it will \nwork for both Windows and Mac and elsewhere.",
    "the key combination for Save, then use the string \"shortcut+S\". This way, it will \nwork for both Windows and Mac and elsewhere. \n\nThe following sequence adds accelerators to the File menu created by the MenuDemo \nprogram in the previous section. After making this change, you can directly select a File \nmenu option by pressing CTRL-O , CTRL-C , CTRL-S , or CTRL-E . \n\n\nA mnemonic can be specified for both MenuItem and Menu objects, and it is very easy to \ndo. Simply precede the letter in the name of the menu or menu item with an underscore. \nFor example, in the preceding example, to add the mnemonic F to the File menu, declare \nfileMenu as shown here: \n\nAfter making this change, you can select the File menu by typing ALT then F . However, \n\nmnemonics are active only if mnemonic parsing is true ( as it is by default ). You can turn \nmnemonic parsing on or off by using setMnemonicParsing ( ), shown here: \n\nfinal void setMnemonicParsing ( boolean enable )",
    "final void setMnemonicParsing ( boolean enable ) \n\nIn this case, if enable is true , then mnemonic parsing is turned on. Otherwise, it is \nturned off. \nAfter making these changes, the File menu will now look like this: \n\nAdd Images to Menu Items \n\nYou can add images to menu items or use images instead of text. The easiest way to add an \n\nimage is to specify it when the menu item is being constructed using this constructor: \n\nMenuItem ( String name , Node image ) \n\nIt creates a menu item with the name specified by name and the image specified by \n\n\nimage . For example, here the About menu item is associated with an image when \nit is created. \n\nAfter this addition, the image specified by aboutIV will be displayed next to the text \n\u201cAbout\u201d when the Help menu is displayed, as shown here: \n\nOne last point: You can also add an image to a menu item after the item has been created \n\nby calling setGraphic ( ) . This lets you change the image during program execution.",
    "One last point: You can also add an image to a menu item after the item has been created \n\nby calling setGraphic ( ) . This lets you change the image during program execution. \n\nUse RadioMenuItem and CheckMenuItem \n\nAlthough the type of menu items used by the preceding examples are, as a general rule, the \nmost commonly used, JavaFX defines two others: check menu items and radio menu items. \nThese elements can streamline a GUI by allowing a menu to provide functionality that \nwould otherwise require additional, stand-alone components. Also, sometimes including \ncheck or radio menu items simply seems most natural for a specific set of features. \nWhatever your reason, it is easy to use check and/or radio menu items in menus, and both \nare examined here. \nTo add a check menu item to a menu, use CheckMenuItem . It defines three constructors, \nwhich parallel the ones defined by MenuItem . The one used in this chapter is shown here: \n\nCheckMenuItem ( String name )",
    "CheckMenuItem ( String name ) \n\nHere, name specifies the name of the item. The initial state of the item is \nunchecked. If you want to check a check menu item under program control, call \n\nsetSelected ( ) , shown here: \n\n\nfinal void setSelected ( boolean selected ) \n\nIf selected is true , the menu item is checked. Otherwise, it is unchecked. \nLike stand-alone check boxes, check menu items generate action events when their state is \nchanged. Check menu items are especially appropriate in menus when you have options that \ncan be selected and you want to display their selected/deselected status. \nA radio menu item can be added to a menu by creating an object of type RadioMenuItem . \nRadioMenuItem defines a number of constructors. The one used in this chapter is shown \nhere: \n\nRadioMenuItem ( String name )",
    "It creates a radio menu item that has the name passed in name . The item is not \nselected. As with the case of check menu items, to select a radio menu item, call \nsetSelected ( ) , passing true as an argument. \nRadioMenuItem works like a stand-alone radio button, generating both change and \naction events. Like stand-alone radio buttons, menu radio items must be put into a toggle \ngroup in order for them to exhibit mutually exclusive selection behavior. \nBecause both CheckMenuItem and RadioMenuItem inherit MenuItem , each has all \nof the functionality provided by MenuItem . Aside from having the extra capabilities of \ncheck boxes and radio buttons, they act like and are used like other menu items. \nTo try check and radio menu items, first remove the code that creates the Options menu in \nthe MenuDemo example program. Then substitute the following code sequence, which \nuses check menu items for the Colors submenu and radio menu items for the Priority \nsubmenu.",
    "After making the substitution, the check menu items in the Colors submenu look like those \nshown here: \n\n\nHere is how the radio menu items in the Priority submenu now look: \n\nCreate a Context Menu \n\nA popular alternative or addition to the menu bar is the popup menu, which in JavaFX is \nreferred to as a context menu . Typically, a context menu is activated by clicking the right \nmouse button when over a control. Popup menus are supported in JavaFX by the \nContextMenu class. The direct superclass of ContextMenu is PopupControl . An \n\nindirect superclass of ContextMenu is javafx.stage.PopupWindow , which supplies \nmuch of its basic functionality. \nContextMenu has two constructors. The one used in this chapter is shown here: \n\n\nContextMenu ( MenuItem \u2026 menuItems )",
    "ContextMenu ( MenuItem \u2026 menuItems ) \n\nHere, menuItems specify the menu items that will constitute the context menu. \nThe second ContextMenu constructor creates an empty menu to which items \nmust be added. \nIn general, context menus are constructed like regular menus. Menu items are created and \nadded to the menu. Menu item selections are also handled in the same way: by handling \naction events. The main difference between a context menu and a regular menu is the \nactivation process. \nTo associate a context menu with a control is amazingly easy. Simply call \nsetContextMenu ( ) on the control, passing in a reference to the menu that you want to \npop up. When you right-click on that control, the associated context menu will be shown. \nThe setContextMenu ( ) method is shown here: \n\nfinal void setContextMenu ( ContextMenu menu )",
    "final void setContextMenu ( ContextMenu menu ) \n\nIn this case, menu specifies the context menu associated with the invoking control. \nTo demonstrate a context menu, we will add one to the MenuDemo program. The context \nmenu will present a standard \u201cEdit\u201d menu that includes the Cut, Copy, and Paste entries. It \nwill be set on a text field control. When the mouse is right-clicked while in the text field, the \ncontext menu will pop up. To begin, create the context menu, as shown here: \n\nThis sequence begins by constructing the MenuItem s that will form the menu. It then \ncreates an instance of ContextMenu called editMenu that contains the items. \nNext, add the action event handler to these menu items, as shown here: \n\nThis finishes the construction of the context menu, but the menu has not yet been associated \nwith a control. \nNow, add the following sequence that creates the text field: \n\n\nNext, set the context menu on the text field:",
    "Next, set the context menu on the text field: \n\nNow, when the mouse is right-clicked over the text field, the context menu will pop up. \nTo add the text field to the program, you must create a flow pane that will hold both the text \nfield and the response label. This pane will then be added to the center of the BorderPane . \nThis step is necessary because only one node can be added to any single location within a \nBorderPane . First, remove this line of code: \n\nReplace it with the following code: \n\nOf course, the menu bar is still added to the top position of the border pane. \nAfter making these changes, when you right-click over the text field, the context menu will \npop up, as shown here: \n\n\nIt is also possible to associate a context menu with a scene. One way to do this is by calling \nsetOnContextMenuRequested ( ) on the root node of the scene. This method is defined \nby Node and is shown here:",
    "Here, eventHandler specifies the handler that will be called when a popup request has been \nreceived for the context menu. In this case, the handler must call the show ( ) method \ndefined by ContextMenu to cause the context menu to be displayed. This is the version we \nwill use: \n\nfinal void show ( Node node , double upperX , double upperY ) \n\nHere, node is the element on which the context menu is linked. The values of \nupperX and upperY define the X,Y location of the upper-left corner of the menu, \nrelative to the screen. Typically, you will pass the screen coordinates at which the \nright-click occurred. To do this, you will call the getScreenX ( ) and \ngetScreenY ( ) methods defined by ContextMenuEvent . They are shown here: \n\nfinal double getScreenX ( ) \n\nfinal double getScreenY ( )",
    "final double getScreenX ( ) \n\nfinal double getScreenY ( ) \n\nThus, you will typically pass the results of these methods to the show ( ) method. \nThe preceding theory can be put into practice by adding the context menu to the root node \nof the scene graph. After doing so, right-clicking anywhere in the scene will cause the menu \nto pop up. To do this, first add the following sequence to the MenuDemo program: \n\n\nSecond, declare rootNode final so that it can be accessed within the anonymous inner \nclass. After you have made these additions and changes, the context menu can be activated \nby clicking the right mouse button anywhere inside the application scene. For example, here \nis the menu displayed after right-clicking in the upper-left portion of the window. \n\nCreate a Toolbar",
    "Create a Toolbar \n\nA toolbar is a component that can serve as both an alternative and as an adjunct to a menu. \nTypically, a toolbar contains a list of buttons that give the user immediate access to various \nprogram options. For example, a toolbar might contain buttons that select various font \noptions, such as bold, italics, highlight, or underline. These options can be selected without \nthe need to drop through a menu. As a general rule, toolbar buttons show images rather \n\nthan text, although either or both are allowed. Furthermore, often tooltips are associated \nwith image-based toolbar buttons. \nIn JavaFX, toolbars are instances of the ToolBar class. It defines the two constructors, \nshown here: \n\nToolBar ( ) \n\nToolBar ( Node \u2026 nodes )",
    "ToolBar ( ) \n\nToolBar ( Node \u2026 nodes ) \n\n\nThe first constructor creates an empty, horizontal toolbar. The second creates a \nhorizontal toolbar that contains the specified nodes, which are usually some form \nof button. If you want to create a vertical toolbar, call setOrientation ( ) on the \ntoolbar. It is shown here: \n\nfinal void setOrientation ( Orientation how )",
    "The value of how must be either Orientation.VERTICAL or \nOrientation.HORIZONTAL . \nYou add buttons ( or other controls ) to a toolbar in much the same way that you add them to \na menu bar: call add ( ) on the reference returned by the getItems ( ) method. Often, \nhowever, it is easier to specify the items in the ToolBar constructor, and that is the \napproach used in this chapter. Once you have created a toolbar, add it to the scene graph. \nFor example, when using a border layout, it could be added to the bottom location. Of \ncourse, other approaches are commonly used. For example, it could be added to a location \ndirectly under the menu bar or at the side of the window. \nTo illustrate a toolbar, we will add one to the MenuDemo program. The toolbar will \npresent three debugging options: Set Breakpoint, Clear Breakpoint, and Resume Execution. \nWe will also add tooltips to the menu items. Recall from the previous chapter, a tooltip is a \nsmall message that describes an item",
    ". \nWe will also add tooltips to the menu items. Recall from the previous chapter, a tooltip is a \nsmall message that describes an item. It is automatically displayed if the mouse hovers over \nthe item for moment. You can add a tooltip to the menu item in the same way as you add it \nto a control: by calling setTooltip ( ) . Tooltips are especially useful when applied to imagebased toolbar controls because sometimes it\u2019s hard to design images that are intuitive to all \nusers. \nFirst, add the following code, which creates the debugging toolbar:",
    "Let\u2019s look at this code closely. First, three buttons are created that correspond to the debug \nactions. Notice that each has an image associated with it. Next, each button deactivates the \ntext display by calling setContentDisplay ( ) . As a point of interest, it would have been \npossible to leave the text displayed, but the toolbar would have had a somewhat \nnonstandard look. ( The text for each button is still needed, however, because it will be used \nby the action event handler for the buttons.) Tooltips are then set for each button. Finally, \nthe toolbar is created, with the buttons specified as the contents. \nNext, add the following sequence, which defines an action event handler for the toolbar \nbuttons: \n\nFinally, add the toolbar to the bottom of the border layout by using this statement: \n\nAfter making these additions, each time the user presses a toolbar button, an action event is",
    "Finally, add the toolbar to the bottom of the border layout by using this statement: \n\nAfter making these additions, each time the user presses a toolbar button, an action event is \n\nfired, and it is handled by displaying the button\u2019s text in the response label. The following \noutput shows the toolbar in action. \n\n\nPut the Entire MenuDemo Program Together",
    "fired, and it is handled by displaying the button\u2019s text in the response label. The following \noutput shows the toolbar in action. \n\n\nPut the Entire MenuDemo Program Together \n\nThroughout the course of this discussion, many changes and additions have been made to \nthe MenuDemo program shown at the start of the chapter. Before concluding, it will be \nhelpful to assemble all the pieces. Doing so not only eliminates any ambiguity about the way \nthe pieces fit together, but it also gives you a complete menu demonstration program that \nyou can experiment with. \nThe following version of MenuDemo includes all of the additions and enhancements \ndescribed in this chapter. For clarity, the program has been reorganized, with separate \nmethods being used to construct the various menus and toolbar. Notice that several of the \nmenu-related variables, such as mb and tbDebug , have been made into instance variables \nso they can be directly accessed by any part of the class.",
    "Continuing Your Exploration of JavaFX \n\nJavaFX represents a major advance in GUI frameworks for Java. It also redefines aspects of \n\nthe Java platform. The preceding three chapters have introduced several of its core features, \nbut there is much left to explore. For example, JavaFX supplies several more controls, such \nas sliders, stand-alone scrollbars, and tables. You will want to experiment with its layouts, \n\nsuch as VBox and Hbox . You will also want to explore, in detail, the various effects in \njavafx.scene.effect and the various transforms in javafx.scene.transform . Another \nexciting class is WebView , which gives you an easy way to integrate web content into a \nscene graph. Frankly, all of JavaFX is worthy of serious study. In many ways, it is charting \nthe future course of Java. \n\n\n\uf709 \nPREV \nChapter 35: Exploring JavaFX Controls \n\u23ee \n\nNEXT \nPart V: Applying Java \u23ed",
    "\uf709 \nPREV \nChapter 35: Exploring JavaFX Controls \n\u23ee \n\nNEXT \nPart V: Applying Java \u23ed \n\n\nPREV \nChapter 36: Introducing JavaFX Menus \n\u23ee \n\nNEXT \nChapter 37: Java Beans \n\u23ed \n\nPART \n\nV \nApplying Java \n\nCHAPTER 37 \n\nJava Beans \n\nCHAPTER 38 \n\nIntroducing \nServlets \n\nAPPENDIX \n\nUsing Java's \nDocumentation \nComments \n\n\uf709 \nPREV \nChapter 36: Introducing JavaFX Menus \n\u23ee \n\nNEXT \nChapter 37: Java Beans \n\u23ed \n\n\nPREV \nPart V: Applying Java \n\u23ee \n\nNEXT \nChapter 38: Introducing Servlets \u23ed \n\nCHAPTER \n\n37 \nJava Beans",
    "This chapter provides an overview of Java Beans. Beans are important because they allow \nyou to build complex systems from software components. These components may be \nprovided by you or supplied by one or more different vendors. Java Beans defines an \narchitecture that specifies how these building blocks can operate together. \nTo better understand the value of Beans, consider the following. Hardware designers have a \nwide variety of components that can be integrated together to construct a system. Resistors, \ncapacitors, and inductors are examples of simple building blocks. Integrated circuits provide \nmore advanced functionality. All of these different parts can be reused. It is not necessary or \npossible to rebuild these capabilities each time a new system is needed. Also, the same \npieces can be used in different types of circuits. This is possible because the behavior of \nthese components is understood and documented",
    ". Also, the same \npieces can be used in different types of circuits. This is possible because the behavior of \nthese components is understood and documented. \nThe software industry has also been seeking the benefits of reusability and interoperability \nof a component-based approach. To realize these benefits, a component architecture is \nneeded that allows programs to be assembled from software building blocks, perhaps \nprovided by different vendors. It must also be possible for a designer to select a component, \nunderstand its capabilities, and incorporate it into an application. When a new version of a \ncomponent becomes available, it should be easy to incorporate this functionality into \nexisting code. Fortunately, Java Beans provides just such an architecture.",
    "What Is a Java Bean? \n\nA Java Bean is a software component that has been designed to be reusable in a variety of \ndifferent environments. There is no restriction on the capability of a Bean. It may perform a \nsimple function, such as obtaining an inventory value, or a complex function, such as \nforecasting the performance of a stock portfolio. A Bean may be visible to an end user. One \nexample of this is a button on a graphical user interface. A Bean may also be invisible to a \nuser. Software to decode a stream of multimedia information in real time is an example of \n\nthis type of building block. Finally, a Bean may be designed to work autonomously on a \nuser\u2019s workstation or to work in cooperation with a set of other distributed components. \nSoftware to generate a pie chart from a set of data points is an example of a Bean that can \n\nexecute locally. However, a Bean that provides real-time price information from a stock or",
    "execute locally. However, a Bean that provides real-time price information from a stock or \n\n\ncommodities exchange would need to work in cooperation with other distributed software \nto obtain its data. \n\nAdvantages of Java Beans \n\nThe following list enumerates some of the benefits that Java Bean technology provides for a \ncomponent developer: \n\n\u2022  A Bean obtains all the benefits of Java\u2019s \u201cwrite-once, run-anywhere\u201d \nparadigm. \n\n\u2022  The properties, events, and methods of a Bean that are exposed to another \napplication can be controlled. \n\n\u2022  Auxiliary software can be provided to help configure a Bean. This software \nis only needed when the design-time parameters for that component are \nbeing set. It does not need to be included in the run-time environment. \n\n\u2022  The state of a Bean can be saved in persistent storage and restored at a \nlater time. \n\n\u2022  A Bean may register to receive events from other objects and can generate \nevents that are sent to other objects.",
    "\u2022  A Bean may register to receive events from other objects and can generate \nevents that are sent to other objects. \n\nIntrospection \n\nAt the core of Java Beans is introspection . This is the process of analyzing a Bean to \ndetermine its capabilities. This is an essential feature of the Java Beans API because it \nallows another application, such as a design tool, to obtain information about a component. \nWithout introspection, the Java Beans technology could not operate. \nThere are two ways in which the developer of a Bean can indicate which of its properties, \nevents, and methods should be exposed. With the first method, simple naming conventions \nare used. These allow the introspection mechanisms to infer information about a Bean. In \nthe second way, an additional class that extends the BeanInfo interface is provided that \nexplicitly supplies this information. Both approaches are examined here. \n\nDesign Patterns for Properties",
    "Design Patterns for Properties \n\nA property is a subset of a Bean\u2019s state. The values assigned to the properties determine the \nbehavior and appearance of that component. A property is set through a setter method. A \nproperty is obtained by a getter method. There are two types of properties: simple and \n\nindexed. \n\nSimple Properties \nA simple property has a single value. It can be identified by the following design patterns, \nwhere N is the name of the property and T is its type: \n\npublic T getN ( ) \n\npublic void setN ( T arg ) \n\n\nA read/write property has both of these methods to access its values. A read-only \nproperty has only a get method. A write-only property has only a set method. \nHere are three read/write simple properties along with their getter and setter methods: \n\nNOTE For a boolean property, a method of the form is PropertyName ( ) \ncan also be used as an accessor.",
    "NOTE For a boolean property, a method of the form is PropertyName ( ) \ncan also be used as an accessor. \n\nIndexed Properties \nAn indexed property consists of multiple values. It can be identified by the following design \npatterns, where N is the name of the property and T is its type: \n\npublic T getN ( int index ); \npublic void setN ( int index , T value ); \n\npublic T[ ] getN ( ); \npublic void setN ( T values [ ]); \n\nHere is an indexed property called data along with its getter and setter methods: \n\n\nDesign Patterns for Events \n\nBeans use the delegation event model that was discussed earlier in this book. Beans can \ngenerate events and send them to other objects. These can be identified by the following \ndesign patterns, where T is the type of the event:",
    "These methods are used to add or remove a listener for the specified event. The \nversion of addTListener ( ) that does not throw an exception can be used to \nmulticast an event, which means that more than one listener can register for the \nevent notification. The version that throws TooManyListenersException \nunicasts the event, which means that the number of listeners can be restricted to \none. In either case, removeTListener ( ) is used to remove the listener. For \nexample, assuming an event interface type called TemperatureListener , a Bean \nthat monitors temperature might supply the following methods: \n\nMethods and Design Patterns \n\nDesign patterns are not used for naming nonproperty methods. The introspection \nmechanism finds all of the public methods of a Bean. Protected and private methods are not \n\n\npresented. \n\nUsing the BeanInfo Interface",
    "presented. \n\nUsing the BeanInfo Interface \n\nAs the preceding discussion shows, design patterns implicitly determine what information is \navailable to the user of a Bean. The BeanInfo interface enables you to explicitly control \nwhat information is available. The BeanInfo interface defines several methods, including \nthese: \n\nPropertyDescriptor[ ] getPropertyDescriptors ( ) \nEventSetDescriptor[ ] getEventSetDescriptors ( ) \nMethodDescriptor[ ] getMethodDescriptors ( )",
    "They return arrays of objects that provide information about the properties, events, \nand methods of a Bean. The classes PropertyDescriptor , \nEventSetDescriptor , and MethodDescriptor are defined within the \njava.beans package, and they describe the indicated elements. By implementing \nthese methods, a developer can designate exactly what is presented to a user, \nbypassing introspection based on design patterns. \nWhen creating a class that implements BeanInfo , you must call that class bname BeanInfo, \nwhere bname is the name of the Bean. For example, if the Bean is called MyBean , then the \ninformation class must be called MyBeanBeanInfo . \nTo simplify the use of BeanInfo , JavaBeans supplies the SimpleBeanInfo class. It \nprovides default implementations of the BeanInfo interface, including the three methods \njust shown. You can extend this class and override one or more of the methods to explicitly \ncontrol what aspects of a Bean are exposed",
    ". You can extend this class and override one or more of the methods to explicitly \ncontrol what aspects of a Bean are exposed. If you don\u2019t override a method, then designpattern introspection will be used. For example, if you don\u2019t override \ngetPropertyDescriptors ( ) , then design patterns are used to discover a Bean\u2019s \nproperties. You will see SimpleBeanInfo in action later in this chapter.",
    "Bound and Constrained Properties \n\nA Bean that has a bound property generates an event when the property is changed. The \nevent is of type PropertyChangeEvent and is sent to objects that previously registered an \ninterest in receiving such notifications. A class that handles this event must implement the \nPropertyChangeListener interface. \nA Bean that has a constrained property generates an event when an attempt is made to \nchange its value. It also generates an event of type PropertyChangeEvent . It too is sent to \n\nobjects that previously registered an interest in receiving such notifications. However, those \nother objects have the ability to veto the proposed change by throwing a \nPropertyVetoException . This capability allows a Bean to operate differently according to \nits run-time environment. A class that handles this event must implement the \nVetoableChangeListener interface. \n\nPersistence",
    "Persistence is the ability to save the current state of a Bean, including the values of a Bean\u2019s \nproperties and instance variables, to nonvolatile storage and to retrieve them at a later time. \nThe object serialization capabilities provided by the Java class libraries are used to provide \npersistence for Beans. \nThe easiest way to serialize a Bean is to have it implement the java.io.Serializable \ninterface, which is simply a marker interface. Implementing java.io.Serializable makes \nserialization automatic. Your Bean need take no other action. Automatic serialization can \nalso be inherited. Therefore, if any superclass of a Bean implements java.io.Serializable , \nthen automatic serialization is obtained. \nWhen using automatic serialization, you can selectively prevent a field from being saved \nthrough the use of the transient keyword. Thus, data members of a Bean specified as \ntransient will not be serialized",
    ". Thus, data members of a Bean specified as \ntransient will not be serialized. \nIf a Bean does not implement java.io.Serializable , you must provide serialization \nyourself, such as by implementing java.io.Externalizable . Otherwise, containers cannot \nsave the configuration of your component.",
    "Customizers \n\nA Bean developer can provide a customizer that helps another developer configure the Bean. \nA customizer can provide a step-by-step guide through the process that must be followed to \nuse the component in a specific context. Online documentation can also be provided. A Bean \ndeveloper has great flexibility to develop a customizer that can differentiate his or her \nproduct in the marketplace. \n\nTable 37-1    The Interfaces in java.beans \n\nThe Java Beans API \n\nThe Java Beans functionality is provided by a set of classes and interfaces in the \n\n\njava.beans package. This section provides a brief overview of its contents. Table 37-1 lists \nthe interfaces in java.beans and provides a brief description of their functionality. Table \n37-2 lists the classes in java.beans . \n\nTable 37-2    The Classes in java.beans \n\n\nAlthough it is beyond the scope of this chapter to discuss all of the classes, four are of",
    "Table 37-2    The Classes in java.beans \n\n\nAlthough it is beyond the scope of this chapter to discuss all of the classes, four are of \n\nparticular interest: Introspector , PropertyDescriptor , EventSetDescriptor , and \nMethodDescriptor . Each is briefly examined here. \n\nIntrospector \n\nThe Introspector class provides several static methods that support introspection. Of most \ninterest is getBeanInfo ( ) . This method returns a BeanInfo object that can be used to \nobtain information about the Bean. The getBeanInfo ( ) method has several forms, \nincluding the one shown here: \n\nstatic BeanInfo getBeanInfo ( Class<?> bean ) throws IntrospectionException \n\nThe returned object contains information about the Bean specified by bean . \n\nPropertyDescriptor",
    "static BeanInfo getBeanInfo ( Class<?> bean ) throws IntrospectionException \n\nThe returned object contains information about the Bean specified by bean . \n\nPropertyDescriptor \n\nThe PropertyDescriptor class describes the characteristics of a Bean property. It supports \nseveral methods that manage and describe properties. For example, you can determine if a \nproperty is bound by calling isBound ( ) . To determine if a property is constrained, call \nisConstrained ( ) . You can obtain the name of a property by calling getName ( ) . \n\nEventSetDescriptor",
    "EventSetDescriptor \n\nThe EventSetDescriptor class represents a Bean event. It supports several methods that \nobtain the methods that a Bean uses to add or remove event listeners, and to otherwise \nmanage events. For example, to obtain the method used to add listeners, call \ngetAddListenerMethod ( ) . To obtain the method used to remove listeners, call \ngetRemoveListenerMethod ( ) . To obtain the type of a listener, call getListenerType ( \n) . You can obtain the name of an event by calling getName ( ) . \n\nMethodDescriptor \n\nThe MethodDescriptor class represents a Bean method. To obtain the name of the \nmethod, call getName ( ) . You can obtain information about the method by calling \ngetMethod ( ) , shown here: \n\nMethod getMethod ( ) \n\nAn object of type Method that describes the method is returned. \n\nA Bean Example",
    "Method getMethod ( ) \n\nAn object of type Method that describes the method is returned. \n\nA Bean Example \n\nThis chapter concludes with an example that illustrates various aspects of Bean \nprogramming, including introspection and using a BeanInfo class. It also makes use of the \n\nIntrospector , PropertyDescriptor , and EventSetDescriptor classes. The example \nuses three classes. The first is a Bean called Colors , shown here: \n\n\n\n\nThe Colors Bean displays a colored object within a frame. The color of the component is \ndetermined by the private Color variable color , and its shape is determined by the private \nboolean variable rectangular . The constructor defines an anonymous inner class that \n\nextends MouseAdapter and overrides its mousePressed ( ) method. The change ( ) \nmethod is invoked in response to mouse presses. It selects a random color and then \nrepaints the component. The getRectangular ( ) and setRectangular ( ) methods provide",
    "access to the one property of this Bean. The change ( ) method calls randomColor ( ) to \n\nchoose a color and then calls repaint ( ) to make the change visible. Notice that the paint ( \n) method uses the rectangular and color variables to determine how to present the Bean. \nThe next class is ColorsBeanInfo . It is a subclass of SimpleBeanInfo that provides \nexplicit information about Colors . It overrides getPropertyDescriptors ( ) in order to \ndesignate which properties are presented to a Bean user. In this case, the only property \nexposed is rectangular . The method creates and returns a PropertyDescriptor object \nfor the rectangular property. The PropertyDescriptor constructor that is used is shown \nhere: \n\nHere, the first argument is the name of the property, and the second argument is \nthe class of the Bean. \n\nThe final class is called IntrospectorDemo . It uses introspection to display the properties \nand events that are available within the Colors Bean.",
    "The final class is called IntrospectorDemo . It uses introspection to display the properties \nand events that are available within the Colors Bean. \n\n\nThe output from this program is the following: \n\nNotice two things in the output. First, because ColorsBeanInfo overrides \ngetPropertyDescriptors ( ) such that the only property returned is rectangular , only \nthe rectangular property is displayed. However, because getEventSetDescriptors ( ) is \nnot overridden by ColorsBeanInfo , design-pattern introspection is used, and all events \n\n\nare found, including those in Colors \u2019 superclass, Canvas . Remember, if you don\u2019t override \n\none of the \u201cget\u201d methods defined by SimpleBeanInfo , then the default, design-pattern \nintrospection is used. To observe the difference that ColorsBeanInfo makes, erase its class \nfile and then run IntrospectorDemo again. This time it will report more properties. \n\n\uf709 \nPREV \nPart V: Applying Java \n\u23ee \n\nNEXT \nChapter 38: Introducing Servlets \u23ed",
    "\uf709 \nPREV \nPart V: Applying Java \n\u23ee \n\nNEXT \nChapter 38: Introducing Servlets \u23ed \n\n\nPREV \nChapter 37: Java Beans \n\u23ee \n\nNEXT \nAppendix: Using Java\u2019s Documentation Comments \n\u23ed \n\nCHAPTER \n\n38 \nIntroducing Servlets \n\nThis chapter presents an introduction to servlets . Servlets are small programs that execute \non the server side of a web connection. Just as applets dynamically extend the functionality \nof a web browser, servlets dynamically extend the functionality of a web server. The topic of \nservlets is quite large, and it is beyond the scope of this chapter to cover it all. Instead, we \nwill focus on the core concepts, interfaces, and classes, and develop several examples. \n\nBackground",
    "In order to understand the advantages of servlets, you must have a basic understanding of \nhow web browsers and servers cooperate to provide content to a user. Consider a request \nfor a static web page. A user enters a Uniform Resource Locator ( URL ) into a browser. The \nbrowser generates an HTTP request to the appropriate web server. The web server maps \nthis request to a specific file. That file is returned in an HTTP response to the browser. The \nHTTP header in the response indicates the type of the content. The Multipurpose Internet \nMail Extensions ( MIME ) are used for this purpose. For example, ordinary ASCII text has a \nMIME type of text/plain. The Hypertext Markup Language ( HTML ) source code of a web \npage has a MIME type of text/html. \nNow consider dynamic content. Assume that an online store uses a database to store \ninformation about its business. This would include items for sale, prices, availability, orders, \nand so forth",
    ". \nNow consider dynamic content. Assume that an online store uses a database to store \ninformation about its business. This would include items for sale, prices, availability, orders, \nand so forth. It wishes to make this information accessible to customers via web pages. The \ncontents of those web pages must be dynamically generated to reflect the latest information \nin the database. \nIn the early days of the Web, a server could dynamically construct a page by creating a \nseparate process to handle each client request. The process would open connections to one",
    "or more databases in order to obtain the necessary information. It communicated with the \nweb server via an interface known as the Common Gateway Interface ( CGI ). CGI allowed the \nseparate process to read data from the HTTP request and write data to the HTTP response. \nA variety of different languages were used to build CGI programs. These included C, C++, \nand Perl. \nHowever, CGI suffered serious performance problems. It was expensive in terms of \n\nprocessor and memory resources to create a separate process for each client request. It was",
    "processor and memory resources to create a separate process for each client request. It was \n\n\nalso expensive to open and close database connections for each client request. In addition, \nthe CGI programs were not platform-independent. Therefore, other techniques were \nintroduced. Among these are servlets. \nServlets offer several advantages in comparison with CGI. First, performance is significantly \nbetter. Servlets execute within the address space of a web server. It is not necessary to create \na separate process to handle each client request. Second, servlets are platform-independent \nbecause they are written in Java. Third, the Java security manager on the server enforces a \nset of restrictions to protect the resources on a server machine. Finally, the full functionality \nof the Java class libraries is available to a servlet. It can communicate with applets, \ndatabases, or other software via the sockets and RMI mechanisms that you have seen \nalready.",
    "Three methods are central to the life cycle of a servlet. These are init ( ) , service ( ) , and \ndestroy ( ) . They are implemented by every servlet and are invoked at specific times by the \nserver. Let us consider a typical user scenario to understand when these methods are called. \nFirst, assume that a user enters a Uniform Resource Locator ( URL ) to a web browser. The \nbrowser then generates an HTTP request for this URL. This request is then sent to the \nappropriate server. \nSecond, this HTTP request is received by the web server. The server maps this request to a \nparticular servlet. The servlet is dynamically retrieved and loaded into the address space of \nthe server. \nThird, the server invokes the init ( ) method of the servlet. This method is invoked only \nwhen the servlet is first loaded into memory. It is possible to pass initialization parameters \nto the servlet so it may configure itself. \nFourth, the server invokes the service ( ) method of the servlet",
    ". It is possible to pass initialization parameters \nto the servlet so it may configure itself. \nFourth, the server invokes the service ( ) method of the servlet. This method is called to \nprocess the HTTP request. You will see that it is possible for the servlet to read data that has \nbeen provided in the HTTP request. It may also formulate an HTTP response for the client. \nThe servlet remains in the server\u2019s address space and is available to process any other HTTP \nrequests received from clients. The service ( ) method is called for each HTTP request. \nFinally, the server may decide to unload the servlet from its memory. The algorithms by \nwhich this determination is made are specific to each server. The server calls the destroy ( ) \nmethod to relinquish any resources such as file handles that are allocated for the servlet. \nImportant data may be saved to a persistent store. The memory allocated for the servlet and \nits objects can then be garbage collected.",
    "Servlet Development Options \n\nTo create servlets, you will need access to a servlet container/server. Two popular ones are \nGlassfish and Tomcat. Glassfish is from Oracle and is provided by the Java EE SDK. It is \nsupported by NetBeans. Tomcat is an open-source product maintained by the Apache \n\nSoftware Foundation. It can also be used by NetBeans. Both Tomcat and Glassfish can also",
    "be used with other IDEs, such as Eclipse. The examples and descriptions in this chapter use \nTomcat for reasons that will soon be apparent. \nAlthough IDEs such as NetBeans and Eclipse are very useful and can streamline the creation \nof servlets, they are not used in this chapter. The way you develop and deploy servlets differs \namong IDEs, and it is simply not possible for this book to address each environment. \nFurthermore, many readers will be using the command-line tools rather than an IDE. \nTherefore, if you are using an IDE, you must refer to the instructions for that environment \nfor information concerning the development and deployment of servlets. For this reason, the \ninstructions given here and elsewhere in this chapter assume that only the command-line \ntools are employed. Thus, they will work for nearly any reader",
    ". For this reason, the \ninstructions given here and elsewhere in this chapter assume that only the command-line \ntools are employed. Thus, they will work for nearly any reader. \nTomcat is used in this chapter because, in the opinion of this author, it makes it relatively \neasy to run the example servlets using only command-line tools and a text editor. It is also \nwidely available in various programming environments. Furthermore, since only commandline tools are used, you don\u2019t need to download and install an IDE just to experiment with \nservlets. Understand, however, that even if you are developing in an environment that uses \nGlassfish, the concepts presented here still apply. It is just that the mechanics of preparing a \nservlet for testing will be slightly different.",
    "REMEMBER The instructions for developing and deploying servlets in \nthis chapter are based on Tomcat and use only command-line tools. If you \nare using an IDE and different servlet container/server, consult the \ndocumentation for your environment. \n\nUsing Tomcat \n\nTomcat contains the class libraries, documentation, and run-time support that you will need \nto create and test servlets. At the time of this writing, several versions of Tomcat are \navailable. The instructions that follow use 7.0.47. You can download Tomcat from \ntomcat.apache.org . You should choose a version appropriate to your environment. \nThe examples in this chapter assume a 64-bit Windows environment. Assuming that a 64bit version of Tomcat 7.0.47 was unpacked from the root directly, the default location is \n\nThis is the location assumed by the examples in this book. If you load Tomcat in a different \nlocation ( or use a different version of Tomcat ), you will need to make appropriate changes",
    "This is the location assumed by the examples in this book. If you load Tomcat in a different \nlocation ( or use a different version of Tomcat ), you will need to make appropriate changes \n\nto the examples. You may need to set the environmental variable JAVA_HOME to the toplevel directory in which the Java Development Kit is installed. \n\n\nNOTE All of the directories shown in this section assume Tomcat 7.0.47. \nIf you install a different version of Tomcat, then you will need to adjust \nthe directory names and paths to match those used by the version you \ninstalled. \n\nOnce installed, you start Tomcat by selecting startup.bat from the bin directly under the \napache-tomcat-7.0.47 directory. To stop Tomcat, execute shutdown.bat , also in the \nbin directory. \nThe classes and interfaces needed to build servlets are contained in servlet-api.jar , which \nis in the following directory:",
    "To make servlet-api.jar accessible, update your CLASSPATH environment variable so \nthat it includes \n\nAlternatively, you can specify this file when you compile the servlets. For example, the \nfollowing command compiles the first servlet example: \n\nOnce you have compiled a servlet, you must enable Tomcat to find it. For our purposes, this \nmeans putting it into a directory under Tomcat\u2019s webapps directory and entering its name \ninto a web.xml file. To keep things simple, the examples in this chapter use the directory \nand web.xml file that Tomcat supplies for its own example servlets. This way, you won\u2019t \nhave to create any files or directories just to experiment with the sample servlets. Here is \nthe procedure that you will follow. \nFirst, copy the servlet\u2019s class file into the following directory: \n\nNext, add the servlet\u2019s name and mapping to the web.xml file in the following directory:",
    "Next, add the servlet\u2019s name and mapping to the web.xml file in the following directory: \n\n\nFor instance, assuming the first example, called HelloServlet , you will add the following \nlines in the section that defines the servlets: \n\nNext, you will add the following lines to the section that defines the servlet mappings: \n\nFollow this same general procedure for all of the examples. \n\nA Simple Servlet \n\nTo become familiar with the key servlet concepts, we will begin by building and testing a \nsimple servlet. The basic steps are the following: \n\n1.  Create and compile the servlet source code. Then, copy the servlet\u2019s class \nfile to the proper directory, and add the servlet\u2019s name and mappings to the \nproper web.xml file. \n\n2.  Start Tomcat. \n\n3.  Start a web browser and request the servlet. \n\nLet us examine each of these steps in detail. \n\nCreate and Compile the Servlet Source Code \n\nTo begin, create a file named HelloServlet.java that contains the following program:",
    "Let\u2019s look closely at this program. First, note that it imports the javax.servlet package. \nThis package contains the classes and interfaces required to build servlets. You will learn \nmore about these later in this chapter. Next, the program defines HelloServlet as a \nsubclass of GenericServlet . The GenericServlet class provides functionality that \nsimplifies the creation of a servlet. For example, it provides versions of init ( ) and destroy ( \n) , which may be used as is. You need supply only the service ( ) method. \nInside HelloServlet , the service ( ) method ( which is inherited from GenericServlet ) is \noverridden. This method handles requests from a client. Notice that the first argument is a \nServletRequest object. This enables the servlet to read data that is provided via the client \nrequest. The second argument is a ServletResponse object. This enables the servlet to \nformulate a response for the client",
    ". This enables the servlet to read data that is provided via the client \nrequest. The second argument is a ServletResponse object. This enables the servlet to \nformulate a response for the client. \nThe call to setContentType ( ) establishes the MIME type of the HTTP response. In this \nprogram, the MIME type is text/html. This indicates that the browser should interpret the \ncontent as HTML source code. \nNext, the getWriter ( ) method obtains a PrintWriter . Anything written to this stream is \nsent to the client as part of the HTTP response. Then println ( ) is used to write some \nsimple HTML source code as the HTTP response. \nCompile this source code and place the HelloServlet.class file in the proper Tomcat \ndirectory as described in the previous section. Also, add HelloServlet to the web.xml file, \nas described earlier.",
    "Start Tomcat \n\nStart Tomcat as explained earlier. Tomcat must be running before you try to execute a \n\nservlet. \n\nStart a Web Browser and Request the Servlet \n\nStart a web browser and enter the URL shown here: \n\n\nAlternatively, you may enter the URL shown here: \n\nThis can be done because 127.0.0.1 is defined as the IP address of the local machine. \nYou will observe the output of the servlet in the browser display area. It will contain the \nstring Hello! in bold type. \n\nThe Servlet API",
    "The Servlet API \n\nTwo packages contain the classes and interfaces that are required to build the servlets \ndescribed in this chapter. These are javax.servlet and javax.servlet.http . They \nconstitute the core of the Servlet API. Keep in mind that these packages are not part of the \nJava core packages. Therefore, they are not included with Java SE. Instead, they are \nprovided by Tomcat. They are also provided by Java EE. \nThe Servlet API has been in a process of ongoing development and enhancement. The \ncurrent servlet specification is version 3.1. However, because changes happen fast in the \nworld of Java, you will want to check for any additions or alterations. This chapter discusses \nthe core of the Servlet API, which will be available to most readers and works with all \nmodern versions of the servlet specification. \n\nThe javax.servlet Package",
    "The javax.servlet Package \n\nThe javax.servlet package contains a number of interfaces and classes that establish the \nframework in which servlets operate. The following table summarizes several key interfaces \nthat are provided in this package. The most significant of these is Servlet . All servlets must \nimplement this interface or extend a class that implements the interface. The \nServletRequest and ServletResponse interfaces are also very important. \n\nInterface \nDescription \n\nServlet \nDeclares life cycle methods for a servlet. \n\nServletConfig \nAllows servlets to get initialization parameters. \n\nServletContext \nEnables servlets to log events and access information about their \n\nenvironment. \n\nServletRequest \nUsed to read data from a client request. \n\nServletResponse \nUsed to write data to a client response. \n\nThe following table summarizes the core classes that are provided in the javax.servlet \npackage: \n\n\nClass \nDescription",
    "ServletResponse \nUsed to write data to a client response. \n\nThe following table summarizes the core classes that are provided in the javax.servlet \npackage: \n\n\nClass \nDescription \n\nGenericServlet \nImplements the Servlet and ServletConfig interfaces. \n\nServletInputStream \nEncapsulates an input stream for reading requests from a \nclient. \n\nServletOutputStream \nEncapsulates an output stream for writing responses to a \nclient. \n\nServletException \nIndicates a servlet error occurred. \n\nUnavailableException \nIndicates a servlet is unavailable. \n\nLet us examine these interfaces and classes in more detail. \n\nThe Servlet Interface \n\nAll servlets must implement the Servlet interface. It declares the init ( ) , service ( ) , and \ndestroy ( ) methods that are called by the server during the life cycle of a servlet. A method \nis also provided that allows a servlet to obtain any initialization parameters. The methods \ndefined by Servlet are shown in Table 38-1.",
    "Table 38-1    The Methods Defined by Servlet \n\nThe init ( ) , service ( ) , and destroy ( ) methods are the life cycle methods of the servlet. \nThese are invoked by the server. The getServletConfig ( ) method is called by the servlet to \nobtain initialization parameters. A servlet developer overrides the getServletInfo ( ) \nmethod to provide a string with useful information ( for example, the version number ). This \nmethod is also invoked by the server. \n\nThe ServletConfig Interface \n\nThe ServletConfig interface allows a servlet to obtain configuration data when it is loaded. \nThe methods declared by this interface are summarized here: \n\nMethod \nDescription \n\n\nServletContext \ngetServletContext ( ) \nReturns the context for this servlet. \n\nString \ngetInitParameter ( String \nparam ) \n\nReturns the value of the initialization parameter named \nparam . \n\nEnumeration<String> \ngetInitParameterNames ( \n) \n\nReturns an enumeration of all initialization parameter \nnames.",
    "Returns the value of the initialization parameter named \nparam . \n\nEnumeration<String> \ngetInitParameterNames ( \n) \n\nReturns an enumeration of all initialization parameter \nnames. \n\nString getServletName ( ) \nReturns the name of the invoking servlet. \n\nThe ServletContext Interface \n\nThe ServletContext interface enables servlets to obtain information about their \nenvironment. Several of its methods are summarized in Table 38-2. \n\nTable 38-2    Various Methods Defined by ServletContext \n\nThe ServletRequest Interface \n\nThe ServletRequest interface enables a servlet to obtain information about a client \nrequest. Several of its methods are summarized in Table 38-3. \n\n\nTable 38-3    Various Methods Defined by ServletRequest \n\nThe ServletResponse Interface \n\nThe ServletResponse interface enables a servlet to formulate a response for a client. \n\nSeveral of its methods are summarized in Table 38-4. \n\nTable 38-4    Various Methods Defined by ServletResponse",
    "Several of its methods are summarized in Table 38-4. \n\nTable 38-4    Various Methods Defined by ServletResponse \n\nThe GenericServlet Class \n\nThe GenericServlet class provides implementations of the basic life cycle methods for a \nservlet. GenericServlet implements the Servlet and ServletConfig interfaces. In \naddition, a method to append a string to the server log file is available. The signatures of \n\n\nthis method are shown here: \n\nvoid log ( String s ) \nvoid log ( String s , Throwable e ) \n\nHere, s is the string to be appended to the log, and e is an exception that occurred. \n\nThe ServletInputStream Class \n\nThe ServletInputStream class extends InputStream . It is implemented by the servlet \ncontainer and provides an input stream that a servlet developer can use to read the data \nfrom a client request. In addition to the input methods inherited from InputStream , a \nmethod is provided to read bytes from the stream. It is shown here:",
    "int readLine ( byte[ ] buffer , int offset , int size ) throws IOException \n\nHere, buffer is the array into which size bytes are placed starting at offset . The \nmethod returns the actual number of bytes read or \u20131 if an end-of-stream \ncondition is encountered. \n\nThe ServletOutputStream Class \n\nThe ServletOutputStream class extends OutputStream . It is implemented by the \nservlet container and provides an output stream that a servlet developer can use to write \ndata to a client response. In addition to the output methods provided by OutputStream , it \nalso defines the print ( ) and println ( ) methods, which output data to the stream. \n\nThe Servlet Exception Classes \n\njavax.servlet defines two exceptions. The first is ServletException , which indicates that \na servlet problem has occurred. The second is UnavailableException , which extends \nServletException . It indicates that a servlet is unavailable. \n\nReading Servlet Parameters",
    "Reading Servlet Parameters \n\nThe ServletRequest interface includes methods that allow you to read the names and \nvalues of parameters that are included in a client request. We will develop a servlet that \nillustrates their use. The example contains two files. A web page is defined in \nPostParameters.html , and a servlet is defined in PostParametersServlet.java . \nThe HTML source code for PostParameters.html is shown in the following listing. It \ndefines a table that contains two labels and two text fields. One of the labels is Employee and \nthe other is Phone. There is also a submit button. Notice that the action parameter of the \n\nform tag specifies a URL. The URL identifies the servlet to process the HTTP POST request.",
    "form tag specifies a URL. The URL identifies the servlet to process the HTTP POST request. \n\n\nThe source code for PostParametersServlet.java is shown in the following listing. The \nservice ( ) method is overridden to process client requests. The getParameterNames ( ) \nmethod returns an enumeration of the parameter names. These are processed in a loop. You \ncan see that the parameter name and value are output to the client. The parameter value is \nobtained via the getParameter ( ) method. \n\n\nCompile the servlet. Next, copy it to the appropriate directory, and update the web.xml file, \n\nas previously described. Then, perform these steps to test this example: \n\n1.  Start Tomcat ( if it is not already running ). \n\n2.  Display the web page in a browser. \n\n3.  Enter an employee name and phone number in the text fields. \n\n4.  Submit the web page. \n\nAfter following these steps, the browser will display a response that is dynamically \n\ngenerated by the servlet.",
    "4.  Submit the web page. \n\nAfter following these steps, the browser will display a response that is dynamically \n\ngenerated by the servlet. \n\nThe javax.servlet.http Package \n\nThe preceding examples have used the classes and interfaces defined in javax.servlet , \nsuch as ServletRequest , ServletResponse , and GenericServlet , to illustrate the basic \nfunctionality of servlets. However, when working with HTTP, you will normally use the \ninterfaces and classes in javax.servlet.http . As you will see, its functionality makes it easy \nto build servlets that work with HTTP requests and responses. \n\n\nThe following table summarizes the interfaces used in this chapter: \n\nInterface \nDescription \n\nHttpServletRequest \nEnables servlets to read data from an HTTP request. \n\nHttpServletResponse \nEnables servlets to write data to an HTTP response. \n\nHttpSession \nAllows session data to be read and written.",
    "HttpServletResponse \nEnables servlets to write data to an HTTP response. \n\nHttpSession \nAllows session data to be read and written. \n\nThe following table summarizes the classes used in this chapter. The most important of \nthese is HttpServlet . Servlet developers typically extend this class in order to process \nHTTP requests. \n\nClass \nDescription \n\nCookie \nAllows state information to be stored on a client machine. \n\nHttpServlet \nProvides methods to handle HTTP requests and responses. \n\nThe HttpServletRequest Interface \n\nThe HttpServletRequest interface enables a servlet to obtain information about a client \nrequest. Several of its methods are shown in Table 38-5. \n\n\nTable 38-5    Various Methods Defined by HttpServletRequest \n\nThe HttpServletResponse Interface \n\nThe HttpServletResponse interface enables a servlet to formulate an HTTP response to a",
    "Table 38-5    Various Methods Defined by HttpServletRequest \n\nThe HttpServletResponse Interface \n\nThe HttpServletResponse interface enables a servlet to formulate an HTTP response to a \n\nclient. Several constants are defined. These correspond to the different status codes that can \nbe assigned to an HTTP response. For example, SC_OK indicates that the HTTP request \nsucceeded, and SC_NOT_FOUND indicates that the requested resource is not available. \nSeveral methods of this interface are summarized in Table 38-6. \n\n\nTable 38-6    Various Methods Defined by HttpServletResponse \n\nThe HttpSession Interface \n\nThe HttpSession interface enables a servlet to read and write the state information that is \nassociated with an HTTP session. Several of its methods are summarized in Table 38-7. All \nof these methods throw an IllegalStateException if the session has already been \ninvalidated. \n\n\nTable 38-7    Various Methods Defined by HttpSession \n\nThe Cookie Class",
    "Table 38-7    Various Methods Defined by HttpSession \n\nThe Cookie Class \n\nThe Cookie class encapsulates a cookie. A cookie is stored on a client and contains state \ninformation. Cookies are valuable for tracking user activities. For example, assume that a \nuser visits an online store. A cookie can save the user\u2019s name, address, and other \ninformation. The user does not need to enter this data each time he or she visits the store. \nA servlet can write a cookie to a user\u2019s machine via the addCookie ( ) method of the \nHttpServletResponse interface. The data for that cookie is then included in the header of \nthe HTTP response that is sent to the browser. \nThe names and values of cookies are stored on the user\u2019s machine. Some of the information \nthat can be saved for each cookie includes the following: \n\n\u2022  The name of the cookie \n\n\u2022  The value of the cookie \n\n\u2022  The expiration date of the cookie \n\n\u2022  The domain and path of the cookie",
    "\u2022  The name of the cookie \n\n\u2022  The value of the cookie \n\n\u2022  The expiration date of the cookie \n\n\u2022  The domain and path of the cookie \n\nThe expiration date determines when this cookie is deleted from the user\u2019s \nmachine. If an expiration date is not explicitly assigned to a cookie, it is deleted \nwhen the current browser session ends. \nThe domain and path of the cookie determine when it is included in the header of an HTTP \nrequest. If the user enters a URL whose domain and path match these values, the cookie is \nthen supplied to the web server. Otherwise, it is not. \nThere is one constructor for Cookie . It has the signature shown here: \n\nCookie ( String name , String value ) \n\nHere, the name and value of the cookie are supplied as arguments to the \nconstructor. The methods of the Cookie class are summarized in Table 38-8. \n\n\nTable 38-8    The Methods Defined by Cookie \n\nThe HttpServlet Class",
    "Table 38-8    The Methods Defined by Cookie \n\nThe HttpServlet Class \n\nThe HttpServlet class extends GenericServlet . It is commonly used when developing \nservlets that receive and process HTTP requests. The methods defined by the HttpServlet \nclass are summarized in Table 38-9. \n\n\nTable 38-9    The Methods Defined by HttpServlet \n\nHandling HTTP Requests and Responses \n\nThe HttpServlet class provides specialized methods that handle the various types of HTTP \nrequests. A servlet developer typically overrides one of these methods. These methods are \ndoDelete ( ) , doGet ( ) , doHead ( ) , doOptions ( ) , doPost ( ) , doPut ( ) , and doTrace ( \n) . A complete description of the different types of HTTP requests is beyond the scope of this \nbook. However, the GET and POST requests are commonly used when handling form input. \nTherefore, this section presents examples of these cases. \n\nHandling HTTP GET Requests",
    "Handling HTTP GET Requests \n\nHere we will develop a servlet that handles an HTTP GET request. The servlet is invoked \nwhen a form on a web page is submitted. The example contains two files. A web page is \ndefined in ColorGet.html , and a servlet is defined in ColorGetServlet.java . The HTML \nsource code for ColorGet.html is shown in the following listing. It defines a form that \ncontains a select element and a submit button. Notice that the action parameter of the form \ntag specifies a URL. The URL identifies a servlet to process the HTTP GET request. \n\nThe source code for ColorGetServlet.java is shown in the following listing. The doGet ( ) \n\n\nmethod is overridden to process any HTTP GET requests that are sent to this servlet. It uses \nthe getParameter ( ) method of HttpServletRequest to obtain the selection that was \nmade by the user. A response is then formulated.",
    "Compile the servlet. Next, copy it to the appropriate directory, and update the web.xml file, \nas previously described. Then, perform these steps to test this example: \n\n1.  Start Tomcat, if it is not already running. \n\n2.  Display the web page in a browser. \n\n3.  Select a color. \n\n4.  Submit the web page. \n\nAfter completing these steps, the browser will display the response that is \ndynamically generated by the servlet. \nOne other point: Parameters for an HTTP GET request are included as part of the URL that \nis sent to the web server. Assume that the user selects the red option and submits the form. \nThe URL sent from the browser to the server is \n\nThe characters to the right of the question mark are known as the query string . \n\nHandling HTTP POST Requests \n\nHere we will develop a servlet that handles an HTTP POST request. The servlet is invoked \nwhen a form on a web page is submitted. The example contains two files. A web page is",
    "Here we will develop a servlet that handles an HTTP POST request. The servlet is invoked \nwhen a form on a web page is submitted. The example contains two files. A web page is \n\ndefined in ColorPost.html , and a servlet is defined in ColorPostServlet.java . \n\n\nThe HTML source code for ColorPost.html is shown in the following listing. It is identical \nto ColorGet.html except that the method parameter for the form tag explicitly specifies \nthat the POST method should be used, and the action parameter for the form tag specifies a \ndifferent servlet. \n\nThe source code for ColorPostServlet.java is shown in the following listing. The doPost ( \n) method is overridden to process any HTTP POST requests that are sent to this servlet. It \nuses the getParameter ( ) method of HttpServletRequest to obtain the selection that \nwas made by the user. A response is then formulated. \n\nCompile the servlet and perform the same steps as described in the previous section to test \n\nit.",
    "Compile the servlet and perform the same steps as described in the previous section to test \n\nit. \n\n\nNOTE Parameters for an HTTP POST request are not included as part of \nthe URL that is sent to the web server. In this example, the URL sent from \nthe browser to the server is \nhttp://localhost:8080/examples/servlets/servlet/ColorPostServlet \n\n. The parameter names and values are sent in the body of the HTTP \nrequest. \n\nUsing Cookies \n\nNow, let\u2019s develop a servlet that illustrates how to use cookies. The servlet is invoked when a \nform on a web page is submitted. The example contains three files as summarized here: \n\nFile \nDescription \n\nAddCookie.html \nAllows a user to specify a value for the cookie named \nMyCookie . \n\nAddCookieServlet.java \nProcesses the submission of AddCookie.html. \n\nGetCookiesServlet.java \nDisplays cookie values.",
    "AddCookieServlet.java \nProcesses the submission of AddCookie.html. \n\nGetCookiesServlet.java \nDisplays cookie values. \n\nThe HTML source code for AddCookie.html is shown in the following listing. This page \ncontains a text field in which a value can be entered. There is also a submit button on the \npage. When this button is pressed, the value in the text field is sent to AddCookieServlet \nvia an HTTP POST request. \n\nThe source code for AddCookieServlet.java is shown in the following listing. It gets the \nvalue of the parameter named \"data\". It then creates a Cookie object that has the name \n\"MyCookie\" and contains the value of the \"data\" parameter. The cookie is then added to the \nheader of the HTTP response via the addCookie ( ) method. A feedback message is then \n\nwritten to the browser.",
    "written to the browser. \n\n\nThe source code for GetCookiesServlet.java is shown in the following listing. It invokes \nthe getCookies ( ) method to read any cookies that are included in the HTTP GET request. \nThe names and values of these cookies are then written to the HTTP response. Observe that \nthe getName ( ) and getValue ( ) methods are called to obtain this information. \n\n\nCompile the servlets. Next, copy them to the appropriate directory, and update the \nweb.xml file, as previously described. Then, perform these steps to test this example: \n\n1.  Start Tomcat, if it is not already running. \n\n2.  Display AddCookie.html in a browser. \n\n3.  Enter a value for MyCookie . \n\n4.  Submit the web page. \n\nAfter completing these steps, you will observe that a feedback message is displayed \nby the browser. \nNext, request the following URL via the browser:",
    "4.  Submit the web page. \n\nAfter completing these steps, you will observe that a feedback message is displayed \nby the browser. \nNext, request the following URL via the browser: \n\nObserve that the name and value of the cookie are displayed in the browser. \nIn this example, an expiration date is not explicitly assigned to the cookie via the \nsetMaxAge ( ) method of Cookie . Therefore, the cookie expires when the browser session \n\nends. You can experiment by using setMaxAge ( ) and observe that the cookie is then saved \n\n\non the client machine. \n\nSession Tracking",
    "HTTP is a stateless protocol. Each request is independent of the previous one. However, in \nsome applications, it is necessary to save state information so that information can be \ncollected from several interactions between a browser and a server. Sessions provide such a \nmechanism. \nA session can be created via the getSession ( ) method of HttpServletRequest . An \nHttpSession object is returned. This object can store a set of bindings that associate names \nwith objects. The setAttribute ( ) , getAttribute ( ) , getAttributeNames ( ) , and \nremoveAttribute ( ) methods of HttpSession manage these bindings. Session state is \nshared by all servlets that are associated with a client. \nThe following servlet illustrates how to use session state. The getSession ( ) method gets \nthe current session. A new session is created if one does not already exist. The \ngetAttribute ( ) method is called to obtain the object that is bound to the name \"date\"",
    ". A new session is created if one does not already exist. The \ngetAttribute ( ) method is called to obtain the object that is bound to the name \"date\". \nThat object is a Date object that encapsulates the date and time when this page was last \naccessed. ( Of course, there is no such binding when the page is first accessed.) A Date \nobject encapsulating the current date and time is then created. The setAttribute ( ) method \nis called to bind the name \"date\" to this object.",
    "When you first request this servlet, the browser displays one line with the current date and \ntime information. On subsequent invocations, two lines are displayed. The first line shows \nthe date and time when the servlet was last accessed. The second line shows the current \ndate and time. \n\n\uf709 \nPREV \nChapter 37: Java Beans \n\u23ee \n\nNEXT \nAppendix: Using Java\u2019s Documentation Comments \n\u23ed \n\n\nPREV \nChapter 38: Introducing Servlets \n\u23ee \n\nNEXT \n\nIndex \u23ed \n\nAPPENDIX \n\nUsing Java\u2019s Documentation Comments",
    "NEXT \nAppendix: Using Java\u2019s Documentation Comments \n\u23ed \n\n\nPREV \nChapter 38: Introducing Servlets \n\u23ee \n\nNEXT \n\nIndex \u23ed \n\nAPPENDIX \n\nUsing Java\u2019s Documentation Comments \n\nAs explained in Part I, Java supports three types of comments. The first two are the // and \nthe /* */ . The third type is called a documentation comment . It begins with the character \nsequence /** . It ends with */ . Documentation comments allow you to embed information \nabout your program into the program itself. You can then use the javadoc utility program \n( supplied with the JDK ) to extract the information and put it into an HTML file. \nDocumentation comments make it convenient to document your programs. You have almost \ncertainly seen documentation generated with javadoc , because that is the way the Java API \nlibrary was documented. \n\nThe javadoc Tags \n\nThe javadoc utility recognizes the following tags: \n\nTag \nMeaning \n\n@author \nIdentifies the author.",
    "The javadoc Tags \n\nThe javadoc utility recognizes the following tags: \n\nTag \nMeaning \n\n@author \nIdentifies the author. \n\n{@code } \nDisplays information as-is, without processing HTML styles, in code \nfont. \n\n@deprecated \nSpecifies that a program element is deprecated. \n\n{@docRoot } \nSpecifies the path to the root directory of the current documentation. \n\n@exception \nIdentifies an exception thrown by a method or constructor. \n\n{@inheritDoc } \nInherits a comment from the immediate superclass. \n\n{@link } \nInserts an in-line link to another topic. \n\n{@linkplain } \nInserts an in-line link to another topic, but the link is displayed in a \nplaintext font. \n\n{@literal } \nDisplays information as-is, without processing HTML styles. \n\n@param \nDocuments a parameter. \n\n@return \nDocuments a method\u2019s return value. \n\n@see \nSpecifies a link to another topic. \n\n\n@serial \nDocuments a default serializable field.",
    "@param \nDocuments a parameter. \n\n@return \nDocuments a method\u2019s return value. \n\n@see \nSpecifies a link to another topic. \n\n\n@serial \nDocuments a default serializable field. \n\n@serialData \nDocuments the data written by the writeObject ( ) or \nwriteExternal ( ) methods. \n\n@serialField \nDocuments an ObjectStreamField component. \n\n@since \nStates the release when a specific change was introduced. \n\n@throws \nSame as @exception . \n\n{@value } \nDisplays the value of a constant, which must be a static field. \n\n@version \nSpecifies the version of a class.",
    "@version \nSpecifies the version of a class. \n\nDocument tags that begin with an \u201cat\u201d sign (@) are called stand-alone tags ( also called \nblock tags ), and they must be used on their own line. Tags that begin with a brace, such as \n{@code } , are called in-line tags, and they can be used within a larger description. You may \nalso use other, standard HTML tags in a documentation comment. However, some tags, \nsuch as headings, should not be used because they disrupt the look of the HTML file \nproduced by javadoc . \nAs it relates to documenting source code, you can use documentation comments to \ndocument classes, interfaces, fields, constructors, and methods. In all cases, the \ndocumentation comment must immediately precede the item being documented. Some tags, \nsuch as @see , @since , and @deprecated , can be used to document any element. Other \ntags apply only to the relevant elements. Each tag is examined next. \n\nNOTE Documentation comments can also be used for documenting a",
    "NOTE Documentation comments can also be used for documenting a \n\npackage and preparing an overview, but the procedures differ from those \nused to document source code. See the javadoc documentation for \ndetails on these uses. \n\n@author \n\nThe @author tag documents the author of a class or interface. It has the following syntax: \n\n@author description \n\nHere, description will usually be the name of the author. You will need to specify \n\nthe -author option when executing javadoc in order for the @author field to be \nincluded in the HTML documentation. \n\n{@code } \n\nThe {@code } tag enables you to embed text, such as a snippet of code, into a comment. \n\n\nThat text is then displayed as-is in code font, without any further processing, such as HTML \nrendering. It has the following syntax: \n\n{@code code-snippet } \n\n@deprecated",
    "That text is then displayed as-is in code font, without any further processing, such as HTML \nrendering. It has the following syntax: \n\n{@code code-snippet } \n\n@deprecated \n\nThe @deprecated tag specifies that a program element is deprecated. It is recommended \nthat you include @see or {@link } tags to inform the programmer about available \nalternatives. The syntax is the following: \n\n@deprecated description \n\nHere, description is the message that describes the deprecation. The \n@deprecated tag can be used in documentation for fields, methods, constructors, \nclasses, and interfaces. \n\n{@docRoot } \n\n{@docRoot } specifies the path to the root directory of the current documentation. \n\n@exception \n\nThe @exception tag describes an exception to a method. It has the following syntax: \n\n@exception exception-name explanation",
    "@exception \n\nThe @exception tag describes an exception to a method. It has the following syntax: \n\n@exception exception-name explanation \n\nHere, the fully qualified name of the exception is specified by exception-name , and \nexplanation is a string that describes how the exception can occur. The \n@exception tag can only be used in documentation for a method or constructor. \n\n{@inheritDoc } \n\nThis tag inherits a comment from the immediate superclass. \n\n{@link } \n\nThe {@link } tag provides an in-line link to additional information. It has the following \nsyntax: \n\n{@link pkg.class#member text } \n\nHere, pkg.class#member specifies the name of a class or method to which a link is \nadded, and text is the string that is displayed. \n\n{@linkplain } \n\nInserts an in-line link to another topic. The link is displayed in plain-text font. Otherwise, it \nis similar to {@link } . \n\n{@literal }",
    "{@linkplain } \n\nInserts an in-line link to another topic. The link is displayed in plain-text font. Otherwise, it \nis similar to {@link } . \n\n{@literal } \n\nThe {@literal } tag enables you to embed text into a comment. That text is then displayed \nas-is, without any further processing, such as HTML rendering. It has the following syntax: \n\n{@literal description } \n\n\nHere, description is the text that is embedded. \n\n@param \n\nThe @param tag documents a parameter. It has the following syntax: \n\n@param parameter-name explanation \n\nHere, parameter-name specifies the name of a parameter. The meaning of that \nparameter is described by explanation . The @param tag can be used only in \ndocumentation for a method or constructor, or a generic class or interface. \n\n@return \n\nThe @return tag describes the return value of a method. It has the following syntax: \n\n@return explanation",
    "@return \n\nThe @return tag describes the return value of a method. It has the following syntax: \n\n@return explanation \n\nHere, explanation describes the type and meaning of the value returned by a \nmethod. The @return tag can be used only in documentation for a method. \n\n@see \n\nThe @see tag provides a reference to additional information. Two commonly used forms \nare shown here: \n\n@see anchor \n@see pkg.class#member text",
    "@see \n\nThe @see tag provides a reference to additional information. Two commonly used forms \nare shown here: \n\n@see anchor \n@see pkg.class#member text \n\nIn the first form, anchor is a link to an absolute or relative URL. In the second \nform, pkg.class#member specifies the name of the item, and text is the text \ndisplayed for that item. The text parameter is optional, and if not used, then the \nitem specified by pkg.class#member is displayed. The member name, too, is \noptional. Thus, you can specify a reference to a package, class, or interface in \naddition to a reference to a specific method or field. The name can be fully \nqualified or partially qualified. However, the dot that precedes the member name \n( if it exists ) must be replaced by a hash character. \n\n@serial \n\nThe @serial tag defines the comment for a default serializable field. It has the following \nsyntax: \n\n@serial description \n\nHere, description is the comment for that field. \n\n@serialData",
    "@serial \n\nThe @serial tag defines the comment for a default serializable field. It has the following \nsyntax: \n\n@serial description \n\nHere, description is the comment for that field. \n\n@serialData \n\nThe @serialData tag documents the data written by the writeObject ( ) and \nwriteExternal ( ) methods. It has the following syntax: \n\n@serialData description \n\n\nHere, description is the comment for that data. \n\n@serialField \n\nFor a class that implements Serializable , the @serialField tag provides comments for an \nObjectStreamField component. It has the following syntax: \n\n@serialField name type description \n\nHere, name is the name of the field, type is its type, and description is the \ncomment for that field. \n\n@since \n\nThe @since tag states that an element was introduced in a specific release. It has the \nfollowing syntax: \n\n@since release \n\nHere, release is a string that designates the release or version in which this feature \nbecame available. \n\n@throws",
    "@since release \n\nHere, release is a string that designates the release or version in which this feature \nbecame available. \n\n@throws \n\nThe @throws tag has the same meaning as the @exception tag. \n\n{@value } \n\n{@value } has two forms. The first displays the value of the constant that it precedes, which \nmust be a static field. It has this form: \n\n{@value } \n\nThe second form displays the value of a specified static field. It has this form: \n\n{@value pkg.class#field } \n\nHere, pkg.class#field specifies the name of the static field. \n\n@version \n\nThe @version tag specifies the version of a class or interface. It has the following syntax: \n\n@version info \n\nHere, info is a string that contains version information, typically a version number, \nsuch as 2.2. You will need to specify the -version option when executing javadoc \nin order for the @version field to be included in the HTML documentation. \n\nThe General Form of a Documentation Comment",
    "The General Form of a Documentation Comment \n\nAfter the beginning /** , the first line or lines become the main description of your class, \n\ninterface, field, constructor, or method. After that, you can include one or more of the \nvarious @ tags. Each @ tag must start at the beginning of a new line or follow one or more \nasterisks ( * ) that are at the start of a line. Multiple tags of the same type should be grouped \n\ntogether. For example, if you have three @see tags, put them one after the other. In-line \n\n\ntags ( those that begin with a brace ) can be used within any description. \nHere is an example of a documentation comment for a class: \n\nWhat javadoc Outputs \n\nThe javadoc program takes as input your Java program\u2019s source file and outputs several \nHTML files that contain the program\u2019s documentation. Information about each class will be \nin its own HTML file. javadoc will also output an index and a hierarchy tree. Other HTML \nfiles can be generated.",
    "An Example that Uses Documentation Comments \n\nFollowing is a sample program that uses documentation comments. Notice the way each \ncomment immediately precedes the item that it describes. After being processed by \njavadoc , the documentation about the SquareNum class will be found in \nSquareNum.html . \n\n\n\n\n\uf709 \nPREV \nChapter 38: Introducing Servlets \n\u23ee \n\nNEXT \n\nIndex \u23ed \n\n\nPREV \nAppendix: Using Java\u2019s Documentation Comments \n\u23ee \n\nIndex \n\n& \nbitwise AND \nBoolean logical AND \nand bounded type declarations \n&& ( short-circuit AND ) \n* \nand glob syntax \nmultiplication operator \nregular expression quantifier \nused in import statement \n** ( glob syntax ) \n@ \nannotation syntax \nused with tags ( javadoc ) \n| \nbitwise OR \nBoolean logical OR \n|| ( short-circuit OR ) \n[ ] \ncharacter class specification \n^ \nbitwise exclusive OR ( XOR ) \nBoolean logical exclusive OR ( XOR ) \n: ( used with a label ) \n:: \nconstructor reference",
    "method reference \n, ( comma ) \nformat flag \n{ } \nused with javadoc tags \n= \n\n= = ( Boolean logical operator ) \n\n\n= = ( relational operator ) \nversus equals ( ) \n! \n!= \n/ \n/* */ \n/** */ \n// \n< \nargument index syntax \n< > \ndiamond operator ( type inference ) \nand generic type parameter \n<?> \n<< \n<= \n\u2013 \nformat flag \n\u2013 > lambda expression arrow operator \n\u2013 \u2013 \n% \nused in format conversion specifier syntax \nmodulus operator \n( format flag \n( ) \nused in a lambda expression \nused to raise the precedence of operations \n. \ndot operator \nin import statement \nin multileveled package statement \nand nested interfaces \nregular expression wildcard character \nseparator \n\u2026 ( variable-length argument syntax ) \n+ \naddition operator \n\nconcatenation operator \nformat flag \nregular expression quantifier",
    "concatenation operator \nformat flag \nregular expression quantifier \n\n\nunary plus \n++ \n# format flag \n? \nregular expression quantifier \nwildcard argument specifier \n?: ( ternary if-then-else operator ) \n> \n>> \n>>> \n>= \n; ( semicolon ) \nused in try-with-resources statement \n~ ( bitwise unary NOT operator ) \n_ ( underscore ) \n\nA \n\nabs ( ) \nAbstract method ( s ) \nand lambda expressions \nabstract type modifier \nAbstract Window Toolkit. See AWT ( Abstract Window Toolkit ) \nAbstractAction interface \nAbstractButton class \nAbstractCollection class \nAbstractList class \nAbstractMap class \nAbstractQueue class \nAbstractSequentialList class \nAbstractSet class \naccept ( ) \nAccess control \nand default access \n\nexample program \nand inheritance \nand packages \nAccess modifiers \nacos ( ) \nacquire ( )",
    "example program \nand inheritance \nand packages \nAccess modifiers \nacos ( ) \nacquire ( ) \n\n\nAction ( Swing ) \nAction interface \nActionEvent class \nJavaFX \nActionListener interface \nactionPerformed ( ) \nadapt ( ) \nAdapter classes \nadd ( ) \naddActionListener ( ) \naddAll ( ) \naddCookie ( ) \naddElement ( ) \naddEventFilter ( ) \naddExact ( ) \naddFirst ( ) \naddImage ( ) \naddItem ( ) \naddKeyListener ( ) \naddLast ( ) \naddListener ( ) \naddMouseListener ( ) \naddMouseMotionListener ( ) \nAddress, Internet \naddSeparator ( ) \naddSuppressed ( ) \naddTab ( ) \naddTListener ( ) 1202 \nadd Type Listener ( ) \nAdjustmentEvent class \nAdjustmentListener interface \nadjustmentValueChanged ( ) \nAffine class \nAlgorithms, collection \nALIGN \nallMatch ( ) \n\nallocate ( ) \nALT \nanchor constraint field \nAND operator",
    "allocate ( ) \nALT \nanchor constraint field \nAND operator \n\n\nbitwise (&) \nBoolean logical (&) \nand bounded type declarations (&) \nshort-circuit (&&) \nAnnotatedElement interface \nAnnotation interface \nAnnotation ( s ) \nbuilt-in \ncontainer \ndeclaration example \nmarker \nmember, default value for \nobtaining all \nreflection to obtain, using \nrepeated \nrestrictions on \nretention policies \nsingle-member \ntype \nannotationType ( ) \nanyMatch ( ) \nApache Software Foundation \nAPI library, compact profiles of the \nAPI packages, table of core Java \nappend ( ) \nAppendable interface \nappendCodePoint ( ) \nappendTo ( ) \nApplet \nApplet, AWT-based \narchitecture \nbasics \ncolors, setting and obtaining \nevent-driven nature of the \nexecuting an \nand the Internet \n\nlocal \nand main ( ) \noutputting to console \npassing parameters to an \n\n\nrequest for repainting",
    "local \nand main ( ) \noutputting to console \npassing parameters to an \n\n\nrequest for repainting \n\nand security \nsigned \nskeleton \nand socket connections \nas source and listener for events \nstring output to an \nand uncaught exceptions \nviewer \nApplet class \nmethods, table of \napplet package \nApplet, Swing \nAPPLET tag, HTML \nfull syntax for \nAppletContext interface \nmethods, table of \nAppletStub interface \nappletviewer \nstatus window, using \nApplication class \nApplication launcher ( java ) and main ( ) \napply ( ) \napplyAsDouble ( ) \nARCHIVE \nAreaAveragingScaleFilter class \nareFieldsSet \nArgument ( s ) \ncommand-line \nindex \npassing \ntype. See Type argument ( s ) \nvariable-length. See Varargs \nwildcard. See Wildcard arguments \nArithmetic operators \nArithmeticException \n\nArray class \nArray ( s ) \nboundary checks \nand collections",
    "Array class \nArray ( s ) \nboundary checks \nand collections \n\n\nconstructor reference for \nconverting collections into \ncopying with arraycopy ( ) \ndeclaration syntax, alternative \ndynamic \nand the for-each loop \nand generics \nimplemented as objects \nindexes \ninitializing \nlength instance variable of \nmultidimensional \none-dimensional \nand spliterators \nand the stream API \nof strings \nand valueOf ( ) \nand varargs \nArrayBlockingQueue class \narraycopy ( ) \nArrayDeque class \nArrayIndexOutOfBoundsException \nArrayList class \nexample using an \nexample using a stream API stream \nArrays class \nArrayStoreException \narrive ( ) \narriveAndAwaitAdvance ( ) \narriveAndDeregister ( ) \nArrow operator (\u2013>) \nASCII character set \nand strings on the Internet \nasin ( ) \nasList ( ) \nAssembly language \nassert statement \n\nAssertions \nAssertionError \nAssignment operator",
    "Assertions \nAssertionError \nAssignment operator \n\n\n= \narithmetic compound ( op =) \nbitwise compound \nBoolean logical \natan ( ) \natan2 ( ) \nAtomic operations \nAtomicInteger class \nAtomicLong class \nAttributeView interface \nAudioClip interface \nAutoboxing/unboxing \nBoolean and Character values \nand the Collections Framework \ndefinition of \nand error prevention \nand expressions \nand methods \nwhen to use \nAutoCloseable interface \nAutomatic resource management ( ARM ) \navailable ( ) \navailableProcessors ( ) \nawait ( ) \nawaitAdvance ( ) \nawaitAdvanceInterruptibly ( ) \nAWT ( Abstract Window Toolkit ) \nand applet architectural constraints \nclasses, table of some \ncolor system \ncontrols. See Controls, AWT \ncreating stand-alone windows with \nand fonts \nlayout managers. See Layout manager ( s ) \nsupport for imaging \nsupport for text and graphics \n\nand Swing \nAWTEvent class \n\nB",
    "and Swing \nAWTEvent class \n\nB \n\n\nB \nBase64 class \nBaseStream interface \nmethods, table of \nBASIC \nBasic multilingual plane ( BMP ) \nBasicFileAttributes class \nmethods, table of \nBasicFileAttributeView interface \nBCP 47 \nBCPL \nBeanInfo interface \nBeans, Java. See Java Beans \nBell curve \nBell Laboratories \nBerkeley UNIX \nBerners-Lee, Tim \nBeyond Photography, The Digital Darkroom ( Holzmann ) \nBiConsumer functional interface \nBiFunction functional interface \nBinary \nliterals \nnumbers and integers \nBinaryOperator<T> predefined functional interface \nbinarySearch ( ) \nbitCount ( ) \nBitSet class \nmethods, table of \nBitwise operators \nBlock lambdas. See also Lambda expression ( s ) \nBLOCKED \nBlocks of code. See Code blocks \nBoolean \nliterals \n\nlogical operators \nBoolean class \n\nand autoboxing/unboxing \nmethods, table of \nboolean data type \nand relational operators",
    "logical operators \nBoolean class \n\nand autoboxing/unboxing \nmethods, table of \nboolean data type \nand relational operators \n\n\nbooleanValue ( ) \nBorder interface \nBorderFactory class \nBorderLayout class \nexample with insets \nBorderPane class \nmethods for positioning nodes within a \nboxed ( ) \nBoxing \nbreak statement \nand the for-each loop \nas form of goto \nBuffer class \nmethods, table of \nBuffer, NIO \nBufferedInputStream class \nBufferedOutputStream class \nBufferedReader class \nBufferedWriter class \nBuffering, double \nbulkRegister ( ) \nButton class \nAWT \nJavaFX \nButtonBase class \nButtonGroup class \nButtonModel interface \nButtons \nJavaFX \npush. See Push buttons \nradio. See Radio buttons \nSwing \ntoggle. See Toggle button, JavaFX ; Toggle button, Swing \nButtonUI \nByte class \nmethods defined by, table of \n\nbyte data type \nand automatic type conversion \nand automatic type promotion \nByteArrayInputStream class \n\n\nByteArrayOutputStream class",
    "byte data type \nand automatic type conversion \nand automatic type promotion \nByteArrayInputStream class \n\n\nByteArrayOutputStream class \n\nByteBuffer class \nget ( ) and put ( ) methods, table of \nBytecode \nBYTES \nbyteValue ( ) \n\nC \n\nC \nhistory of \nand Java \nC Programming Language, The ( Kernighan and Ritchie ) \nC++ \nhistory of \nand Java \nC# and Java \nCalendar class \nconstants \nmethods defined by, table of a sampling of \nCall-by-reference \nCall-by-value \ncall ( ) \nCallable interface \nCallSite class \ncancel ( ) \nCanvas class \nAWT \nJavaFX \ncapacity ( ) \ncapacityIncrement Vector data member \nCard layouts \nCardLayout class \nCaretEvent class \nCase sensitivity and Java \ncase statement \nCasts \n\nand casting one instance of a generic class into another \nand erasure \nusing instanceof with \n\n\ncatch clause ( s )",
    "and casting one instance of a generic class into another \nand erasure \nusing instanceof with \n\n\ncatch clause ( s ) \n\ndisplaying exception description within \nand the more precise ( final ) rethrow feature \nmulti-catch feature of \nusing multiple \nand nested try statements \ncbrt ( ) \nceil ( ) \nCGI ( Common Gateway Interface ) \nchanged ( ) \nChangeListener interface \nChannel interface \nChannel ( s ), NIO. See also NIO and channel-based I/O \nchar data type \nand automatic type conversion \nand automatic type promotion \nCharacter class \nand autoboxing/unboxing \nmethods, table of various \nsupport for 32\u2013bit Unicode \nCharacter ( s ) \nbasic multilingual plane ( BMP ) \nchanging case of \nclasses ( regular expressions ) \ncode point \nescape sequences \nextraction from String objects \nformatting an individual \nliterals \nsupplemental \nCharacter.Subset class \nCharacter.UnicodeBlock class \ncharacteristics ( ) \nCharArrayReader class \nCharArrayWriter class \ncharAt ( )",
    "CharBuffer class \nchars ( ) \nCharSequence interface \nCharsets \n\n\ncharValue ( ) \nCheck boxes \nAWT \nJavaFX \nSwing \nand Swing menus \ncheckAll ( ) \nCheckbox class \nAWT \nJavaFX \nCheckboxGroup class \nCheckboxMenuItem class \nchecked\u2026 methods \ncheckedCollection ( ) \ncheckedList ( ) \ncheckedMap ( ) \ncheckedSet ( ) \ncheckID ( ) \nCheckMenuItem class \nChoice class \nChoice controls \nChoiceBox control \nClass class \nmethods, table of some \n.class filename extension \nclass keyword \nCLASS retention policy \nClass ( es ) \nabstract \naccess levels of \nadapter \nanonymous. See also Inner classes \ncharacter, regular expression \nand code \nin collections, storing user-defined \nconstructor. See Constructor \ncontrolling access to. See Access control \n\nas a data type \ndefinition of \nencapsulation achieved through",
    "as a data type \ndefinition of \nencapsulation achieved through \n\n\nfinal \ngeneral form of \ngeneric. See Generic class \ninner. See Inner classes \ninstance of a \nand interfaces \nlibraries \nliteral \nmember. See Member, class \nname and source file name \nnested \npackages as containers for \npublic \nscope defined by a \ntype for bounded types, using a \nClassCastException \nClassDefinition class \nClassFileTransformer interface \nClassLoader class \nclassModifiers ( ) \nClassNotFoundException \nCLASSPATH \n\u2013classpath option \nClassValue class \nclear ( ) \nClient/server model \nand sockets \nclone ( ) \nCloneable interface \nCloneNotSupportedException \nCloning, potential dangers of \nclose ( ) \nwithin a finally block, calling \nCloseable interface \nClosures \nCOBOL \n\nCODE \nCode base \nCode blocks \nand the break statement",
    "CODE \nCode base \nCode blocks \nand the break statement \n\n\nand scopes \nstatic \nsynchronized \nCode point, definition of \nCode, unreachable \nCODEBASE \ncodePointAt ( ) \ncodePointBefore ( ) \ncodePointCount ( ) \ncodePoints ( ) \ncollect ( ) \nCollection interface \nmethods defined by, table of \nCollection-view \nCollection ( s ) \nalgorithms \ninto arrays, converting \nand autoboxing \nclasses \nconcurrent \ncycling through \ndynamically typesafe view of a \nand the for-each version of the for loop \nFramework. See Collections Framework \ngeneric nature of \ninterfaces \nand iterators \nand legacy classes and interfaces \nmodifiable versus unmodifiable \nand primitive types \nrandom access to \nstoring user-defined classes in \nand the stream API \nstream API stream to obtain a, using a \nand synchronization \nand type safety \n\nwhen to use \nCollections class \nalgorithms defined by, table of \nCollections Framework",
    "when to use \nCollections class \nalgorithms defined by, table of \nCollections Framework \n\n\nadvantages of generics as applied to the \nJDK 5 changes to \nlegacy classes and interfaces \nand method inferences \noverview \nCollector interface \nCollectors class \nColor class, AWT \nconstants \nColor class, JavaFX \nCombo box, JavaFX \nenabling users to edit a \nCombo boxes, Swing \nComboBox class \nComboBoxBase class \nComboBoxModel interface \nComment \ndocumentation \nCommon Gateway interface ( CGI ) \ncommonPool ( ) \nCompact profiles \nComparable interface \nComparable<Path> interface \nComparator interface \ncomparator ( ) \nComparators \nusing a lambda expression with \ncompare ( ) \ncompareAndSet ( ) \ncompareTo ( ) \ncompareToIgnoreCase ( ) \ncompareUnsigned ( ) \ncomparing ( ) \ncomparingByKey ( ) \ncomparingByValue ( ) \nCompilation unit \ncompile ( ) \n\nCompiler class \nCompiler, Java \nand main ( )",
    "Compiler class \nCompiler, Java \nand main ( ) \n\n\nComponent class \nComponentAdapter class \ncomponentAdded ( ) \nComponentEvent class \ncomponentHidden ( ) \nComponentListener interface \ncomponentMoved ( ) \ncomponentRemoved ( ) \ncomponentResized ( ) \nComponents, AWT \nlightweight versus heavyweight \nand overriding paint ( ) \nComponents, Swing \narchitecture \nclass names for, table of \nheavyweight \nlightweight \npainting \nand pluggable look and feel \nand tabbed panes \ncomponentShown ( ) \nComponentUI \ncompute ( ) \nconcat ( ) \nConcurrency utilities \nversus traditional multithreading and synchronization \nConcurrent API \npackages \nConcurrent collection classes \nConcurrent program, definition of \nConcurrentHashMap class \nConcurrentLinkedDeque \nConcurrentLinkedQueue class \nConcurrentSkipListMap class \nConcurrentSkipListSet class \nCondition class \n\nconnect ( ) \nConsole class \nmethods, table of \nConsole I/O",
    "connect ( ) \nConsole class \nmethods, table of \nConsole I/O \n\n\nconsole ( ) \nconst keyword \nConstants \nConstructor class \nConstructor reference \nfor an array \nto generic classes \nConstructor ( s ) \nin class hierarchy, order of execution of \ndefault \nenumeration \nfactory methods versus overloaded \ngeneric \nobject parameters for \noverloading \nparameterized \nreference. See Constructor reference ( s ) \nand super ( ) \nthis ( ) and overloaded \nconstructorModifiers ( ) \nConsumer<T> predefined functional interface \nContainer class \nContainer, JavaFX \nContainer ( s ), Swing \nlightweight versus heavyweight \npanes. See also Content pane \ntop-level \nContainerAdapter class \nContainerEvent class \nContainerListener interface \nContainment hierarchy \ncontains ( ) \ncontainsAll ( ) \nContent pane \ndefault layout manager of JFrame \nContentDisplay enumeration \n\ncontentEquals ( ) \nContext switching \nrules for \nContextMenu class \n\n\nContextMenuEvent class",
    "contentEquals ( ) \nContext switching \nrules for \nContextMenu class \n\n\nContextMenuEvent class \n\ncontinue statement \nControl class \nControl statements. See Statements, control \nControl ( s ), AWT \naction events, using an anonymous inner class or lambda expression to \nhandle \ndefinition of an \nfundamentals \nControl ( s ), JavaFX \nadding an image to a \nadding a tooltip to a \ndisabling \nand effects and transforms \nconvert ( ) \nConvolveOp built-in convolution filter \nConvolution filters \nCookie class \nmethods, table of \nCookieHandler class \nCookieManager class \nCookiePolicy interface \nCookies \nexample servlet using \nCookieStore interface \ncopy ( ) \ncopyOf ( ) \ncopyOfRange ( ) \nCopyOnWriteArrayList class \nCopyOnWriteArraySet class \ncopySign ( ) \ncos ( ) \ncosh ( ) \ncount ( ) \ncountDown ( ) \nCountDownLatch class \nCountedCompleter class \n\ncountStackFrames ( ) \ncreateImage ( ) \ncreateLineBorder ( )",
    "countStackFrames ( ) \ncreateImage ( ) \ncreateLineBorder ( ) \n\n\nCropImageFilter class \nCurrency class \nmethods, table of \ncurrentThread ( ) \ncurrentTimeMillis ( ) \nCustomMenuItem class \nCyclicBarrier class \n\nD \n\nData types. See also Type ( s ); Types, primitive \nDatagramPacket class \nmethods, list of some \nDatagrams \nserver/client example \nDatagramSocket class \nDataInput interface \nDataInputStream class \nDataOutput interface \nDataOutputStream class \nDate and time. See Time and date ; Time and date API \nDate class \nmethods, table of \nDateFormat class \nDateTimeFormatter class \nDeadlock \ndecode ( ) \nDecoder class \nDecrement operator (\u2013 \u2013) \ndecrementAndGet ( ) \ndecrementExact ( ) \ndeepEquals ( ) \ndeepHashCode ( ) \ndeepToString ( ) \n\ndefault \nclause for annotation member \nto declare a default interface method, using \nstatement \nDefaultMutableTreeNode class \ndefaults Properties instance variable",
    "default \nclause for annotation member \nto declare a default interface method, using \nstatement \nDefaultMutableTreeNode class \ndefaults Properties instance variable \n\n\nDelayQueue class \nDelegation event model \nand Beans \nand event listeners \nand event sources \nand Swing \nusing \ndelete operator \ndelete ( ) \ndeleteCharAt ( ) \ndeleteOnExit ( ) \ndelimiter ( ) \nDelimiters \nScanner class \n@Deprecated built-in annotation \nDeque interface \nmethods, table of \ndescendingIterator ( ) \ndestroy ( ) \ndestroyForcibly ( ) \nDestructors versus finalize ( ) \nDialog boxes \nfile \nDialog class \nDiamond operator (<>) \nDictionary class \nabstract methods, table of \ndigit ( ) \nDimension class \nreflection example using the \nDirectories as File objects \ncreating \nDirectory, listing the contents of a \nusing list ( ) \nusing listFiles ( ) \nusing NIO \nDirectory tree, obtaining a list of files in a \n\nDirectoryStream<Path> class \nDirectoryStream.Filter interface \ndispose ( )",
    "DirectoryStream<Path> class \nDirectoryStream.Filter interface \ndispose ( ) \n\n\ndistinct ( ) \ndivideUnsigned ( ) \nDLL ( dynamic link library ) \ndo-while loop \nDocument base \nDocument interface \nDocument/view methodology \n@Documented built-in annotation \ndoDelete ( ) \ndoGet ( ) \ndoHead ( ) \nDomain name \nDomain Naming Service ( DNS ) \ndoOptions ( ) \ndoPost ( ) \ndoPut ( ) \nDosFileAttributes class \nDosFileAttributeView interface \nDot operator (.) \ndoTrace ( ) \nDouble buffering \nDouble class \nmethods, table of \ndouble data type \nand automatic type conversion \nand automatic type promotion \nDoubleAccumulator class \nDoubleAdder class \nDoubleBinaryOperator functional interface \nDoubleBuffer class \ndoubles ( ) \nDoubleStream interface \nDoubleSummaryStatistics class \ndoubleToLongBits ( ) \ndoubleToRawLongBits ( ) \ndoubleValue ( ) \n\ndrawArc ( ) \ndrawImage ( ) \ndrawLine ( ) \ndrawOval ( ) \n\n\ndrawPolygon ( )",
    "drawArc ( ) \ndrawImage ( ) \ndrawLine ( ) \ndrawOval ( ) \n\n\ndrawPolygon ( ) \n\ndrawRect ( ) \ndrawRoundRect ( ) \ndrawString ( ) \nDuration class \nDynamic link library ( DLL ) \nDynamic method \ndispatch \nlookup \nresolution \n\nE \n\nE ( Math constant ) \nEarly binding \nechoCharIsSet ( ) \nEclipse IDE \nEdit control \nEffect class \nEffects \nlist of some built-in \nprogram demonstrating \nelement ( ) \nelementAt ( ) \nelementCount Vector data member \nelementData Vector data member \nelements ( ) \nElementType enumeration \nElementType.TYPE_USE \nelse \nempty ( ) \nEMPTY_LIST static variable \nEMPTY_MAP static variable \nEMPTY_SET static variable \n\nEmptyStackException \nEncapsulation \nand access control \nand scope rules \nEncoder class \nend ( )",
    "EmptyStackException \nEncapsulation \nand access control \nand scope rules \nEncoder class \nend ( ) \n\n\nendsWith ( ) \nensureCapacity ( ) \nentrySet ( ) \nenum \nEnum class \nmethods, table of \nEnumConstantNotPresentException \nenumerate ( ) \nEnumeration interface \nEnumeration ( s ) \n= = relational operator and \nas a class type in Java \nconstants \nconstructor \nrestrictions \nvalues in switch statements, using \nvariable, declaring an \nEnumMap class \nEnumSet class \nfactory methods, table of \nEnvironment properties, list of \nequals ( ) \nversus = = \nequalsIgnoreCase ( ) \nErasure \nand ambiguity errors \nbridge methods and \nerr \nError class \nErrors \nambiguity \nassertions to check for, using \nautoboxing/unboxing and prevention of \nautomatic type promotions and compile-time \ncompile-time versus run-time \ngenerics and prevention of \n\nraw types and run-time \nrun-time. See also Exception handling \nunreachable code \nEvent",
    "raw types and run-time \nrun-time. See also Exception handling \nunreachable code \nEvent \n\n\nand applets \nbubbling \nchange \ndefinition of an \ndesign patterns for a Java Bean \ndispatch chain \ndispatching thread and Swing \ndriven programs \nfilter \nlisteners \nloop with polling \nmodel, delegation. See Delegation event model \nmulticasting and unicasting \nsources \ntimestamp \nEvent class \nEvent handling \nand adapter classes \nevent classes \nand inner classes \nand JavaFX \nkeyboard \nand lambda expressions \nmouse \nand Swing \nSee also Delegation event model \nEvent listener interfaces \nand adapter classes \ntable of commonly used \nEventHandler interface \nEventListener interface \nEventListenerProxy class \nEventObject class \nEventSetDescriptor class \nException, definition of an \nException class \n\nException classes \nand generics \nhierarchy of the built-in \nException handling",
    "Exception classes \nand generics \nhierarchy of the built-in \nException handling \n\n\nblock, general form of \nand chained exceptions \nand creating custom exceptions \nand the default exception handler \nand lambdas \nand the more precise ( final ) rethrow feature \nmulti-catch \nand suppressed exceptions \nand uncaught exceptions \nExceptions, built-in \nchecked, table of \nrun-time, constructors for \nunchecked, table of \nExceptions, I/O \nexchange ( ) \nExchanger class \nexec ( ) \nexecute ( ) \nExecution point \nExecutor interface \nExecutors \nusing \nExecutors class \nExecutorService interface \nexists ( ) \nexit ( ) \nexitValue ( ) \nexp ( ) \nexpm1 ( ) \nExpression lambda. See also Lambda expression ( s ) \nExpressions \nand autoboxing/unboxing \nautomatic type promotion in \nregular. See Regular expressions \nextends \nand bounded wildcard arguments \nExternalizable interface \n\nF",
    "F \n\n\nfalse \nFALSE \nFAT file system \nField class \nField, final \nfieldModifiers ( ) \nfields array \nFile attribute ( s ) \nFile to access, using \ninterfaces \nNIO to access, using \nview interfaces \nFile class \ninstance into a Path instance, converting a \nmethods \nfile ( ) \nFile ( s ) \nto a buffer, map a \nclose ( ) to close a, using \nI/O. See also NIO ; NIO and channel-based I/O \npath to a, obtaining a \npointer \nsource \nsystem, accessing the \ntry-with-resources to automatically close a, using \nFileChannel class \nFileDialog class \nFileFilter interface \nFileInputStream class \nFilenameFilter interface \nFileNotFoundException \nFileOutputStream class \nFileReader class \nFiles class \nmethods, table of a sampling of \nFileStore class \nFileSystem class \n\nFileSystems class \nFileVisitor interface \nFileVisitResult enumeration",
    "FileSystems class \nFileVisitor interface \nFileVisitResult enumeration \n\n\nFileWriter class \nfill ( ) \nfillArc ( ) \nfillInStackTrace ( ) \nfillOval ( ) \nfillPolygon ( ) \nfillRect ( ) \nfillRoundRect ( ) \nfillText ( ) \nfilter ( ) \nFilteredImageSource class \nFilterInputStream class \nFilterOutputStream class \nFilterReader class \nFilterWriter class \nfinal \nto prevent class inheritance \nto prevent method overriding \nFinalization \nfinalize ( ) \nfinally block \nfind ( ) \nfindInLine ( ) \nfindWithinHorizon ( ) \nFinger protocol \nfire ( ) \nfirst ( ) \nfirstElement ( ) \nfirstKey ( ) \nflatMap ( ) \nflatMapToDouble ( ) \nflatMapToInt ( ) \nflatMapToLong ( ) \nflip ( ) \nFloat class \nmethods, table of \n\nfloat data type \nand type promotion \nFloating-point ( s ) \nliterals",
    "float data type \nand type promotion \nFloating-point ( s ) \nliterals \n\n\nFloatBuffer class \nfloatValue ( ) \nfloor ( ) \nfloorDiv ( ) \nfloorMod ( ) \nFlowLayout class \nFlowPane class \nflush ( ) \nFlushable interface \nFocusAdapter class \nFocusEvent class \nfocusGained ( ) \nFocusListener interface \nfocusLost ( ) \nFont class, AWT \nmethods, table of some \nFont class, JavaFX \nFont ( s ) \ncreating and selecting \ndetermining available \ninformation, obtaining \nmetrics to manage text output, using \nterminology used to describe \nFontMetrics class \nmethods, table of some \nfor loop \nenhanced. See For-each version of the for loop \nvariations \nFor-each version of the for loop \nand arrays \nand the break statement \nand collections \ngeneral form \nand the Iterable interface \nand maps \nforceTermination ( ) \n\nforDigit ( ) \nforEach ( ) \nforEachOrdered ( ) \nforEachRemaining ( ) \n\n\nFork/Join Framework",
    "forDigit ( ) \nforEach ( ) \nforEachOrdered ( ) \nforEachRemaining ( ) \n\n\nFork/Join Framework \n\nadvantages to using the \nclasses, main \ntips for using the \nFork/Join Framework divide-and-conquer strategy \nand the sequential processing threshold interaction with the level of \nparallelism \nFork/Join Framework tasks \nasynchronous execution of \ncancelling \ncompletion status of \nand the parallelism level \nrestarting \nstarting \nand subtasks \nthat do not return a result \nthat return a result \nfork ( ) \nForkJoinPool class \ncommon pool \nand work stealing \nForkJoinTask class \nFormat flags \nFormat specifiers ( conversions ) \nargument index with, using an \nand format flags \nand specifying minimum field width \nand specifying precision \nsuffixes for the time and date, table of \ntable of \nuppercase versions of \nformat ( ) \nFormatStyle enumeration \nFormattable interface \nFormattableFlags class \nFormatted input, using Scanner to read \nFormatter class",
    "closing an instance of the \nconstructors \nmethods, table of \n\n\nSee also Format specifiers \nforName ( ) \nFORTRAN \nFrame class \nFrame window ( s ) \ncreating a stand-alone \nhandling events in \nwithin an AWT-based applet, creating \nFrank, Ed \nfreeMemory ( ) \nfrom ( ) \nFTP ( File Transfer Protocol ) \nFunction<T,R> predefined functional interface \nFunctional interfaces \nand their abstract methods, table of \ngeneric \npredefined \n@FunctionalInterface built-in annotation \nFuture interface \nFXCollections class \n\nG \n\nGarbage collection \nand images \ngc ( ) \nGeneric class \nand casting \nexample program with one type parameter \nexample program with two type parameters \ngeneral form of a \nhierarchies \nand instanceof \noverriding methods in a \nand raw types \nand type inference \n\nGeneric constructors \nGeneric interfaces \nand classes \nGeneric method \n\n\nGenerics",
    "Generic constructors \nGeneric interfaces \nand classes \nGeneric method \n\n\nGenerics \n\nand annotations \nand ambiguity errors \nand arrays \nand casts \nand the Collections Framework \nand compatibility with pre-generics code \nand exception classes \nrestrictions when using \ntype checking and \nGenericServlet class \nget ( ) \nand buffers \ngetActionCommand ( ) \ngetActiveThreadCount ( ) \ngetAddListenerMethod ( ) \ngetAddress ( ) \ngetAdjustable ( ) \ngetAdjustmentType ( ) \ngetAlignment ( ) \ngetAllByName ( ) \ngetAllFonts ( ) \ngetAndSet ( ) \ngetAnnotation ( ) \ngetAnnotations ( ) \ngetAnnotationsByType ( ) \ngetApplet ( ) \ngetAppletContext ( ) \ngetArrivedParties ( ) \ngetAsDouble ( ) \ngetAscent ( ) \ngetAsInt ( ) \ngetAsLong ( ) \ngetAttribute ( ) \ngetAttributeNames ( ) \ngetAudioClip ( ) \n\ngetAvailableFontFamilyNames ( ) \ngetBackground ( ) \ngetBeanInfo ( ) \ngetBlue ( )",
    "getAvailableFontFamilyNames ( ) \ngetBackground ( ) \ngetBeanInfo ( ) \ngetBlue ( ) \n\n\ngetButton () \ngetByAddress ( ) \ngetByName ( ) \ngetBytes ( ) \ngetCalendarType ( ) \ngetCause ( ) \ngetChannel ( ) \ngetChars ( ) \ngetChild ( ) \ngetChildren ( ) \ngetClass ( ) \ngetClickCount ( ) \ngetCodeBase ( ) \ngetColor ( ) \ngetCommonPoolParallelism ( ) \ngetComponent ( ) \ngetConstructor ( ) \ngetConstructors ( ) \ngetContainer ( ) \ngetContentLengthLong ( ) \ngetContentPane ( ) \ngetContents ( ) \ngetContentType ( ) \ngetCookies ( ) \ngetDate ( ) \ngetDateInstance ( ) \ngetDateTimeInstance ( ) \ngetDeclaredAnnotation ( ) \ngetDeclaredAnnotations ( ) \ngetDeclaredAnnotationsByType ( ) \ngetDeclaredMethods ( ) \ngetDefault ( ) \ngetDescent ( ) \ngetDirectionality ( ) \ngetDirectory ( ) \ngetDisplayCountry ( ) \ngetDisplayLanguage ( ) \n\ngetDisplayName ( ) \ngetDocumentBase ( ) \ngetEchoChar ( ) \n\n\ngetErrorStream ( )",
    "getDisplayName ( ) \ngetDocumentBase ( ) \ngetEchoChar ( ) \n\n\ngetErrorStream ( ) \n\ngetEventSetDescriptors ( ) \ngetExpiration ( ) \ngetExponent ( ) \nGetField inner class \ngetField ( ) \nGetFieldID ( ) \ngetFields ( ) \ngetFile ( ) \ngetFileAttributeView ( ) \ngetFiles ( ) \ngetFirst ( ) \ngetFont ( ) \ngetForeground ( ) \ngetForkJoinTaskTag ( ) \ngetFreeSpace ( ) \ngetGraphics ( ) \ngetGraphicsContext2D ( ) \ngetGreen ( ) \ngetHeaderField ( ) \ngetHeaderFields ( ) \ngetHeight ( ) \ngetHostAddress ( ) \ngetHostName ( ) \ngetHour ( ) \ngetHvalue ( ) \ngetIcon ( ) \ngetID ( ) \ngetImage ( ) \ngetInetAddress ( ) \ngetInitParameter ( ) \ngetInitParameterNames ( ) \ngetInputStream ( ) \ngetInsets ( ) \ngetInstance ( ) \ngetInteger ( ) \n\nGetIntField ( ) \ngetItem ( ) \ngetItemCount ( ) \ngetItems ( )",
    "GetIntField ( ) \ngetItem ( ) \ngetItemCount ( ) \ngetItems ( ) \n\n\ngetItemSelectable ( ) \ngetKey ( ) \ngetKeyChar ( ) \ngetKeyCode ( ) \ngetLabel ( ) \ngetLast ( ) \ngetLastModified ( ) \ngetLeading ( ) \ngetListenerType ( ) \ngetLocale ( ) \ngetLocalGraphicsEnvironment ( ) \ngetLocalHost ( ) \ngetLocalizedMessage ( ) \ngetLocalPort ( ) \ngetLocationOnScreen ( ) \ngetLong ( ) \ngetMaximum ( ) \ngetMenuComponentCount ( ) \ngetMenuComponents ( ) \ngetMenuCount ( ) \ngetMenus ( ) \ngetMessage ( ) \ngetMethod ( ) \ngetMethodDescriptors ( ) \ngetMethods ( ) \ngetMinimum ( ) \ngetMinimumSize ( ) \ngetModifiers ( ) \ngetModifiersEx ( ) \ngetMonth ( ) \ngetN ( ) getter method design pattern \ngetName ( ) \ngetNameCount ( ) \ngetNewState ( ) \nGetObjectClass ( ) \ngetOffset ( ) \ngetOldState ( ) \n\ngetOppositeComponent ( ) \ngetOppositeWindow ( ) \ngetOutputStream ( ) \n\n\ngetParallelism ( )",
    "getOppositeComponent ( ) \ngetOppositeWindow ( ) \ngetOutputStream ( ) \n\n\ngetParallelism ( ) \n\ngetParameter ( ) \ngetParameterNames ( ) \ngetParent ( ) \ngetPath ( ) \ngetPhase ( ) \ngetPoint ( ) \ngetPoolSize ( ) \ngetPort ( ) \ngetPreciseWheelRotation ( ) \ngetPreferredSize ( ) \ngetPriority ( ) \ngetProperties ( ) \ngetProperty ( ) \ngetPropertyDescriptors ( ) \ngetQueuedTaskCount ( ) \ngetRed ( ) \ngetRegisteredParties ( ) \ngetRemoveListenerMethod ( ) \ngetRGB ( ) \ngetRuntime ( ) \ngetScreenX ( ) \ngetScreenY ( ) \ngetScript ( ) \ngetScrollAmount ( ) \ngetScrollType ( ) \ngetSecurityManager ( ) \ngetSelectedCheckbox ( ) \ngetSelectedIndex ( ) \ngetSelectedIndexes ( ) \ngetSelectedItem ( ) \ngetSelectedItems ( ) \ngetSelectedText ( ) \ngetSelectedToggle ( ) \ngetSelectedValue ( ) \ngetSelectionModel ( ) \n\ngetServletConfig ( ) \ngetServletContext ( ) \ngetServletInfo ( ) \ngetServletName ( )",
    "getServletConfig ( ) \ngetServletContext ( ) \ngetServletInfo ( ) \ngetServletName ( ) \n\n\ngetSession ( ) \ngetSize ( ) \ngetSource ( ) \ngetStackTrace ( ) \ngetState ( ) \ngetStateChange ( ) \ngetSubElements ( ) \ngetSuperclass ( ) \ngetSuppressed ( ) \ngetSurplusQueuedTaskCount ( ) \ngetTarget ( ) \ngetText ( ) \ngetTimeInstance ( ) \ngetTransforms ( ) \ngetUnarrivedParties ( ) \ngetTotalSpace ( ) \ngetUsableSpace ( ) \ngetValue ( ) \ngetVvalue ( ) \ngetWheelRotation ( ) \ngetWhen ( ) \ngetWidth ( ) \ngetWindow ( ) \ngetWriter ( ) \ngetX ( ) \ngetXOnScreen ( ) \ngetY ( ) \ngetYear ( ) \ngetYOnScreen ( ) \nGIF image format \nGlass pane \nGlassfish \nGlob \nGlow class \nprogram demonstrating \nGosling, James \n\ngoto keyword \nGoto statement, using labeled break as form of \ngrabPixels ( ) \nGraphical User Interface. See GUI ( Graphical User Interface ) \n\n\nGraphics",
    "goto keyword \nGoto statement, using labeled break as form of \ngrabPixels ( ) \nGraphical User Interface. See GUI ( Graphical User Interface ) \n\n\nGraphics \n\nand JavaFX retained mode \ncontext \nsizing \nGraphics class \ndrawing methods \nGraphics2D class \nGraphicsContext class \nGraphicsEnvironment class \nGregorianCalendar class \nGrid bag layouts \nGridBagConstraints class \nconstraint fields, table of \nGridBagLayout class \ngridheight constraint field \nGridLayout class \nGridPane class \ngridwidth constraint field \nGroup class \ngroup ( ) \nGIU ( Graphical User Interface ) \napplets based on the \napproaches to the \neffects and transforms to customize the look of a JavaFX, using \nprograms, handling events generated by \nGZIP file format \n\nH \n\nhandle ( ) \nhasCharacteristics ( ) \nHash code \nHash table \nhashCode ( ) \n\nHashing \nHashMap class \nHashSet class \nfrom a stream API stream, obtaining a \nHashtable class \nand iterators",
    "H \n\nhandle ( ) \nhasCharacteristics ( ) \nHash code \nHash table \nhashCode ( ) \n\nHashing \nHashMap class \nHashSet class \nfrom a stream API stream, obtaining a \nHashtable class \nand iterators \n\n\nlegacy methods, table of \nhasMoreElements ( ) \nhasMoreTokens ( ) \nhasNext ( ) \nhasNext X ( ) Scanner methods \ntable of \nHeaders \nHeadlessException \nheadMap ( ) \nheadSet ( ) \nHEIGHT \nHexadecimals \nas character values \nHierarchical abstraction and classification \nand inheritance \nHigh surrogate char \nhighestOneBit ( ) \nHistogram \nHoare, C.A.R. \nHolzmann, Gerard J. \nHotSpot technology,10 \nHSB ( hue-saturation-brightness ) color model \nHSBtoRGB ( ) \nHSPACE \nHTML ( Hypertext Markup Language ) \nfile for an applet \nand javadoc \nHTMLEditor \nHTTP \nGET requests, handling \nand HttpURLConnection class \nport \nPOST requests, handling \nrequests \nresponse \nand URLConnection class \n\nHTTP session \nstateful \ntracking \nHttpCookie class \n\n\nHttpServlet class",
    "HTTP session \nstateful \ntracking \nHttpCookie class \n\n\nHttpServlet class \n\nmethods, table of \nHttpServletRequest interface \nmethods, table of several \nHttpServletResponse interface \nmethods, table of \nHttpSession interface \nmethods, table of several \nHttpURLConnection class \nmethods, sampling of \nhypot ( ) \n\nI \n\nIcon interface \nIcons \nSwing button \nSwing label \nIdentifiers \nIdentityHashMap class \nIEEEremainder ( ) \nif statement \nboolean variable used to control the \nnested \nand recursive methods \nswitch statement versus \nif-else-if ladder \nIllegalAccessException \nIllegalArgumentException \nIllegalFormatException \nIllegalMonitorStateException \nIllegalStateException \nIllegalThreadStateException \nImage class \n\nAWT \nJavaFX \nImageConsumer interface \nImageFilter class \nImageIcon class \nImageObserver interface \n\n\nImageProducer interface",
    "AWT \nJavaFX \nImageConsumer interface \nImageFilter class \nImageIcon class \nImageObserver interface \n\n\nImageProducer interface \n\nimageUpdate ( ) \nbit flags, table of \nImages \ncreating, loading, displaying \ndouble buffering and \nfile formats for web \nfilters for \nstream model for \nImaging \nImageView class \nIMG tag \nimplements clause \nand generic interfaces \nimport statement \nand static import \nin \nIncrement operator (++) \nincrementExact ( ) \nindexOf ( ) \nIndexOutOfBoundsException \nInet4Address class \nInet6Address class \nInetAddress class \nInetSocketAddress class \ninfinity ( IEEE floating-point specification value ) \ninForkJoinPool ( ) \nINHERIT \nInheritableThreadLocal class \nInheritance \nand annotations \nand enumerations \nfinal and \nand interfaces \nmultilevel \nand multiple superclasses \n@Inherited built-in annotation \n\ninit ( ) \nand JavaFX \nand Swing",
    "init ( ) \nand JavaFX \nand Swing \n\n\ninitCause ( ) \nInline method calls \nInner classes \nanonymous \nInnerShadow class \nprogram demonstrating \nInputEvent class \nInputMismatchException \nInputStream class \nmethods, table of \nobjects, concatenating \nInputStreamReader class \ninsert ( ) \ninsertSeparator ( ) \nInsets class \nInstance of a class \nSee also Object ( s ) \nInstance variables \naccessing \ndefault values of \ndefinition of \nhiding \nand interfaces \nstatic \nas unique to their object \nusing super to access hidden \ninstanceof operator \nand generic classes \nInstant class \nInstantiationException \nInstrumentation interface \nint \nand automatic type conversion \nand automatic type promotion \nand integer literals \nIntBuffer class \nInteger class \n\nconstructors \nmethods, table of \nInteger ( s )",
    "constructors \nmethods, table of \nInteger ( s ) \n\n\nliterals \ninterface keyword \nand annotations \nInterface methods \ndefault \nstatic \ntraditional \nInterface ( s ) \nfunctional. See Functional interfaces \ngeneral form of \ngeneric. See Generic interfaces \nimplementing \nand the inheritance hierarchy \ninheritance of \nmember \nmethods. See Interface methods \nnested \nreference variables \ntypes for bounded types, using \nvariables \ninterfaceModifiers ( ) \nInternet \naddresses, obtaining \naddressing scheme \nand portability \nand security \nInternet Engineering Task Force ( IETF ) BCP 47 \nInternet Protocol ( IP ) \naddresses \ndefinition of \nInterNIC \nInterruptedException \nIntrospection \nIntrospector class \nints ( ) \nIntStream interface \n\nIntSummaryStatistics class \nintValue ( ) \nInvalidPathException \ninvoke ( )",
    "IntSummaryStatistics class \nintValue ( ) \nInvalidPathException \ninvoke ( ) \n\n\ninvokeAll ( ) \ninvokeAndWait ( ) \ninvokeLater ( ) \nI/O \nand applets \nchannel-based. See also NIO ; NIO and channel-based I/O \nclasses, list of \nconsole \nerror handling \nexceptions \nfile \nformatted. See I/O, formatted \ninterfaces, list of \nnew. See NIO \nredirection \nstreams. See Streams, I/O \nI/O, formatted \nformat specifiers. See Format specifiers \nusing Formatter. See also Formatter class \nusing printf ( ) \nusing Scanner. See also Scanner class \nio package. See java.io package \nIOError \nIOException \nipadx constraint field \nipady constraint field \nIPv4 ( Internet Protocol, version 4 ) \nIPv6 ( Internet Protocol, version 6 ) \nisAbsolute ( ) \nisAlive ( ) \nisAltDown ( ) \nisAltGraphDown ( ) \nisAnnotationPresent ( ) \nisBound ( ) \nisCancelled ( ) \nisClosed ( ) \n\nisCompletedAbnormally ( ) \nisCompletedNormally ( ) \nisConnected ( ) \nisConstrained ( )",
    "isCompletedAbnormally ( ) \nisCompletedNormally ( ) \nisConnected ( ) \nisConstrained ( ) \n\n\nisControlDown ( ) \nisDigit ( ) \nisDirectory ( ) \nisEditable ( ) \nisEmpty ( ) \nisEnabled ( ) \nisExecutable ( ) \nisFile ( ) \nisFinite ( ) \nisHidden ( ) \nisIndeterminate ( ) \nisInfinite ( ) \nisLeapYear ( ) \nisLetter ( ) \nisLightweight ( ) \nisLowercase ( ) \nisMetaDown ( ) \nisMulticastAddress ( ) \nisMultipleMode ( ) \nisNaN ( ) \nISO-Latin-1 character set \nisPopupTrigger ( ) \nisPresent ( ) \nis PropertyName ( ) \nisPublic ( ) \nisQuiescent ( ) \nisReadable ( ) \nisSelected ( ) \nisSet array \nisSet ( ) \nisShiftDown ( ) \nisShutdown ( ) \nisTemporary ( ) \nisTerminated ( ) \nisTimeSet \nisUppercase ( ) \n\nisWhitespace ( ) \nisWritable ( ) \nItemEvent class \nItemListener interface",
    "isWhitespace ( ) \nisWritable ( ) \nItemEvent class \nItemListener interface \n\n\nItemSelectable interface \nitemStateChanged ( ) \nIterable interface \nIterable<Path> interface \nIteration statements \nIterator \nand maps \nobtaining an \nand PriorityQueue \nand stream API streams \nand synchronized collections \nIterator interface \nmethods, table of \niterator ( ) \n\nJ \n\nJ2SE 5, new features of \nJApplet class \nJava \nAPI packages, table of core \nand C \nand C++ \nand C# \ndesign features ( buzzwords ) \nhistory of \nand the Internet \nas interpreted language \nkeywords \nas a strongly typed language \nversions of \nand the World Wide Web \nJava Archive ( JAR ) files \nJava Beans \n\nadvantages of \nAPI \ncustomizers \ndemonstration program \nintrospection \nproperties. See Property, Java Bean \n\n\nserialization",
    ".java filename extension \nJava Community Process ( JCP ) \nJava Control Panel \nJava EE SDK \nJava Foundation Classes ( JFC ) \njava ( Java application launcher ). See Application launcher ( java ) \nJava Native Interface ( JNI ) \nJava Network Launch Protocol ( JNLP ) \njava package \nJava SE 7 \nJava SE 8 \nJava Virtual Machine ( JVM ) \njava.applet package \njava.awt package \nclasses, tables of some \njava.awt.Dimension class, reflection example using the \njava.awt.event package \nevent classes, table of commonly used \ninterfaces, table of commonly used \njava.awt.event.InputEvent class. See InputEvent class \njava.awt.event.KeyEvent class. See KeyEvent class \njava.awt.image package \njava.beans package \nclasses, table of \ninterfaces, tables of \njava.io package \nclasses, list of \ninterfaces, list of \njava.io.Externalizable interface \njava.io.IOException",
    ". See IOException \njava.io.Serializable interface \njava.lang package \nclasses and interfaces, list of \nimplicit importation of the \njava.lang.annotation package",
    "java.lang.annotation.RetentionPolicy enumeration \njava.lang.image package \njava.lang.instrument package \njava.lang.invoke package",
    "java.lang.management package \njava.lang.ref package \njava.lang.reflect package \nclasses, table of \njava.net package \nclasses and interfaces, list of \njava.nio package \njava.nio.channels package \njava.nio.channels.spi package \njava.nio.charset package \njava.nio.charset.spi package \njava.nio.file package \njava.nio.file.attribute package \njava.nio.file.spi package \njava.nio.file.WatchService \njava.rmi package \njava.text package \njava.time package \njava.time.format package \njava.util package \nclasses, list of top-level \ninterfaces defined by, list of \njava.util.concurrent package \njava.util.concurrent.atomic package \njava.util.concurrent.locks package \njava.util.function package \nfunctional interfaces defined by, table of \njava.util.jar package \njava.util.List class. See List class \njava.util.logging package \njava.util.prefs package \njava.util.regex package \njava.util.spi package \njava.util.stream package \njava.util.zip package \njavac ( Java compiler )",
    "javadoc \ntags \nutility program \nJavaFX \n\n\nevent handling \nimages, support for \nlauncher thread \nlayout panes \nmenus. See Menus, JavaFX \nnodes. See Node ( s ), JavaFX \npackages \nrepainting \nscene \nscene graph \nstage \nversus Swing \nJavaFX application \nclass \ncompiling and running a \nlaunching a \nskeleton \nthread \njavafx.application package \njavafx.beans.value package \njavafx.collections package \njavafx.event package \njavafx.geometry package \njavafx.scene package \njavafx.scene.canvas package \njavafx.scene.control package \njavafx.scene.effect package \njavafx.scene.image package \njavafx.scene.input package \njavafx.scene.layout package \njavafx.scene.paint package \njavafx.scene.paint.Color class \njavafx.scene.shape package \njavafx.scene.text package \njavafx.scene.transform package \njavafx.stage package \n\njavafx.stage.PopupWindow \njavafxpackager tool \njavah.exe \njavap",
    "javafx.stage.PopupWindow \njavafxpackager tool \njavah.exe \njavap \n\n\njavax.imageio package \njavax.servlet package \ninterfaces and classes, list of core \njavax.servlet.http package \ninterfaces and classes, list of some \njavax.swing package \nclasses, list of \njavax.swing.event package \njavax.swing.table package \njavax.swing.tree package \nJButton class \nJCheckBox class \nJCheckBoxMenuItem class \nJComboBox class \nJComponent class \nJDialog class \nJDK 8 ( Java SE 8 Development Kit ) \nJFormattedTextField class \nJFrame class \nJIT ( Just-In-Time ) compiler \nJLabel class \nJLayeredPane class \nJList class \nJMenu class \nmnemonic \nJMenuBar class \nJMenuItem class \naccelerator key \naction to create a, using an \nand action events \nmnemonic \njni.h \njni_md.h \nJNLP ( Java Network Launch Protocol ) \njoin ( ) \nJOptionPane class \nJoy, Bill \n\nJPanel class \nJPEG image file format \nJPopupMenu class",
    "JPanel class \nJPEG image file format \nJPopupMenu class \n\n\nand mouse events \nJRadioButton class \nJRadioButtonMenuItem class \nJRootPane class \nJScrollBar class \nJSeparator class \nJScrollPane class \nJSpinner class \nJTabbedPane class \nJTable class \nJTextComponent class \nJTextField class \nJToggleButton class \nJToggleButton.ToggleButtonModel class \nJToolbar class \nadding an action to a \nJTree class \nJump statements \nJust In Time ( JIT ) compiler \nJVM ( Java Virtual Machine ) \nJWindow class \n\nK \n\nKernighan, Brian \nKey codes, virtual \nKeyAdapter class \nKeyboard events, handling \nKeyCombination class \nkeyCombination ( ) \nKeyEvent class \nKeyListener interface \nkeyPressed ( ) \nkeyReleased ( ) \nkeys ( ) \nkeySet ( ) \nKeyStroke class \n\nkeyTyped ( ) \nKeywords, table of Java \n\nL",
    "keyTyped ( ) \nKeywords, table of Java \n\nL \n\n\nLabel \nAWT standard control \nSwing \nused with break statement \nused with continue statement \nLabel class \nAWT \nJavaFX \nLabel, JavaFX \nadding an image to a \nLabeled class \nLambda expression ( s ) \nas arguments, passing \nblock \nbody \nand comparators \ndefinition of \nand exceptions \nand generics \nto handle action events \nparameters \nand the stream API \ntarget type \nand variable capture \nLambda arrow operator (\u2013>) \nlast ( ) \nlastElement ( ) \nlastIndexOf ( ) \nlastKey ( ) \nLate binding \nlaunch ( ) \nLayered pane \nLayout managers, AWT \ndefault \nLayout panes, JavaFX \n\nLayoutManager interface \nLazy behavior ( stream API stream ) \nlength instance variable of arrays \nlength ( )",
    "LayoutManager interface \nLazy behavior ( stream API stream ) \nlength instance variable of arrays \nlength ( ) \n\n\nLexer ( lexical analyzer ) \nLibraries, class \nLibrary, compact profiles of the API \nLindholm, Tim \nLineNumberInputStream deprecated class \nLineNumberReader class \nlines ( ) \nLinkedBlockingDeque class \nLinkedBlockingQueue class \nLinkedHashMap class \nLinkedHashSet class \nLinkedList class \nexample program using the \nfrom a stream API stream, obtaining a \nLinkedTransferQueue \nList \ncontrols \nitems \nList class \nList interface \nfrom a stream API stream, obtaining a \nmethods, table of \nList, Swing \nList view \nchange events, handling \nmultiple selections in a, enabling \nscrollbars \nlist ( ) \nand directories \nlist ( ), ThreadGroup \nlistFiles ( ) \nListIterator interface \nmethods, table of \nlistIterator ( ) \nListModel \nListResourceBundle class \nListSelectionEvent class \n\nListSelectionListener interface \nListSelectionModel interface \nListView class \n\n\nLiterals",
    "ListSelectionListener interface \nListSelectionModel interface \nListView class \n\n\nLiterals \n\nclass \nregular expression \nstring \nload ( ) \nloadLibrary ( ) \nLocalDate class \nLocalDateTime class \nLocale class \nLocale Data Markup Language ( LDML ) \nLocale.Builder class \nLocalTime class \nLock interface \nmethods, table of \nlock ( ) \nlockInterruptibly ( ) \nLocks \nlog ( ) \nmath method \nservlet method \nlog10 ( ) \nlog1p ( ) \nLogical operators \nbitwise \nBoolean \nlong \nand automatic type conversion \nand automatic type promotion \nliteral \nLong class \nmethods, table of \nLongAccumulator class \nLongAdder class \nlongBitsToDouble ( ) \nLongBuffer class \nlongs ( ) \n\nLongStream interface \nlongValue ( ) \nLook and feels \nlookup ( ) \n\n\nloop ( ) \nLoop ( s ) \nBoolean object to control, using a \ncontinue statement and \ndo-while \nfor. See for loop \ninfinite \nnested \nwith polling, event \nwhile \nLow surrogate char \nlowestOneBit ( ) \n\nM",
    "M \n\nmain ( ) \nand applets \nand the java application launcher \nand command-line arguments \nand Swing programs \nand windowed applications \nmain ( default name of main thread ) \nmakeGUI ( ) \nMalformedURLException \nMap interface \nmethods, table of \nmap ( ) \nand stream API streams \nMap ( s ) \nclasses \ncollection-view of a, obtaining a \nflat \ninterfaces \nand stream API streams \n\nsubmaps of \nMap.Entry interface \nmethods, table of non-static \nMapMode.PRIVATE \nMapMode.READ_ONLY \nMapMode.READ_WRITE",
    "submaps of \nMap.Entry interface \nmethods, table of non-static \nMapMode.PRIVATE \nMapMode.READ_ONLY \nMapMode.READ_WRITE \n\n\nMappedByteBuffer class \nmapToDouble ( ) \nmapToInt ( ) \nmapToLong ( ) \nmark ( ) \nmarkSupported ( ) \nMatcher class \nmatcher ( ) \nmatches ( ) \nMath class \nrounding methods, table of \nand static import example \nmax ( ) \nMAX_EXPONENT \nMAX_PRIORITY \nMAX_RADIX \nMAX_VALUE \nMediaTracker class \nMember, class \naccess and inheritance \naccess, table of \ncontrolling access to \nstatic \nMember interface \nMemory \nallocation using new \ndeallocation \nleaks \nmanagement, in Java \nand the Runtime class \nMemoryImageSource class \nMenu bars and AWT menus \naction command string of \nand events \nMenu class \nAWT \n\nJavaFX \nMenu item as an event source, AWT \nMenu ( s ), JavaFX \naccelerator keys",
    "JavaFX \nMenu item as an event source, AWT \nMenu ( s ), JavaFX \naccelerator keys \n\n\ncheck menu items \nclasses, table of core \ncontext menu \ndemonstration program \nevents, handling \nand images \nmain, creating a \nmenu bar \nmnemonics \npopup \nradio menu items \nstandard menu \nand submenus \nand toolbars \nand tooltips \nMenu ( s ), Swing \naccelerator keys \naction command string \naction to manage multiple components of a, using an \nand check boxes \nclasses, interaction of core \ndemonstration program \nevents \nand images \nmain, creating a \nmenu bar \nmnemonics \npopup \nand radio buttons \nand submenus \nand toolbars \nand tooltips \nMenuBar class \nAWT \nJavaFX \nMenuDragMouseEvent \n\nMenuEvent \nMenuItem class \nAWT \nJavaFX",
    "MenuEvent \nMenuItem class \nAWT \nJavaFX \n\n\nMenuEvent \nMenuKeyEvent \nMenuListener \nMetadata. See also Annotation ( s ) \nMethod class \nMethod reference ( s ) \nand the Collections Framework \nand generics \nto instance methods \nto static methods \nto a superclass version of a method \nMethod ( s ) \nabstract. See Abstract method ( s ) \nand annotations \nand autoboxing/unboxing \nbridge \ncalling \ndefault interface \ndispatch, dynamic \nand the dot (.) operator \nfactory \nfinal \ngeneral form \ngeneric \ngetter \nhidden, using super to access \ninlining \ninterface. See Interface methods \nlookup, dynamic \nnative \noverloading \noverriding. See Overriding, method \nand parameters \npassing an object to \nrecursive \nreference. See Method reference ( s ) \nresolution, dynamic \n\nreturning an object from \nreturning a value from \nscope defined by",
    "returning an object from \nreturning a value from \nscope defined by \n\n\nsetter \nstatic \nsubclasser responsibility \nsynchronized \ntype inference and \nvarargs. See Varargs \nvariable-arity \nMethodDescriptor class \nMethodHandle class \nmethodModifiers ( ) \nMethodType class \nMIME ( Multipurpose Internet Mail Extensions ) \nmin ( ) \nminimumLayoutSize ( ) \nMIN_EXPONENT \nMIN_NORMAL \nMIN_PRIORITY \nMIN_RADIX \nMIN_VALUE \nmkdir ( ) \nmkdirs ( ) \nModel-Delegate component architecture \nModel-View-Controller ( MVC ) component architecture \nModifier class \n\u201cis\u201d methods, table of \nModulus operator (%) \nMonitor \nMouse events, handling \nMouseAdapter class \nmouseClicked ( ) \nmouseDragged ( ) \nmouseEntered ( ) \nMouseEvent class \nmouseExited ( ) \nMouseListener interface \nMouseMotionAdapter class \n\nMouseMotionListener interface \nmouseMoved ( ) \nmousePressed ( ) \nmouseReleased ( ) \n\n\nMouseWheelEvent class",
    "MouseMotionListener interface \nmouseMoved ( ) \nmousePressed ( ) \nmouseReleased ( ) \n\n\nMouseWheelEvent class \n\nMouseWheelListener interface \nmouseWheelMoved ( ) \nMulti-core systems \nMultipleSelectionModel class \nmultiplyExact ( ) \nMultitasking \npreemptive \nMultithreaded programming \nand context switching. See Context switching \neffectively using \nand multi-core versus single-core systems \nand spurious wakeup \nand StringBuilder class \nand synchronization. See Synchronization \nand threads. See Thread ( s ) \nversus the concurrency utilities, traditional \nand parallel programming \nversus single-threaded system \nMutableComboBoxModel \nMutableTreeNode interface \nMVC ( Model-View-Controller ) component architecture \n\nN \n\nNAME \nName-space collisions \nbetween instance variables and local variables \npackages and \nNaming class \nNaN \nnanoTime ( ) \n@Native built-in annotation \nnative modifier \nNatural ordering \nnaturalOrder ( ) \nNaughton, Patrick",
    "NavigableMap interface \nmethods, table of \nNavigableSet interface \n\n\nmethods, table of \nnegateExact ( ) \nNegative numbers in Java, representation of \nNEGATIVE_INFINITY \nNegativeArraySizeException \n.NET Framework \nNetBeans \nNetworking \nbasics \nclasses and interfaces, list of \nnew \nautoboxing and \nconstructor reference and \nand enumerations \nand type inference \nNEW \nNew I/O. See NIO \nnewByteChannel ( ) \nnewCachedThreadPool ( ) \nnewCondition ( ) \nnewDirectoryStream ( ) \nnewFileSystem ( ) \nnewFixedThreadPool ( ) \nnewInputStream ( ) \nNewline, inserting a \nnewOutputStream ( ) \nnewScheduledThreadPool ( ) \nnext ( ) \nnextAfter ( ) \nnextBoolean ( ) \nnextBytes ( ) \nnextDouble ( ) \nnextDown ( ) \nnextElement ( ) \nnextFloat ( ) \nnextGaussian ( ) \nnextInt ( ) \n\nnextLong ( ) \nnextToken ( ) \nnextUp ( ) \n\n\nnext X ( ) Scanner methods",
    "nextLong ( ) \nnextToken ( ) \nnextUp ( ) \n\n\nnext X ( ) Scanner methods \n\ntable of \nNIO \nand directories \npackages, list of \npre-JDK 7 NIO versus new \nreading a file using pre-JDK 7 \nfor path and file system operations, using \nand the stream API \nfor stream-based I/O, using \nwriting to a file using pre-JDK 7 \nNIO and channel-based I/O \ncopying a file using \nreading a file using \nwriting to a file using \nNIO.2 \nNode class \nNode ( s ), JavaFX \ndisabling \neffects and transforms to alter the look of, using \nhierarchy \nscrolling capabilities to, adding \ntext \ntree \nnoneMatch ( ) \nNORM_PRIORITY \nNoSuchElementException \nNoSuchFieldException \nNoSuchMethodException \nNOT operator \nbitwise unary (~) \nBoolean logical unary (!) \nNotDirectoryException \nnotepad \nnotify ( ) \nnotifyAll ( ) \n\nnotifyObservers ( ) \nNotSerializableException \nnow ( ) \nnull",
    "notifyObservers ( ) \nNotSerializableException \nnow ( ) \nnull \n\n\nalternative to using \nNull statement \nNullPointerException \nusing Optional to prevent a \nnullsFirst ( ) \nnullsLast ( ) \nNumber class \nNumberFormatException \nnumberOfLeadingZeros ( ) \nnumberOfTrailingZeros ( ) \nNumbers, formatting \n\nO \n\nOak \nObject class \nas a data type, problems with using the \nObject class methods \nand functional interfaces \ntable of \nObject reference variables \nand abstract classes \nand argument passing \nassigning \ndeclaring \nand cloning \nand dynamic method dispatch \nto superclass reference variable, assigning subclass \nOBJECT tag \nObject-oriented programming ( OOP ) \nmodel in Java \nObject ( s ) \nbitwise copy ( clone ) of \ncreating/declaring \ninitialization with a constructor \nto a method, passing \nmonitor, implicit \n\nas parameters \nreturning \nserialization of. See Serialization",
    "as parameters \nreturning \nserialization of. See Serialization \n\n\ntype at run time, determining \nObject.notify ( ). See notify ( ) \nObject.wait ( ). See wait ( ) \nObjectInput interface \nmethods defined by, table of \nObjectInputStream class \nmethods defined by, table of \nObjectOutput interface \nmethods defined by, table of \nObjectOutputStream class \nmethods defined by, table of \nObjects class \nObservable class \nmethods, table of \nobservableArrayList ( ) \nObservableList \nObservableValue \nObserver interface \nOctals \nas character values \nof ( ) \noffer ( ) \nofferFirst ( ) \nofferLast ( ) \noffsetByCodePoints ( ) \nofLocalizedDate ( ) \nofLocalizedDateTime ( ) \nofLocalizedTime ( ) \nofNullable ( ) \nofPattern ( ) \npattern letters \nonAdvance ( ) \nopen ( ) \nopenConnection ( ) \nOpenOption interface \nOperator ( s ) \narithmetic \n\nassignment. See Assignment operator ( s ) \nbitwise \nBoolean logical",
    "assignment. See Assignment operator ( s ) \nbitwise \nBoolean logical \n\n\nconditional-and \nconditional-or \ndiamond (<>) \nparentheses and \nprecedence, table of \nrelational \nternary if-then-else (?:) \nOptional class \nmethods, table of \nOptionalDouble class \nOptionalInt class \nOptionalLong class \nOR operator \nbitwise (|) \nbitwise exclusive (^) \nBoolean logical (|) \nBoolean logical exclusive (^) \nOR operator, short-circuit (||) Boolean logical \nOracle \nOrdinal value, enumeration constant\u2019s \nordinal ( ) \norElse ( ) \nout output stream \nout ( ) \nOutputStream class \nmethods, table of \nOutputStreamWriter class \nOverloading methods \n@Override, built-in annotation \nOverriding, method \nand abstract classes \nand bridge methods \nand dynamic method dispatch \nfinal to prevent, using \nin a generic class \nand run-time polymorphism \n\nP \n\nPackage ( s )",
    "P \n\nPackage ( s ) \n\n\naccess to classes contained in \nbuilt-in standard Java classes and \ncore Java API, table of \nthe default \ndefining \nfinding \nimporting \nSwing \nversion data, obtaining \nPackage class \nmethods, table of \npackage statement \nPaint class \nPaint mode, setting \npaint ( ) \nlightweight AWT components and overriding \nPaintable area, computing \npaintBorder ( ) \npaintChildren ( ) \npaintComponent ( ) \nPainting in Swing \nPanel class \nPanes, Swing container. See also Content pane \nParallel processing \nof a stream API stream \nParallel programming. See Programming, parallel \nparallel ( ) \nparallelPrefix ( ) \nparallelSetAll ( ) \nparallelSort ( ) \nparallelStream ( ) \nPARAM NAME and VALUE \nParameter ( s ) \napplets and \nand constructors \nfinal \n\nand lambda expressions \nobjects as \nand overloaded constructors \nand overloaded methods",
    "and lambda expressions \nobjects as \nand overloaded constructors \nand overloaded methods \n\n\nand the scope of a method \nservlet, reading \ntype. See Type parameter ( s ) \nvariable-length ( varargs ) \nParameterized types \nparameterModifiers ( ) \nParent class \nparse ( ) \nparseBoolean ( ) \nparseByte ( ) \nparseDouble ( ) \nparseFloat ( ) \nparseInt ( ) \nparseLong ( ) \nparseShort ( ) \nparseUnsignedInt ( ) \nparseUnsignedLong ( ) \nParsing, definition of \nPascal \nPasswordField class \nPasswords, reading \nPath interface \nconverting a File object into an instance of the \ninstance for stream-based I/O, using a \nmethods, table of a sampling of \nobtaining an instance of the \nPaths class \nPattern class \nPattern matching, regular expressions \nPatternSyntaxException \nPayne, Jonathan \npeek ( ) \npeekFirst ( ) \npeekLast ( ) \nPeers, native \nPeriod class \nPersistence ( Java Beans ) \n\nPhaser class \ncompatibility with fork/join \nPI ( Math constant )",
    "Phaser class \ncompatibility with fork/join \nPI ( Math constant ) \n\n\nPIPE \nPipeline for actions on stream API streams \nPipedInputStream class \nPipedOutputStream class \nPipedReader class \nPipedWriter class \nPixelGrabber class \nPlatform class \nPlatform.exit ( ) \nplay ( ) \nPluggable look and feel ( PLAF ) \nPNG file format \nPoint class \nPointers \npoll ( ) \npollFirst ( ) \nPolling \npollLast ( ) \nPolygon class \nPolymorphism \nand dynamic method dispatch \nand interfaces \nand overloaded methods \npop ( ) \nPopupControl class \nPopupMenu class \nPopupMenuEvent \nPort \nPortability problem \nand data types \nand native methods \nand thread context switching \nPos enumeration \nPOSITIVE_INFINITY \nPosixFileAttributes class \nPosixFileAttributeView interface \n\npostVisitDirectory ( ) \npow ( ) \nPredicate<T> predefined functional interface \npreferredLayoutSize ( ) \n\n\nprevious ( )",
    "previous ( ) \n\npreVisitDirectory ( ) \nPrimitiveIterator interface \nPrimitiveIterator.OfDouble interface \nPrimitiveIterator.OfInt interface \nPrimitiveIterator.OfLong interface \nprint ( ) \nprintf ( ) \nfunction, C/C++ \nmethod, Java \nprintln ( ) \nand applets \nand Boolean output \nand String objects \nprintStackTrace ( ) \nPrintStream class \nPrintWriter class \nPriorityBlockingQueue class \nPriorityQueue class \nprivate access modifier \nand inheritance \nProcess class \nmethods, table of \nProcess, definition of \nProcess-based versus thread-based multitasking \nProcessBuilder class \nmethods, table of \nProcessBuilder.Redirect class \nProcessBuilder.Redirect.Type enumeration \nProgram, creating a windowed \nProgramming \nmultithreaded. See Multithreaded programming \nobject-oriented. See Object-oriented programming \nprocess-oriented \nstructured \nProgramming, parallel \nand specifying the level of parallelism \n\nProject Coin \nProperties class \nmethods, table of",
    "Project Coin \nProperties class \nmethods, table of \n\n\nProperties, environment \nProperty, Java Bean \nbound and constrained \ndesign patterns for \nPropertyChangeEvent \nPropertyChangeListener interface \nPropertyDescriptor class \nPropertyPermission class \nPropertyResourceBundle class \nPropertyVetoException \nprotected access modifier \nProtocols, overview of networking \nPseudorandom numbers \npublic access modifier \nPush buttons, AWT \naction command string of \nPush buttons, JavaFX \nadding an image to \nPush buttons, Swing \naction command string of \npush ( ) \nPushback \nPushbackInputStream \nPushbackReader class \nput ( ) \nand buffers \nputAll ( ) \nPutField inner class \nputValue ( ) \n\nQ \n\nQuery string \nQueue interface \n\nmethods, table of \nquietlyInvoke ( ) \nquietlyJoin ( ) \n\nR \n\nRace condition",
    "Q \n\nQuery string \nQueue interface \n\nmethods, table of \nquietlyInvoke ( ) \nquietlyJoin ( ) \n\nR \n\nRace condition \n\n\nRadio buttons \nJavaFX \nSwing \nand Swing menus \nRadioButton class \nRadioMenuItem class \nRadix \nradix ( ) \nRandom class \nmethods, table of core \nrandom ( ) \nRandomAccess interface \nRandomAccessFile class \nrange ( ) \nRaw types \nREAD \nread ( ) \nReadable interface \nReadableByteChannel interface \nreadAttributes ( ) \nreadBoolean ( ) \nreadDouble ( ) \nReader class \nmethods defined by, table of \nreadExternal ( ) \nreadInt ( ) \nreadLine ( ) \nreadObject ( ) \nreadPassword ( ) \nReadWriteLock interface \nReal numbers \nrebind ( ) \nreceive ( ) \nRecursion \nand the Fork/Join Framework divide-and-conquer strategy \nRecursiveAction class \n\nRecursiveTask class \nexample program using \nRedirect class \nreduce ( ) \n\n\nReduction operations",
    "RecursiveTask class \nexample program using \nRedirect class \nreduce ( ) \n\n\nReduction operations \n\nmutable \nReentrantLock \nReentrantReadWriteLock \nReflection \nand annotations \nReflectiveOperationException \nRegion class \nregionMatches ( ) \nregister ( ) \nRegular expressions \nsyntax \nwildcards and quantifiers \nreinitialize ( ) \nRelational operators \nRelative index \nrelease ( ) \nremainderUnsigned ( ) \nRemote interface \nRemote method invocation ( RMI ) \nRemoteException \nremove ( ) \nremoveActionListener ( ) \nremoveAll ( ) \nremoveAttribute ( ) \nremoveEldestEntry ( ) \nremoveElement ( ) \nremoveElementAt ( ) \nremoveFirst ( ) \nremoveIf ( ) \nremoveKeyListener ( ) \nremoveLast ( ) \nremoveTListener ( ) \nremove Type Listener ( ) \nrenameTo ( ) \nrepaint ( ) \n\n@Repeatable annotation \nreplace ( ) \nreplaceAll ( ) \nreplaceFirst ( ) \n\n\nreplaceRange ( )",
    "@Repeatable annotation \nreplace ( ) \nreplaceAll ( ) \nreplaceFirst ( ) \n\n\nreplaceRange ( ) \n\nReplicateScaleFilter class \nreset ( ) \nresolve ( ) \nResource bundles \nResourceBundle class \nmethods, table of \nResourceBundle.Control class \nresume ( ) \nretainAll ( ) \n@Retention built-in annotation \nRetentionPolicy enumeration \nreturn statement \nin a lambda expression \nreverse ( ) \nreverseBytes ( ) \nreversed ( ) \nreverseOrder ( ) \ncollection algorithm \nComparator method \nrewind ( ) \nRGB ( red-green-blue ) color model \ndefault \nRGBImageFilter class \nexample program demonstrating the \nRGBtoHSB ( ) \nRichards, Martin \nrint ( ) \nRitchie, Dennis \nrmi protocol \nRMI ( Remote Method Invocation ) \nrmic compiler \nrmiregistry ( RMI registry ) \nRotate class \nprogram demonstrating \nrotateLeft ( ) \n\nrotateRight ( ) \nround ( ) \nRun-time \nsystem, Java. See also Java Virtual Machine ( JVM )",
    "rotateRight ( ) \nround ( ) \nRun-time \nsystem, Java. See also Java Virtual Machine ( JVM ) \n\n\ntype information \nrun ( ) \noverriding \nusing a flag variable with \nRUNNABLE \nRunnable interface \nimplementing the \nRuntime class \nexecuting other programs and \nmemory management and \nmethods, table of some \nRUNTIME retention policy \nRuntimeException class \nRuntimePermission class \n\nS \n\n@SafeVarargs built-in annotation \nSAM ( Single Abstract Method ) type \nsave ( ) \nscalb ( ) \nScale class \nprogram demonstrating \nScanner \nScanner class \nclosing an instance of the \nconstructors \ndelimiters \ndemonstration programs \nhasNext X ( ) methods, table of \nhow to use \nmethods, miscellaneous \nnext X ( ) methods, table of \nScene class \n\nschedule ( ) \nScheduledExecutorService interface \nScheduledThreadPoolExecutor class \nScientific notation \nScopes in Java \nScroll bars \n\n\nScroll pane",
    "schedule ( ) \nScheduledExecutorService interface \nScheduledThreadPoolExecutor class \nScientific notation \nScopes in Java \nScroll bars \n\n\nScroll pane \n\nScrollbar class \nScrollPane class \nsearch ( ) \nSecurity manager \nSecurity problem \nand native methods \nand servlets \nSecurityException \nSecurityManager class \nseek ( ) \nSeekableByteChannel interface \nselect ( ) \nselectedItemProperty ( ) \nselectedToggleProperty ( ) \nSelection statements \nSelectionMode \nSelectionModel class \nSelectors \nSemaphore \nand setting initial synchronization state \nSemaphore class \nsend ( ) \nSeparable Model architecture \nSeparator class \nSeparatorMenuItem class \nSeparators \nSequenceInputStream class \nsequential ( ) \nSerializable interface \nSerialization \nexample program \nand Java Beans \nand static variables \nand transient variables \nServer \nServerSocket class \n\nservice ( ) \nServiceLoader class \nServlet interface",
    "service ( ) \nServiceLoader class \nServlet interface \n\n\nmethods, table of \nServlet ( s ) \nadvantages of \nAPI \ndevelopment options \nexample program for a simple \nlife cycle of \nparameters, reading \nand portability \nand security \nand session tracking \nusing Tomcat to develop \nServletConfig interface \nServletContext interface \nmethods, table of various \nServletException class \nServletInputStream class \nServletOutputStream class \nServletRequest interface \nmethods, table of various \nServletResponse interface \nmethods, table of various \nSession tracking, HTTP \nSet interface \nfrom a stream API stream, obtaining a \nSet-view, obtaining \nset ( ) \nsetAccelerator ( ) \nsetActionCommand ( ) \nsetAlignment ( ) \nsetAll ( ) \nsetAllowIndeterminate ( ) \nsetAngle ( ) \nsetAttribute ( ) \nsetBackground ( ) \nsetBlockIncrement ( ) \n\nsetBorder ( ) \nsetBounds ( ) \nsetChanged ( ) \nsetCharAt ( )",
    "setBorder ( ) \nsetBounds ( ) \nsetChanged ( ) \nsetCharAt ( ) \n\n\nsetColor ( ) \nsetConstraints ( ) \nsetContent ( ) \nsetContentDisplay ( ) \nsetContentType ( ) \nsetContextMenu ( ) \nsetDefault ( ) \nsetDefaultCloseOperation ( ) \nsetDisable ( ) \nsetDisabledIcon ( ) \nsetEchoChar ( ) \nsetEditable ( ) \nsetEffect ( ) \nsetEnabled ( ) \nsetFill ( ) \nsetFont ( ) \nsetForeground ( ) \nsetForkJoinTaskTag ( ) \nsetGraphic ( ) \nsetHorizontalTextPosition ( ) \nsetHvalue ( ) \nsetIcon ( ) \nSetIntField ( ) \nsetJMenuBar ( ) \nsetLabel ( ) \nsetLastModified ( ) \nsetLayout ( ) \nsetLength ( ) \nsetLevel ( ) \nsetLocation ( ) \nsetMaxAge ( ) \nsetMnemonic ( ) \nsetMnemonicParsing ( ) \nsetMultipleMode ( ) \nsetN ( ) setter method design pattern \nsetName ( ) \nsetOnAction ( ) \n\nsetOnContextMenuRequested ( ) \nsetOrientation ( ) \nsetPaintMode ( )",
    "setOnContextMenuRequested ( ) \nsetOrientation ( ) \nsetPaintMode ( ) \n\n\nsetPannable ( ) \nsetPivotX ( ) \nsetPivotY ( ) \nsetPrefColumnCount ( ) \nsetPreferredSize ( ) \nsetPrefHeight ( ) \nsetPrefSize ( ) \nsetPrefViewportHeight ( ) \nsetPrefViewportWidth ( ) \nsetPrefWidth ( ) \nsetPressedIcon ( ) \nsetPriority ( ) \nsetPromptText ( ) \nsetReadOnly ( ) \nsetRolloverIcon ( ) \nsetRotate ( ) \nsetScaleX ( ) \nsetScaleY ( ) \nsetScene ( ) \nsetSelected ( ) \nsetSelectedCheckbox ( ) \nsetSelectedIcon ( ) \nsetSelectionMode ( ) \nsetSize ( ) \nsetStackTrace ( ) \nsetState ( ) \nsetStroke ( ) \nsetText ( ) \nsetTitle ( ) \nsetToggleGroup ( ) \nsetTooltip ( ) \nsetToolTipText ( ) \nsetTranslateX ( ) \nsetTranslateY ( ) \nsetUnitIncrement ( ) \nsetValue ( ) \n\nsetValues ( ) \nsetVvalue ( ) \nsetVisible ( ) \nsetX ( )",
    "setValues ( ) \nsetVvalue ( ) \nsetVisible ( ) \nsetX ( ) \n\n\nsetXORMode ( ) \nsetY \nShear class \nSheridan, Mike \nShift operators, bitwise \nShort class \nmethods defined by, table of \nshort data type \nand automatic type conversion \nand automatic type promotion \nShortBuffer class \nshortValue ( ) \nshow ( ) \nshowDocument ( ) \nshowStatus ( ) \nshuffle ( ) \nshutdown ( ) \nshutdownNow ( ) \nSign extension \nsignal ( ) \nsignum ( ) \nSimpleBeanInfo class \nSimpleDateFormat class \nformatting string symbols, table of \nSimpleFileVisitor class \nSimpleTimeZone class \nsin ( ) \nSingleSelectionModel \nsinh ( ) \nSIZE \nsize ( ) \nskip ( ) \nSKIP_SIBLINGS \nSKIP_SUBTREE \nsleep ( ) \nslice ( ) \n\nSlider box \nSocket class \nSocket ( s ) \ndatagram",
    "Slider box \nSocket class \nSocket ( s ) \ndatagram \n\n\noverview \nTCP/IP client \nTCP/IP server \nSocketAddress class \nSocketChannel class \nSocketException \nsort ( ) \nsorted ( ) \nSortedMap interface \nmethods, table of \nSortedSet interface \nmethods, table of \nSource code file, naming a \nSOURCE retention policy \nsplit ( ) \nSpliterator \nand arrays \ncharacteristics \nSpliterator interface \nmethods declared by, table of \nand streamAPI streams \nspliterator ( ) \nSpliterator.OfDouble interface \nSpliterator.OfInt interface \nSpliterator.OfLong interface \nSpliterator.OfPrimitive interface \nsqrt ( ) \nStack \ndefinition of \nways to implement a \nStack class \nmethods, table of \nStack frame \nStack trace \nStackTraceElement class \nmethods, table of \nStage class \n\nStampedLock interface \nStandardCopyOption values, partial list of \nStandardOpenOption class \n\n\nenumeration, table of values for the",
    "StampedLock interface \nStandardCopyOption values, partial list of \nStandardOpenOption class \n\n\nenumeration, table of values for the \n\nStandardOpenOption.CREATE \nStandardOpenOption.READ \nStandardOpenOption.TRUNCATE_EXISTING \nStandardOpenOption.WRITE \nStandard Template Library ( STL ) \nstart ( ) \nstartsWith ( ) \nState enumeration \nStatements \nnull \nStatements, control \niteration \njump \nselection \nstatic \nmember restrictions \nStatic import \nstop ( ) \nstore ( ) \nStream API \nand collections \ninterfaces \nand lambda expressions \nand NIO \nStream interface \nmethods, table of some \nStream, intermediate operations on a stream API \nto create a pipeline of actions \nlazy behavior of \nstateless versus stateful \nStream, stream API \ncollection from a, obtaining a \ndefinition of a \niterators and a \nmapping a \n\nobtaining a \noperations on a, terminal versus intermediate \nordered versus unordered \nparallel processing of a",
    "obtaining a \noperations on a, terminal versus intermediate \nordered versus unordered \nparallel processing of a \n\n\nparallel, using a \nreduction operations \nstream ( ) \nStream ( s ), byte \nclasses in java.io, table of \nStream ( s ), character \nclasses in java.io, table of \nStream ( s ), I/O \nbenefits \nbuffered \nclasses, top-level \nclosing \nconcatenating input to \ndefinition of \nfiltered \nflushing \nand NIO \npredefined \nstrictfp \nStrictMath class \nString class \nconstructors \nmethods, table of some \nString ( s ) \narrays of \nchanging case of characters in \ncomparison \nconcatenating \nconstants \nconverting data into a \ncreating \nextracting characters from \nformatted, creating a \nformatting a \nimmutability of \njoining \nlength, obtaining \n\nliterals \nmodifiable, creating and working with \nmodifying",
    "literals \nmodifiable, creating and working with \nmodifying \n\n\nnumbers to and from, converting \nas objects \nparsing a formatted input \nreading \nsearching \nStringBuffer class \nmethods, table of some \nStringBufferInputStream deprecated class \nStringBuilder class \nand synchronization \nStringIndexOutOfBounds exception \nStringJoiner class \nStringReader class \nStringTokenizer class \nmethods, table of \nstringWidth ( ) \nStringWriter class \nstrokeLine ( ) \nstrokeOval ( ) \nstrokeRect ( ) \nstrokeText ( ) \nStroustrup, Bjarne \nStubs ( RMI ) \nSubclass \nsubList ( ) \nsubMap ( ) \nsubmit ( ) \nsubSequence ( ) \nsubSet ( ) \nsubstring ( ) \nsubtractExact ( ) \nsum ( ) \nSun Microsystems \nsuper \nand bounded wildcard arguments \nand interface default methods \nand method references \n\nand methods or instance variables \nsuper ( ) \nand superclass constructors \n\n\nSuperclass",
    "and methods or instance variables \nsuper ( ) \nand superclass constructors \n\n\nSuperclass \n\nabstract \nSupplemental character, definition of \nSupplier<T> predefined functional interface \n@SuppressWarnings built-in annotation \nsuspend ( ) \nSwing \napplet, example of a simple \napplication, example of a simple \nand the AWT \ncomponent classes, list of \ncomponents. See Components, Swing \nevent handling \nhistory of \nand JavaFX \nmenus. See Menu ( s ), Swing \nand MVC architecture \npackages, list of \nand painting \nthreading issues \nSwing: A Beginner\u2019s Guide ( Schildt ) \nSwingConstants interface \nSwingUtilities class \nswitch statement \nand auto-unboxing \nnested \nusing enumeration constants to control a \nusing a String to control a \nversus the if statement \nSynchronization \nand atomic operations \nand collections \nand deadlock \nand interprocess communication \nobjects, using \nrace condition and",
    "and StringBuilder class \nvia synchronized block \nvia synchronized method \nversus concurrency utilities, traditional \n\n\nsynchronized modifier \n\nused with a method \nused with an object \nsynchronizedList ( ) \nsynchronizedSet ( ) \nSynchronizers \nSynchronousQueue class \nSystem class \nmethods, table of \nSystem.console ( ) \nSystem.err standard error stream \nSystem.exit ( ) \nSystem.getProperties ( ) \nSystem.getProperty ( ) \nSystem.in standard input stream \nSystem.in.read ( ) \nSystem.nanoTime ( ) \nSystem.out standard output stream \nand static import \nSystem.out.println ( ) and applets \n\nT \n\nTabbed panes \nTable, Swing \nTableColumnModel \nTableModel \nTableModelEvent class \ntailMap ( ) \ntailSet ( ) \ntan ( ) \ntanh ( ) \n@Target built-in annotation \nTCP/IP \n\nclient sockets \ndisadvantages of \nserver sockets \nSee also Transmission Control Protocol ( TCP ) \nTERMINATE \nTERMINATED",
    "client sockets \ndisadvantages of \nserver sockets \nSee also Transmission Control Protocol ( TCP ) \nTERMINATE \nTERMINATED \n\n\nTernary if-then-else operator (?:) \ntest ( ) \nText area \nText class \nText components as an event source \nText fields \nAWT \nSwing \nText formatting using java.text classes \nText output using font metrics, managing \nTextArea class \nAWT \nJavaFX \nTextComponent class \nTextEvent class \nTextField class \nAWT \nJavaFX \nTexInputControl \nTextListener interface \ntextValueChanged ( ) \nthenComparing ( ) \nthenComparingDouble ( ) \nthenComparingInt ( ) \nthenComparingLong ( ) \nthis \nand lambda expressions \nand type annotations \nthis ( ) \nThompson, Ken \nThread class \nconstructors \nextending \nmethods, table of \nThread ( s ) \ncreating \ndaemon \n\nand deadlock \ndefinition of \nexecutors to manage, using",
    "and deadlock \ndefinition of \nexecutors to manage, using \n\n\ngroup \nJavaFX \nlocal variables \nmain \nmessaging \npool \npriorities \nresuming \nand spurious wakeup \nstates of, possible \nstopping \nsuspending \nand Swing, event dispatching \nsynchronization. See Synchronization \nThread.UncaughtExceptionHandler interface \nThreadGroup class \nmethods, table of \nThreadLocal class \nThreadPoolExecutor class \nthrow \nThrowable class \nmethods defined by, table of \nobtaining an object of the \nthrows \nThumb \ntime \nTime and date \nformatting \njava.util classes that deal with \nstrings, parsing \nTime and Date API \npackages, list of \ntimedJoin ( ) \ntimedWait ( ) \nTIMED_WAITING \nTimer class \n\nmethods, table of \nTimerTask class \nmethods, table of \nTimestamp, event",
    "methods, table of \nTimerTask class \nmethods, table of \nTimestamp, event \n\n\nTimeUnit enumeration \nTimeZone class \nmethods defined by, table of some \nto ( ) \ntoAbsolutePath ( ) \ntoArray ( ) \ntoBinaryString ( ) \ntoCharArray ( ) \ntoDays ( ) \ntoDegrees ( ) \nToDoubleFunction functional interface \ntoFile ( ) \nToggle button, JavaFX \nadding an image to a \nToggle button, Swing \nToggle interface \nToggle group \nhandling change events in a \nand RadioMenuItems \nToggleButton class \nToggleGroup class \ntoHexString ( ) \ntoHours ( ) \ntoIntExact ( ) \nTokens \ntoLanguageTag ( ) \ntoList ( ) \ntoLocalDate ( ) \ntoLocalTime ( ) \ntoLowerCase ( ) \nTomcat \ntoMicros ( ) \ntoMillis ( ) \ntoMinutes ( ) \ntoNanos ( ) \ntoOctalString ( ) \nToolbar class \n\nToolbars \nTooltip class \nTooltips",
    "Toolbars \nTooltip class \nTooltips \n\n\nTooManyListenersException \ntoPath ( ) \ntoRadians ( ) \ntoSeconds ( ) \ntoSet ( ) \ntoString ( ) \ntotalMemory ( ) \ntoUnsignedInt ( ) \ntoUnsignedLong ( ) \ntoUnsignedString ( ) \ntoUpperCase ( ) \ntoZonedDateTime ( ) \ntransient modifier \nTransform class \nTransforms \nprogram demonstrating \nTranslate class \ntranslatePoint ( ) \nTransmission Control Protocol ( TCP ) \ndefinition of \nand stream-based I/O \nSee also TCP/IP \nTreeExpansionEvent class \nTreeExpansionListener interface \nTreeItem class \nTreeMap class \nexample using a comparator \nTreeModel \nTreeModelEvent class \nTreeModelListener interface \nTreeNode interface \nTreePath class \nTrees \nJavaFX \nSwing \nTreeSelectionEvent class \n\nTreeSelectionListener interface \nTreeSelectionModel \nTreeSet class \nTreeView class \n\n\ntrim ( )",
    "TreeSelectionListener interface \nTreeSelectionModel \nTreeSet class \nTreeView class \n\n\ntrim ( ) \n\ntrimToSize ( ) \ntrue \nTRUE \nTrue and false in Java \nTruncation \ntry block ( s ) \nnested \ntry-with-resources statement \nadvantages to using \ntryAdvance ( ) \ntryLock ( ) \ntrySplit ( ) \ntryUnfork ( ) \nTwo\u2019s complement \nTYPE \nType argument ( s ) \nand bounded types \nand generic class hierarchies \nand type inference \nType conversion \nautomatic \nnarrowing \nwidening \nType enumeration \nType interface \nType parameter ( s ) \nand bounded types \ncannot create an instance of a \nand class hierarchies \nand erasure \nand primitive types \nand static members \nand type safety \nused with a class \nused with a method \nType safety \n\nand collections \nand generic methods \nand generics",
    "and collections \nand generic methods \nand generics \n\n\nand raw types \nand wildcard arguments \ntype ( ) \nType ( s ) \nannotations \nbounded \ncasting \nchecking \nclass as a data \ninference \nnon-reifiable \nparameterized \npromotion \nraw \nsimple \nTypeNotPresentException \nTypes, primitive ( simple ) \nautoboxing/unboxing and \nand collections \niterators for \nto a string representation, converting \nto or from a sequence of bytes, converting \nwrappers for \nTypesafe view of a collection, obtaining a dynamically \n\nU \n\nUDP protocol \n\nUI delegate \nulp ( ) \nUnaryOperator functional interface \nUnavailableException \nUnboxing \nuncaughtException ( ) \n\nUncaughtExceptionHandler interface \nUnchecked warnings and raw types \nUnicastRemoteObject \nUnicode \ncode points, table of some Character methods providing support for \nsupport for 32\u2013bit",
    "UncaughtExceptionHandler interface \nUnchecked warnings and raw types \nUnicastRemoteObject \nUnicode \ncode points, table of some Character methods providing support for \nsupport for 32\u2013bit \n\n\nUnicode Technical Standard ( UTS ) 35 \nUniform Resource Identifier ( URI ) \nUniform Resource Locator ( URL ). See URL ( Uniform Resource Locator ) \nUNIX \nUnknownHostException \nunlock ( ) \nunmodifiable\u2026 collections methods \nunordered ( ) \nUnreachable code \nunread ( ) \nUnsupportedOperationException \nupdate ( ) \noverriding \nURI ( Uniform Resource Identifier ) \nURI class \nURL ( Uniform Resource Locator ) \nspecification format \nURL class \nmethods, list of some \nURLConnection class \nuseDelimiter ( ) \nUser Datagram Protocol ( UDP ) \nuseRadix ( ) \nUTS 35 \nUUID class \n\nV \n\nvalue ( annotation member name ) \nvalueChanged ( ) \nvalueOf ( ) \nvalues ( ) \nvan Hoff, Arthur \nVarargs \nand ambiguity \nmethods, overloading \n\nand Java\u2019s printf ( ) \nparameter \nVariable ( s ) \ncapture",
    "and Java\u2019s printf ( ) \nparameter \nVariable ( s ) \ncapture \n\n\ndeclaration \ndefinition of \ndynamic initialization of \neffectively final \nenumeration \nfinal \ninstance. See Instance variables \ninterface \ninterface reference \nobject reference. See Object reference variables \nscope and lifetime of \nVector class \nlegacy methods, table of \nVetoableChangeListener interface \nViewport, scroll pane \nvisitFile ( ) \nvoid \nVoid class \nvolatile modifier \nVSPACE \n\nW \n\nwait ( ) \nwaitFor ( ) \nWAITING \nWALL_TIME \nwalk ( ) \nwalkFileTree ( ) \nWarth, Chris \nWatchable interface \nWeakHashMap class \nWeb browser \nexecuting applet in \n\nusing status window of \nWeb server and servlets \nWebView class \nweightx constraint field \nweighty constraint field \nwhile loop \n\n\nWhitespace",
    "using status window of \nWeb server and servlets \nWebView class \nweightx constraint field \nweighty constraint field \nwhile loop \n\n\nWhitespace \n\nfrom a string, removing \nwhois \nWIDTH \nWildcard arguments \nbounded \nused in creating an array \nWindow, AWT-based \ndisplaying information within an \nas an event source \nframe. See Frame window \nfundamentals \nand graphics \nstatus, using \nWindow class \nWindow, Swing JFrame \nwindowActivated ( ) \nWindowAdapter class \nwindowClosed ( ) \nwindowClosing ( ) \nWindowConstants interface \nwindowDeactivated ( ) \nwindowDeiconified ( ) \nWindowEvent class \nWindowFocusListener interface \nwindowGainedFocus ( ) \nwindowIconified ( ) \nWindowListener interface \nwindowLostFocus ( ) \nwindowOpened ( ) \nWindowStateListener interface \nWork stealing \nWorld Wide Web ( WWW ) \nwrap ( ) \nWrappers, primitive type \nWRITE \n\nwrite ( ) \nwriteBoolean ( ) \nwriteDouble ( ) \nWriter class",
    "write ( ) \nwriteBoolean ( ) \nwriteDouble ( ) \nWriter class \n\n\nmethods defined by, table of \nwriteExternal ( ) \nwriteInt ( ) \nwriteObject ( ) \nwriteTo ( ) \n\nX \n\nXOR ( exclusive OR ) operator (^) \nbitwise \nBoolean logical \n\nY \n\nYellin, Frank \n\nZ \n\nZero crossing \nZIP file format \n\n\n\n\n\n\n\n\n\uf709 \nPREV \nAppendix: Using Java\u2019s Documentation Comments \n\u23ee"
  ],
  "metadata": [
    {
      "chunk_id": 0,
      "page_number": 1,
      "length": 653,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1,
      "page_number": 33,
      "length": 376,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.752,
      "has_code_example": false
    },
    {
      "chunk_id": 2,
      "page_number": 33,
      "length": 966,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 3,
      "page_number": 1,
      "length": 681,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 4,
      "page_number": 34,
      "length": 914,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 5,
      "page_number": 1,
      "length": 988,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 6,
      "page_number": 1,
      "length": 984,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 7,
      "page_number": 1,
      "length": 719,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 8,
      "page_number": 1,
      "length": 260,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.52,
      "has_code_example": false
    },
    {
      "chunk_id": 9,
      "page_number": 35,
      "length": 863,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 10,
      "page_number": 1,
      "length": 718,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 11,
      "page_number": 1,
      "length": 875,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 12,
      "page_number": 1,
      "length": 585,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 13,
      "page_number": 1,
      "length": 433,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.866,
      "has_code_example": false
    },
    {
      "chunk_id": 14,
      "page_number": 36,
      "length": 974,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 15,
      "page_number": 1,
      "length": 735,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 16,
      "page_number": 1,
      "length": 959,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 17,
      "page_number": 37,
      "length": 690,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "public"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 18,
      "page_number": 1,
      "length": 948,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 19,
      "page_number": 1,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 20,
      "page_number": 1,
      "length": 951,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 21,
      "page_number": 1,
      "length": 449,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.898,
      "has_code_example": false
    },
    {
      "chunk_id": 22,
      "page_number": 1,
      "length": 261,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.522,
      "has_code_example": false
    },
    {
      "chunk_id": 23,
      "page_number": 38,
      "length": 944,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 24,
      "page_number": 1,
      "length": 911,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 25,
      "page_number": 1,
      "length": 650,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 26,
      "page_number": 1,
      "length": 860,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 27,
      "page_number": 39,
      "length": 505,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 28,
      "page_number": 1,
      "length": 840,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 29,
      "page_number": 1,
      "length": 999,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 30,
      "page_number": 1,
      "length": 226,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.452,
      "has_code_example": false
    },
    {
      "chunk_id": 31,
      "page_number": 1,
      "length": 802,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "private"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 32,
      "page_number": 40,
      "length": 289,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.578,
      "has_code_example": false
    },
    {
      "chunk_id": 33,
      "page_number": 1,
      "length": 844,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 34,
      "page_number": 1,
      "length": 968,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 35,
      "page_number": 1,
      "length": 700,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 36,
      "page_number": 1,
      "length": 488,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.976,
      "has_code_example": false
    },
    {
      "chunk_id": 37,
      "page_number": 41,
      "length": 935,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 38,
      "page_number": 1,
      "length": 399,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.798,
      "has_code_example": false
    },
    {
      "chunk_id": 39,
      "page_number": 1,
      "length": 995,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 40,
      "page_number": 1,
      "length": 479,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Interface"
      ],
      "code_patterns": [],
      "quality_score": 1.058,
      "has_code_example": false
    },
    {
      "chunk_id": 41,
      "page_number": 42,
      "length": 704,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 42,
      "page_number": 1,
      "length": 744,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 43,
      "page_number": 1,
      "length": 656,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 44,
      "page_number": 1,
      "length": 720,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 45,
      "page_number": 43,
      "length": 842,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 46,
      "page_number": 1,
      "length": 573,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 47,
      "page_number": 1,
      "length": 592,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 48,
      "page_number": 1,
      "length": 713,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 49,
      "page_number": 44,
      "length": 683,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 50,
      "page_number": 1,
      "length": 737,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 51,
      "page_number": 1,
      "length": 824,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 52,
      "page_number": 1,
      "length": 983,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 53,
      "page_number": 1,
      "length": 338,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class in"
      ],
      "quality_score": 0.976,
      "has_code_example": true
    },
    {
      "chunk_id": 54,
      "page_number": 45,
      "length": 411,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.822,
      "has_code_example": false
    },
    {
      "chunk_id": 55,
      "page_number": 45,
      "length": 983,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 56,
      "page_number": 1,
      "length": 227,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "Static",
        "import"
      ],
      "code_patterns": [],
      "quality_score": 0.654,
      "has_code_example": false
    },
    {
      "chunk_id": 57,
      "page_number": 1,
      "length": 980,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "Static",
        "import"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 58,
      "page_number": 46,
      "length": 684,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 59,
      "page_number": 1,
      "length": 938,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 60,
      "page_number": 1,
      "length": 816,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 61,
      "page_number": 1,
      "length": 735,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 62,
      "page_number": 1,
      "length": 493,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.986,
      "has_code_example": false
    },
    {
      "chunk_id": 63,
      "page_number": 47,
      "length": 930,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 64,
      "page_number": 1,
      "length": 478,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.956,
      "has_code_example": false
    },
    {
      "chunk_id": 65,
      "page_number": 1,
      "length": 944,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 66,
      "page_number": 1,
      "length": 200,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.4,
      "has_code_example": false
    },
    {
      "chunk_id": 67,
      "page_number": 1,
      "length": 490,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.08,
      "has_code_example": false
    },
    {
      "chunk_id": 68,
      "page_number": 48,
      "length": 973,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface is",
        "interface without",
        "interface when"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 69,
      "page_number": 1,
      "length": 606,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 70,
      "page_number": 49,
      "length": 675,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 71,
      "page_number": 49,
      "length": 788,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 72,
      "page_number": 1,
      "length": 485,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.97,
      "has_code_example": false
    },
    {
      "chunk_id": 73,
      "page_number": 1,
      "length": 914,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 74,
      "page_number": 1,
      "length": 276,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.552,
      "has_code_example": false
    },
    {
      "chunk_id": 75,
      "page_number": 50,
      "length": 954,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 76,
      "page_number": 1,
      "length": 920,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 77,
      "page_number": 1,
      "length": 658,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 78,
      "page_number": 1,
      "length": 888,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 79,
      "page_number": 51,
      "length": 983,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface to"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 80,
      "page_number": 1,
      "length": 925,
      "chunk_type": "code",
      "java_keywords_count": 12,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class will",
        "class defines",
        "class contains",
        "class is",
        "class are"
      ],
      "quality_score": 3.2,
      "has_code_example": true
    },
    {
      "chunk_id": 81,
      "page_number": 1,
      "length": 965,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "private",
        "public",
        "public",
        "interface",
        "class",
        "class",
        "private",
        "class"
      ],
      "code_patterns": [
        "class are",
        "interface of",
        "class are",
        "class is",
        "class \nmay",
        "interface of",
        "class represents",
        "class need"
      ],
      "quality_score": 4.0,
      "has_code_example": true
    },
    {
      "chunk_id": 82,
      "page_number": 1,
      "length": 305,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "private",
        "class",
        "class",
        "private",
        "private",
        "class",
        "class"
      ],
      "code_patterns": [
        "class cannot",
        "class may"
      ],
      "quality_score": 1.71,
      "has_code_example": true
    },
    {
      "chunk_id": 83,
      "page_number": 1,
      "length": 222,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "public",
        "public",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface should"
      ],
      "quality_score": 1.044,
      "has_code_example": true
    },
    {
      "chunk_id": 84,
      "page_number": 52,
      "length": 81,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "public",
        "private"
      ],
      "code_patterns": [],
      "quality_score": 0.362,
      "has_code_example": false
    },
    {
      "chunk_id": 85,
      "page_number": 1,
      "length": 990,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class animal"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 86,
      "page_number": 1,
      "length": 627,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "abstract",
        "class",
        "class"
      ],
      "code_patterns": [
        "class definition",
        "class of",
        "class of"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 87,
      "page_number": 53,
      "length": 806,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class inherits",
        "class hierarchy",
        "class encapsulates",
        "class will",
        "class inherits"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 88,
      "page_number": 54,
      "length": 463,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface to",
        "class of"
      ],
      "quality_score": 1.5260000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 89,
      "page_number": 55,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "implements",
        "interface",
        "interface",
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface to",
        "interface to",
        "class of"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 90,
      "page_number": 1,
      "length": 581,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 91,
      "page_number": 1,
      "length": 947,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "public",
        "interface"
      ],
      "code_patterns": [
        "interface of"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 92,
      "page_number": 1,
      "length": 924,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface with",
        "interface so",
        "interface with",
        "class definition"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 93,
      "page_number": 1,
      "length": 371,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 0.842,
      "has_code_example": false
    },
    {
      "chunk_id": 94,
      "page_number": 56,
      "length": 904,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface can"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 95,
      "page_number": 1,
      "length": 356,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class libraries"
      ],
      "quality_score": 1.012,
      "has_code_example": true
    },
    {
      "chunk_id": 96,
      "page_number": 1,
      "length": 663,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 97,
      "page_number": 57,
      "length": 930,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class definitions",
        "class defined",
        "class should"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 98,
      "page_number": 1,
      "length": 493,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class should",
        "class \nname",
        "class names"
      ],
      "quality_score": 1.9860000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 99,
      "page_number": 1,
      "length": 820,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class name",
        "class is"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 100,
      "page_number": 58,
      "length": 909,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class and",
        "class extension",
        "class they",
        "class file",
        "class that",
        "class extension"
      ],
      "quality_score": 3.2,
      "has_code_example": true
    },
    {
      "chunk_id": 101,
      "page_number": 1,
      "length": 901,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 102,
      "page_number": 1,
      "length": 995,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class to",
        "class is",
        "class definition",
        "class except"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 103,
      "page_number": 59,
      "length": 945,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "public",
        "class",
        "class",
        "public",
        "class",
        "public",
        "private",
        "class",
        "public"
      ],
      "code_patterns": [
        "class members",
        "class member",
        "class in"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 104,
      "page_number": 1,
      "length": 907,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "static",
        "class"
      ],
      "code_patterns": [
        "class when"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 105,
      "page_number": 1,
      "length": 993,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class String"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 106,
      "page_number": 1,
      "length": 295,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.59,
      "has_code_example": false
    },
    {
      "chunk_id": 107,
      "page_number": 60,
      "length": 639,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 108,
      "page_number": 1,
      "length": 936,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 109,
      "page_number": 1,
      "length": 465,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class definition"
      ],
      "quality_score": 1.23,
      "has_code_example": true
    },
    {
      "chunk_id": 110,
      "page_number": 61,
      "length": 938,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 111,
      "page_number": 62,
      "length": 574,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 112,
      "page_number": 62,
      "length": 905,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 113,
      "page_number": 1,
      "length": 925,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 114,
      "page_number": 63,
      "length": 918,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 115,
      "page_number": 64,
      "length": 781,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 116,
      "page_number": 1,
      "length": 572,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 117,
      "page_number": 65,
      "length": 709,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 118,
      "page_number": 1,
      "length": 915,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 119,
      "page_number": 66,
      "length": 719,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 120,
      "page_number": 67,
      "length": 849,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 121,
      "page_number": 68,
      "length": 971,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 122,
      "page_number": 1,
      "length": 891,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 123,
      "page_number": 69,
      "length": 607,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 124,
      "page_number": 1,
      "length": 488,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.076,
      "has_code_example": false
    },
    {
      "chunk_id": 125,
      "page_number": 70,
      "length": 537,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class predefined",
        "class libraries"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 126,
      "page_number": 1,
      "length": 482,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class libraries",
        "class libraries"
      ],
      "quality_score": 1.6640000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 127,
      "page_number": 71,
      "length": 604,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 128,
      "page_number": 1,
      "length": 751,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 129,
      "page_number": 72,
      "length": 902,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class types"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 130,
      "page_number": 1,
      "length": 870,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 131,
      "page_number": 1,
      "length": 390,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.78,
      "has_code_example": false
    },
    {
      "chunk_id": 132,
      "page_number": 1,
      "length": 987,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 133,
      "page_number": 1,
      "length": 204,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.408,
      "has_code_example": false
    },
    {
      "chunk_id": 134,
      "page_number": 73,
      "length": 703,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 135,
      "page_number": 1,
      "length": 868,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 136,
      "page_number": 74,
      "length": 487,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.974,
      "has_code_example": false
    },
    {
      "chunk_id": 137,
      "page_number": 74,
      "length": 743,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 138,
      "page_number": 75,
      "length": 573,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 139,
      "page_number": 1,
      "length": 583,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 140,
      "page_number": 1,
      "length": 742,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 141,
      "page_number": 76,
      "length": 758,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 142,
      "page_number": 77,
      "length": 851,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 143,
      "page_number": 77,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 144,
      "page_number": 78,
      "length": 880,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 145,
      "page_number": 79,
      "length": 976,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 146,
      "page_number": 1,
      "length": 926,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 147,
      "page_number": 1,
      "length": 413,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.826,
      "has_code_example": false
    },
    {
      "chunk_id": 148,
      "page_number": 1,
      "length": 888,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 149,
      "page_number": 80,
      "length": 366,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.732,
      "has_code_example": false
    },
    {
      "chunk_id": 150,
      "page_number": 1,
      "length": 912,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 151,
      "page_number": 1,
      "length": 942,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 152,
      "page_number": 1,
      "length": 244,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.488,
      "has_code_example": false
    },
    {
      "chunk_id": 153,
      "page_number": 81,
      "length": 919,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 154,
      "page_number": 1,
      "length": 928,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 155,
      "page_number": 1,
      "length": 309,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.618,
      "has_code_example": false
    },
    {
      "chunk_id": 156,
      "page_number": 82,
      "length": 944,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 157,
      "page_number": 1,
      "length": 498,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.996,
      "has_code_example": false
    },
    {
      "chunk_id": 158,
      "page_number": 83,
      "length": 965,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "interface",
        "Class",
        "interface"
      ],
      "code_patterns": [
        "class or",
        "interface types"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 159,
      "page_number": 83,
      "length": 535,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 160,
      "page_number": 1,
      "length": 581,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 161,
      "page_number": 1,
      "length": 709,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 162,
      "page_number": 1,
      "length": 377,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class and",
        "class scope"
      ],
      "quality_score": 1.354,
      "has_code_example": true
    },
    {
      "chunk_id": 163,
      "page_number": 84,
      "length": 946,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class scope"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 164,
      "page_number": 1,
      "length": 525,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 165,
      "page_number": 1,
      "length": 474,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.948,
      "has_code_example": false
    },
    {
      "chunk_id": 166,
      "page_number": 85,
      "length": 571,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 167,
      "page_number": 86,
      "length": 809,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 168,
      "page_number": 86,
      "length": 417,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.834,
      "has_code_example": false
    },
    {
      "chunk_id": 169,
      "page_number": 1,
      "length": 989,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 170,
      "page_number": 1,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 171,
      "page_number": 87,
      "length": 916,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 172,
      "page_number": 88,
      "length": 797,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 173,
      "page_number": 88,
      "length": 794,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 174,
      "page_number": 89,
      "length": 592,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 175,
      "page_number": 1,
      "length": 736,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 176,
      "page_number": 90,
      "length": 679,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 177,
      "page_number": 90,
      "length": 938,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 178,
      "page_number": 91,
      "length": 919,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 179,
      "page_number": 1,
      "length": 519,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 180,
      "page_number": 1,
      "length": 603,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 181,
      "page_number": 92,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 182,
      "page_number": 92,
      "length": 461,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.922,
      "has_code_example": false
    },
    {
      "chunk_id": 183,
      "page_number": 1,
      "length": 635,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 184,
      "page_number": 93,
      "length": 836,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 185,
      "page_number": 94,
      "length": 880,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 186,
      "page_number": 95,
      "length": 967,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 187,
      "page_number": 96,
      "length": 146,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.292,
      "has_code_example": false
    },
    {
      "chunk_id": 188,
      "page_number": 97,
      "length": 940,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 189,
      "page_number": 98,
      "length": 962,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 190,
      "page_number": 1,
      "length": 539,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 191,
      "page_number": 100,
      "length": 904,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 192,
      "page_number": 1,
      "length": 402,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.804,
      "has_code_example": false
    },
    {
      "chunk_id": 193,
      "page_number": 1,
      "length": 974,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 194,
      "page_number": 101,
      "length": 980,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 195,
      "page_number": 102,
      "length": 550,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 196,
      "page_number": 102,
      "length": 941,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 197,
      "page_number": 104,
      "length": 824,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 198,
      "page_number": 105,
      "length": 669,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 199,
      "page_number": 105,
      "length": 627,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 200,
      "page_number": 106,
      "length": 987,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 201,
      "page_number": 106,
      "length": 956,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 202,
      "page_number": 1,
      "length": 949,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 203,
      "page_number": 1,
      "length": 676,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 204,
      "page_number": 1,
      "length": 385,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.77,
      "has_code_example": false
    },
    {
      "chunk_id": 205,
      "page_number": 108,
      "length": 965,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 206,
      "page_number": 109,
      "length": 813,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 207,
      "page_number": 109,
      "length": 775,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 208,
      "page_number": 110,
      "length": 909,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 209,
      "page_number": 111,
      "length": 249,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.498,
      "has_code_example": false
    },
    {
      "chunk_id": 210,
      "page_number": 1,
      "length": 996,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 211,
      "page_number": 1,
      "length": 637,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 212,
      "page_number": 112,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 213,
      "page_number": 113,
      "length": 812,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 214,
      "page_number": 1,
      "length": 570,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 215,
      "page_number": 114,
      "length": 601,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 216,
      "page_number": 1,
      "length": 984,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 217,
      "page_number": 115,
      "length": 766,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 218,
      "page_number": 115,
      "length": 916,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 219,
      "page_number": 116,
      "length": 966,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 220,
      "page_number": 117,
      "length": 962,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 221,
      "page_number": 118,
      "length": 985,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 222,
      "page_number": 119,
      "length": 969,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 223,
      "page_number": 120,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 224,
      "page_number": 120,
      "length": 853,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 225,
      "page_number": 1,
      "length": 705,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 226,
      "page_number": 121,
      "length": 689,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 227,
      "page_number": 1,
      "length": 447,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.894,
      "has_code_example": false
    },
    {
      "chunk_id": 228,
      "page_number": 122,
      "length": 644,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 229,
      "page_number": 122,
      "length": 926,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 230,
      "page_number": 123,
      "length": 803,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 231,
      "page_number": 124,
      "length": 399,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.798,
      "has_code_example": false
    },
    {
      "chunk_id": 232,
      "page_number": 124,
      "length": 832,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 233,
      "page_number": 1,
      "length": 835,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 234,
      "page_number": 125,
      "length": 882,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 235,
      "page_number": 1,
      "length": 665,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 236,
      "page_number": 126,
      "length": 903,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 237,
      "page_number": 127,
      "length": 462,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.124,
      "has_code_example": false
    },
    {
      "chunk_id": 238,
      "page_number": 127,
      "length": 815,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 239,
      "page_number": 128,
      "length": 571,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 240,
      "page_number": 129,
      "length": 961,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 241,
      "page_number": 1,
      "length": 400,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.8,
      "has_code_example": false
    },
    {
      "chunk_id": 242,
      "page_number": 130,
      "length": 976,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 243,
      "page_number": 132,
      "length": 899,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 244,
      "page_number": 134,
      "length": 933,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 245,
      "page_number": 1,
      "length": 989,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 246,
      "page_number": 135,
      "length": 958,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 247,
      "page_number": 136,
      "length": 622,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 248,
      "page_number": 1,
      "length": 845,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 249,
      "page_number": 137,
      "length": 751,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 250,
      "page_number": 1,
      "length": 778,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 251,
      "page_number": 138,
      "length": 581,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 252,
      "page_number": 138,
      "length": 853,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 253,
      "page_number": 1,
      "length": 851,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 254,
      "page_number": 1,
      "length": 146,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.292,
      "has_code_example": false
    },
    {
      "chunk_id": 255,
      "page_number": 140,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 256,
      "page_number": 1,
      "length": 297,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.594,
      "has_code_example": false
    },
    {
      "chunk_id": 257,
      "page_number": 1,
      "length": 498,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.996,
      "has_code_example": false
    },
    {
      "chunk_id": 258,
      "page_number": 141,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 259,
      "page_number": 142,
      "length": 794,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 260,
      "page_number": 143,
      "length": 449,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.898,
      "has_code_example": false
    },
    {
      "chunk_id": 261,
      "page_number": 1,
      "length": 970,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 262,
      "page_number": 144,
      "length": 745,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 263,
      "page_number": 1,
      "length": 487,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.974,
      "has_code_example": false
    },
    {
      "chunk_id": 264,
      "page_number": 145,
      "length": 905,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 265,
      "page_number": 1,
      "length": 948,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 266,
      "page_number": 1,
      "length": 317,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.634,
      "has_code_example": false
    },
    {
      "chunk_id": 267,
      "page_number": 1,
      "length": 646,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 268,
      "page_number": 146,
      "length": 815,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 269,
      "page_number": 147,
      "length": 896,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 270,
      "page_number": 1,
      "length": 977,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 271,
      "page_number": 149,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 272,
      "page_number": 1,
      "length": 858,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 273,
      "page_number": 151,
      "length": 937,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 274,
      "page_number": 152,
      "length": 737,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 275,
      "page_number": 153,
      "length": 709,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 276,
      "page_number": 154,
      "length": 747,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 277,
      "page_number": 1,
      "length": 891,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 278,
      "page_number": 1,
      "length": 428,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.856,
      "has_code_example": false
    },
    {
      "chunk_id": 279,
      "page_number": 155,
      "length": 974,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 280,
      "page_number": 155,
      "length": 973,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 281,
      "page_number": 1,
      "length": 900,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 282,
      "page_number": 157,
      "length": 822,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 283,
      "page_number": 1,
      "length": 802,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 284,
      "page_number": 159,
      "length": 747,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 285,
      "page_number": 160,
      "length": 816,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "Class"
      ],
      "code_patterns": [
        "class is",
        "class \nforms",
        "class is",
        "class and",
        "class can"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 286,
      "page_number": 1,
      "length": 835,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "Class"
      ],
      "code_patterns": [
        "class has",
        "class is",
        "class is"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 287,
      "page_number": 1,
      "length": 631,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Class",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface to",
        "class is",
        "class keyword",
        "class definition"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 288,
      "page_number": 161,
      "length": 506,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class are",
        "class are",
        "class are"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 289,
      "page_number": 1,
      "length": 717,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "static",
        "public",
        "class",
        "class"
      ],
      "code_patterns": [
        "class does",
        "class is"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 290,
      "page_number": 162,
      "length": 688,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class with",
        "class called",
        "class defines",
        "class declaration"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 291,
      "page_number": 1,
      "length": 703,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 292,
      "page_number": 1,
      "length": 515,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 293,
      "page_number": 163,
      "length": 648,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class called",
        "class called",
        "class files",
        "class into",
        "class file",
        "class to",
        "class in"
      ],
      "quality_score": 3.2,
      "has_code_example": true
    },
    {
      "chunk_id": 294,
      "page_number": 164,
      "length": 635,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 295,
      "page_number": 165,
      "length": 978,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class type",
        "class objects"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 296,
      "page_number": 1,
      "length": 614,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 297,
      "page_number": 166,
      "length": 669,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 298,
      "page_number": 1,
      "length": 997,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class type",
        "class that",
        "class name",
        "class is",
        "class definition"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 299,
      "page_number": 1,
      "length": 619,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 300,
      "page_number": 1,
      "length": 634,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 301,
      "page_number": 167,
      "length": 723,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class and",
        "class creates",
        "class creates",
        "class is"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 302,
      "page_number": 1,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 303,
      "page_number": 168,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 304,
      "page_number": 1,
      "length": 967,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class types"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 305,
      "page_number": 1,
      "length": 505,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Class",
        "class",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class that",
        "interface to",
        "class implementor"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 306,
      "page_number": 169,
      "length": 790,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class itself",
        "class rather",
        "class \ncompute"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 307,
      "page_number": 171,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 308,
      "page_number": 1,
      "length": 875,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 309,
      "page_number": 1,
      "length": 440,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class in"
      ],
      "quality_score": 1.18,
      "has_code_example": true
    },
    {
      "chunk_id": 310,
      "page_number": 1,
      "length": 110,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class as"
      ],
      "quality_score": 0.52,
      "has_code_example": true
    },
    {
      "chunk_id": 311,
      "page_number": 172,
      "length": 872,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class where"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 312,
      "page_number": 173,
      "length": 937,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 313,
      "page_number": 1,
      "length": 966,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 314,
      "page_number": 174,
      "length": 886,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 315,
      "page_number": 175,
      "length": 838,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 316,
      "page_number": 176,
      "length": 569,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 317,
      "page_number": 1,
      "length": 562,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class each"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 318,
      "page_number": 1,
      "length": 849,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class in",
        "class type"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 319,
      "page_number": 177,
      "length": 808,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class name",
        "class is"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 320,
      "page_number": 1,
      "length": 882,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class name",
        "class is"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 321,
      "page_number": 179,
      "length": 968,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 322,
      "page_number": 1,
      "length": 798,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 323,
      "page_number": 1,
      "length": 856,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 324,
      "page_number": 181,
      "length": 723,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 325,
      "page_number": 1,
      "length": 842,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 326,
      "page_number": 1,
      "length": 380,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.76,
      "has_code_example": false
    },
    {
      "chunk_id": 327,
      "page_number": 1,
      "length": 789,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 328,
      "page_number": 182,
      "length": 881,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 329,
      "page_number": 1,
      "length": 556,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "Class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 330,
      "page_number": 1,
      "length": 937,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "Class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class is",
        "interface to",
        "class through"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 331,
      "page_number": 1,
      "length": 272,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class through"
      ],
      "quality_score": 1.1440000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 332,
      "page_number": 183,
      "length": 735,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "implements"
      ],
      "code_patterns": [
        "class called"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 333,
      "page_number": 184,
      "length": 916,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class defines",
        "interface defined",
        "class TestStack"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 334,
      "page_number": 185,
      "length": 627,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 335,
      "page_number": 186,
      "length": 567,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 336,
      "page_number": 1,
      "length": 952,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 337,
      "page_number": 1,
      "length": 358,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.716,
      "has_code_example": false
    },
    {
      "chunk_id": 338,
      "page_number": 187,
      "length": 900,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 339,
      "page_number": 189,
      "length": 894,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 340,
      "page_number": 1,
      "length": 994,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class library"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 341,
      "page_number": 1,
      "length": 919,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class library",
        "class to"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 342,
      "page_number": 1,
      "length": 756,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 343,
      "page_number": 190,
      "length": 656,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class developed"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 344,
      "page_number": 191,
      "length": 861,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 345,
      "page_number": 192,
      "length": 479,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.958,
      "has_code_example": false
    },
    {
      "chunk_id": 346,
      "page_number": 193,
      "length": 872,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class type",
        "class as"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 347,
      "page_number": 194,
      "length": 226,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.452,
      "has_code_example": false
    },
    {
      "chunk_id": 348,
      "page_number": 1,
      "length": 885,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 349,
      "page_number": 196,
      "length": 386,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.772,
      "has_code_example": false
    },
    {
      "chunk_id": 350,
      "page_number": 196,
      "length": 893,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class type"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 351,
      "page_number": 197,
      "length": 965,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class types"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 352,
      "page_number": 199,
      "length": 944,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 353,
      "page_number": 1,
      "length": 232,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.464,
      "has_code_example": false
    },
    {
      "chunk_id": 354,
      "page_number": 200,
      "length": 930,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 355,
      "page_number": 1,
      "length": 992,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 356,
      "page_number": 1,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 357,
      "page_number": 1,
      "length": 412,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.824,
      "has_code_example": false
    },
    {
      "chunk_id": 358,
      "page_number": 201,
      "length": 516,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 359,
      "page_number": 202,
      "length": 354,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class creates",
        "class shown"
      ],
      "quality_score": 1.3079999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 360,
      "page_number": 1,
      "length": 976,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "interface",
        "interface",
        "class",
        "package",
        "class",
        "public",
        "private",
        "protected"
      ],
      "code_patterns": [
        "interface to",
        "interface is"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 361,
      "page_number": 1,
      "length": 375,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "public",
        "private",
        "protected",
        "protected",
        "public",
        "private",
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.6500000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 362,
      "page_number": 1,
      "length": 997,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "public",
        "class",
        "private",
        "class",
        "public",
        "class",
        "public",
        "package",
        "package",
        "class",
        "class",
        "private",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class is",
        "class have"
      ],
      "quality_score": 2.9,
      "has_code_example": true
    },
    {
      "chunk_id": 363,
      "page_number": 1,
      "length": 244,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "private",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 0.688,
      "has_code_example": false
    },
    {
      "chunk_id": 364,
      "page_number": 203,
      "length": 919,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "public",
        "private",
        "class",
        "public",
        "public",
        "private",
        "class",
        "class",
        "public",
        "class"
      ],
      "code_patterns": [
        "class shown"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 365,
      "page_number": 204,
      "length": 641,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "private",
        "private",
        "class"
      ],
      "code_patterns": [
        "class shown"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 366,
      "page_number": 205,
      "length": 933,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "public",
        "static",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class member",
        "class member"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 367,
      "page_number": 206,
      "length": 861,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "static",
        "static",
        "class",
        "static",
        "static",
        "static",
        "static",
        "class",
        "static",
        "class",
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [
        "class are",
        "class are",
        "class \nshare"
      ],
      "quality_score": 3.0000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 368,
      "page_number": 1,
      "length": 950,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "class",
        "class",
        "static",
        "static",
        "static",
        "class",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [
        "class is",
        "class that",
        "class is"
      ],
      "quality_score": 2.9,
      "has_code_example": true
    },
    {
      "chunk_id": 369,
      "page_number": 207,
      "length": 987,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "class",
        "static",
        "class",
        "static",
        "class",
        "class",
        "static",
        "static",
        "static",
        "class",
        "implements",
        "static",
        "static",
        "class",
        "final"
      ],
      "code_patterns": [
        "class in",
        "class followed",
        "class in",
        "class name"
      ],
      "quality_score": 3.3,
      "has_code_example": true
    },
    {
      "chunk_id": 370,
      "page_number": 208,
      "length": 460,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2200000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 371,
      "page_number": 1,
      "length": 754,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "final",
        "final",
        "final",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 372,
      "page_number": 1,
      "length": 614,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 373,
      "page_number": 209,
      "length": 901,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nalways"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 374,
      "page_number": 211,
      "length": 954,
      "chunk_type": "code",
      "java_keywords_count": 25,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "private",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "static",
        "static",
        "static",
        "class",
        "static",
        "static",
        "static",
        "class",
        "static",
        "class"
      ],
      "code_patterns": [
        "class within",
        "class is",
        "class B",
        "class A",
        "class has",
        "class in",
        "class does",
        "class that",
        "class scope",
        "class that",
        "class is",
        "class through",
        "class directly"
      ],
      "quality_score": 6.1,
      "has_code_example": true
    },
    {
      "chunk_id": 375,
      "page_number": 1,
      "length": 749,
      "chunk_type": "code",
      "java_keywords_count": 17,
      "java_keywords": [
        "static",
        "static",
        "class",
        "static",
        "class",
        "static",
        "class",
        "class",
        "class",
        "static",
        "class",
        "class",
        "static",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class through",
        "class directly",
        "class is",
        "class is",
        "class and",
        "class do",
        "class named",
        "class called"
      ],
      "quality_score": 4.300000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 376,
      "page_number": 212,
      "length": 947,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class named",
        "class Outer",
        "class Inner",
        "class Outer",
        "class Inner",
        "class Outer",
        "class instance",
        "class has",
        "class are"
      ],
      "quality_score": 3.8,
      "has_code_example": true
    },
    {
      "chunk_id": 377,
      "page_number": 213,
      "length": 699,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class and",
        "class \nscope",
        "class within"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 378,
      "page_number": 214,
      "length": 543,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 379,
      "page_number": 1,
      "length": 901,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class will",
        "class \nin",
        "class library"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 380,
      "page_number": 215,
      "length": 884,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 381,
      "page_number": 215,
      "length": 954,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class contains"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 382,
      "page_number": 217,
      "length": 925,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 383,
      "page_number": 218,
      "length": 289,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.578,
      "has_code_example": false
    },
    {
      "chunk_id": 384,
      "page_number": 1,
      "length": 929,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 385,
      "page_number": 219,
      "length": 808,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 386,
      "page_number": 219,
      "length": 940,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 387,
      "page_number": 1,
      "length": 968,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 388,
      "page_number": 221,
      "length": 914,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 389,
      "page_number": 222,
      "length": 217,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.434,
      "has_code_example": false
    },
    {
      "chunk_id": 390,
      "page_number": 223,
      "length": 844,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 391,
      "page_number": 225,
      "length": 948,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 392,
      "page_number": 226,
      "length": 469,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.938,
      "has_code_example": false
    },
    {
      "chunk_id": 393,
      "page_number": 227,
      "length": 848,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 394,
      "page_number": 227,
      "length": 836,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class can",
        "class that",
        "class that",
        "class is",
        "class and"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 395,
      "page_number": 228,
      "length": 945,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "extends",
        "extends",
        "class",
        "class"
      ],
      "code_patterns": [
        "class into",
        "class called",
        "class called",
        "class of",
        "class B",
        "class for",
        "class for",
        "class does",
        "class cannot",
        "class can",
        "class for",
        "class declaration",
        "class is"
      ],
      "quality_score": 4.2,
      "has_code_example": true
    },
    {
      "chunk_id": 396,
      "page_number": 230,
      "length": 878,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "private",
        "class",
        "private",
        "class",
        "class",
        "private"
      ],
      "code_patterns": [
        "class for",
        "class that",
        "class becomes",
        "class of",
        "class can",
        "class of",
        "class includes",
        "class that",
        "class hierarchy",
        "class member"
      ],
      "quality_score": 3.7,
      "has_code_example": true
    },
    {
      "chunk_id": 397,
      "page_number": 231,
      "length": 880,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "private",
        "private",
        "class",
        "class",
        "final",
        "class",
        "class"
      ],
      "code_patterns": [
        "class member",
        "class developed",
        "class will",
        "class that"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 398,
      "page_number": 234,
      "length": 776,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class can",
        "class inherits",
        "class that",
        "class can",
        "class simply",
        "class Variable",
        "class Object",
        "class can",
        "class derived"
      ],
      "quality_score": 2.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 399,
      "page_number": 1,
      "length": 211,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 0.622,
      "has_code_example": true
    },
    {
      "chunk_id": 400,
      "page_number": 235,
      "length": 883,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class object",
        "class reference",
        "class has",
        "class adds"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 401,
      "page_number": 1,
      "length": 990,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "private"
      ],
      "code_patterns": [
        "class must",
        "class that",
        "class to",
        "class needs"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 402,
      "page_number": 1,
      "length": 317,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class needs",
        "class that"
      ],
      "quality_score": 1.034,
      "has_code_example": true
    },
    {
      "chunk_id": 403,
      "page_number": 1,
      "length": 428,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Constructors",
        "class can",
        "class by"
      ],
      "quality_score": 1.556,
      "has_code_example": true
    },
    {
      "chunk_id": 404,
      "page_number": 236,
      "length": 939,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "private",
        "private"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 405,
      "page_number": 237,
      "length": 863,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class variable",
        "class calls",
        "class \nimmediately",
        "class constructor"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 406,
      "page_number": 240,
      "length": 746,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class of",
        "class in",
        "class hide",
        "class \nhierarchy"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 407,
      "page_number": 241,
      "length": 921,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class hierarchies",
        "class and",
        "class as",
        "class of",
        "class of",
        "class of",
        "class \ninherits",
        "class BoxWeight",
        "class to",
        "class called"
      ],
      "quality_score": 3.1,
      "has_code_example": true
    },
    {
      "chunk_id": 408,
      "page_number": 242,
      "length": 748,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \nhierarchy",
        "class constructor",
        "class needs"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 409,
      "page_number": 1,
      "length": 670,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class hierarchy",
        "class hierarchies",
        "class hierarchy",
        "class called",
        "class \n\ncalled"
      ],
      "quality_score": 2.4,
      "has_code_example": true
    },
    {
      "chunk_id": 410,
      "page_number": 245,
      "length": 924,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \n\n\nhierarchy",
        "class to",
        "class will",
        "class has"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 411,
      "page_number": 246,
      "length": 574,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class hierarchy",
        "class has",
        "class is",
        "class will"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 412,
      "page_number": 247,
      "length": 960,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class version",
        "class version",
        "class version"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 413,
      "page_number": 248,
      "length": 367,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.734,
      "has_code_example": false
    },
    {
      "chunk_id": 414,
      "page_number": 1,
      "length": 852,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [
        "class reference",
        "class object"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 415,
      "page_number": 1,
      "length": 914,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class reference",
        "class contains",
        "class reference"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 416,
      "page_number": 250,
      "length": 860,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class called"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 417,
      "page_number": 1,
      "length": 926,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "implements",
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class to",
        "class provides",
        "class can",
        "class must",
        "class the"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 418,
      "page_number": 1,
      "length": 675,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "interface",
        "abstract",
        "interface"
      ],
      "code_patterns": [
        "class must",
        "class the",
        "class \ncan",
        "interface is"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 419,
      "page_number": 252,
      "length": 969,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "Abstract"
      ],
      "code_patterns": [
        "class called",
        "interface that",
        "interface to"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 420,
      "page_number": 1,
      "length": 572,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Abstract",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class that",
        "class to",
        "class determines",
        "class is"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 421,
      "page_number": 254,
      "length": 587,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class Figure",
        "class libraries"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 422,
      "page_number": 254,
      "length": 901,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "abstract",
        "abstract",
        "abstract",
        "abstract"
      ],
      "code_patterns": [
        "class in",
        "class to",
        "class Triangle",
        "class does",
        "class must"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 423,
      "page_number": 1,
      "length": 845,
      "chunk_type": "code",
      "java_keywords_count": 26,
      "java_keywords": [
        "abstract",
        "class",
        "abstract",
        "abstract",
        "class",
        "abstract",
        "abstract",
        "class",
        "class",
        "abstract",
        "class",
        "abstract",
        "class",
        "abstract",
        "class",
        "abstract",
        "abstract",
        "static",
        "abstract",
        "class",
        "abstract",
        "abstract",
        "class",
        "abstract",
        "class",
        "implements"
      ],
      "code_patterns": [
        "class that",
        "class abstract",
        "class keyword",
        "class declaration",
        "class cannot",
        "class is",
        "class of",
        "class must",
        "class with",
        "class which"
      ],
      "quality_score": 5.6,
      "has_code_example": true
    },
    {
      "chunk_id": 424,
      "page_number": 255,
      "length": 954,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "class",
        "abstract",
        "class",
        "class",
        "implements",
        "Abstract",
        "abstract",
        "abstract",
        "class",
        "abstract",
        "class",
        "class",
        "abstract"
      ],
      "code_patterns": [
        "class A",
        "class A",
        "class references",
        "class so",
        "class object",
        "class shown"
      ],
      "quality_score": 3.5,
      "has_code_example": true
    },
    {
      "chunk_id": 425,
      "page_number": 1,
      "length": 258,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "abstract"
      ],
      "code_patterns": [],
      "quality_score": 0.616,
      "has_code_example": false
    },
    {
      "chunk_id": 426,
      "page_number": 256,
      "length": 954,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "abstract",
        "class",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [
        "class that",
        "class derived",
        "class reference"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 427,
      "page_number": 1,
      "length": 368,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "final",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1360000000000001,
      "has_code_example": false
    },
    {
      "chunk_id": 428,
      "page_number": 1,
      "length": 862,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "final",
        "final",
        "final",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 429,
      "page_number": 258,
      "length": 748,
      "chunk_type": "code",
      "java_keywords_count": 17,
      "java_keywords": [
        "final",
        "final",
        "class",
        "class",
        "final",
        "class",
        "final",
        "final",
        "class",
        "abstract",
        "final",
        "abstract",
        "class",
        "final",
        "class",
        "final",
        "Class"
      ],
      "code_patterns": [
        "class from",
        "class declaration",
        "class as",
        "class as",
        "class is"
      ],
      "quality_score": 3.7,
      "has_code_example": true
    },
    {
      "chunk_id": 430,
      "page_number": 1,
      "length": 961,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "final",
        "Class",
        "class",
        "class",
        "Class",
        "class"
      ],
      "code_patterns": [
        "class of",
        "class of"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 431,
      "page_number": 259,
      "length": 527,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 432,
      "page_number": 1,
      "length": 971,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 433,
      "page_number": 260,
      "length": 219,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.438,
      "has_code_example": false
    },
    {
      "chunk_id": 434,
      "page_number": 1,
      "length": 936,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "class",
        "package",
        "class",
        "package",
        "class",
        "class",
        "interface",
        "class",
        "interface",
        "abstract",
        "interface",
        "interface",
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "class name",
        "class named",
        "class \nnamed",
        "class definitions",
        "interface to",
        "interface keyword",
        "interface \nfrom"
      ],
      "quality_score": 3.8000000000000007,
      "has_code_example": true
    },
    {
      "chunk_id": 435,
      "page_number": 1,
      "length": 175,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "class",
        "abstract"
      ],
      "code_patterns": [
        "interface s",
        "class can",
        "class can"
      ],
      "quality_score": 1.4500000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 436,
      "page_number": 1,
      "length": 972,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "package",
        "package",
        "package"
      ],
      "code_patterns": [
        "class was",
        "class to",
        "class will",
        "class \nnames",
        "class name",
        "class name"
      ],
      "quality_score": 3.2,
      "has_code_example": true
    },
    {
      "chunk_id": 437,
      "page_number": 261,
      "length": 924,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "package",
        "class",
        "package",
        "Package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "class",
        "package",
        "package",
        "package",
        "package",
        "package"
      ],
      "code_patterns": [
        "class members",
        "class names"
      ],
      "quality_score": 2.9,
      "has_code_example": true
    },
    {
      "chunk_id": 438,
      "page_number": 1,
      "length": 943,
      "chunk_type": "code",
      "java_keywords_count": 12,
      "java_keywords": [
        "package",
        "package",
        "package",
        "class",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package"
      ],
      "code_patterns": [
        "class files"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 439,
      "page_number": 1,
      "length": 676,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "package",
        "package",
        "package",
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 440,
      "page_number": 262,
      "length": 923,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "package",
        "package",
        "class",
        "class"
      ],
      "code_patterns": [
        "class path",
        "class path"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 441,
      "page_number": 263,
      "length": 711,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "package",
        "class",
        "Package",
        "package",
        "class",
        "class"
      ],
      "code_patterns": [
        "class path",
        "class files",
        "class file"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 442,
      "page_number": 264,
      "length": 454,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.108,
      "has_code_example": false
    },
    {
      "chunk_id": 443,
      "page_number": 264,
      "length": 958,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "package",
        "private",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class is",
        "class members"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 444,
      "page_number": 1,
      "length": 959,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "package",
        "package",
        "package",
        "private",
        "public",
        "protected",
        "Class",
        "public",
        "private",
        "class",
        "package",
        "package",
        "class",
        "protected"
      ],
      "code_patterns": [
        "class your",
        "class directly"
      ],
      "quality_score": 2.8000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 445,
      "page_number": 265,
      "length": 555,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "package",
        "class",
        "protected",
        "class",
        "public",
        "class",
        "public",
        "class",
        "package",
        "class",
        "public",
        "public",
        "class",
        "class"
      ],
      "code_patterns": [
        "class your",
        "class directly",
        "class has",
        "class is",
        "class has",
        "class is",
        "class declared"
      ],
      "quality_score": 3.8000000000000007,
      "has_code_example": true
    },
    {
      "chunk_id": 446,
      "page_number": 1,
      "length": 548,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "package",
        "class",
        "private"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 447,
      "page_number": 1,
      "length": 675,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "protected",
        "public",
        "class",
        "class",
        "class",
        "package",
        "private",
        "class",
        "package"
      ],
      "code_patterns": [
        "class in",
        "class of",
        "class of"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 448,
      "page_number": 266,
      "length": 903,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "package",
        "class",
        "private",
        "class",
        "package",
        "class",
        "public",
        "package"
      ],
      "code_patterns": [
        "class of",
        "class or",
        "class OtherPackage"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 449,
      "page_number": 1,
      "length": 950,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "package",
        "package",
        "package",
        "package",
        "class",
        "import",
        "class",
        "import",
        "import"
      ],
      "code_patterns": [
        "class you",
        "class can"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 450,
      "page_number": 1,
      "length": 211,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "import",
        "import",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 0.722,
      "has_code_example": false
    },
    {
      "chunk_id": 451,
      "page_number": 269,
      "length": 593,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "class",
        "import",
        "import",
        "package",
        "package",
        "package",
        "package",
        "import",
        "package"
      ],
      "code_patterns": [
        "class definitions"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 452,
      "page_number": 1,
      "length": 485,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "package",
        "package",
        "package",
        "import",
        "package",
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.77,
      "has_code_example": true
    },
    {
      "chunk_id": 453,
      "page_number": 1,
      "length": 627,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "class",
        "import",
        "class",
        "package",
        "import",
        "class",
        "package",
        "import",
        "import"
      ],
      "code_patterns": [
        "class with",
        "class specifying",
        "class \nname"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 454,
      "page_number": 270,
      "length": 976,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "import",
        "package",
        "package",
        "public",
        "class",
        "package",
        "class",
        "public",
        "class",
        "public",
        "public",
        "package",
        "class",
        "public",
        "class"
      ],
      "code_patterns": [
        "class of",
        "class for",
        "class is",
        "class and"
      ],
      "quality_score": 3.3,
      "has_code_example": true
    },
    {
      "chunk_id": 455,
      "page_number": 1,
      "length": 237,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "public",
        "class",
        "interface",
        "abstract",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class and",
        "interface from"
      ],
      "quality_score": 1.4740000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 456,
      "page_number": 271,
      "length": 895,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "class",
        "interface",
        "class",
        "interface",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class must",
        "class can",
        "class must",
        "class is",
        "interface keyword"
      ],
      "quality_score": 3.0,
      "has_code_example": true
    },
    {
      "chunk_id": 457,
      "page_number": 1,
      "length": 810,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "static",
        "class"
      ],
      "code_patterns": [
        "class to",
        "class hierarchy"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 458,
      "page_number": 1,
      "length": 105,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class hierarchy"
      ],
      "quality_score": 0.6100000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 459,
      "page_number": 1,
      "length": 486,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "Interface",
        "interface",
        "class",
        "interface",
        "interface",
        "package",
        "public",
        "interface",
        "interface",
        "public",
        "interface"
      ],
      "code_patterns": [
        "interface is",
        "interface is",
        "interface can",
        "interface must",
        "interface declared"
      ],
      "quality_score": 3.072,
      "has_code_example": true
    },
    {
      "chunk_id": 460,
      "page_number": 272,
      "length": 391,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "interface",
        "abstract",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class that",
        "interface must"
      ],
      "quality_score": 1.682,
      "has_code_example": true
    },
    {
      "chunk_id": 461,
      "page_number": 1,
      "length": 818,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface that",
        "interface \ncould",
        "interface that",
        "interface could",
        "interface \nmethod",
        "interface to",
        "interface still"
      ],
      "quality_score": 3.1000000000000005,
      "has_code_example": true
    },
    {
      "chunk_id": 462,
      "page_number": 1,
      "length": 714,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "final",
        "static",
        "class",
        "public",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface still",
        "interface in",
        "interface declarations",
        "interface definition",
        "interface that"
      ],
      "quality_score": 2.9,
      "has_code_example": true
    },
    {
      "chunk_id": 463,
      "page_number": 273,
      "length": 917,
      "chunk_type": "code",
      "java_keywords_count": 21,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "implements",
        "class",
        "interface",
        "class",
        "implements",
        "class",
        "implements",
        "interface",
        "class",
        "implements",
        "interface",
        "interface",
        "public",
        "interface",
        "class",
        "implements",
        "interface",
        "public"
      ],
      "code_patterns": [
        "interface has",
        "class definition",
        "class that",
        "class implements",
        "class implements",
        "interface must",
        "interface definition",
        "class that",
        "interface shown"
      ],
      "quality_score": 4.9,
      "has_code_example": true
    },
    {
      "chunk_id": 464,
      "page_number": 1,
      "length": 716,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "class",
        "implements",
        "interface",
        "public",
        "interface",
        "public",
        "implements",
        "Interface",
        "interface",
        "class",
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class that",
        "interface shown",
        "interface method",
        "interface rather",
        "class type",
        "class that",
        "interface can"
      ],
      "quality_score": 3.7,
      "has_code_example": true
    },
    {
      "chunk_id": 465,
      "page_number": 274,
      "length": 771,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "implements",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface rather",
        "class type",
        "class that",
        "interface can",
        "interface being",
        "interface without",
        "class reference",
        "class object"
      ],
      "quality_score": 3.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 466,
      "page_number": 1,
      "length": 460,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface reference",
        "interface type"
      ],
      "quality_score": 1.52,
      "has_code_example": true
    },
    {
      "chunk_id": 467,
      "page_number": 275,
      "length": 846,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface type",
        "interface reference",
        "interface declaration",
        "interface reference"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 468,
      "page_number": 275,
      "length": 695,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "interface",
        "class",
        "abstract",
        "class",
        "abstract",
        "class",
        "abstract"
      ],
      "code_patterns": [
        "class includes",
        "interface but",
        "class must",
        "class Incomplete",
        "class that"
      ],
      "quality_score": 3.0,
      "has_code_example": true
    },
    {
      "chunk_id": 469,
      "page_number": 277,
      "length": 848,
      "chunk_type": "code",
      "java_keywords_count": 23,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "public",
        "private",
        "protected",
        "interface",
        "public",
        "interface",
        "class",
        "interface",
        "class",
        "interface",
        "interface",
        "interface",
        "interface",
        "public",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "interface can",
        "class or",
        "interface is",
        "interface or",
        "interface can",
        "interface is",
        "class or",
        "interface of",
        "class or",
        "interface in",
        "interface is",
        "interface called",
        "interface by"
      ],
      "quality_score": 5.9,
      "has_code_example": true
    },
    {
      "chunk_id": 470,
      "page_number": 277,
      "length": 867,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "interface",
        "public",
        "implements",
        "interface",
        "class",
        "implements",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface called",
        "interface by",
        "class called",
        "interface to"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 471,
      "page_number": 278,
      "length": 963,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "interface to",
        "interface to",
        "interface that",
        "interface will",
        "class called",
        "interface definition"
      ],
      "quality_score": 3.0,
      "has_code_example": true
    },
    {
      "chunk_id": 472,
      "page_number": 280,
      "length": 741,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class uses",
        "interface reference",
        "interface through",
        "interface reference"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 473,
      "page_number": 283,
      "length": 785,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "import",
        "interface",
        "interface",
        "class",
        "interface",
        "interface",
        "class",
        "interface",
        "class",
        "class",
        "final"
      ],
      "code_patterns": [
        "interface that",
        "interface in",
        "interface \n\ncontains",
        "class that",
        "interface doesn",
        "class were",
        "class \nname"
      ],
      "quality_score": 3.5,
      "has_code_example": true
    },
    {
      "chunk_id": 474,
      "page_number": 283,
      "length": 906,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class \nprovides",
        "interface where",
        "class had",
        "interface to"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 475,
      "page_number": 286,
      "length": 819,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "interface",
        "interface",
        "extends",
        "class",
        "implements",
        "interface",
        "interface",
        "interface",
        "class",
        "implements",
        "interface",
        "interface",
        "Interface"
      ],
      "code_patterns": [
        "interface to",
        "interface can",
        "class implements",
        "interface that",
        "interface inheritance",
        "class that",
        "interface must"
      ],
      "quality_score": 3.7,
      "has_code_example": true
    },
    {
      "chunk_id": 476,
      "page_number": 1,
      "length": 394,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "Interface",
        "interface",
        "interface",
        "abstract",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface could",
        "interface were",
        "interface and",
        "interface that"
      ],
      "quality_score": 2.188,
      "has_code_example": true
    },
    {
      "chunk_id": 477,
      "page_number": 287,
      "length": 853,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "abstract",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface called",
        "interface method",
        "interface method"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 478,
      "page_number": 1,
      "length": 607,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface \nthat",
        "interface is"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 479,
      "page_number": 1,
      "length": 609,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface might",
        "interface is",
        "class that"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 480,
      "page_number": 1,
      "length": 956,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "class",
        "interface",
        "interface",
        "interface",
        "class",
        "class",
        "interface",
        "interface",
        "class",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface that",
        "class \nused",
        "interface makes",
        "class optional",
        "interface still",
        "interface and",
        "class is",
        "class can",
        "interface cannot",
        "interface by",
        "interface can",
        "interface must",
        "class if"
      ],
      "quality_score": 5.1,
      "has_code_example": true
    },
    {
      "chunk_id": 481,
      "page_number": 1,
      "length": 425,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface can",
        "interface must",
        "class if"
      ],
      "quality_score": 1.75,
      "has_code_example": true
    },
    {
      "chunk_id": 482,
      "page_number": 1,
      "length": 251,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface default"
      ],
      "quality_score": 1.002,
      "has_code_example": true
    },
    {
      "chunk_id": 483,
      "page_number": 288,
      "length": 928,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface method",
        "class to",
        "class does",
        "class shown"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 484,
      "page_number": 289,
      "length": 744,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nis",
        "class will",
        "class uses",
        "class to"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 485,
      "page_number": 290,
      "length": 847,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface shown",
        "interface so",
        "interface can"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 486,
      "page_number": 1,
      "length": 767,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "implements",
        "class",
        "implements",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class that",
        "class \nprovide"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 487,
      "page_number": 1,
      "length": 908,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "interface",
        "class",
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface can",
        "interface \ncan",
        "class and",
        "class can",
        "interface cannot"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 488,
      "page_number": 1,
      "length": 263,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface cannot",
        "class that"
      ],
      "quality_score": 1.126,
      "has_code_example": true
    },
    {
      "chunk_id": 489,
      "page_number": 291,
      "length": 982,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "implements",
        "class",
        "extends",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class \ncalled",
        "class implementation",
        "interface default"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 490,
      "page_number": 1,
      "length": 922,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "interface",
        "implements",
        "class",
        "implements",
        "class",
        "implements",
        "interface",
        "interface",
        "extends"
      ],
      "code_patterns": [
        "class implementation",
        "interface default",
        "class implements",
        "class does",
        "interface inherits"
      ],
      "quality_score": 3.0,
      "has_code_example": true
    },
    {
      "chunk_id": 491,
      "page_number": 1,
      "length": 264,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "interface"
      ],
      "code_patterns": [
        "interface by"
      ],
      "quality_score": 0.9279999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 492,
      "page_number": 292,
      "length": 983,
      "chunk_type": "code",
      "java_keywords_count": 18,
      "java_keywords": [
        "static",
        "Interface",
        "interface",
        "static",
        "static",
        "class",
        "static",
        "interface",
        "interface",
        "interface",
        "static",
        "static",
        "interface",
        "static",
        "class",
        "static",
        "interface",
        "static"
      ],
      "code_patterns": [
        "interface can",
        "interface is",
        "interface is",
        "interface name",
        "class is",
        "interface by"
      ],
      "quality_score": 4.0,
      "has_code_example": true
    },
    {
      "chunk_id": 493,
      "page_number": 293,
      "length": 942,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "static",
        "static",
        "interface",
        "class",
        "Final"
      ],
      "code_patterns": [
        "interface methods",
        "class \nor"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 494,
      "page_number": 293,
      "length": 748,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 495,
      "page_number": 1,
      "length": 996,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 496,
      "page_number": 1,
      "length": 351,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.702,
      "has_code_example": false
    },
    {
      "chunk_id": 497,
      "page_number": 295,
      "length": 853,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Throwable"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 498,
      "page_number": 1,
      "length": 451,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class Throwable",
        "class hierarchy",
        "class is"
      ],
      "quality_score": 1.802,
      "has_code_example": true
    },
    {
      "chunk_id": 499,
      "page_number": 296,
      "length": 892,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class that",
        "class to",
        "class of"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 500,
      "page_number": 1,
      "length": 602,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 501,
      "page_number": 1,
      "length": 422,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.844,
      "has_code_example": false
    },
    {
      "chunk_id": 502,
      "page_number": 297,
      "length": 917,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class name",
        "class of"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 503,
      "page_number": 1,
      "length": 761,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 504,
      "page_number": 298,
      "length": 499,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.998,
      "has_code_example": false
    },
    {
      "chunk_id": 505,
      "page_number": 1,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 506,
      "page_number": 1,
      "length": 434,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 0.968,
      "has_code_example": false
    },
    {
      "chunk_id": 507,
      "page_number": 299,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 508,
      "page_number": 300,
      "length": 683,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 509,
      "page_number": 301,
      "length": 972,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class will",
        "class would"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 510,
      "page_number": 1,
      "length": 846,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 511,
      "page_number": 302,
      "length": 917,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 512,
      "page_number": 303,
      "length": 968,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 513,
      "page_number": 1,
      "length": 265,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 0.73,
      "has_code_example": true
    },
    {
      "chunk_id": 514,
      "page_number": 305,
      "length": 899,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 515,
      "page_number": 306,
      "length": 986,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 516,
      "page_number": 1,
      "length": 971,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 517,
      "page_number": 307,
      "length": 334,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.668,
      "has_code_example": false
    },
    {
      "chunk_id": 518,
      "page_number": 1,
      "length": 868,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 519,
      "page_number": 1,
      "length": 493,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.986,
      "has_code_example": false
    },
    {
      "chunk_id": 520,
      "page_number": 308,
      "length": 913,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 521,
      "page_number": 1,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 522,
      "page_number": 310,
      "length": 793,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class of",
        "class of",
        "class does"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 523,
      "page_number": 311,
      "length": 913,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "public"
      ],
      "code_patterns": [
        "class does"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 524,
      "page_number": 312,
      "length": 558,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of",
        "class to"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 525,
      "page_number": 313,
      "length": 609,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class of",
        "class is",
        "class defines"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 526,
      "page_number": 1,
      "length": 951,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 527,
      "page_number": 1,
      "length": 768,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 528,
      "page_number": 314,
      "length": 931,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 529,
      "page_number": 315,
      "length": 790,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 530,
      "page_number": 1,
      "length": 990,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 531,
      "page_number": 1,
      "length": 446,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1920000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 532,
      "page_number": 316,
      "length": 941,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 533,
      "page_number": 317,
      "length": 946,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 534,
      "page_number": 1,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 535,
      "page_number": 1,
      "length": 986,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 536,
      "page_number": 1,
      "length": 365,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.73,
      "has_code_example": false
    },
    {
      "chunk_id": 537,
      "page_number": 318,
      "length": 605,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 538,
      "page_number": 318,
      "length": 969,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 539,
      "page_number": 1,
      "length": 968,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class libraries"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 540,
      "page_number": 1,
      "length": 948,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 541,
      "page_number": 1,
      "length": 570,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 542,
      "page_number": 319,
      "length": 775,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 543,
      "page_number": 1,
      "length": 501,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 544,
      "page_number": 1,
      "length": 929,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 545,
      "page_number": 320,
      "length": 901,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 546,
      "page_number": 1,
      "length": 927,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 547,
      "page_number": 1,
      "length": 553,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "synchronized",
        "synchronized",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 548,
      "page_number": 1,
      "length": 655,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "synchronized",
        "Class",
        "Interface"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 549,
      "page_number": 321,
      "length": 903,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "Class",
        "Interface",
        "class",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 550,
      "page_number": 1,
      "length": 954,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 551,
      "page_number": 322,
      "length": 648,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "public",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 552,
      "page_number": 322,
      "length": 981,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 553,
      "page_number": 323,
      "length": 873,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 554,
      "page_number": 1,
      "length": 931,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "static",
        "static",
        "class",
        "final",
        "final"
      ],
      "code_patterns": [
        "class and"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 555,
      "page_number": 324,
      "length": 819,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "final",
        "final",
        "interface",
        "class",
        "class",
        "implements",
        "interface",
        "implements",
        "class",
        "public"
      ],
      "code_patterns": [
        "class that",
        "class need",
        "public void run ("
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 556,
      "page_number": 324,
      "length": 730,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "public",
        "class",
        "implements",
        "class"
      ],
      "code_patterns": [
        "public void run (",
        "class that"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 557,
      "page_number": 325,
      "length": 662,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 558,
      "page_number": 325,
      "length": 797,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 559,
      "page_number": 1,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "extends",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class must"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 560,
      "page_number": 327,
      "length": 406,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "public"
      ],
      "code_patterns": [],
      "quality_score": 0.912,
      "has_code_example": false
    },
    {
      "chunk_id": 561,
      "page_number": 1,
      "length": 982,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class defines",
        "class does"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 562,
      "page_number": 329,
      "length": 607,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 563,
      "page_number": 1,
      "length": 983,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 564,
      "page_number": 331,
      "length": 761,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 565,
      "page_number": 333,
      "length": 570,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 566,
      "page_number": 1,
      "length": 496,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.992,
      "has_code_example": false
    },
    {
      "chunk_id": 567,
      "page_number": 334,
      "length": 859,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 568,
      "page_number": 1,
      "length": 926,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "final",
        "static",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 569,
      "page_number": 1,
      "length": 969,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "synchronized",
        "Synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 570,
      "page_number": 335,
      "length": 877,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "synchronized",
        "synchronized",
        "synchronized",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 571,
      "page_number": 1,
      "length": 468,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.036,
      "has_code_example": false
    },
    {
      "chunk_id": 572,
      "page_number": 1,
      "length": 511,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class and",
        "class starts"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 573,
      "page_number": 337,
      "length": 936,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 574,
      "page_number": 1,
      "length": 829,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "synchronized",
        "synchronized",
        "synchronized",
        "synchronized",
        "synchronized",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 575,
      "page_number": 338,
      "length": 831,
      "chunk_type": "code",
      "java_keywords_count": 12,
      "java_keywords": [
        "synchronized",
        "class",
        "class",
        "synchronized",
        "class",
        "synchronized",
        "class",
        "class",
        "synchronized",
        "class",
        "synchronized",
        "synchronized"
      ],
      "code_patterns": [
        "class that",
        "class does",
        "class was",
        "class be",
        "class inside"
      ],
      "quality_score": 3.2,
      "has_code_example": true
    },
    {
      "chunk_id": 576,
      "page_number": 338,
      "length": 790,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "synchronized",
        "synchronized",
        "synchronized",
        "synchronized",
        "synchronized",
        "class",
        "synchronized",
        "synchronized",
        "synchronized"
      ],
      "code_patterns": [
        "class inside",
        "class occurs"
      ],
      "quality_score": 2.4,
      "has_code_example": true
    },
    {
      "chunk_id": 577,
      "page_number": 340,
      "length": 932,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 578,
      "page_number": 1,
      "length": 848,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 579,
      "page_number": 1,
      "length": 544,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 580,
      "page_number": 1,
      "length": 923,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 581,
      "page_number": 341,
      "length": 946,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "implements",
        "class",
        "synchronized"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 582,
      "page_number": 343,
      "length": 808,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 583,
      "page_number": 345,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "synchronized",
        "synchronized",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 584,
      "page_number": 346,
      "length": 800,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "synchronized",
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 585,
      "page_number": 346,
      "length": 671,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 586,
      "page_number": 1,
      "length": 987,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class was"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 587,
      "page_number": 1,
      "length": 999,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class was"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 588,
      "page_number": 1,
      "length": 461,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.922,
      "has_code_example": false
    },
    {
      "chunk_id": 589,
      "page_number": 349,
      "length": 374,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.748,
      "has_code_example": false
    },
    {
      "chunk_id": 590,
      "page_number": 1,
      "length": 985,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "synchronized"
      ],
      "code_patterns": [
        "class contains"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 591,
      "page_number": 1,
      "length": 253,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.506,
      "has_code_example": false
    },
    {
      "chunk_id": 592,
      "page_number": 350,
      "length": 950,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 593,
      "page_number": 353,
      "length": 809,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 594,
      "page_number": 353,
      "length": 777,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 595,
      "page_number": 1,
      "length": 994,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 596,
      "page_number": 354,
      "length": 636,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 597,
      "page_number": 1,
      "length": 951,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "class"
      ],
      "code_patterns": [
        "class type"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 598,
      "page_number": 1,
      "length": 317,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.634,
      "has_code_example": false
    },
    {
      "chunk_id": 599,
      "page_number": 355,
      "length": 922,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "enum",
        "public",
        "static",
        "final",
        "class",
        "enum"
      ],
      "code_patterns": [
        "class type"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 600,
      "page_number": 1,
      "length": 982,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "enum",
        "enum"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 601,
      "page_number": 356,
      "length": 719,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "enum",
        "public",
        "static",
        "enum",
        "public",
        "static",
        "enum"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 602,
      "page_number": 359,
      "length": 985,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "public",
        "static",
        "enum",
        "public",
        "static",
        "enum",
        "enum"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 603,
      "page_number": 360,
      "length": 259,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 0.618,
      "has_code_example": false
    },
    {
      "chunk_id": 604,
      "page_number": 361,
      "length": 932,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "Class",
        "class",
        "enum",
        "enum",
        "class",
        "enum"
      ],
      "code_patterns": [
        "class type",
        "class gives"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 605,
      "page_number": 361,
      "length": 969,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 606,
      "page_number": 1,
      "length": 842,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "enum",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 607,
      "page_number": 1,
      "length": 635,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "enum",
        "enum",
        "enum",
        "class",
        "class",
        "Enum",
        "enum"
      ],
      "code_patterns": [
        "class type",
        "class in",
        "class when"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 608,
      "page_number": 363,
      "length": 960,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Enum",
        "enum",
        "Enum",
        "class",
        "Enum",
        "class",
        "final"
      ],
      "code_patterns": [
        "class when",
        "class defines",
        "class is"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 609,
      "page_number": 1,
      "length": 939,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "enum"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 610,
      "page_number": 1,
      "length": 313,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.626,
      "has_code_example": false
    },
    {
      "chunk_id": 611,
      "page_number": 364,
      "length": 752,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "enum",
        "interface",
        "enum"
      ],
      "code_patterns": [
        "interface and"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 612,
      "page_number": 366,
      "length": 926,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 613,
      "page_number": 368,
      "length": 966,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 614,
      "page_number": 1,
      "length": 974,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "abstract",
        "class"
      ],
      "code_patterns": [
        "class Number"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 615,
      "page_number": 369,
      "length": 593,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 616,
      "page_number": 1,
      "length": 856,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 617,
      "page_number": 370,
      "length": 410,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.82,
      "has_code_example": false
    },
    {
      "chunk_id": 618,
      "page_number": 1,
      "length": 910,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 619,
      "page_number": 1,
      "length": 497,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.994,
      "has_code_example": false
    },
    {
      "chunk_id": 620,
      "page_number": 371,
      "length": 906,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 621,
      "page_number": 372,
      "length": 903,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 622,
      "page_number": 372,
      "length": 767,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 623,
      "page_number": 374,
      "length": 608,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 624,
      "page_number": 374,
      "length": 966,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 625,
      "page_number": 1,
      "length": 186,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.372,
      "has_code_example": false
    },
    {
      "chunk_id": 626,
      "page_number": 375,
      "length": 976,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 627,
      "page_number": 376,
      "length": 977,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 628,
      "page_number": 1,
      "length": 771,
      "chunk_type": "technical",
      "java_keywords_count": 8,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "Annotation",
        "annotation",
        "interface",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.8,
      "has_code_example": false
    },
    {
      "chunk_id": 629,
      "page_number": 1,
      "length": 991,
      "chunk_type": "code",
      "java_keywords_count": 17,
      "java_keywords": [
        "annotation",
        "interface",
        "annotation",
        "interface",
        "annotation",
        "implements",
        "annotation",
        "extends",
        "annotation",
        "Annotation",
        "interface",
        "Annotation",
        "interface",
        "annotation",
        "package",
        "Class",
        "annotation"
      ],
      "code_patterns": [
        "interface of"
      ],
      "quality_score": 2.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 630,
      "page_number": 377,
      "length": 749,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "annotation",
        "annotation",
        "enum",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 631,
      "page_number": 377,
      "length": 737,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "Annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 632,
      "page_number": 1,
      "length": 956,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "CLASS",
        "annotation",
        "annotation",
        "CLASS",
        "class",
        "annotation",
        "class",
        "annotation",
        "annotation",
        "class"
      ],
      "code_patterns": [
        "class file",
        "class file",
        "class file"
      ],
      "quality_score": 2.9,
      "has_code_example": true
    },
    {
      "chunk_id": 633,
      "page_number": 378,
      "length": 672,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "annotation",
        "class",
        "annotation",
        "annotation",
        "CLASS"
      ],
      "code_patterns": [
        "class file"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 634,
      "page_number": 1,
      "length": 981,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "package",
        "Class",
        "class",
        "Class",
        "Class",
        "final",
        "Class"
      ],
      "code_patterns": [
        "class to",
        "class whose"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 635,
      "page_number": 1,
      "length": 660,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "final",
        "Class",
        "Class",
        "Class",
        "Class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 636,
      "page_number": 379,
      "length": 956,
      "chunk_type": "technical",
      "java_keywords_count": 8,
      "java_keywords": [
        "Class",
        "class",
        "class",
        "Class",
        "Class",
        "class",
        "Class",
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.8,
      "has_code_example": false
    },
    {
      "chunk_id": 637,
      "page_number": 1,
      "length": 732,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "Class",
        "Class",
        "Class",
        "annotation",
        "extends",
        "Annotation",
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 638,
      "page_number": 380,
      "length": 850,
      "chunk_type": "technical",
      "java_keywords_count": 12,
      "java_keywords": [
        "extends",
        "Annotation",
        "Class",
        "Class",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 2.2,
      "has_code_example": false
    },
    {
      "chunk_id": 639,
      "page_number": 381,
      "length": 937,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "annotation",
        "class",
        "class",
        "Class",
        "annotation",
        "class",
        "Class",
        "class",
        "Class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class literal",
        "class is",
        "class name",
        "class literal"
      ],
      "quality_score": 2.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 640,
      "page_number": 382,
      "length": 854,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "annotation",
        "class",
        "Class"
      ],
      "code_patterns": [
        "class objects"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 641,
      "page_number": 383,
      "length": 713,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Class",
        "Annotation",
        "Class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class and",
        "class and"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 642,
      "page_number": 384,
      "length": 738,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "class",
        "Annotation",
        "Annotation",
        "interface",
        "annotation",
        "Annotation",
        "annotation",
        "Interface",
        "interface"
      ],
      "code_patterns": [
        "class and",
        "interface of"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 643,
      "page_number": 385,
      "length": 803,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "interface",
        "interface",
        "Class",
        "Package",
        "Annotation",
        "Class",
        "extends",
        "Annotation"
      ],
      "code_patterns": [
        "interface supports"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 644,
      "page_number": 1,
      "length": 945,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "Class",
        "extends",
        "Annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 645,
      "page_number": 386,
      "length": 967,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "interface",
        "annotation",
        "interface"
      ],
      "code_patterns": [
        "interface contains"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 646,
      "page_number": 388,
      "length": 912,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 647,
      "page_number": 389,
      "length": 873,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 648,
      "page_number": 390,
      "length": 894,
      "chunk_type": "technical",
      "java_keywords_count": 8,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "Native",
        "Native",
        "native",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.8,
      "has_code_example": false
    },
    {
      "chunk_id": 649,
      "page_number": 390,
      "length": 978,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "interface",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "Annotation",
        "annotation"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 2.6000000000000005,
      "has_code_example": true
    },
    {
      "chunk_id": 650,
      "page_number": 1,
      "length": 901,
      "chunk_type": "technical",
      "java_keywords_count": 11,
      "java_keywords": [
        "Annotation",
        "annotation",
        "PACKAGE",
        "Package",
        "Class",
        "interface",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 2.1,
      "has_code_example": false
    },
    {
      "chunk_id": 651,
      "page_number": 391,
      "length": 882,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "annotation",
        "annotation",
        "class",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [
        "class declarations",
        "class to",
        "class is",
        "class method"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 652,
      "page_number": 1,
      "length": 997,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "annotation",
        "annotation",
        "interface",
        "interface",
        "interface",
        "interface",
        "abstract",
        "interface",
        "interface",
        "interface",
        "interface",
        "abstract",
        "interface",
        "annotation"
      ],
      "code_patterns": [
        "interface is",
        "interface is",
        "interface that",
        "interface is",
        "interface with"
      ],
      "quality_score": 3.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 653,
      "page_number": 1,
      "length": 727,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "annotation",
        "static",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 654,
      "page_number": 392,
      "length": 746,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "annotation",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 655,
      "page_number": 392,
      "length": 831,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 656,
      "page_number": 1,
      "length": 732,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 657,
      "page_number": 393,
      "length": 946,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "Annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 658,
      "page_number": 394,
      "length": 784,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 659,
      "page_number": 396,
      "length": 971,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 660,
      "page_number": 397,
      "length": 951,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "annotation",
        "class",
        "annotation"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 661,
      "page_number": 1,
      "length": 208,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.416,
      "has_code_example": false
    },
    {
      "chunk_id": 662,
      "page_number": 1,
      "length": 986,
      "chunk_type": "technical",
      "java_keywords_count": 15,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 2.5,
      "has_code_example": false
    },
    {
      "chunk_id": 663,
      "page_number": 398,
      "length": 802,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "class",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 664,
      "page_number": 1,
      "length": 974,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 665,
      "page_number": 400,
      "length": 601,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "Class",
        "enum",
        "annotation",
        "annotation"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 666,
      "page_number": 1,
      "length": 980,
      "chunk_type": "technical",
      "java_keywords_count": 8,
      "java_keywords": [
        "package",
        "package",
        "transient",
        "volatile",
        "native",
        "strictfp",
        "static",
        "import"
      ],
      "code_patterns": [],
      "quality_score": 1.8,
      "has_code_example": false
    },
    {
      "chunk_id": 667,
      "page_number": 1,
      "length": 998,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 668,
      "page_number": 1,
      "length": 274,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.548,
      "has_code_example": false
    },
    {
      "chunk_id": 669,
      "page_number": 402,
      "length": 956,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "abstract",
        "implements",
        "class",
        "package"
      ],
      "code_patterns": [
        "class \nhierarchies"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 670,
      "page_number": 1,
      "length": 234,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.468,
      "has_code_example": false
    },
    {
      "chunk_id": 671,
      "page_number": 1,
      "length": 966,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 672,
      "page_number": 1,
      "length": 394,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.788,
      "has_code_example": false
    },
    {
      "chunk_id": 673,
      "page_number": 403,
      "length": 929,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "abstract",
        "abstract",
        "import",
        "abstract",
        "abstract"
      ],
      "code_patterns": [
        "class hierarchies"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 674,
      "page_number": 404,
      "length": 727,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "abstract",
        "abstract",
        "abstract",
        "abstract"
      ],
      "code_patterns": [
        "class hierarchies"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 675,
      "page_number": 1,
      "length": 704,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "import",
        "package",
        "package",
        "class",
        "public",
        "static",
        "final"
      ],
      "code_patterns": [
        "class called"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 676,
      "page_number": 405,
      "length": 757,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 677,
      "page_number": 1,
      "length": 790,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 678,
      "page_number": 1,
      "length": 903,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "abstract",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 679,
      "page_number": 406,
      "length": 818,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 680,
      "page_number": 406,
      "length": 881,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 681,
      "page_number": 407,
      "length": 817,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \nPrintStream"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 682,
      "page_number": 409,
      "length": 809,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 683,
      "page_number": 1,
      "length": 975,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class for"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 684,
      "page_number": 410,
      "length": 615,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 685,
      "page_number": 410,
      "length": 596,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 686,
      "page_number": 411,
      "length": 958,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 687,
      "page_number": 411,
      "length": 572,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 688,
      "page_number": 1,
      "length": 872,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 689,
      "page_number": 412,
      "length": 534,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface in",
        "interface in"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 690,
      "page_number": 1,
      "length": 985,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 691,
      "page_number": 413,
      "length": 866,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 692,
      "page_number": 414,
      "length": 663,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 693,
      "page_number": 415,
      "length": 882,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 694,
      "page_number": 416,
      "length": 466,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.1320000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 695,
      "page_number": 1,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 696,
      "page_number": 417,
      "length": 705,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 697,
      "page_number": 1,
      "length": 980,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 698,
      "page_number": 1,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface defined",
        "interface defines",
        "interface in"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 699,
      "page_number": 419,
      "length": 687,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 700,
      "page_number": 420,
      "length": 754,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 701,
      "page_number": 420,
      "length": 687,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 702,
      "page_number": 421,
      "length": 918,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 703,
      "page_number": 1,
      "length": 801,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 704,
      "page_number": 1,
      "length": 956,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class of",
        "interface and"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 705,
      "page_number": 422,
      "length": 492,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.084,
      "has_code_example": false
    },
    {
      "chunk_id": 706,
      "page_number": 1,
      "length": 940,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "import",
        "Abstract",
        "interface",
        "import",
        "package",
        "class",
        "class"
      ],
      "code_patterns": [
        "class Applet",
        "class SimpleApplet"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 707,
      "page_number": 1,
      "length": 889,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "public"
      ],
      "code_patterns": [
        "class SimpleApplet",
        "class must"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 708,
      "page_number": 1,
      "length": 330,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.66,
      "has_code_example": false
    },
    {
      "chunk_id": 709,
      "page_number": 1,
      "length": 417,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 0.9339999999999999,
      "has_code_example": false
    },
    {
      "chunk_id": 710,
      "page_number": 423,
      "length": 848,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 711,
      "page_number": 1,
      "length": 947,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 712,
      "page_number": 424,
      "length": 881,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 713,
      "page_number": 424,
      "length": 579,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 714,
      "page_number": 1,
      "length": 894,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 715,
      "page_number": 425,
      "length": 825,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "transient",
        "volatile",
        "transient",
        "volatile"
      ],
      "code_patterns": [
        "interface provided"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 716,
      "page_number": 1,
      "length": 888,
      "chunk_type": "technical",
      "java_keywords_count": 8,
      "java_keywords": [
        "transient",
        "volatile",
        "transient",
        "volatile",
        "transient",
        "volatile",
        "volatile",
        "private"
      ],
      "code_patterns": [],
      "quality_score": 1.8,
      "has_code_example": false
    },
    {
      "chunk_id": 717,
      "page_number": 426,
      "length": 630,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "synchronized",
        "volatile",
        "volatile",
        "private",
        "private"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 718,
      "page_number": 1,
      "length": 866,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \nhierarchies",
        "class called"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 719,
      "page_number": 1,
      "length": 569,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 720,
      "page_number": 427,
      "length": 742,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "strictfp"
      ],
      "code_patterns": [
        "class type",
        "class hierarchy"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 721,
      "page_number": 429,
      "length": 869,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "strictfp",
        "class",
        "interface",
        "strictfp",
        "class",
        "strictfp",
        "class",
        "strictfp",
        "strictfp",
        "class",
        "Native"
      ],
      "code_patterns": [
        "interface with",
        "class is",
        "class are",
        "class of"
      ],
      "quality_score": 2.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 722,
      "page_number": 1,
      "length": 896,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "native",
        "native",
        "package",
        "native",
        "native",
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 723,
      "page_number": 1,
      "length": 327,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "native",
        "native",
        "native",
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.054,
      "has_code_example": false
    },
    {
      "chunk_id": 724,
      "page_number": 1,
      "length": 891,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "native",
        "native",
        "native",
        "Native",
        "Interface",
        "native",
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 725,
      "page_number": 430,
      "length": 814,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "native",
        "native",
        "static",
        "static",
        "class",
        "native",
        "class",
        "static"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 726,
      "page_number": 431,
      "length": 839,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "class",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 727,
      "page_number": 431,
      "length": 874,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "native",
        "class",
        "class",
        "native",
        "class",
        "native",
        "class"
      ],
      "code_patterns": [
        "class may",
        "class \nname",
        "class in"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 728,
      "page_number": 1,
      "length": 159,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.318,
      "has_code_example": false
    },
    {
      "chunk_id": 729,
      "page_number": 432,
      "length": 876,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class NativeDemo"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 730,
      "page_number": 433,
      "length": 883,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "Native",
        "Native",
        "native",
        "native",
        "native",
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 731,
      "page_number": 1,
      "length": 552,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "native",
        "native",
        "native",
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 732,
      "page_number": 1,
      "length": 921,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 733,
      "page_number": 434,
      "length": 861,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 734,
      "page_number": 435,
      "length": 766,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 735,
      "page_number": 1,
      "length": 378,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.756,
      "has_code_example": false
    },
    {
      "chunk_id": 736,
      "page_number": 436,
      "length": 948,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 737,
      "page_number": 437,
      "length": 513,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "package",
        "package",
        "class",
        "Static",
        "Import"
      ],
      "code_patterns": [
        "class with"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 738,
      "page_number": 1,
      "length": 896,
      "chunk_type": "code",
      "java_keywords_count": 21,
      "java_keywords": [
        "Static",
        "Import",
        "static",
        "import",
        "import",
        "import",
        "static",
        "import",
        "import",
        "static",
        "class",
        "interface",
        "static",
        "import",
        "static",
        "class",
        "static",
        "static",
        "import",
        "static",
        "class"
      ],
      "code_patterns": [
        "class or",
        "class Math"
      ],
      "quality_score": 3.5,
      "has_code_example": true
    },
    {
      "chunk_id": 739,
      "page_number": 438,
      "length": 836,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "static",
        "class",
        "class",
        "class",
        "static",
        "import",
        "static",
        "import",
        "class"
      ],
      "code_patterns": [
        "class name",
        "class name",
        "class \nname"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 740,
      "page_number": 440,
      "length": 843,
      "chunk_type": "code",
      "java_keywords_count": 18,
      "java_keywords": [
        "class",
        "import",
        "static",
        "import",
        "static",
        "static",
        "class",
        "interface",
        "static",
        "package",
        "static",
        "static",
        "import",
        "static",
        "class",
        "interface",
        "import",
        "static"
      ],
      "code_patterns": [
        "class \nname",
        "class or",
        "interface that",
        "class or"
      ],
      "quality_score": 3.5999999999999996,
      "has_code_example": true
    },
    {
      "chunk_id": 741,
      "page_number": 440,
      "length": 656,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "import",
        "static",
        "static",
        "class",
        "import",
        "static",
        "static",
        "import",
        "class",
        "static"
      ],
      "code_patterns": [
        "class or"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 742,
      "page_number": 1,
      "length": 919,
      "chunk_type": "technical",
      "java_keywords_count": 11,
      "java_keywords": [
        "static",
        "static",
        "import",
        "import",
        "static",
        "static",
        "import",
        "import",
        "static",
        "static",
        "import"
      ],
      "code_patterns": [],
      "quality_score": 2.1,
      "has_code_example": false
    },
    {
      "chunk_id": 743,
      "page_number": 1,
      "length": 420,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "static",
        "import",
        "static",
        "import",
        "Static",
        "import",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.54,
      "has_code_example": false
    },
    {
      "chunk_id": 744,
      "page_number": 441,
      "length": 718,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 745,
      "page_number": 442,
      "length": 958,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class contains"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 746,
      "page_number": 1,
      "length": 671,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class because"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 747,
      "page_number": 443,
      "length": 906,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class will",
        "class that",
        "class will"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 748,
      "page_number": 1,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 749,
      "page_number": 1,
      "length": 305,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class in"
      ],
      "quality_score": 0.9099999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 750,
      "page_number": 1,
      "length": 752,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 751,
      "page_number": 444,
      "length": 749,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 752,
      "page_number": 1,
      "length": 887,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 753,
      "page_number": 1,
      "length": 908,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 754,
      "page_number": 1,
      "length": 829,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 755,
      "page_number": 1,
      "length": 103,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.206,
      "has_code_example": false
    },
    {
      "chunk_id": 756,
      "page_number": 446,
      "length": 945,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class or",
        "class of"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 757,
      "page_number": 1,
      "length": 440,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.88,
      "has_code_example": false
    },
    {
      "chunk_id": 758,
      "page_number": 447,
      "length": 667,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class Gen"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 759,
      "page_number": 447,
      "length": 696,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 760,
      "page_number": 1,
      "length": 730,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 761,
      "page_number": 449,
      "length": 645,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "Class",
        "class",
        "Class",
        "class",
        "Class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class types",
        "class of",
        "class name",
        "class demonstrates"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 762,
      "page_number": 1,
      "length": 914,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 763,
      "page_number": 1,
      "length": 310,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 0.72,
      "has_code_example": false
    },
    {
      "chunk_id": 764,
      "page_number": 450,
      "length": 883,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 765,
      "page_number": 1,
      "length": 592,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 766,
      "page_number": 1,
      "length": 845,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 767,
      "page_number": 451,
      "length": 743,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class type"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 768,
      "page_number": 1,
      "length": 582,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 769,
      "page_number": 452,
      "length": 646,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class can"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 770,
      "page_number": 452,
      "length": 555,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 771,
      "page_number": 1,
      "length": 909,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 772,
      "page_number": 454,
      "length": 684,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 773,
      "page_number": 454,
      "length": 881,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class that"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 774,
      "page_number": 455,
      "length": 935,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class and"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 775,
      "page_number": 457,
      "length": 738,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class and",
        "class type",
        "class that",
        "class to"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 776,
      "page_number": 457,
      "length": 935,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 777,
      "page_number": 458,
      "length": 588,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "extends",
        "extends",
        "class"
      ],
      "code_patterns": [
        "class from",
        "class defines",
        "class shown"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 778,
      "page_number": 1,
      "length": 887,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class of",
        "class type",
        "interface type",
        "class \ntype",
        "class type",
        "interface type",
        "interface are"
      ],
      "quality_score": 3.0,
      "has_code_example": true
    },
    {
      "chunk_id": 779,
      "page_number": 1,
      "length": 292,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class type",
        "interface type",
        "interface are",
        "class and"
      ],
      "quality_score": 1.8840000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 780,
      "page_number": 1,
      "length": 942,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class called",
        "interface called",
        "class of",
        "class shown"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 781,
      "page_number": 460,
      "length": 694,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 782,
      "page_number": 461,
      "length": 967,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 783,
      "page_number": 461,
      "length": 782,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "class"
      ],
      "code_patterns": [
        "class hierarchy"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 784,
      "page_number": 464,
      "length": 827,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class called"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 785,
      "page_number": 1,
      "length": 925,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 786,
      "page_number": 465,
      "length": 541,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 787,
      "page_number": 466,
      "length": 823,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "extends",
        "class",
        "extends"
      ],
      "code_patterns": [
        "class \nderived"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 788,
      "page_number": 467,
      "length": 923,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "extends",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class that",
        "class forming"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 789,
      "page_number": 469,
      "length": 943,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "static",
        "class"
      ],
      "code_patterns": [
        "class are",
        "class can",
        "class called",
        "class called"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 790,
      "page_number": 470,
      "length": 386,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "extends",
        "interface",
        "class",
        "implements"
      ],
      "code_patterns": [
        "interface declared",
        "class \nthat"
      ],
      "quality_score": 1.572,
      "has_code_example": true
    },
    {
      "chunk_id": 791,
      "page_number": 471,
      "length": 960,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 792,
      "page_number": 1,
      "length": 158,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.316,
      "has_code_example": false
    },
    {
      "chunk_id": 793,
      "page_number": 1,
      "length": 827,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 794,
      "page_number": 472,
      "length": 974,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "class"
      ],
      "code_patterns": [
        "class of",
        "class of",
        "class is"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 795,
      "page_number": 473,
      "length": 838,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class is",
        "class of",
        "interface \ncalled"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 796,
      "page_number": 474,
      "length": 621,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface is",
        "interface defined"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 797,
      "page_number": 1,
      "length": 825,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "implements",
        "class",
        "implements",
        "interface",
        "class",
        "implements",
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface without",
        "class implements",
        "class must"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 798,
      "page_number": 475,
      "length": 961,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "class",
        "implements",
        "interface",
        "class",
        "interface",
        "interface",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class implements",
        "class does",
        "interface offers",
        "interface can",
        "interface can",
        "interface is"
      ],
      "quality_score": 3.1,
      "has_code_example": true
    },
    {
      "chunk_id": 799,
      "page_number": 1,
      "length": 944,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface is",
        "class to"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 800,
      "page_number": 476,
      "length": 765,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \nis"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 801,
      "page_number": 1,
      "length": 930,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 802,
      "page_number": 478,
      "length": 932,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 803,
      "page_number": 1,
      "length": 953,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "final",
        "Class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class hierarchy",
        "class can",
        "class or",
        "class must",
        "class \n\nHere"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 804,
      "page_number": 479,
      "length": 986,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "extends",
        "class",
        "extends"
      ],
      "code_patterns": [
        "class \n\nHere",
        "class Gen",
        "class of",
        "class would",
        "class is"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 805,
      "page_number": 480,
      "length": 952,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \n\nIt",
        "class to",
        "class of"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 806,
      "page_number": 484,
      "length": 913,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class demonstrates",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 807,
      "page_number": 1,
      "length": 782,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class type"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 808,
      "page_number": 486,
      "length": 895,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "Class"
      ],
      "code_patterns": [
        "class into"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 809,
      "page_number": 487,
      "length": 827,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class can",
        "class version"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 810,
      "page_number": 1,
      "length": 854,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 811,
      "page_number": 489,
      "length": 841,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 812,
      "page_number": 1,
      "length": 691,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 813,
      "page_number": 1,
      "length": 785,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 814,
      "page_number": 490,
      "length": 661,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 815,
      "page_number": 491,
      "length": 953,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "extends"
      ],
      "code_patterns": [
        "class to",
        "class does",
        "class Gen2"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 816,
      "page_number": 492,
      "length": 969,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class file"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 817,
      "page_number": 493,
      "length": 803,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 818,
      "page_number": 494,
      "length": 761,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 819,
      "page_number": 494,
      "length": 928,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 820,
      "page_number": 495,
      "length": 756,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "class",
        "Static",
        "static",
        "class",
        "static",
        "class",
        "static",
        "class",
        "static"
      ],
      "code_patterns": [
        "class are"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 821,
      "page_number": 496,
      "length": 789,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 822,
      "page_number": 497,
      "length": 831,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class cannot"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 823,
      "page_number": 1,
      "length": 811,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 824,
      "page_number": 1,
      "length": 604,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 825,
      "page_number": 1,
      "length": 814,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 826,
      "page_number": 1,
      "length": 404,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 0.908,
      "has_code_example": false
    },
    {
      "chunk_id": 827,
      "page_number": 498,
      "length": 513,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "interface",
        "abstract",
        "interface"
      ],
      "code_patterns": [
        "interface is",
        "interface that"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 828,
      "page_number": 1,
      "length": 541,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "Abstract"
      ],
      "code_patterns": [
        "interface typically",
        "interface Runnable",
        "interface because",
        "interface defines",
        "interface is"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 829,
      "page_number": 1,
      "length": 444,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "public",
        "interface",
        "public",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface may",
        "interface because"
      ],
      "quality_score": 1.888,
      "has_code_example": true
    },
    {
      "chunk_id": 830,
      "page_number": 1,
      "length": 978,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 831,
      "page_number": 499,
      "length": 867,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 832,
      "page_number": 1,
      "length": 355,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.71,
      "has_code_example": false
    },
    {
      "chunk_id": 833,
      "page_number": 1,
      "length": 775,
      "chunk_type": "code",
      "java_keywords_count": 12,
      "java_keywords": [
        "interface",
        "interface",
        "abstract",
        "interface",
        "abstract",
        "interface",
        "interface",
        "abstract",
        "interface",
        "abstract",
        "abstract",
        "interface"
      ],
      "code_patterns": [
        "interface is",
        "interface that",
        "interface \nmethods",
        "interface method",
        "interface methods"
      ],
      "quality_score": 3.2,
      "has_code_example": true
    },
    {
      "chunk_id": 834,
      "page_number": 500,
      "length": 973,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "abstract",
        "interface",
        "abstract",
        "interface",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface that",
        "interface reference",
        "interface MyNumber",
        "interface reference"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 835,
      "page_number": 1,
      "length": 657,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "class",
        "implements",
        "interface",
        "abstract",
        "interface"
      ],
      "code_patterns": [
        "interface reference",
        "class is"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 836,
      "page_number": 1,
      "length": 981,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "abstract",
        "abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 837,
      "page_number": 501,
      "length": 904,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 838,
      "page_number": 503,
      "length": 530,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 839,
      "page_number": 1,
      "length": 939,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface reference",
        "interface NumericTest"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 840,
      "page_number": 504,
      "length": 672,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface NumericTest2"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 841,
      "page_number": 1,
      "length": 551,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 842,
      "page_number": 1,
      "length": 769,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 843,
      "page_number": 505,
      "length": 922,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 844,
      "page_number": 506,
      "length": 983,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface StringFunc"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 845,
      "page_number": 507,
      "length": 602,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface associated",
        "interface reference"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 846,
      "page_number": 507,
      "length": 880,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface that",
        "interface SomeFunc"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 847,
      "page_number": 508,
      "length": 666,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface SomeFunc",
        "interface is",
        "interface can"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 848,
      "page_number": 509,
      "length": 925,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface type"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 849,
      "page_number": 509,
      "length": 456,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.012,
      "has_code_example": false
    },
    {
      "chunk_id": 850,
      "page_number": 1,
      "length": 748,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface StringFunc",
        "class instance"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 851,
      "page_number": 1,
      "length": 760,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface variable"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 852,
      "page_number": 512,
      "length": 521,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 853,
      "page_number": 512,
      "length": 763,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "abstract",
        "interface",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 854,
      "page_number": 513,
      "length": 960,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface \nDoubleNumericArrayFunc"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 855,
      "page_number": 1,
      "length": 970,
      "chunk_type": "technical",
      "java_keywords_count": 8,
      "java_keywords": [
        "static",
        "class",
        "class",
        "static",
        "class",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.8,
      "has_code_example": false
    },
    {
      "chunk_id": 856,
      "page_number": 1,
      "length": 567,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "final",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 857,
      "page_number": 514,
      "length": 924,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "final",
        "final",
        "class",
        "final",
        "interface",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 858,
      "page_number": 515,
      "length": 646,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "static",
        "static",
        "static",
        "class",
        "static"
      ],
      "code_patterns": [
        "class name"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 859,
      "page_number": 516,
      "length": 902,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "static",
        "interface",
        "static",
        "class"
      ],
      "code_patterns": [
        "class name"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 860,
      "page_number": 517,
      "length": 676,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 861,
      "page_number": 519,
      "length": 599,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class is",
        "interface matches"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 862,
      "page_number": 519,
      "length": 630,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface because"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 863,
      "page_number": 521,
      "length": 737,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface MyFunc",
        "class version"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 864,
      "page_number": 521,
      "length": 487,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.274,
      "has_code_example": true
    },
    {
      "chunk_id": 865,
      "page_number": 1,
      "length": 964,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class name"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 866,
      "page_number": 1,
      "length": 932,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "implements",
        "interface",
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "interface specifies"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 867,
      "page_number": 1,
      "length": 797,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 868,
      "page_number": 523,
      "length": 867,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "interface"
      ],
      "code_patterns": [
        "interface reference"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 869,
      "page_number": 524,
      "length": 969,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface reference"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 870,
      "page_number": 526,
      "length": 904,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class to",
        "class name"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 871,
      "page_number": 527,
      "length": 798,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 872,
      "page_number": 1,
      "length": 938,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class has"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 873,
      "page_number": 1,
      "length": 192,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.384,
      "has_code_example": false
    },
    {
      "chunk_id": 874,
      "page_number": 1,
      "length": 599,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface shown",
        "interface must"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 875,
      "page_number": 529,
      "length": 986,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "package",
        "Interface"
      ],
      "code_patterns": [
        "interface because"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 876,
      "page_number": 530,
      "length": 981,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface in",
        "interface called",
        "interface could"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 877,
      "page_number": 530,
      "length": 939,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 878,
      "page_number": 533,
      "length": 342,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.684,
      "has_code_example": false
    },
    {
      "chunk_id": 879,
      "page_number": 1,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 880,
      "page_number": 1,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 881,
      "page_number": 1,
      "length": 270,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 0.64,
      "has_code_example": false
    },
    {
      "chunk_id": 882,
      "page_number": 534,
      "length": 970,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class supports",
        "class provides"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 883,
      "page_number": 535,
      "length": 688,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 884,
      "page_number": 535,
      "length": 954,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 885,
      "page_number": 536,
      "length": 884,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 886,
      "page_number": 537,
      "length": 791,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 887,
      "page_number": 537,
      "length": 705,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 888,
      "page_number": 1,
      "length": 810,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 889,
      "page_number": 538,
      "length": 833,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 890,
      "page_number": 1,
      "length": 776,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 891,
      "page_number": 539,
      "length": 427,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.854,
      "has_code_example": false
    },
    {
      "chunk_id": 892,
      "page_number": 1,
      "length": 982,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "implements"
      ],
      "code_patterns": [
        "class implements"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 893,
      "page_number": 1,
      "length": 211,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.422,
      "has_code_example": false
    },
    {
      "chunk_id": 894,
      "page_number": 540,
      "length": 903,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 895,
      "page_number": 541,
      "length": 986,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 896,
      "page_number": 1,
      "length": 891,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 897,
      "page_number": 542,
      "length": 977,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 898,
      "page_number": 1,
      "length": 878,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class includes"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 899,
      "page_number": 543,
      "length": 623,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 900,
      "page_number": 544,
      "length": 868,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 901,
      "page_number": 1,
      "length": 960,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 902,
      "page_number": 545,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 903,
      "page_number": 546,
      "length": 958,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 904,
      "page_number": 547,
      "length": 900,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 905,
      "page_number": 548,
      "length": 936,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 906,
      "page_number": 548,
      "length": 850,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 907,
      "page_number": 550,
      "length": 816,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 908,
      "page_number": 1,
      "length": 894,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 909,
      "page_number": 551,
      "length": 859,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 910,
      "page_number": 1,
      "length": 511,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "static",
        "class",
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [
        "class type",
        "class for"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 911,
      "page_number": 552,
      "length": 937,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 912,
      "page_number": 553,
      "length": 969,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 913,
      "page_number": 553,
      "length": 947,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 914,
      "page_number": 554,
      "length": 968,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 915,
      "page_number": 555,
      "length": 941,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 916,
      "page_number": 1,
      "length": 946,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 917,
      "page_number": 1,
      "length": 609,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 918,
      "page_number": 556,
      "length": 946,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 919,
      "page_number": 556,
      "length": 813,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 920,
      "page_number": 1,
      "length": 980,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 921,
      "page_number": 557,
      "length": 977,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 922,
      "page_number": 1,
      "length": 799,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 923,
      "page_number": 558,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 924,
      "page_number": 559,
      "length": 959,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 925,
      "page_number": 1,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 926,
      "page_number": 560,
      "length": 942,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 927,
      "page_number": 561,
      "length": 909,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 928,
      "page_number": 562,
      "length": 983,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 929,
      "page_number": 563,
      "length": 917,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 930,
      "page_number": 563,
      "length": 823,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 931,
      "page_number": 1,
      "length": 719,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 932,
      "page_number": 564,
      "length": 753,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 933,
      "page_number": 565,
      "length": 882,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 934,
      "page_number": 566,
      "length": 976,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 935,
      "page_number": 1,
      "length": 860,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "abstract",
        "class",
        "abstract"
      ],
      "code_patterns": [
        "class Number",
        "class that"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 936,
      "page_number": 567,
      "length": 982,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 937,
      "page_number": 568,
      "length": 871,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 938,
      "page_number": 571,
      "length": 963,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 939,
      "page_number": 1,
      "length": 557,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 940,
      "page_number": 572,
      "length": 919,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 941,
      "page_number": 572,
      "length": 802,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 942,
      "page_number": 578,
      "length": 879,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 943,
      "page_number": 580,
      "length": 900,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "Class",
        "static"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 944,
      "page_number": 581,
      "length": 819,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 945,
      "page_number": 582,
      "length": 787,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 946,
      "page_number": 1,
      "length": 962,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class has"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 947,
      "page_number": 1,
      "length": 813,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 948,
      "page_number": 583,
      "length": 780,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "static",
        "static",
        "static",
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 949,
      "page_number": 583,
      "length": 930,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "Class",
        "class",
        "abstract",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class has",
        "class encapsulates",
        "class for"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 950,
      "page_number": 585,
      "length": 826,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "static",
        "class"
      ],
      "code_patterns": [
        "class encapsulates"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 951,
      "page_number": 1,
      "length": 613,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 952,
      "page_number": 587,
      "length": 638,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 953,
      "page_number": 588,
      "length": 724,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 954,
      "page_number": 589,
      "length": 862,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 955,
      "page_number": 1,
      "length": 541,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 956,
      "page_number": 1,
      "length": 914,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "abstract",
        "class"
      ],
      "code_patterns": [
        "class encapsulates"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 957,
      "page_number": 590,
      "length": 932,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 958,
      "page_number": 592,
      "length": 503,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "static"
      ],
      "code_patterns": [
        "class holds"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 959,
      "page_number": 593,
      "length": 751,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 960,
      "page_number": 594,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 961,
      "page_number": 596,
      "length": 484,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "Interface"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.268,
      "has_code_example": true
    },
    {
      "chunk_id": 962,
      "page_number": 1,
      "length": 994,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface can",
        "interface defines",
        "class allows",
        "class \nthat"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 963,
      "page_number": 1,
      "length": 715,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 964,
      "page_number": 597,
      "length": 831,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "protected",
        "class",
        "implements",
        "class",
        "public",
        "implements",
        "class",
        "public"
      ],
      "code_patterns": [
        "class that",
        "class so"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 965,
      "page_number": 599,
      "length": 783,
      "chunk_type": "code",
      "java_keywords_count": 16,
      "java_keywords": [
        "class",
        "class",
        "Class",
        "Class",
        "class",
        "interface",
        "Class",
        "Class",
        "Class",
        "Class",
        "class",
        "Class",
        "class",
        "interface",
        "Class",
        "Class"
      ],
      "code_patterns": [
        "class is",
        "class without",
        "class or",
        "class Class",
        "class or",
        "interface represented"
      ],
      "quality_score": 3.8000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 966,
      "page_number": 601,
      "length": 734,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Class",
        "Class",
        "class",
        "public",
        "Class",
        "abstract",
        "class"
      ],
      "code_patterns": [
        "class ClassLoader"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 967,
      "page_number": 602,
      "length": 977,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Class",
        "abstract",
        "class",
        "class",
        "static"
      ],
      "code_patterns": [
        "class ClassLoader",
        "class contains"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 968,
      "page_number": 1,
      "length": 981,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 969,
      "page_number": 604,
      "length": 939,
      "chunk_type": "technical",
      "java_keywords_count": 9,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.9,
      "has_code_example": false
    },
    {
      "chunk_id": 970,
      "page_number": 1,
      "length": 967,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 971,
      "page_number": 605,
      "length": 927,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 972,
      "page_number": 608,
      "length": 976,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "Interface",
        "interface",
        "class",
        "abstract",
        "implements"
      ],
      "code_patterns": [
        "class supports",
        "interface and",
        "interface must",
        "class that"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 973,
      "page_number": 1,
      "length": 991,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "implements",
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class that",
        "interface and"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 974,
      "page_number": 609,
      "length": 752,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 975,
      "page_number": 611,
      "length": 519,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 976,
      "page_number": 611,
      "length": 772,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 977,
      "page_number": 612,
      "length": 915,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 978,
      "page_number": 616,
      "length": 920,
      "chunk_type": "technical",
      "java_keywords_count": 8,
      "java_keywords": [
        "Package",
        "Package",
        "package",
        "Package",
        "package",
        "Package",
        "Package",
        "Package"
      ],
      "code_patterns": [],
      "quality_score": 1.8,
      "has_code_example": false
    },
    {
      "chunk_id": 979,
      "page_number": 616,
      "length": 542,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Package",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class supports",
        "class from"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 980,
      "page_number": 1,
      "length": 743,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class describes"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 981,
      "page_number": 618,
      "length": 918,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "class",
        "native",
        "Enum",
        "enum",
        "Enum",
        "Enum",
        "class",
        "class",
        "Enum",
        "extends",
        "Enum"
      ],
      "code_patterns": [
        "class is",
        "class that",
        "class Enum"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 982,
      "page_number": 1,
      "length": 762,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "class",
        "Enum",
        "extends",
        "Enum",
        "Enum",
        "public",
        "Enum",
        "Enum",
        "Class",
        "Interface",
        "interface",
        "interface",
        "Interface"
      ],
      "code_patterns": [
        "class Enum",
        "interface defines",
        "interface is"
      ],
      "quality_score": 2.9,
      "has_code_example": true
    },
    {
      "chunk_id": 983,
      "page_number": 619,
      "length": 594,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Interface",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface Comparable",
        "interface declares"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 984,
      "page_number": 1,
      "length": 835,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "Enum",
        "Interface",
        "class",
        "implements"
      ],
      "code_patterns": [
        "interface is",
        "class that"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 985,
      "page_number": 620,
      "length": 901,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Interface",
        "class",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class whose",
        "class must",
        "interface that",
        "interface Iterable"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 986,
      "page_number": 1,
      "length": 890,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "abstract",
        "interface",
        "Interface"
      ],
      "code_patterns": [
        "interface Iterable",
        "interface added"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 987,
      "page_number": 1,
      "length": 718,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Interface",
        "interface",
        "Interface",
        "implements"
      ],
      "code_patterns": [
        "interface indicates"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 988,
      "page_number": 621,
      "length": 926,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "implements",
        "interface",
        "Interface"
      ],
      "code_patterns": [
        "interface \ndefines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 989,
      "page_number": 1,
      "length": 958,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "Interface",
        "static",
        "interface",
        "annotation",
        "annotation",
        "annotation",
        "annotation",
        "Annotation",
        "interface"
      ],
      "code_patterns": [
        "interface is"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 990,
      "page_number": 622,
      "length": 981,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 991,
      "page_number": 623,
      "length": 968,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "package",
        "class",
        "package",
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 992,
      "page_number": 623,
      "length": 266,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.532,
      "has_code_example": false
    },
    {
      "chunk_id": 993,
      "page_number": 623,
      "length": 947,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 994,
      "page_number": 624,
      "length": 306,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.612,
      "has_code_example": false
    },
    {
      "chunk_id": 995,
      "page_number": 1,
      "length": 998,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 996,
      "page_number": 1,
      "length": 304,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.608,
      "has_code_example": false
    },
    {
      "chunk_id": 997,
      "page_number": 1,
      "length": 550,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \neasier"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 998,
      "page_number": 626,
      "length": 710,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "static",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class need"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 999,
      "page_number": 1,
      "length": 935,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class can"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1000,
      "page_number": 1,
      "length": 604,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1001,
      "page_number": 1,
      "length": 592,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1002,
      "page_number": 627,
      "length": 649,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1003,
      "page_number": 1,
      "length": 828,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1004,
      "page_number": 1,
      "length": 732,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1005,
      "page_number": 1,
      "length": 709,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1006,
      "page_number": 628,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1007,
      "page_number": 1,
      "length": 592,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "Interface",
        "Extends",
        "Extends",
        "Extends",
        "Extends",
        "Extends",
        "Extends"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 1008,
      "page_number": 1,
      "length": 955,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1009,
      "page_number": 1,
      "length": 232,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.464,
      "has_code_example": false
    },
    {
      "chunk_id": 1010,
      "page_number": 629,
      "length": 359,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Interface",
        "interface",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface is",
        "class that",
        "interface that",
        "interface Collection"
      ],
      "quality_score": 2.018,
      "has_code_example": true
    },
    {
      "chunk_id": 1011,
      "page_number": 1,
      "length": 959,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1012,
      "page_number": 1,
      "length": 192,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.384,
      "has_code_example": false
    },
    {
      "chunk_id": 1013,
      "page_number": 1,
      "length": 978,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface added"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1014,
      "page_number": 1,
      "length": 540,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1015,
      "page_number": 1,
      "length": 495,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.99,
      "has_code_example": false
    },
    {
      "chunk_id": 1016,
      "page_number": 631,
      "length": 907,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "Interface",
        "interface",
        "extends",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface extends",
        "interface \nthat",
        "interface List"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1017,
      "page_number": 1,
      "length": 940,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1018,
      "page_number": 1,
      "length": 451,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.902,
      "has_code_example": false
    },
    {
      "chunk_id": 1019,
      "page_number": 632,
      "length": 982,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Interface",
        "interface",
        "extends",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines",
        "interface that",
        "interface Set"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1020,
      "page_number": 632,
      "length": 832,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "interface",
        "interface",
        "Interface",
        "interface",
        "extends",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface that",
        "interface Set",
        "interface extends",
        "interface that",
        "interface SortedSet",
        "interface declares"
      ],
      "quality_score": 3.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1021,
      "page_number": 633,
      "length": 940,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Interface",
        "interface",
        "extends",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface extends",
        "interface that",
        "interface NavigableSet"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1022,
      "page_number": 634,
      "length": 843,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "Interface",
        "interface",
        "extends",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface NavigableSet",
        "interface extends",
        "interface that",
        "interface Queue"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 1023,
      "page_number": 1,
      "length": 622,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface Queue"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1024,
      "page_number": 635,
      "length": 835,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1025,
      "page_number": 1,
      "length": 886,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Interface",
        "interface",
        "extends",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface extends",
        "interface that",
        "interface Deque"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1026,
      "page_number": 636,
      "length": 741,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1027,
      "page_number": 637,
      "length": 929,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "abstract",
        "synchronized",
        "synchronized",
        "Class",
        "Implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 1028,
      "page_number": 1,
      "length": 942,
      "chunk_type": "technical",
      "java_keywords_count": 21,
      "java_keywords": [
        "Class",
        "Implements",
        "interface",
        "Extends",
        "implements",
        "interface",
        "Extends",
        "implements",
        "interface",
        "Extends",
        "Implements",
        "Implements",
        "Implements",
        "interface",
        "Extends",
        "implements",
        "interface",
        "Extends",
        "enum",
        "Extends",
        "Extends"
      ],
      "code_patterns": [],
      "quality_score": 3.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1029,
      "page_number": 638,
      "length": 798,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "Extends",
        "enum",
        "Extends",
        "Extends",
        "Extends",
        "Implements",
        "Extends",
        "Class",
        "class",
        "extends",
        "implements",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class extends",
        "class that",
        "class ArrayList"
      ],
      "quality_score": 3.0000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 1030,
      "page_number": 1,
      "length": 957,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Class",
        "class",
        "extends",
        "implements",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class extends",
        "class that",
        "class ArrayList"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 1031,
      "page_number": 1,
      "length": 962,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "extends"
      ],
      "code_patterns": [
        "class Vector"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1032,
      "page_number": 639,
      "length": 176,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.352,
      "has_code_example": false
    },
    {
      "chunk_id": 1033,
      "page_number": 640,
      "length": 896,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1034,
      "page_number": 1,
      "length": 386,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.772,
      "has_code_example": false
    },
    {
      "chunk_id": 1035,
      "page_number": 1,
      "length": 977,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1036,
      "page_number": 641,
      "length": 844,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1037,
      "page_number": 642,
      "length": 895,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Class",
        "class",
        "extends",
        "implements",
        "class",
        "class",
        "extends"
      ],
      "code_patterns": [
        "class extends",
        "class \nthat",
        "class LinkedList"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 1038,
      "page_number": 1,
      "length": 947,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "extends",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class LinkedList"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1039,
      "page_number": 643,
      "length": 813,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "implements",
        "interface",
        "Class",
        "extends",
        "implements",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class HashSet"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1040,
      "page_number": 1,
      "length": 941,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "extends",
        "implements",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class HashSet"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1041,
      "page_number": 1,
      "length": 911,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1042,
      "page_number": 645,
      "length": 936,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Class",
        "class",
        "extends",
        "class",
        "class"
      ],
      "code_patterns": [
        "class extends",
        "class that",
        "class LinkedHashSet"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1043,
      "page_number": 646,
      "length": 770,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "Class"
      ],
      "code_patterns": [
        "class LinkedHashSet"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1044,
      "page_number": 646,
      "length": 744,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Class",
        "extends",
        "implements",
        "interface",
        "class",
        "class",
        "extends"
      ],
      "code_patterns": [
        "class that",
        "class TreeSet"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1045,
      "page_number": 647,
      "length": 655,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1046,
      "page_number": 647,
      "length": 929,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "implements",
        "interface",
        "Class",
        "extends",
        "implements",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class PriorityQueue"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1047,
      "page_number": 648,
      "length": 507,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "extends",
        "extends",
        "extends"
      ],
      "code_patterns": [
        "class PriorityQueue"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1048,
      "page_number": 1,
      "length": 959,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1049,
      "page_number": 1,
      "length": 265,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.53,
      "has_code_example": false
    },
    {
      "chunk_id": 1050,
      "page_number": 649,
      "length": 921,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "interface",
        "Class",
        "class",
        "extends",
        "implements",
        "interface",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class extends",
        "interface supports",
        "class that",
        "class ArrayDeque"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1051,
      "page_number": 649,
      "length": 892,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "extends",
        "Class",
        "extends",
        "implements",
        "enum",
        "class",
        "class",
        "extends",
        "Enum"
      ],
      "code_patterns": [
        "class ArrayDeque",
        "class that",
        "class EnumSet"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1052,
      "page_number": 650,
      "length": 849,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "extends",
        "implements",
        "enum",
        "class",
        "class",
        "extends",
        "Enum",
        "Enum",
        "enum"
      ],
      "code_patterns": [
        "class that",
        "class EnumSet"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1053,
      "page_number": 1,
      "length": 624,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "implements",
        "interface",
        "extends",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface Iterator",
        "interface ListIterator"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1054,
      "page_number": 651,
      "length": 952,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface Iterator",
        "interface ListIterator",
        "interface declares"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 1055,
      "page_number": 1,
      "length": 791,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1056,
      "page_number": 653,
      "length": 739,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1057,
      "page_number": 654,
      "length": 481,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.962,
      "has_code_example": false
    },
    {
      "chunk_id": 1058,
      "page_number": 656,
      "length": 872,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1059,
      "page_number": 1,
      "length": 967,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface that",
        "interface Spliterator"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1060,
      "page_number": 1,
      "length": 991,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "interface Spliterator",
        "interface that",
        "interface declared"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1061,
      "page_number": 657,
      "length": 535,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1062,
      "page_number": 658,
      "length": 904,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1063,
      "page_number": 1,
      "length": 768,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "interface of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1064,
      "page_number": 660,
      "length": 527,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1065,
      "page_number": 661,
      "length": 687,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "Interface"
      ],
      "code_patterns": [
        "class in"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1066,
      "page_number": 1,
      "length": 941,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "Interface",
        "interface",
        "interface",
        "interface",
        "class",
        "implements",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface contains",
        "class implements"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1067,
      "page_number": 662,
      "length": 977,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "Interface",
        "class",
        "Extends",
        "Extends",
        "interface"
      ],
      "code_patterns": [
        "class of",
        "interface is"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1068,
      "page_number": 1,
      "length": 457,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Extends",
        "interface",
        "Interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface is",
        "interface maps",
        "interface Map"
      ],
      "quality_score": 2.0140000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1069,
      "page_number": 1,
      "length": 963,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1070,
      "page_number": 1,
      "length": 195,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.39,
      "has_code_example": false
    },
    {
      "chunk_id": 1071,
      "page_number": 663,
      "length": 558,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Interface",
        "interface",
        "extends",
        "interface"
      ],
      "code_patterns": [
        "interface extends",
        "interface SortedMap"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 1072,
      "page_number": 665,
      "length": 892,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface SortedMap"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1073,
      "page_number": 666,
      "length": 913,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Interface",
        "interface",
        "extends",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface extends",
        "interface that",
        "interface NavigableMap"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1074,
      "page_number": 666,
      "length": 877,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Interface",
        "interface",
        "interface",
        "interface",
        "static",
        "static",
        "Static"
      ],
      "code_patterns": [
        "interface enables",
        "interface returns",
        "interface Map"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 1075,
      "page_number": 668,
      "length": 975,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "Static",
        "Class",
        "Implements",
        "interface",
        "Extends",
        "enum",
        "Extends",
        "Extends",
        "Extends",
        "Extends",
        "Extends",
        "implements",
        "class"
      ],
      "code_patterns": [
        "class for",
        "class is"
      ],
      "quality_score": 2.6999999999999997,
      "has_code_example": true
    },
    {
      "chunk_id": 1076,
      "page_number": 1,
      "length": 888,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "Class",
        "class",
        "extends",
        "implements",
        "interface",
        "class",
        "class",
        "extends",
        "extends"
      ],
      "code_patterns": [
        "class extends",
        "class that",
        "class HashMap"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1077,
      "page_number": 669,
      "length": 599,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1078,
      "page_number": 670,
      "length": 688,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1079,
      "page_number": 1,
      "length": 717,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "Class",
        "class",
        "extends",
        "implements",
        "interface",
        "class",
        "class",
        "extends",
        "extends",
        "extends"
      ],
      "code_patterns": [
        "class extends",
        "class that",
        "class TreeMap"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1080,
      "page_number": 671,
      "length": 882,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "extends",
        "extends",
        "extends",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface \nand"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1081,
      "page_number": 671,
      "length": 891,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Class",
        "extends",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class LinkedHashMap"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 1082,
      "page_number": 1,
      "length": 369,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "extends",
        "extends"
      ],
      "code_patterns": [
        "class LinkedHashMap"
      ],
      "quality_score": 1.238,
      "has_code_example": true
    },
    {
      "chunk_id": 1083,
      "page_number": 1,
      "length": 777,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1084,
      "page_number": 1,
      "length": 840,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "protected",
        "Class",
        "extends",
        "implements",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class IdentityHashMap"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1085,
      "page_number": 673,
      "length": 986,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "class",
        "Class",
        "extends",
        "implements",
        "enum",
        "class",
        "class",
        "extends",
        "Enum",
        "Enum",
        "enum",
        "Class",
        "extends",
        "extends"
      ],
      "code_patterns": [
        "class IdentityHashMap",
        "class that",
        "class EnumMap"
      ],
      "quality_score": 3.0000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 1086,
      "page_number": 1,
      "length": 913,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface that",
        "interface Comparator",
        "interface defined"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 1087,
      "page_number": 674,
      "length": 667,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1088,
      "page_number": 674,
      "length": 909,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "interface"
      ],
      "code_patterns": [
        "interface methods"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1089,
      "page_number": 1,
      "length": 982,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "static",
        "extends",
        "static",
        "static",
        "extends",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 1090,
      "page_number": 1,
      "length": 815,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1091,
      "page_number": 675,
      "length": 977,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface \nFunction"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1092,
      "page_number": 676,
      "length": 980,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1093,
      "page_number": 677,
      "length": 924,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "static",
        "static",
        "static",
        "implements",
        "class",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 1094,
      "page_number": 678,
      "length": 923,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1095,
      "page_number": 1,
      "length": 975,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class in",
        "class entirely"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1096,
      "page_number": 679,
      "length": 846,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1097,
      "page_number": 681,
      "length": 968,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class TComp"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1098,
      "page_number": 682,
      "length": 683,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1099,
      "page_number": 1,
      "length": 593,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1100,
      "page_number": 1,
      "length": 935,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1101,
      "page_number": 1,
      "length": 483,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.966,
      "has_code_example": false
    },
    {
      "chunk_id": 1102,
      "page_number": 684,
      "length": 663,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "synchronized",
        "synchronized",
        "synchronized",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 1103,
      "page_number": 688,
      "length": 909,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1104,
      "page_number": 689,
      "length": 864,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "static"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1105,
      "page_number": 1,
      "length": 949,
      "chunk_type": "technical",
      "java_keywords_count": 9,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.9,
      "has_code_example": false
    },
    {
      "chunk_id": 1106,
      "page_number": 690,
      "length": 722,
      "chunk_type": "technical",
      "java_keywords_count": 12,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "Class",
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 2.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1107,
      "page_number": 1,
      "length": 701,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1108,
      "page_number": 1,
      "length": 814,
      "chunk_type": "technical",
      "java_keywords_count": 12,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "Class",
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 2.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1109,
      "page_number": 1,
      "length": 861,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1110,
      "page_number": 691,
      "length": 819,
      "chunk_type": "technical",
      "java_keywords_count": 10,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 2.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1111,
      "page_number": 1,
      "length": 984,
      "chunk_type": "technical",
      "java_keywords_count": 10,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 2.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1112,
      "page_number": 692,
      "length": 667,
      "chunk_type": "technical",
      "java_keywords_count": 9,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.9,
      "has_code_example": false
    },
    {
      "chunk_id": 1113,
      "page_number": 692,
      "length": 869,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1114,
      "page_number": 1,
      "length": 993,
      "chunk_type": "technical",
      "java_keywords_count": 10,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "extends",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 2.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1115,
      "page_number": 693,
      "length": 733,
      "chunk_type": "technical",
      "java_keywords_count": 9,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "interface",
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.9,
      "has_code_example": false
    },
    {
      "chunk_id": 1116,
      "page_number": 693,
      "length": 559,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 1117,
      "page_number": 1,
      "length": 616,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1118,
      "page_number": 694,
      "length": 812,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface defined"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1119,
      "page_number": 1,
      "length": 959,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "synchronized",
        "synchronized"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1120,
      "page_number": 1,
      "length": 221,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.442,
      "has_code_example": false
    },
    {
      "chunk_id": 1121,
      "page_number": 1,
      "length": 942,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "Interface",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface called",
        "interface defines",
        "interface has",
        "interface Enumeration"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1122,
      "page_number": 696,
      "length": 429,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.858,
      "has_code_example": false
    },
    {
      "chunk_id": 1123,
      "page_number": 1,
      "length": 842,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "implements",
        "synchronized",
        "interface",
        "class",
        "extends"
      ],
      "code_patterns": [
        "class Vector"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1124,
      "page_number": 1,
      "length": 921,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1125,
      "page_number": 1,
      "length": 355,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 0.8099999999999999,
      "has_code_example": false
    },
    {
      "chunk_id": 1126,
      "page_number": 697,
      "length": 923,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1127,
      "page_number": 698,
      "length": 929,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface is"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1128,
      "page_number": 701,
      "length": 593,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "class"
      ],
      "code_patterns": [
        "class of",
        "class Stack"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1129,
      "page_number": 702,
      "length": 932,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1130,
      "page_number": 703,
      "length": 711,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "abstract",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class Dictionary"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1131,
      "page_number": 704,
      "length": 793,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "abstract",
        "class",
        "interface",
        "Abstract"
      ],
      "code_patterns": [
        "class Dictionary",
        "class is",
        "interface to"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1132,
      "page_number": 704,
      "length": 827,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Abstract",
        "interface",
        "synchronized",
        "class"
      ],
      "code_patterns": [
        "class Hashtable"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1133,
      "page_number": 1,
      "length": 825,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "implements",
        "extends",
        "extends"
      ],
      "code_patterns": [
        "class Hashtable"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1134,
      "page_number": 705,
      "length": 959,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1135,
      "page_number": 706,
      "length": 865,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1136,
      "page_number": 708,
      "length": 667,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class of",
        "class is"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1137,
      "page_number": 710,
      "length": 690,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1138,
      "page_number": 1,
      "length": 993,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1139,
      "page_number": 711,
      "length": 726,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1140,
      "page_number": 712,
      "length": 855,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1141,
      "page_number": 713,
      "length": 260,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.52,
      "has_code_example": false
    },
    {
      "chunk_id": 1142,
      "page_number": 714,
      "length": 946,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1143,
      "page_number": 715,
      "length": 974,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1144,
      "page_number": 1,
      "length": 992,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1145,
      "page_number": 1,
      "length": 503,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1146,
      "page_number": 717,
      "length": 806,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1147,
      "page_number": 718,
      "length": 906,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class creates"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1148,
      "page_number": 722,
      "length": 823,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Optional"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1149,
      "page_number": 723,
      "length": 715,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Optional"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1150,
      "page_number": 723,
      "length": 620,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1151,
      "page_number": 724,
      "length": 765,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1152,
      "page_number": 1,
      "length": 861,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class encapsulates"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1153,
      "page_number": 725,
      "length": 955,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class encapsulates",
        "class were"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 1154,
      "page_number": 726,
      "length": 566,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1155,
      "page_number": 726,
      "length": 742,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "abstract",
        "class",
        "class"
      ],
      "code_patterns": [
        "class provides",
        "class library",
        "class is"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 1156,
      "page_number": 727,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "public",
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1157,
      "page_number": 729,
      "length": 794,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1158,
      "page_number": 1,
      "length": 959,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1159,
      "page_number": 731,
      "length": 851,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "abstract",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class allows"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1160,
      "page_number": 732,
      "length": 962,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "implements",
        "abstract"
      ],
      "code_patterns": [
        "class is",
        "class of"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1161,
      "page_number": 1,
      "length": 744,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1162,
      "page_number": 734,
      "length": 927,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "static"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1163,
      "page_number": 1,
      "length": 855,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "static",
        "final",
        "final",
        "final",
        "static",
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 1164,
      "page_number": 735,
      "length": 959,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class constructs",
        "class is"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1165,
      "page_number": 1,
      "length": 231,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 0.762,
      "has_code_example": true
    },
    {
      "chunk_id": 1166,
      "page_number": 1,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "public"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1167,
      "page_number": 1,
      "length": 892,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1168,
      "page_number": 736,
      "length": 554,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1169,
      "page_number": 1,
      "length": 937,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class is",
        "class undergoes"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1170,
      "page_number": 738,
      "length": 669,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1171,
      "page_number": 738,
      "length": 903,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1172,
      "page_number": 739,
      "length": 943,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "implements",
        "interface",
        "class",
        "extends"
      ],
      "code_patterns": [
        "class being"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1173,
      "page_number": 739,
      "length": 661,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "implements",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class to",
        "class and",
        "interface allow"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1174,
      "page_number": 742,
      "length": 958,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1175,
      "page_number": 1,
      "length": 134,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 0.468,
      "has_code_example": false
    },
    {
      "chunk_id": 1176,
      "page_number": 1,
      "length": 662,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "protected",
        "abstract",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1177,
      "page_number": 743,
      "length": 790,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1178,
      "page_number": 743,
      "length": 912,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class encapsulates"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1179,
      "page_number": 745,
      "length": 873,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class operates"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1180,
      "page_number": 1,
      "length": 686,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1181,
      "page_number": 747,
      "length": 965,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1182,
      "page_number": 1,
      "length": 885,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1183,
      "page_number": 1,
      "length": 251,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.502,
      "has_code_example": false
    },
    {
      "chunk_id": 1184,
      "page_number": 748,
      "length": 956,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1185,
      "page_number": 749,
      "length": 987,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1186,
      "page_number": 750,
      "length": 878,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1187,
      "page_number": 750,
      "length": 742,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1188,
      "page_number": 751,
      "length": 739,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1189,
      "page_number": 752,
      "length": 665,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1190,
      "page_number": 754,
      "length": 808,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1191,
      "page_number": 754,
      "length": 968,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1192,
      "page_number": 756,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1193,
      "page_number": 757,
      "length": 971,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1194,
      "page_number": 758,
      "length": 824,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1195,
      "page_number": 1,
      "length": 978,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1196,
      "page_number": 760,
      "length": 880,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1197,
      "page_number": 761,
      "length": 786,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1198,
      "page_number": 761,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1199,
      "page_number": 762,
      "length": 264,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.528,
      "has_code_example": false
    },
    {
      "chunk_id": 1200,
      "page_number": 1,
      "length": 959,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1201,
      "page_number": 763,
      "length": 602,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1202,
      "page_number": 763,
      "length": 779,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "implements",
        "interface",
        "implements"
      ],
      "code_patterns": [
        "interface or"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1203,
      "page_number": 1,
      "length": 908,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1204,
      "page_number": 764,
      "length": 930,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1205,
      "page_number": 765,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1206,
      "page_number": 1,
      "length": 410,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.82,
      "has_code_example": false
    },
    {
      "chunk_id": 1207,
      "page_number": 768,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1208,
      "page_number": 769,
      "length": 803,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "implements",
        "interface",
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 1209,
      "page_number": 771,
      "length": 789,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1210,
      "page_number": 771,
      "length": 816,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1211,
      "page_number": 773,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1212,
      "page_number": 1,
      "length": 988,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1213,
      "page_number": 775,
      "length": 890,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1214,
      "page_number": 1,
      "length": 937,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "package",
        "abstract",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class ResourceBundle",
        "interface elements"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1215,
      "page_number": 1,
      "length": 891,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1216,
      "page_number": 776,
      "length": 940,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "abstract",
        "class",
        "protected",
        "abstract"
      ],
      "code_patterns": [
        "class \nResourceBundle",
        "class ListResourceBundle"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1217,
      "page_number": 778,
      "length": 960,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "protected",
        "abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1218,
      "page_number": 779,
      "length": 969,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Extends",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class to",
        "class for"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1219,
      "page_number": 781,
      "length": 982,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class for",
        "class is",
        "class to"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 1220,
      "page_number": 781,
      "length": 618,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class to"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1221,
      "page_number": 1,
      "length": 659,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1222,
      "page_number": 782,
      "length": 828,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "package",
        "abstract",
        "static",
        "Abstract",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 1223,
      "page_number": 784,
      "length": 831,
      "chunk_type": "technical",
      "java_keywords_count": 6,
      "java_keywords": [
        "package",
        "package",
        "package",
        "package",
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.6,
      "has_code_example": false
    },
    {
      "chunk_id": 1224,
      "page_number": 785,
      "length": 609,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1225,
      "page_number": 1,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1226,
      "page_number": 1,
      "length": 288,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.576,
      "has_code_example": false
    },
    {
      "chunk_id": 1227,
      "page_number": 786,
      "length": 767,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1228,
      "page_number": 1,
      "length": 675,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1229,
      "page_number": 787,
      "length": 703,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class does",
        "class does",
        "interface and"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1230,
      "page_number": 1,
      "length": 847,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface and"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1231,
      "page_number": 788,
      "length": 859,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1232,
      "page_number": 1,
      "length": 499,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.998,
      "has_code_example": false
    },
    {
      "chunk_id": 1233,
      "page_number": 789,
      "length": 636,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1234,
      "page_number": 1,
      "length": 963,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1235,
      "page_number": 790,
      "length": 771,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1236,
      "page_number": 1,
      "length": 690,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "implements",
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class and"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1237,
      "page_number": 791,
      "length": 948,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1238,
      "page_number": 792,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "implements",
        "interface",
        "class",
        "implements"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1239,
      "page_number": 793,
      "length": 982,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1240,
      "page_number": 794,
      "length": 777,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1241,
      "page_number": 794,
      "length": 837,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1242,
      "page_number": 1,
      "length": 997,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "interface",
        "interface",
        "class",
        "extends",
        "class",
        "implements",
        "implements",
        "class",
        "implements"
      ],
      "code_patterns": [
        "interface is",
        "interface also",
        "class that",
        "class that",
        "class that"
      ],
      "quality_score": 2.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1243,
      "page_number": 1,
      "length": 991,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface is",
        "class of",
        "class that"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 1244,
      "page_number": 795,
      "length": 542,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1245,
      "page_number": 1,
      "length": 801,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1246,
      "page_number": 1,
      "length": 888,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1247,
      "page_number": 796,
      "length": 162,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 0.42400000000000004,
      "has_code_example": false
    },
    {
      "chunk_id": 1248,
      "page_number": 1,
      "length": 865,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1249,
      "page_number": 1,
      "length": 796,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1250,
      "page_number": 1,
      "length": 833,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1251,
      "page_number": 797,
      "length": 773,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1252,
      "page_number": 798,
      "length": 958,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "abstract",
        "class",
        "implements",
        "class",
        "abstract",
        "class",
        "implements",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class will",
        "class in",
        "class that",
        "class return"
      ],
      "quality_score": 2.8,
      "has_code_example": true
    },
    {
      "chunk_id": 1253,
      "page_number": 798,
      "length": 637,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class creates"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1254,
      "page_number": 799,
      "length": 974,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "abstract",
        "class"
      ],
      "code_patterns": [
        "class InputStream"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1255,
      "page_number": 800,
      "length": 950,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1256,
      "page_number": 802,
      "length": 960,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1257,
      "page_number": 803,
      "length": 780,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1258,
      "page_number": 804,
      "length": 832,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class has"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1259,
      "page_number": 805,
      "length": 817,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1260,
      "page_number": 806,
      "length": 872,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "protected",
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1261,
      "page_number": 807,
      "length": 927,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1262,
      "page_number": 1,
      "length": 920,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "extends",
        "class",
        "implements",
        "class"
      ],
      "code_patterns": [
        "class by",
        "class allows"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 1263,
      "page_number": 1,
      "length": 332,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class allows"
      ],
      "quality_score": 0.964,
      "has_code_example": true
    },
    {
      "chunk_id": 1264,
      "page_number": 809,
      "length": 980,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1265,
      "page_number": 1,
      "length": 832,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1266,
      "page_number": 810,
      "length": 935,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1267,
      "page_number": 1,
      "length": 875,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "implements"
      ],
      "code_patterns": [
        "class implements"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1268,
      "page_number": 1,
      "length": 818,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1269,
      "page_number": 812,
      "length": 782,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1270,
      "page_number": 813,
      "length": 448,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "extends"
      ],
      "code_patterns": [
        "class allows"
      ],
      "quality_score": 1.296,
      "has_code_example": true
    },
    {
      "chunk_id": 1271,
      "page_number": 1,
      "length": 847,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "class"
      ],
      "code_patterns": [
        "class fulfills"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1272,
      "page_number": 814,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "implements"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1273,
      "page_number": 1,
      "length": 965,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1274,
      "page_number": 816,
      "length": 240,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.48,
      "has_code_example": false
    },
    {
      "chunk_id": 1275,
      "page_number": 1,
      "length": 960,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1276,
      "page_number": 1,
      "length": 817,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class in"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1277,
      "page_number": 817,
      "length": 724,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1278,
      "page_number": 818,
      "length": 769,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "extends",
        "extends",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1279,
      "page_number": 1,
      "length": 802,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "implements",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 1280,
      "page_number": 1,
      "length": 917,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "final",
        "final",
        "final",
        "extends",
        "extends",
        "interface",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1281,
      "page_number": 819,
      "length": 843,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "final",
        "final",
        "final",
        "implements",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 1282,
      "page_number": 1,
      "length": 797,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1283,
      "page_number": 1,
      "length": 909,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1284,
      "page_number": 821,
      "length": 896,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "abstract",
        "abstract",
        "class",
        "implements",
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1285,
      "page_number": 822,
      "length": 941,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "abstract",
        "class",
        "implements",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class throw",
        "class creates"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1286,
      "page_number": 823,
      "length": 285,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.57,
      "has_code_example": false
    },
    {
      "chunk_id": 1287,
      "page_number": 1,
      "length": 978,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1288,
      "page_number": 824,
      "length": 860,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class has"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1289,
      "page_number": 825,
      "length": 368,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.736,
      "has_code_example": false
    },
    {
      "chunk_id": 1290,
      "page_number": 826,
      "length": 895,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1291,
      "page_number": 1,
      "length": 262,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.524,
      "has_code_example": false
    },
    {
      "chunk_id": 1292,
      "page_number": 828,
      "length": 976,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1293,
      "page_number": 1,
      "length": 392,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.784,
      "has_code_example": false
    },
    {
      "chunk_id": 1294,
      "page_number": 829,
      "length": 774,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class allows"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1295,
      "page_number": 1,
      "length": 651,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1296,
      "page_number": 831,
      "length": 965,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1297,
      "page_number": 831,
      "length": 889,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1298,
      "page_number": 832,
      "length": 957,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class described"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1299,
      "page_number": 1,
      "length": 576,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1300,
      "page_number": 833,
      "length": 738,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "Class",
        "class",
        "implements",
        "interface",
        "class",
        "static"
      ],
      "code_patterns": [
        "class was",
        "class because"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1301,
      "page_number": 1,
      "length": 922,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1302,
      "page_number": 1,
      "length": 283,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.566,
      "has_code_example": false
    },
    {
      "chunk_id": 1303,
      "page_number": 834,
      "length": 824,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1304,
      "page_number": 835,
      "length": 906,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1305,
      "page_number": 835,
      "length": 541,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "implements",
        "interface",
        "interface",
        "class",
        "class",
        "transient",
        "static"
      ],
      "code_patterns": [
        "interface can",
        "interface defines",
        "class may",
        "class is"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1306,
      "page_number": 1,
      "length": 968,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "extends"
      ],
      "code_patterns": [
        "interface is",
        "interface defines",
        "interface extends"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1307,
      "page_number": 836,
      "length": 958,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "extends",
        "class",
        "implements",
        "interface",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class extends",
        "class and",
        "class is",
        "class are",
        "class to"
      ],
      "quality_score": 2.8,
      "has_code_example": true
    },
    {
      "chunk_id": 1308,
      "page_number": 837,
      "length": 776,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "interface",
        "extends",
        "class",
        "extends",
        "class",
        "implements",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface extends",
        "class extends",
        "class and",
        "class is"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1309,
      "page_number": 838,
      "length": 749,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class are",
        "class to"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1310,
      "page_number": 1,
      "length": 932,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class MyClass"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1311,
      "page_number": 839,
      "length": 336,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "transient"
      ],
      "code_patterns": [],
      "quality_score": 0.772,
      "has_code_example": false
    },
    {
      "chunk_id": 1312,
      "page_number": 839,
      "length": 956,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "interface to",
        "interface to"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1313,
      "page_number": 841,
      "length": 938,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1314,
      "page_number": 1,
      "length": 974,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "Package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1315,
      "page_number": 842,
      "length": 875,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1316,
      "page_number": 843,
      "length": 846,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1317,
      "page_number": 843,
      "length": 881,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1318,
      "page_number": 844,
      "length": 817,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "extends",
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1319,
      "page_number": 1,
      "length": 905,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "static",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface \nimplemented",
        "class is"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 1320,
      "page_number": 845,
      "length": 556,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1321,
      "page_number": 1,
      "length": 929,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1322,
      "page_number": 846,
      "length": 621,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1323,
      "page_number": 1,
      "length": 931,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface because"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1324,
      "page_number": 1,
      "length": 460,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.92,
      "has_code_example": false
    },
    {
      "chunk_id": 1325,
      "page_number": 847,
      "length": 375,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "Class"
      ],
      "code_patterns": [
        "class defined"
      ],
      "quality_score": 1.15,
      "has_code_example": true
    },
    {
      "chunk_id": 1326,
      "page_number": 1,
      "length": 954,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1327,
      "page_number": 1,
      "length": 373,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 1.146,
      "has_code_example": true
    },
    {
      "chunk_id": 1328,
      "page_number": 848,
      "length": 778,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "Class",
        "interface",
        "class",
        "class",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 1329,
      "page_number": 850,
      "length": 721,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1330,
      "page_number": 1,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1331,
      "page_number": 851,
      "length": 766,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1332,
      "page_number": 1,
      "length": 423,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 0.946,
      "has_code_example": false
    },
    {
      "chunk_id": 1333,
      "page_number": 1,
      "length": 816,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class to"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1334,
      "page_number": 852,
      "length": 982,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "static"
      ],
      "code_patterns": [
        "class offers"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1335,
      "page_number": 1,
      "length": 485,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \nencapsulates"
      ],
      "quality_score": 1.27,
      "has_code_example": true
    },
    {
      "chunk_id": 1336,
      "page_number": 1,
      "length": 949,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1337,
      "page_number": 853,
      "length": 960,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1338,
      "page_number": 1,
      "length": 581,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1339,
      "page_number": 1,
      "length": 949,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1340,
      "page_number": 1,
      "length": 828,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1341,
      "page_number": 854,
      "length": 924,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1342,
      "page_number": 1,
      "length": 544,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1343,
      "page_number": 855,
      "length": 741,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1344,
      "page_number": 1,
      "length": 276,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.552,
      "has_code_example": false
    },
    {
      "chunk_id": 1345,
      "page_number": 856,
      "length": 967,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1346,
      "page_number": 1,
      "length": 175,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.35,
      "has_code_example": false
    },
    {
      "chunk_id": 1347,
      "page_number": 857,
      "length": 966,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1348,
      "page_number": 1,
      "length": 346,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.692,
      "has_code_example": false
    },
    {
      "chunk_id": 1349,
      "page_number": 1,
      "length": 760,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "PRIVATE",
        "private"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1350,
      "page_number": 858,
      "length": 805,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1351,
      "page_number": 859,
      "length": 548,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1352,
      "page_number": 1,
      "length": 969,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1353,
      "page_number": 1,
      "length": 583,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1354,
      "page_number": 860,
      "length": 559,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1355,
      "page_number": 861,
      "length": 687,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1356,
      "page_number": 1,
      "length": 993,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1357,
      "page_number": 1,
      "length": 278,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.556,
      "has_code_example": false
    },
    {
      "chunk_id": 1358,
      "page_number": 862,
      "length": 904,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1359,
      "page_number": 862,
      "length": 780,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1360,
      "page_number": 863,
      "length": 569,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1361,
      "page_number": 863,
      "length": 691,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1362,
      "page_number": 864,
      "length": 616,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1363,
      "page_number": 864,
      "length": 863,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1364,
      "page_number": 865,
      "length": 455,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.91,
      "has_code_example": false
    },
    {
      "chunk_id": 1365,
      "page_number": 866,
      "length": 939,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1366,
      "page_number": 867,
      "length": 823,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "package",
        "class",
        "class"
      ],
      "code_patterns": [
        "class in",
        "class deals",
        "class is"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1367,
      "page_number": 867,
      "length": 750,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1368,
      "page_number": 868,
      "length": 835,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1369,
      "page_number": 868,
      "length": 663,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1370,
      "page_number": 1,
      "length": 421,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 0.942,
      "has_code_example": false
    },
    {
      "chunk_id": 1371,
      "page_number": 1,
      "length": 764,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "implements"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1372,
      "page_number": 871,
      "length": 976,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1373,
      "page_number": 1,
      "length": 984,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1374,
      "page_number": 873,
      "length": 638,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1375,
      "page_number": 873,
      "length": 572,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1376,
      "page_number": 874,
      "length": 874,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface that",
        "interface that",
        "interface FileVisitor"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 1377,
      "page_number": 875,
      "length": 963,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "implements"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1378,
      "page_number": 875,
      "length": 861,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "extends",
        "class",
        "class"
      ],
      "code_patterns": [
        "class MyFileVisitor",
        "class was"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 1379,
      "page_number": 1,
      "length": 986,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1380,
      "page_number": 1,
      "length": 947,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1381,
      "page_number": 877,
      "length": 839,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1382,
      "page_number": 1,
      "length": 654,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1383,
      "page_number": 879,
      "length": 810,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1384,
      "page_number": 880,
      "length": 445,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.89,
      "has_code_example": false
    },
    {
      "chunk_id": 1385,
      "page_number": 1,
      "length": 993,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1386,
      "page_number": 882,
      "length": 924,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1387,
      "page_number": 1,
      "length": 249,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.498,
      "has_code_example": false
    },
    {
      "chunk_id": 1388,
      "page_number": 883,
      "length": 381,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 0.862,
      "has_code_example": false
    },
    {
      "chunk_id": 1389,
      "page_number": 884,
      "length": 971,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "Class",
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1390,
      "page_number": 1,
      "length": 997,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1391,
      "page_number": 1,
      "length": 616,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1392,
      "page_number": 886,
      "length": 898,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1393,
      "page_number": 1,
      "length": 991,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1394,
      "page_number": 1,
      "length": 834,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1395,
      "page_number": 887,
      "length": 786,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "package",
        "package"
      ],
      "code_patterns": [
        "interface \nintroduced"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1396,
      "page_number": 1,
      "length": 957,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "static",
        "class",
        "class",
        "static",
        "static"
      ],
      "code_patterns": [
        "class is",
        "class by",
        "class \nhides",
        "class has",
        "class return"
      ],
      "quality_score": 2.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1397,
      "page_number": 888,
      "length": 243,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 0.786,
      "has_code_example": false
    },
    {
      "chunk_id": 1398,
      "page_number": 1,
      "length": 991,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1399,
      "page_number": 889,
      "length": 975,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class has"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1400,
      "page_number": 1,
      "length": 823,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1401,
      "page_number": 890,
      "length": 956,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1402,
      "page_number": 890,
      "length": 386,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.772,
      "has_code_example": false
    },
    {
      "chunk_id": 1403,
      "page_number": 1,
      "length": 990,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class is"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1404,
      "page_number": 1,
      "length": 919,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1405,
      "page_number": 891,
      "length": 590,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1406,
      "page_number": 1,
      "length": 951,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1407,
      "page_number": 892,
      "length": 657,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1408,
      "page_number": 893,
      "length": 558,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1409,
      "page_number": 894,
      "length": 846,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1410,
      "page_number": 1,
      "length": 965,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class library",
        "class provides"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1411,
      "page_number": 1,
      "length": 885,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1412,
      "page_number": 1,
      "length": 696,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class has"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1413,
      "page_number": 895,
      "length": 805,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1414,
      "page_number": 1,
      "length": 955,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class for"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1415,
      "page_number": 896,
      "length": 906,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1416,
      "page_number": 1,
      "length": 989,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1417,
      "page_number": 1,
      "length": 687,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1418,
      "page_number": 897,
      "length": 936,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1419,
      "page_number": 899,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "static"
      ],
      "code_patterns": [
        "class of",
        "class is"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1420,
      "page_number": 1,
      "length": 808,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1421,
      "page_number": 900,
      "length": 664,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1422,
      "page_number": 900,
      "length": 819,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class encapsulates"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1423,
      "page_number": 902,
      "length": 646,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "package",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class is"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1424,
      "page_number": 902,
      "length": 939,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1425,
      "page_number": 1,
      "length": 777,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1426,
      "page_number": 1,
      "length": 922,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1427,
      "page_number": 903,
      "length": 566,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "public"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1428,
      "page_number": 1,
      "length": 996,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "abstract",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class InetSocketAddress"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1429,
      "page_number": 1,
      "length": 926,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1430,
      "page_number": 904,
      "length": 842,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1431,
      "page_number": 1,
      "length": 903,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1432,
      "page_number": 1,
      "length": 985,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1433,
      "page_number": 905,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1434,
      "page_number": 907,
      "length": 851,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Class",
        "Class",
        "class",
        "class",
        "package"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1435,
      "page_number": 1,
      "length": 872,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "Abstract",
        "interface",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class described",
        "class JApplet",
        "interface than",
        "interface is"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 1436,
      "page_number": 1,
      "length": 569,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1437,
      "page_number": 909,
      "length": 92,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.184,
      "has_code_example": false
    },
    {
      "chunk_id": 1438,
      "page_number": 1,
      "length": 956,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1439,
      "page_number": 1,
      "length": 874,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1440,
      "page_number": 1,
      "length": 968,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1441,
      "page_number": 1,
      "length": 366,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.732,
      "has_code_example": false
    },
    {
      "chunk_id": 1442,
      "page_number": 910,
      "length": 308,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.616,
      "has_code_example": false
    },
    {
      "chunk_id": 1443,
      "page_number": 1,
      "length": 978,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1444,
      "page_number": 1,
      "length": 282,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.564,
      "has_code_example": false
    },
    {
      "chunk_id": 1445,
      "page_number": 911,
      "length": 756,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Class",
        "class",
        "extends",
        "class",
        "extends",
        "extends",
        "interface"
      ],
      "code_patterns": [
        "class defines",
        "class Panel"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1446,
      "page_number": 911,
      "length": 929,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1447,
      "page_number": 1,
      "length": 985,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1448,
      "page_number": 1,
      "length": 931,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1449,
      "page_number": 1,
      "length": 897,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1450,
      "page_number": 914,
      "length": 859,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1451,
      "page_number": 1,
      "length": 746,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1452,
      "page_number": 1,
      "length": 709,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1453,
      "page_number": 916,
      "length": 684,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1454,
      "page_number": 1,
      "length": 583,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1455,
      "page_number": 1,
      "length": 938,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1456,
      "page_number": 917,
      "length": 968,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Color"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1457,
      "page_number": 918,
      "length": 903,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1458,
      "page_number": 918,
      "length": 353,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.706,
      "has_code_example": false
    },
    {
      "chunk_id": 1459,
      "page_number": 919,
      "length": 913,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1460,
      "page_number": 1,
      "length": 733,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1461,
      "page_number": 1,
      "length": 202,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.404,
      "has_code_example": false
    },
    {
      "chunk_id": 1462,
      "page_number": 1,
      "length": 996,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1463,
      "page_number": 920,
      "length": 811,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1464,
      "page_number": 921,
      "length": 377,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.754,
      "has_code_example": false
    },
    {
      "chunk_id": 1465,
      "page_number": 922,
      "length": 950,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1466,
      "page_number": 1,
      "length": 900,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1467,
      "page_number": 923,
      "length": 679,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1468,
      "page_number": 923,
      "length": 918,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class file"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1469,
      "page_number": 1,
      "length": 985,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class file"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1470,
      "page_number": 925,
      "length": 793,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1471,
      "page_number": 926,
      "length": 888,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1472,
      "page_number": 926,
      "length": 898,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1473,
      "page_number": 928,
      "length": 814,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class file"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1474,
      "page_number": 930,
      "length": 752,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "Interface"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1475,
      "page_number": 1,
      "length": 955,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1476,
      "page_number": 1,
      "length": 313,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.626,
      "has_code_example": false
    },
    {
      "chunk_id": 1477,
      "page_number": 932,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Interface",
        "interface",
        "Interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines",
        "interface provides"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1478,
      "page_number": 933,
      "length": 405,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "Class"
      ],
      "code_patterns": [
        "interface most"
      ],
      "quality_score": 1.21,
      "has_code_example": true
    },
    {
      "chunk_id": 1479,
      "page_number": 1,
      "length": 970,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface to"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1480,
      "page_number": 1,
      "length": 795,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1481,
      "page_number": 935,
      "length": 891,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1482,
      "page_number": 1,
      "length": 997,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface logic",
        "interface element"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1483,
      "page_number": 1,
      "length": 448,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.896,
      "has_code_example": false
    },
    {
      "chunk_id": 1484,
      "page_number": 1,
      "length": 811,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1485,
      "page_number": 936,
      "length": 581,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "public"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1486,
      "page_number": 936,
      "length": 858,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "public",
        "public"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1487,
      "page_number": 1,
      "length": 887,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "public",
        "public",
        "class"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1488,
      "page_number": 1,
      "length": 863,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1489,
      "page_number": 937,
      "length": 808,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class hierarchy",
        "class for"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1490,
      "page_number": 1,
      "length": 942,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "package"
      ],
      "code_patterns": [
        "class AWTEvent",
        "class of",
        "class of"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 1491,
      "page_number": 938,
      "length": 565,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "package",
        "interface",
        "class",
        "Class"
      ],
      "code_patterns": [
        "class of",
        "class of",
        "interface elements",
        "class are"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1492,
      "page_number": 938,
      "length": 734,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1493,
      "page_number": 939,
      "length": 979,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1494,
      "page_number": 939,
      "length": 835,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1495,
      "page_number": 1,
      "length": 934,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1496,
      "page_number": 940,
      "length": 820,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1497,
      "page_number": 1,
      "length": 599,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [
        "class either"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1498,
      "page_number": 1,
      "length": 878,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class defines",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1499,
      "page_number": 941,
      "length": 762,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1500,
      "page_number": 1,
      "length": 872,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface operation"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1501,
      "page_number": 942,
      "length": 893,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Class",
        "abstract",
        "class",
        "class"
      ],
      "code_patterns": [
        "class InputEvent",
        "class of",
        "class for",
        "class defined"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1502,
      "page_number": 942,
      "length": 944,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1503,
      "page_number": 1,
      "length": 834,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1504,
      "page_number": 943,
      "length": 979,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface elements"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1505,
      "page_number": 1,
      "length": 955,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1506,
      "page_number": 944,
      "length": 907,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1507,
      "page_number": 1,
      "length": 775,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class defines",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1508,
      "page_number": 945,
      "length": 892,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class of",
        "class are"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1509,
      "page_number": 945,
      "length": 829,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1510,
      "page_number": 1,
      "length": 829,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class encapsulates",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1511,
      "page_number": 946,
      "length": 523,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "Class",
        "class"
      ],
      "code_patterns": [
        "class encapsulates",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1512,
      "page_number": 1,
      "length": 992,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1513,
      "page_number": 1,
      "length": 985,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class describe",
        "class is"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1514,
      "page_number": 947,
      "length": 943,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "Class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class defines"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1515,
      "page_number": 1,
      "length": 792,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1516,
      "page_number": 1,
      "length": 811,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1517,
      "page_number": 948,
      "length": 935,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface components",
        "interface elements",
        "class derived"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 1518,
      "page_number": 949,
      "length": 945,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "package",
        "interface",
        "Interface",
        "interface",
        "Interface"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1519,
      "page_number": 1,
      "length": 981,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "Interface",
        "interface",
        "Interface",
        "interface",
        "Interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines",
        "interface defines",
        "interface contains"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1520,
      "page_number": 950,
      "length": 636,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Interface",
        "interface",
        "Interface",
        "interface",
        "Interface"
      ],
      "code_patterns": [
        "interface defines",
        "interface defines"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1521,
      "page_number": 1,
      "length": 713,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Interface",
        "interface",
        "Interface"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1522,
      "page_number": 1,
      "length": 937,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Interface",
        "interface",
        "Interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines",
        "interface defines"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 1523,
      "page_number": 951,
      "length": 964,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "interface",
        "Interface",
        "interface",
        "Interface",
        "interface",
        "Interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines",
        "interface defines",
        "interface defines",
        "interface defines"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1524,
      "page_number": 1,
      "length": 872,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "Interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines",
        "interface defines"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1525,
      "page_number": 952,
      "length": 798,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface in"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1526,
      "page_number": 1,
      "length": 554,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1527,
      "page_number": 1,
      "length": 955,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1528,
      "page_number": 1,
      "length": 242,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.484,
      "has_code_example": false
    },
    {
      "chunk_id": 1529,
      "page_number": 953,
      "length": 928,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "extends",
        "implements"
      ],
      "code_patterns": [
        "class extends",
        "class of"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1530,
      "page_number": 1,
      "length": 532,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1531,
      "page_number": 1,
      "length": 591,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1532,
      "page_number": 956,
      "length": 659,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1533,
      "page_number": 957,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1534,
      "page_number": 1,
      "length": 946,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "interface",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class provides",
        "class to",
        "class has"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 1535,
      "page_number": 960,
      "length": 203,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "implements"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 0.806,
      "has_code_example": true
    },
    {
      "chunk_id": 1536,
      "page_number": 1,
      "length": 967,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "extends",
        "extends",
        "class",
        "extends",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 1537,
      "page_number": 1,
      "length": 556,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1538,
      "page_number": 961,
      "length": 407,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.814,
      "has_code_example": false
    },
    {
      "chunk_id": 1539,
      "page_number": 1,
      "length": 952,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "extends",
        "extends"
      ],
      "code_patterns": [
        "class is",
        "class defined"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1540,
      "page_number": 1,
      "length": 418,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.836,
      "has_code_example": false
    },
    {
      "chunk_id": 1541,
      "page_number": 963,
      "length": 655,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "extends",
        "class",
        "extends",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class that"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1542,
      "page_number": 1,
      "length": 379,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class can"
      ],
      "quality_score": 1.358,
      "has_code_example": true
    },
    {
      "chunk_id": 1543,
      "page_number": 964,
      "length": 946,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "extends",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class in",
        "MouseAdapter (){",
        "class extends",
        "class is",
        "class is"
      ],
      "quality_score": 2.8,
      "has_code_example": true
    },
    {
      "chunk_id": 1544,
      "page_number": 965,
      "length": 272,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Class"
      ],
      "code_patterns": [],
      "quality_score": 0.644,
      "has_code_example": false
    },
    {
      "chunk_id": 1545,
      "page_number": 1,
      "length": 954,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1546,
      "page_number": 1,
      "length": 969,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1547,
      "page_number": 1,
      "length": 399,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.798,
      "has_code_example": false
    },
    {
      "chunk_id": 1548,
      "page_number": 966,
      "length": 879,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1549,
      "page_number": 967,
      "length": 861,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1550,
      "page_number": 968,
      "length": 721,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class hierarchy",
        "class hierarchies",
        "class hierarchy",
        "class hierarchy"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1551,
      "page_number": 1,
      "length": 945,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "class",
        "abstract",
        "class",
        "interface",
        "public",
        "class"
      ],
      "code_patterns": [
        "class hierarchy",
        "class \nthat",
        "interface elements",
        "class is",
        "class of"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1552,
      "page_number": 969,
      "length": 524,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is",
        "class of"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1553,
      "page_number": 969,
      "length": 897,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is",
        "class of",
        "class for"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1554,
      "page_number": 1,
      "length": 916,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class creates",
        "class of",
        "class of"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1555,
      "page_number": 970,
      "length": 954,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1556,
      "page_number": 1,
      "length": 984,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1557,
      "page_number": 971,
      "length": 802,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1558,
      "page_number": 1,
      "length": 971,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "class of",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1559,
      "page_number": 1,
      "length": 952,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class of",
        "class is"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1560,
      "page_number": 1,
      "length": 252,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.504,
      "has_code_example": false
    },
    {
      "chunk_id": 1561,
      "page_number": 972,
      "length": 907,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1562,
      "page_number": 974,
      "length": 873,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1563,
      "page_number": 1,
      "length": 577,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1564,
      "page_number": 1,
      "length": 729,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1565,
      "page_number": 1,
      "length": 696,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1566,
      "page_number": 982,
      "length": 955,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1567,
      "page_number": 1,
      "length": 956,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1568,
      "page_number": 983,
      "length": 578,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1569,
      "page_number": 983,
      "length": 884,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1570,
      "page_number": 984,
      "length": 900,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1571,
      "page_number": 986,
      "length": 651,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1572,
      "page_number": 987,
      "length": 942,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1573,
      "page_number": 987,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1574,
      "page_number": 1,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "static",
        "static"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1575,
      "page_number": 988,
      "length": 944,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1576,
      "page_number": 989,
      "length": 855,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1577,
      "page_number": 989,
      "length": 769,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1578,
      "page_number": 991,
      "length": 532,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1579,
      "page_number": 991,
      "length": 938,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "protected"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1580,
      "page_number": 993,
      "length": 854,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "protected",
        "static",
        "class",
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1581,
      "page_number": 994,
      "length": 940,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1582,
      "page_number": 995,
      "length": 207,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.414,
      "has_code_example": false
    },
    {
      "chunk_id": 1583,
      "page_number": 1,
      "length": 984,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1584,
      "page_number": 996,
      "length": 841,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1585,
      "page_number": 998,
      "length": 767,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1586,
      "page_number": 999,
      "length": 857,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1587,
      "page_number": 1,
      "length": 955,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1588,
      "page_number": 1,
      "length": 184,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.368,
      "has_code_example": false
    },
    {
      "chunk_id": 1589,
      "page_number": 1000,
      "length": 929,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1590,
      "page_number": 1,
      "length": 969,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1591,
      "page_number": 1001,
      "length": 355,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.71,
      "has_code_example": false
    },
    {
      "chunk_id": 1592,
      "page_number": 1003,
      "length": 857,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1593,
      "page_number": 1007,
      "length": 960,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1594,
      "page_number": 1,
      "length": 863,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class advances"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1595,
      "page_number": 1008,
      "length": 272,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.544,
      "has_code_example": false
    },
    {
      "chunk_id": 1596,
      "page_number": 1,
      "length": 961,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1597,
      "page_number": 1,
      "length": 815,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1598,
      "page_number": 1,
      "length": 418,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.836,
      "has_code_example": false
    },
    {
      "chunk_id": 1599,
      "page_number": 1010,
      "length": 782,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1600,
      "page_number": 1,
      "length": 930,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1601,
      "page_number": 1,
      "length": 646,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1602,
      "page_number": 1011,
      "length": 759,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "implements",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface and",
        "interface for"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1603,
      "page_number": 1011,
      "length": 956,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1604,
      "page_number": 1,
      "length": 813,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1605,
      "page_number": 1012,
      "length": 752,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1606,
      "page_number": 1013,
      "length": 732,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1607,
      "page_number": 1,
      "length": 938,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "implements",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1608,
      "page_number": 1,
      "length": 360,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.72,
      "has_code_example": false
    },
    {
      "chunk_id": 1609,
      "page_number": 1014,
      "length": 663,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1610,
      "page_number": 1016,
      "length": 849,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1611,
      "page_number": 1017,
      "length": 565,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1612,
      "page_number": 1,
      "length": 833,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "interface",
        "abstract",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface with"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 1613,
      "page_number": 1018,
      "length": 791,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1614,
      "page_number": 1,
      "length": 944,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1615,
      "page_number": 1,
      "length": 997,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "implements",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface \ndefines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1616,
      "page_number": 1019,
      "length": 958,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1617,
      "page_number": 1021,
      "length": 465,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.93,
      "has_code_example": false
    },
    {
      "chunk_id": 1618,
      "page_number": 1022,
      "length": 968,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1619,
      "page_number": 1023,
      "length": 860,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1620,
      "page_number": 1024,
      "length": 706,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "implements",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1621,
      "page_number": 1024,
      "length": 603,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1622,
      "page_number": 1,
      "length": 802,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1623,
      "page_number": 1,
      "length": 567,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1624,
      "page_number": 1026,
      "length": 724,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1625,
      "page_number": 1,
      "length": 746,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1626,
      "page_number": 1027,
      "length": 944,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1627,
      "page_number": 1027,
      "length": 151,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.302,
      "has_code_example": false
    },
    {
      "chunk_id": 1628,
      "page_number": 1,
      "length": 942,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1629,
      "page_number": 1,
      "length": 780,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1630,
      "page_number": 1030,
      "length": 708,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1631,
      "page_number": 1,
      "length": 989,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1632,
      "page_number": 1031,
      "length": 835,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1633,
      "page_number": 1031,
      "length": 769,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "implements"
      ],
      "code_patterns": [
        "class implements",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1634,
      "page_number": 1,
      "length": 937,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class TextComponent"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1635,
      "page_number": 1034,
      "length": 554,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1636,
      "page_number": 1,
      "length": 985,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1637,
      "page_number": 1035,
      "length": 904,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1638,
      "page_number": 1,
      "length": 958,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1639,
      "page_number": 1037,
      "length": 813,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1640,
      "page_number": 1,
      "length": 965,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1641,
      "page_number": 1,
      "length": 488,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.476,
      "has_code_example": true
    },
    {
      "chunk_id": 1642,
      "page_number": 1,
      "length": 590,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1643,
      "page_number": 1039,
      "length": 726,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1644,
      "page_number": 1,
      "length": 997,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1645,
      "page_number": 1040,
      "length": 961,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "implements"
      ],
      "code_patterns": [
        "class implements"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1646,
      "page_number": 1042,
      "length": 855,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1647,
      "page_number": 1043,
      "length": 832,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1648,
      "page_number": 1045,
      "length": 729,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1649,
      "page_number": 1047,
      "length": 851,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1650,
      "page_number": 1047,
      "length": 735,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1651,
      "page_number": 1,
      "length": 984,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1652,
      "page_number": 1,
      "length": 239,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.478,
      "has_code_example": false
    },
    {
      "chunk_id": 1653,
      "page_number": 1,
      "length": 705,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1654,
      "page_number": 1049,
      "length": 733,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1655,
      "page_number": 1051,
      "length": 646,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1656,
      "page_number": 1052,
      "length": 942,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1657,
      "page_number": 1,
      "length": 265,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.53,
      "has_code_example": false
    },
    {
      "chunk_id": 1658,
      "page_number": 1053,
      "length": 851,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1659,
      "page_number": 1053,
      "length": 724,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1660,
      "page_number": 1054,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1661,
      "page_number": 1,
      "length": 547,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1662,
      "page_number": 1,
      "length": 912,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1663,
      "page_number": 1,
      "length": 389,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.778,
      "has_code_example": false
    },
    {
      "chunk_id": 1664,
      "page_number": 1055,
      "length": 961,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1665,
      "page_number": 1,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class of",
        "class defines"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1666,
      "page_number": 1058,
      "length": 931,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1667,
      "page_number": 1,
      "length": 996,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1668,
      "page_number": 1,
      "length": 698,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1669,
      "page_number": 1059,
      "length": 695,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1670,
      "page_number": 1,
      "length": 976,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1671,
      "page_number": 1060,
      "length": 621,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1672,
      "page_number": 1,
      "length": 986,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1673,
      "page_number": 1065,
      "length": 854,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class Dialog"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1674,
      "page_number": 1068,
      "length": 603,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1675,
      "page_number": 1071,
      "length": 950,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1676,
      "page_number": 1071,
      "length": 719,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class \nimplementation"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1677,
      "page_number": 1073,
      "length": 937,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1678,
      "page_number": 1074,
      "length": 218,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.436,
      "has_code_example": false
    },
    {
      "chunk_id": 1679,
      "page_number": 1,
      "length": 974,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "package",
        "class",
        "package",
        "package"
      ],
      "code_patterns": [
        "class and"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1680,
      "page_number": 1,
      "length": 267,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.534,
      "has_code_example": false
    },
    {
      "chunk_id": 1681,
      "page_number": 1075,
      "length": 588,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1682,
      "page_number": 1075,
      "length": 631,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "abstract",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1683,
      "page_number": 1,
      "length": 590,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1684,
      "page_number": 1,
      "length": 979,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class doesn",
        "class in",
        "class \nthat"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1685,
      "page_number": 1076,
      "length": 919,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1686,
      "page_number": 1,
      "length": 992,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "implements",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class that",
        "interface is"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1687,
      "page_number": 1077,
      "length": 940,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface calls"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1688,
      "page_number": 1078,
      "length": 857,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface used"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1689,
      "page_number": 1079,
      "length": 925,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "static",
        "interface",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class has",
        "interface that",
        "class to"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1690,
      "page_number": 1,
      "length": 926,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1691,
      "page_number": 1,
      "length": 496,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.992,
      "has_code_example": false
    },
    {
      "chunk_id": 1692,
      "page_number": 1080,
      "length": 737,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1693,
      "page_number": 1082,
      "length": 722,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1694,
      "page_number": 1082,
      "length": 920,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1695,
      "page_number": 1,
      "length": 578,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1696,
      "page_number": 1083,
      "length": 783,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1697,
      "page_number": 1083,
      "length": 678,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1698,
      "page_number": 1084,
      "length": 867,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1699,
      "page_number": 1086,
      "length": 883,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "implements",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface for",
        "interface will",
        "class that"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1700,
      "page_number": 1,
      "length": 924,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1701,
      "page_number": 1087,
      "length": 547,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1702,
      "page_number": 1088,
      "length": 525,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "implements",
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface for",
        "interface is"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1703,
      "page_number": 1,
      "length": 564,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1704,
      "page_number": 1089,
      "length": 974,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1705,
      "page_number": 1090,
      "length": 317,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface pair"
      ],
      "quality_score": 0.9339999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1706,
      "page_number": 1091,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "abstract",
        "class",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1707,
      "page_number": 1092,
      "length": 925,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1708,
      "page_number": 1,
      "length": 396,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.792,
      "has_code_example": false
    },
    {
      "chunk_id": 1709,
      "page_number": 1,
      "length": 790,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "class",
        "abstract"
      ],
      "code_patterns": [
        "interface for",
        "class called",
        "interface called",
        "class called"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1710,
      "page_number": 1095,
      "length": 959,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "class",
        "Class",
        "class",
        "implements"
      ],
      "code_patterns": [
        "class called",
        "class is",
        "class that",
        "class that"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 1711,
      "page_number": 1096,
      "length": 931,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "interface used",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1712,
      "page_number": 1098,
      "length": 928,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1713,
      "page_number": 1100,
      "length": 647,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1714,
      "page_number": 1101,
      "length": 829,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "abstract",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class Convolver",
        "interface to"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1715,
      "page_number": 1102,
      "length": 837,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1716,
      "page_number": 1106,
      "length": 881,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1717,
      "page_number": 1108,
      "length": 853,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1718,
      "page_number": 1,
      "length": 902,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1719,
      "page_number": 1,
      "length": 880,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1720,
      "page_number": 1,
      "length": 266,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.532,
      "has_code_example": false
    },
    {
      "chunk_id": 1721,
      "page_number": 1111,
      "length": 589,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1722,
      "page_number": 1,
      "length": 939,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1723,
      "page_number": 1,
      "length": 857,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1724,
      "page_number": 1112,
      "length": 969,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "Implements"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1725,
      "page_number": 1112,
      "length": 217,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.434,
      "has_code_example": false
    },
    {
      "chunk_id": 1726,
      "page_number": 1,
      "length": 965,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "extends",
        "class",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 1727,
      "page_number": 1,
      "length": 760,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1728,
      "page_number": 1113,
      "length": 984,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "synchronized",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1729,
      "page_number": 1113,
      "length": 616,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1730,
      "page_number": 1,
      "length": 937,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1731,
      "page_number": 1,
      "length": 345,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "implements"
      ],
      "code_patterns": [
        "class implements"
      ],
      "quality_score": 1.0899999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1732,
      "page_number": 1,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1733,
      "page_number": 1114,
      "length": 545,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1734,
      "page_number": 1117,
      "length": 869,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "class",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1735,
      "page_number": 1,
      "length": 771,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1736,
      "page_number": 1118,
      "length": 585,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1737,
      "page_number": 1120,
      "length": 928,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1738,
      "page_number": 1,
      "length": 212,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.424,
      "has_code_example": false
    },
    {
      "chunk_id": 1739,
      "page_number": 1,
      "length": 993,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1740,
      "page_number": 1121,
      "length": 612,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1741,
      "page_number": 1122,
      "length": 927,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1742,
      "page_number": 1,
      "length": 562,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1743,
      "page_number": 1,
      "length": 878,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1744,
      "page_number": 1124,
      "length": 908,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1745,
      "page_number": 1,
      "length": 688,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1746,
      "page_number": 1126,
      "length": 667,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1747,
      "page_number": 1127,
      "length": 958,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1748,
      "page_number": 1127,
      "length": 539,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "synchronized"
      ],
      "code_patterns": [
        "class fills"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1749,
      "page_number": 1,
      "length": 910,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "final"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1750,
      "page_number": 1,
      "length": 612,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1751,
      "page_number": 1,
      "length": 912,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1752,
      "page_number": 1,
      "length": 420,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.84,
      "has_code_example": false
    },
    {
      "chunk_id": 1753,
      "page_number": 1130,
      "length": 413,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.826,
      "has_code_example": false
    },
    {
      "chunk_id": 1754,
      "page_number": 1130,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1755,
      "page_number": 1131,
      "length": 692,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1756,
      "page_number": 1133,
      "length": 985,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1757,
      "page_number": 1,
      "length": 988,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1758,
      "page_number": 1,
      "length": 384,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.768,
      "has_code_example": false
    },
    {
      "chunk_id": 1759,
      "page_number": 1134,
      "length": 862,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "synchronized",
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1760,
      "page_number": 1,
      "length": 635,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1761,
      "page_number": 1,
      "length": 392,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "extends"
      ],
      "code_patterns": [
        "class called"
      ],
      "quality_score": 1.184,
      "has_code_example": true
    },
    {
      "chunk_id": 1762,
      "page_number": 1135,
      "length": 720,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1763,
      "page_number": 1138,
      "length": 913,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class to"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1764,
      "page_number": 1,
      "length": 938,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1765,
      "page_number": 1,
      "length": 241,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.482,
      "has_code_example": false
    },
    {
      "chunk_id": 1766,
      "page_number": 1,
      "length": 973,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "extends",
        "interface",
        "extends"
      ],
      "code_patterns": [
        "interface extends",
        "interface ScheduledExecutorService"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1767,
      "page_number": 1139,
      "length": 826,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "implements",
        "implements",
        "interface",
        "implements"
      ],
      "code_patterns": [
        "interface to"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1768,
      "page_number": 1,
      "length": 405,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.01,
      "has_code_example": false
    },
    {
      "chunk_id": 1769,
      "page_number": 1,
      "length": 922,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1770,
      "page_number": 1140,
      "length": 620,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1771,
      "page_number": 1,
      "length": 878,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface represents",
        "interface that",
        "interface Callable"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1772,
      "page_number": 1142,
      "length": 965,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface that",
        "interface Future"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1773,
      "page_number": 1143,
      "length": 821,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface Future"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1774,
      "page_number": 1143,
      "length": 815,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1775,
      "page_number": 1146,
      "length": 833,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1776,
      "page_number": 1,
      "length": 730,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1777,
      "page_number": 1,
      "length": 777,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1778,
      "page_number": 1147,
      "length": 843,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1779,
      "page_number": 1,
      "length": 942,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1780,
      "page_number": 1,
      "length": 929,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1781,
      "page_number": 1,
      "length": 229,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.458,
      "has_code_example": false
    },
    {
      "chunk_id": 1782,
      "page_number": 1148,
      "length": 725,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1783,
      "page_number": 1149,
      "length": 770,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface \nspecifies"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1784,
      "page_number": 1,
      "length": 757,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1785,
      "page_number": 1151,
      "length": 927,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "synchronized",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1786,
      "page_number": 1152,
      "length": 117,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.234,
      "has_code_example": false
    },
    {
      "chunk_id": 1787,
      "page_number": 1,
      "length": 958,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "package"
      ],
      "code_patterns": [
        "class library"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1788,
      "page_number": 1,
      "length": 955,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "package"
      ],
      "code_patterns": [
        "class library"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1789,
      "page_number": 1,
      "length": 994,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1790,
      "page_number": 1153,
      "length": 866,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "abstract",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class of",
        "class of"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 1791,
      "page_number": 1,
      "length": 789,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "abstract",
        "class",
        "abstract",
        "class",
        "class",
        "extends",
        "abstract",
        "class"
      ],
      "code_patterns": [
        "class of",
        "class of",
        "class that",
        "class will",
        "class CountedCompleter",
        "class that"
      ],
      "quality_score": 3.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1792,
      "page_number": 1,
      "length": 706,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "abstract",
        "class",
        "final",
        "final"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1793,
      "page_number": 1,
      "length": 379,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 0.958,
      "has_code_example": false
    },
    {
      "chunk_id": 1794,
      "page_number": 1154,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1795,
      "page_number": 1,
      "length": 576,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1796,
      "page_number": 1,
      "length": 991,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "abstract",
        "class",
        "protected",
        "abstract",
        "protected",
        "abstract",
        "abstract"
      ],
      "code_patterns": [
        "class of",
        "class encapsulates",
        "class is"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 1797,
      "page_number": 1155,
      "length": 697,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "abstract",
        "class",
        "protected",
        "abstract"
      ],
      "code_patterns": [
        "class of",
        "class encapsulates"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1798,
      "page_number": 1,
      "length": 399,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "protected",
        "abstract",
        "protected",
        "abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.198,
      "has_code_example": false
    },
    {
      "chunk_id": 1799,
      "page_number": 1,
      "length": 743,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1800,
      "page_number": 1,
      "length": 726,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1801,
      "page_number": 1156,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1802,
      "page_number": 1,
      "length": 643,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1803,
      "page_number": 1,
      "length": 951,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1804,
      "page_number": 1,
      "length": 558,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1805,
      "page_number": 1157,
      "length": 307,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.614,
      "has_code_example": false
    },
    {
      "chunk_id": 1806,
      "page_number": 1,
      "length": 891,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1807,
      "page_number": 1,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1808,
      "page_number": 1,
      "length": 958,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1809,
      "page_number": 1,
      "length": 460,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.92,
      "has_code_example": false
    },
    {
      "chunk_id": 1810,
      "page_number": 1158,
      "length": 727,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 1811,
      "page_number": 1,
      "length": 938,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "extends",
        "extends",
        "final"
      ],
      "code_patterns": [
        "class \nthat"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1812,
      "page_number": 1,
      "length": 384,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.768,
      "has_code_example": false
    },
    {
      "chunk_id": 1813,
      "page_number": 1161,
      "length": 654,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1814,
      "page_number": 1,
      "length": 698,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1815,
      "page_number": 1,
      "length": 711,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1816,
      "page_number": 1162,
      "length": 759,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1817,
      "page_number": 1162,
      "length": 849,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1818,
      "page_number": 1165,
      "length": 657,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1819,
      "page_number": 1,
      "length": 651,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1820,
      "page_number": 1,
      "length": 959,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1821,
      "page_number": 1166,
      "length": 688,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1822,
      "page_number": 1,
      "length": 621,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1823,
      "page_number": 1,
      "length": 849,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1824,
      "page_number": 1169,
      "length": 712,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1825,
      "page_number": 1169,
      "length": 779,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1826,
      "page_number": 1,
      "length": 877,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1827,
      "page_number": 1,
      "length": 782,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1828,
      "page_number": 1170,
      "length": 593,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1829,
      "page_number": 1,
      "length": 877,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1830,
      "page_number": 1,
      "length": 832,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1831,
      "page_number": 1171,
      "length": 760,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "final",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1832,
      "page_number": 1171,
      "length": 745,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "class"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1833,
      "page_number": 1,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1834,
      "page_number": 1,
      "length": 484,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.968,
      "has_code_example": false
    },
    {
      "chunk_id": 1835,
      "page_number": 1172,
      "length": 898,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "synchronized",
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1836,
      "page_number": 1,
      "length": 499,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.998,
      "has_code_example": false
    },
    {
      "chunk_id": 1837,
      "page_number": 1173,
      "length": 954,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "synchronized"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1838,
      "page_number": 1173,
      "length": 206,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.412,
      "has_code_example": false
    },
    {
      "chunk_id": 1839,
      "page_number": 1,
      "length": 955,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1840,
      "page_number": 1,
      "length": 641,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1841,
      "page_number": 1,
      "length": 663,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1842,
      "page_number": 1174,
      "length": 735,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "extends"
      ],
      "code_patterns": [
        "interface declared",
        "interface BaseStream"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1843,
      "page_number": 1175,
      "length": 808,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "extends",
        "extends",
        "extends",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface BaseStream",
        "interface Stream"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1844,
      "page_number": 1175,
      "length": 490,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface Stream",
        "interface adds"
      ],
      "quality_score": 1.58,
      "has_code_example": true
    },
    {
      "chunk_id": 1845,
      "page_number": 1,
      "length": 950,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1846,
      "page_number": 1,
      "length": 804,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1847,
      "page_number": 1,
      "length": 552,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1848,
      "page_number": 1177,
      "length": 937,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface has"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1849,
      "page_number": 1177,
      "length": 949,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "static",
        "class",
        "static"
      ],
      "code_patterns": [
        "class by"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1850,
      "page_number": 1,
      "length": 673,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1851,
      "page_number": 1178,
      "length": 556,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1852,
      "page_number": 1179,
      "length": 864,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface now"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1853,
      "page_number": 1,
      "length": 810,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class packaged",
        "class Optional"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 1854,
      "page_number": 1,
      "length": 600,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Optional"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1855,
      "page_number": 1180,
      "length": 734,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1856,
      "page_number": 1,
      "length": 972,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "interface declared"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1857,
      "page_number": 1181,
      "length": 986,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "abstract",
        "implements"
      ],
      "code_patterns": [
        "interface defined"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1858,
      "page_number": 1,
      "length": 81,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.162,
      "has_code_example": false
    },
    {
      "chunk_id": 1859,
      "page_number": 1,
      "length": 993,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1860,
      "page_number": 1,
      "length": 897,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "extends",
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "interface declared"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1861,
      "page_number": 1182,
      "length": 854,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1862,
      "page_number": 1183,
      "length": 901,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1863,
      "page_number": 1183,
      "length": 960,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1864,
      "page_number": 1184,
      "length": 294,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.588,
      "has_code_example": false
    },
    {
      "chunk_id": 1865,
      "page_number": 1,
      "length": 963,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1866,
      "page_number": 1,
      "length": 707,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1867,
      "page_number": 1185,
      "length": 826,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1868,
      "page_number": 1185,
      "length": 973,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1869,
      "page_number": 1186,
      "length": 718,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1870,
      "page_number": 1,
      "length": 798,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1871,
      "page_number": 1,
      "length": 921,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1872,
      "page_number": 1187,
      "length": 638,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "extends",
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "interface declared"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1873,
      "page_number": 1187,
      "length": 611,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1874,
      "page_number": 1188,
      "length": 840,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1875,
      "page_number": 1188,
      "length": 917,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1876,
      "page_number": 1190,
      "length": 784,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "abstract",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1877,
      "page_number": 1190,
      "length": 934,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1878,
      "page_number": 1191,
      "length": 952,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "interface",
        "class",
        "class",
        "static"
      ],
      "code_patterns": [
        "interface is",
        "interface Collector",
        "class defines"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1879,
      "page_number": 1192,
      "length": 898,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1880,
      "page_number": 1194,
      "length": 625,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1881,
      "page_number": 1,
      "length": 971,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "interface declared",
        "interface defined"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 1882,
      "page_number": 1,
      "length": 906,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1883,
      "page_number": 1195,
      "length": 761,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1884,
      "page_number": 1,
      "length": 977,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface declared"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1885,
      "page_number": 1196,
      "length": 798,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface and"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1886,
      "page_number": 1197,
      "length": 569,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1887,
      "page_number": 1197,
      "length": 653,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1888,
      "page_number": 1198,
      "length": 915,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1889,
      "page_number": 1199,
      "length": 878,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1890,
      "page_number": 1200,
      "length": 978,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1891,
      "page_number": 1201,
      "length": 708,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1892,
      "page_number": 1,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1893,
      "page_number": 1,
      "length": 532,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1894,
      "page_number": 1202,
      "length": 262,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.524,
      "has_code_example": false
    },
    {
      "chunk_id": 1895,
      "page_number": 1202,
      "length": 833,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1896,
      "page_number": 1204,
      "length": 971,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "static",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class defines",
        "interface that"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1897,
      "page_number": 1,
      "length": 747,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class has"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1898,
      "page_number": 1205,
      "length": 943,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1899,
      "page_number": 1205,
      "length": 219,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.438,
      "has_code_example": false
    },
    {
      "chunk_id": 1900,
      "page_number": 1,
      "length": 978,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class is",
        "class between"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 1901,
      "page_number": 1,
      "length": 745,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class is",
        "class between",
        "class that"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1902,
      "page_number": 1206,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1903,
      "page_number": 1207,
      "length": 943,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1904,
      "page_number": 1208,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1905,
      "page_number": 1209,
      "length": 801,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1906,
      "page_number": 1210,
      "length": 797,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1907,
      "page_number": 1210,
      "length": 845,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1908,
      "page_number": 1212,
      "length": 851,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1909,
      "page_number": 1,
      "length": 714,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1910,
      "page_number": 1,
      "length": 742,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1911,
      "page_number": 1213,
      "length": 879,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "package",
        "Class",
        "class",
        "package",
        "class",
        "package"
      ],
      "code_patterns": [
        "class supports"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 1912,
      "page_number": 1213,
      "length": 926,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "Class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class java",
        "class object",
        "class object"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1913,
      "page_number": 1214,
      "length": 96,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.192,
      "has_code_example": false
    },
    {
      "chunk_id": 1914,
      "page_number": 1215,
      "length": 858,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "public",
        "class",
        "class",
        "Class",
        "class",
        "class",
        "class",
        "static",
        "public"
      ],
      "code_patterns": [
        "class A",
        "class A",
        "class provides"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1915,
      "page_number": 1,
      "length": 269,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "public",
        "public"
      ],
      "code_patterns": [],
      "quality_score": 0.8380000000000001,
      "has_code_example": false
    },
    {
      "chunk_id": 1916,
      "page_number": 1216,
      "length": 854,
      "chunk_type": "technical",
      "java_keywords_count": 12,
      "java_keywords": [
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "static",
        "PROTECTED",
        "PUBLIC",
        "PRIVATE",
        "STATIC",
        "FINAL"
      ],
      "code_patterns": [],
      "quality_score": 2.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1917,
      "page_number": 1,
      "length": 813,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1918,
      "page_number": 1,
      "length": 792,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "interface that",
        "interface uses"
      ],
      "quality_score": 1.9,
      "has_code_example": true
    },
    {
      "chunk_id": 1919,
      "page_number": 1219,
      "length": 761,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1920,
      "page_number": 1220,
      "length": 733,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1921,
      "page_number": 1,
      "length": 960,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1922,
      "page_number": 1,
      "length": 435,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.87,
      "has_code_example": false
    },
    {
      "chunk_id": 1923,
      "page_number": 1221,
      "length": 787,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class to",
        "class \n\n\nto",
        "class loading"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1924,
      "page_number": 1,
      "length": 807,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1925,
      "page_number": 1,
      "length": 819,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1926,
      "page_number": 1222,
      "length": 533,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1927,
      "page_number": 1,
      "length": 871,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "package",
        "Class",
        "abstract",
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 1928,
      "page_number": 1,
      "length": 716,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "static",
        "final",
        "static",
        "final",
        "static",
        "final",
        "static",
        "class",
        "final"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 1929,
      "page_number": 1223,
      "length": 749,
      "chunk_type": "technical",
      "java_keywords_count": 7,
      "java_keywords": [
        "final",
        "static",
        "final",
        "static",
        "final",
        "static",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.7000000000000002,
      "has_code_example": false
    },
    {
      "chunk_id": 1930,
      "page_number": 1224,
      "length": 964,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "static",
        "final",
        "static",
        "final",
        "static",
        "final",
        "static",
        "class"
      ],
      "code_patterns": [
        "class also"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 1931,
      "page_number": 1225,
      "length": 769,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "Class"
      ],
      "code_patterns": [
        "class also",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 1932,
      "page_number": 1225,
      "length": 918,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1933,
      "page_number": 1226,
      "length": 870,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1934,
      "page_number": 1227,
      "length": 807,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1935,
      "page_number": 1,
      "length": 932,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1936,
      "page_number": 1,
      "length": 550,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "public",
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 1937,
      "page_number": 1228,
      "length": 678,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "static",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 1938,
      "page_number": 1228,
      "length": 861,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1939,
      "page_number": 1229,
      "length": 712,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1940,
      "page_number": 1230,
      "length": 727,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1941,
      "page_number": 1230,
      "length": 583,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1942,
      "page_number": 1231,
      "length": 731,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1943,
      "page_number": 1231,
      "length": 974,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1944,
      "page_number": 1232,
      "length": 572,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1945,
      "page_number": 1232,
      "length": 745,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1946,
      "page_number": 1,
      "length": 815,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1947,
      "page_number": 1233,
      "length": 945,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1948,
      "page_number": 1234,
      "length": 585,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1949,
      "page_number": 1,
      "length": 938,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1950,
      "page_number": 1,
      "length": 503,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1951,
      "page_number": 1,
      "length": 715,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "Abstract",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1952,
      "page_number": 1236,
      "length": 923,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "native",
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1953,
      "page_number": 1,
      "length": 291,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.582,
      "has_code_example": false
    },
    {
      "chunk_id": 1954,
      "page_number": 1,
      "length": 983,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1955,
      "page_number": 1,
      "length": 845,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "native",
        "native"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1956,
      "page_number": 1237,
      "length": 908,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1957,
      "page_number": 1,
      "length": 882,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1958,
      "page_number": 1,
      "length": 267,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.534,
      "has_code_example": false
    },
    {
      "chunk_id": 1959,
      "page_number": 1,
      "length": 986,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1960,
      "page_number": 1,
      "length": 351,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.702,
      "has_code_example": false
    },
    {
      "chunk_id": 1961,
      "page_number": 1238,
      "length": 882,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1962,
      "page_number": 1,
      "length": 779,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1963,
      "page_number": 1,
      "length": 924,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1964,
      "page_number": 1239,
      "length": 866,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "package",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class names",
        "class for",
        "class for",
        "class for"
      ],
      "quality_score": 2.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 1965,
      "page_number": 1,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1966,
      "page_number": 1,
      "length": 371,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.742,
      "has_code_example": false
    },
    {
      "chunk_id": 1967,
      "page_number": 1,
      "length": 454,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.908,
      "has_code_example": false
    },
    {
      "chunk_id": 1968,
      "page_number": 1240,
      "length": 976,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1969,
      "page_number": 1,
      "length": 522,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1970,
      "page_number": 1,
      "length": 575,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 1971,
      "page_number": 1,
      "length": 738,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1972,
      "page_number": 1241,
      "length": 827,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1973,
      "page_number": 1242,
      "length": 948,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "package",
        "class",
        "class"
      ],
      "code_patterns": [
        "class and"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1974,
      "page_number": 1,
      "length": 547,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Component"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1975,
      "page_number": 1243,
      "length": 840,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1976,
      "page_number": 1,
      "length": 847,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface declared"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1977,
      "page_number": 1,
      "length": 512,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Container"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1978,
      "page_number": 1244,
      "length": 885,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Container"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1979,
      "page_number": 1244,
      "length": 321,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.642,
      "has_code_example": false
    },
    {
      "chunk_id": 1980,
      "page_number": 1,
      "length": 703,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1981,
      "page_number": 1,
      "length": 780,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1982,
      "page_number": 1245,
      "length": 932,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1983,
      "page_number": 1,
      "length": 655,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1984,
      "page_number": 1,
      "length": 912,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1985,
      "page_number": 1,
      "length": 419,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.838,
      "has_code_example": false
    },
    {
      "chunk_id": 1986,
      "page_number": 1246,
      "length": 817,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "package",
        "class",
        "package",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface and"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 1987,
      "page_number": 1,
      "length": 669,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1988,
      "page_number": 1248,
      "length": 811,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1989,
      "page_number": 1,
      "length": 861,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1990,
      "page_number": 1,
      "length": 361,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.722,
      "has_code_example": false
    },
    {
      "chunk_id": 1991,
      "page_number": 1249,
      "length": 872,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1992,
      "page_number": 1,
      "length": 278,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.556,
      "has_code_example": false
    },
    {
      "chunk_id": 1993,
      "page_number": 1250,
      "length": 816,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 1994,
      "page_number": 1252,
      "length": 653,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1995,
      "page_number": 1,
      "length": 802,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1996,
      "page_number": 1,
      "length": 911,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class Component"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 1997,
      "page_number": 1,
      "length": 887,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 1998,
      "page_number": 1253,
      "length": 716,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "protected"
      ],
      "code_patterns": [
        "class of",
        "class portion"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 1999,
      "page_number": 1,
      "length": 871,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "protected"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2000,
      "page_number": 1,
      "length": 992,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2001,
      "page_number": 1254,
      "length": 791,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "extends",
        "class"
      ],
      "code_patterns": [
        "class called",
        "class to"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2002,
      "page_number": 1255,
      "length": 927,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "extends"
      ],
      "code_patterns": [
        "class extends"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2003,
      "page_number": 1,
      "length": 360,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "interface",
        "class",
        "static"
      ],
      "code_patterns": [
        "interface that"
      ],
      "quality_score": 1.22,
      "has_code_example": true
    },
    {
      "chunk_id": 2004,
      "page_number": 1,
      "length": 924,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class creates"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2005,
      "page_number": 1,
      "length": 261,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.522,
      "has_code_example": false
    },
    {
      "chunk_id": 2006,
      "page_number": 1258,
      "length": 981,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2007,
      "page_number": 1,
      "length": 946,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2008,
      "page_number": 1259,
      "length": 93,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.186,
      "has_code_example": false
    },
    {
      "chunk_id": 2009,
      "page_number": 1259,
      "length": 964,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "interface",
        "class",
        "implements"
      ],
      "code_patterns": [
        "interface defined"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 2010,
      "page_number": 1260,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2011,
      "page_number": 1260,
      "length": 955,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface for"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2012,
      "page_number": 1262,
      "length": 654,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2013,
      "page_number": 1262,
      "length": 833,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2014,
      "page_number": 1,
      "length": 971,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2015,
      "page_number": 1264,
      "length": 677,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2016,
      "page_number": 1265,
      "length": 777,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2017,
      "page_number": 1267,
      "length": 985,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "implements"
      ],
      "code_patterns": [
        "class for"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2018,
      "page_number": 1267,
      "length": 210,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.42,
      "has_code_example": false
    },
    {
      "chunk_id": 2019,
      "page_number": 1,
      "length": 939,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class called"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2020,
      "page_number": 1,
      "length": 333,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.666,
      "has_code_example": false
    },
    {
      "chunk_id": 2021,
      "page_number": 1268,
      "length": 883,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class provides",
        "class is"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2022,
      "page_number": 1,
      "length": 908,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2023,
      "page_number": 1,
      "length": 183,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.366,
      "has_code_example": false
    },
    {
      "chunk_id": 2024,
      "page_number": 1271,
      "length": 861,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2025,
      "page_number": 1273,
      "length": 175,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 0.44999999999999996,
      "has_code_example": false
    },
    {
      "chunk_id": 2026,
      "page_number": 1,
      "length": 965,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2027,
      "page_number": 1,
      "length": 875,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class or"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2028,
      "page_number": 1274,
      "length": 880,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2029,
      "page_number": 1276,
      "length": 959,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2030,
      "page_number": 1277,
      "length": 96,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.192,
      "has_code_example": false
    },
    {
      "chunk_id": 2031,
      "page_number": 1279,
      "length": 952,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2032,
      "page_number": 1,
      "length": 422,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.844,
      "has_code_example": false
    },
    {
      "chunk_id": 2033,
      "page_number": 1280,
      "length": 885,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2034,
      "page_number": 1280,
      "length": 707,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class JList"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2035,
      "page_number": 1,
      "length": 762,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class JList",
        "interface defines"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2036,
      "page_number": 1282,
      "length": 900,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2037,
      "page_number": 1,
      "length": 805,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2038,
      "page_number": 1283,
      "length": 842,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2039,
      "page_number": 1283,
      "length": 732,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class JComboBox"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2040,
      "page_number": 1,
      "length": 957,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class JComboBox"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2041,
      "page_number": 1286,
      "length": 779,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2042,
      "page_number": 1287,
      "length": 379,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 0.858,
      "has_code_example": false
    },
    {
      "chunk_id": 2043,
      "page_number": 1,
      "length": 940,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2044,
      "page_number": 1289,
      "length": 606,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2045,
      "page_number": 1289,
      "length": 940,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "extends",
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [
        "class encapsulates",
        "interface declares",
        "interface extends",
        "class implements"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2046,
      "page_number": 1,
      "length": 841,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2047,
      "page_number": 1,
      "length": 941,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2048,
      "page_number": 1290,
      "length": 250,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.5,
      "has_code_example": false
    },
    {
      "chunk_id": 2049,
      "page_number": 1,
      "length": 929,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2050,
      "page_number": 1,
      "length": 656,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2051,
      "page_number": 1,
      "length": 279,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.558,
      "has_code_example": false
    },
    {
      "chunk_id": 2052,
      "page_number": 1293,
      "length": 980,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2053,
      "page_number": 1,
      "length": 468,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.936,
      "has_code_example": false
    },
    {
      "chunk_id": 2054,
      "page_number": 1294,
      "length": 944,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2055,
      "page_number": 1294,
      "length": 912,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2056,
      "page_number": 1,
      "length": 673,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2057,
      "page_number": 1297,
      "length": 554,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2058,
      "page_number": 1,
      "length": 956,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2059,
      "page_number": 1,
      "length": 926,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "extends"
      ],
      "code_patterns": [
        "class that",
        "class of"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2060,
      "page_number": 1,
      "length": 473,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of",
        "class of"
      ],
      "quality_score": 1.346,
      "has_code_example": true
    },
    {
      "chunk_id": 2061,
      "page_number": 1,
      "length": 224,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.448,
      "has_code_example": false
    },
    {
      "chunk_id": 2062,
      "page_number": 1298,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2063,
      "page_number": 1,
      "length": 942,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2064,
      "page_number": 1299,
      "length": 948,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2065,
      "page_number": 1,
      "length": 783,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2066,
      "page_number": 1,
      "length": 730,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2067,
      "page_number": 1300,
      "length": 962,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2068,
      "page_number": 1300,
      "length": 968,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2069,
      "page_number": 1,
      "length": 986,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2070,
      "page_number": 1301,
      "length": 984,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2071,
      "page_number": 1,
      "length": 170,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.34,
      "has_code_example": false
    },
    {
      "chunk_id": 2072,
      "page_number": 1,
      "length": 935,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2073,
      "page_number": 1,
      "length": 679,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2074,
      "page_number": 1302,
      "length": 804,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2075,
      "page_number": 1,
      "length": 249,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.498,
      "has_code_example": false
    },
    {
      "chunk_id": 2076,
      "page_number": 1306,
      "length": 976,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "interface"
      ],
      "code_patterns": [
        "interface and"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2077,
      "page_number": 1,
      "length": 410,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.82,
      "has_code_example": false
    },
    {
      "chunk_id": 2078,
      "page_number": 1,
      "length": 802,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2079,
      "page_number": 1307,
      "length": 946,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2080,
      "page_number": 1,
      "length": 359,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.718,
      "has_code_example": false
    },
    {
      "chunk_id": 2081,
      "page_number": 1,
      "length": 973,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2082,
      "page_number": 1308,
      "length": 979,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "static",
        "static",
        "static",
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2083,
      "page_number": 1308,
      "length": 882,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2084,
      "page_number": 1309,
      "length": 873,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2085,
      "page_number": 1310,
      "length": 477,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.954,
      "has_code_example": false
    },
    {
      "chunk_id": 2086,
      "page_number": 1310,
      "length": 799,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2087,
      "page_number": 1,
      "length": 802,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2088,
      "page_number": 1311,
      "length": 836,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2089,
      "page_number": 1,
      "length": 841,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2090,
      "page_number": 1,
      "length": 488,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.976,
      "has_code_example": false
    },
    {
      "chunk_id": 2091,
      "page_number": 1,
      "length": 631,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2092,
      "page_number": 1312,
      "length": 666,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2093,
      "page_number": 1313,
      "length": 949,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2094,
      "page_number": 1,
      "length": 932,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface and"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2095,
      "page_number": 1,
      "length": 771,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface and",
        "class defines"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2096,
      "page_number": 1315,
      "length": 726,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2097,
      "page_number": 1,
      "length": 762,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2098,
      "page_number": 1316,
      "length": 939,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2099,
      "page_number": 1,
      "length": 503,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2100,
      "page_number": 1317,
      "length": 756,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2101,
      "page_number": 1,
      "length": 588,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2102,
      "page_number": 1318,
      "length": 855,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2103,
      "page_number": 1,
      "length": 942,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2104,
      "page_number": 1,
      "length": 999,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2105,
      "page_number": 1,
      "length": 503,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2106,
      "page_number": 1319,
      "length": 821,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2107,
      "page_number": 1320,
      "length": 976,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2108,
      "page_number": 1,
      "length": 814,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2109,
      "page_number": 1,
      "length": 614,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "extends"
      ],
      "code_patterns": [
        "interface and"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2110,
      "page_number": 1321,
      "length": 912,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2111,
      "page_number": 1322,
      "length": 850,
      "chunk_type": "technical",
      "java_keywords_count": 14,
      "java_keywords": [
        "static",
        "final",
        "static",
        "final",
        "static",
        "final",
        "static",
        "final",
        "static",
        "final",
        "static",
        "final",
        "static",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 2.4000000000000004,
      "has_code_example": false
    },
    {
      "chunk_id": 2112,
      "page_number": 1,
      "length": 818,
      "chunk_type": "technical",
      "java_keywords_count": 10,
      "java_keywords": [
        "static",
        "final",
        "static",
        "final",
        "static",
        "final",
        "static",
        "final",
        "static",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 2.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2113,
      "page_number": 1323,
      "length": 941,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface yourself"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2114,
      "page_number": 1,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2115,
      "page_number": 1324,
      "length": 923,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "extends",
        "extends",
        "class"
      ],
      "code_patterns": [
        "class called",
        "class that"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 2116,
      "page_number": 1,
      "length": 530,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2117,
      "page_number": 1325,
      "length": 765,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2118,
      "page_number": 1326,
      "length": 790,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2119,
      "page_number": 1327,
      "length": 447,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.894,
      "has_code_example": false
    },
    {
      "chunk_id": 2120,
      "page_number": 1327,
      "length": 908,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2121,
      "page_number": 1328,
      "length": 842,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2122,
      "page_number": 1335,
      "length": 681,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2123,
      "page_number": 1,
      "length": 913,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2124,
      "page_number": 1,
      "length": 981,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2125,
      "page_number": 1,
      "length": 218,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.436,
      "has_code_example": false
    },
    {
      "chunk_id": 2126,
      "page_number": 1338,
      "length": 591,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2127,
      "page_number": 1338,
      "length": 893,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2128,
      "page_number": 1,
      "length": 956,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2129,
      "page_number": 1,
      "length": 213,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.426,
      "has_code_example": false
    },
    {
      "chunk_id": 2130,
      "page_number": 1,
      "length": 690,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2131,
      "page_number": 1339,
      "length": 958,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2132,
      "page_number": 1,
      "length": 240,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.48,
      "has_code_example": false
    },
    {
      "chunk_id": 2133,
      "page_number": 1,
      "length": 984,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class for"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2134,
      "page_number": 1340,
      "length": 889,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "class",
        "Class",
        "class",
        "class",
        "class",
        "abstract"
      ],
      "code_patterns": [
        "class provides",
        "class \nsupports",
        "class of",
        "class will",
        "class defines"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2135,
      "page_number": 1,
      "length": 984,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "abstract"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2136,
      "page_number": 1,
      "length": 241,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "public",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 0.6819999999999999,
      "has_code_example": false
    },
    {
      "chunk_id": 2137,
      "page_number": 1,
      "length": 978,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "public",
        "static",
        "class",
        "class"
      ],
      "code_patterns": [
        "class of",
        "class other",
        "class to"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 2138,
      "page_number": 1341,
      "length": 741,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2139,
      "page_number": 1,
      "length": 998,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "class",
        "class",
        "package",
        "class",
        "extends",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class JavaFXSkel",
        "class from"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 2140,
      "page_number": 1,
      "length": 982,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "class"
      ],
      "code_patterns": [
        "class from"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2141,
      "page_number": 1,
      "length": 484,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.968,
      "has_code_example": false
    },
    {
      "chunk_id": 2142,
      "page_number": 1344,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2143,
      "page_number": 1,
      "length": 862,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class used"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2144,
      "page_number": 1345,
      "length": 814,
      "chunk_type": "code",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2145,
      "page_number": 1345,
      "length": 763,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2146,
      "page_number": 1,
      "length": 974,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2147,
      "page_number": 1,
      "length": 393,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.786,
      "has_code_example": false
    },
    {
      "chunk_id": 2148,
      "page_number": 1346,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2149,
      "page_number": 1346,
      "length": 941,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class defines"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2150,
      "page_number": 1347,
      "length": 932,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2151,
      "page_number": 1347,
      "length": 679,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2152,
      "page_number": 1,
      "length": 988,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2153,
      "page_number": 1349,
      "length": 933,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "interface",
        "interface",
        "extends"
      ],
      "code_patterns": [
        "class for",
        "interface with",
        "interface EventHandler"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2154,
      "page_number": 1,
      "length": 944,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "extends"
      ],
      "code_patterns": [
        "interface EventHandler"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2155,
      "page_number": 1,
      "length": 940,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2156,
      "page_number": 1350,
      "length": 385,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.77,
      "has_code_example": false
    },
    {
      "chunk_id": 2157,
      "page_number": 1,
      "length": 742,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2158,
      "page_number": 1,
      "length": 915,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "class"
      ],
      "code_patterns": [
        "class or"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2159,
      "page_number": 1351,
      "length": 598,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2160,
      "page_number": 1,
      "length": 895,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class to"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2161,
      "page_number": 1354,
      "length": 933,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2162,
      "page_number": 1,
      "length": 808,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "abstract"
      ],
      "code_patterns": [
        "interface defines"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2163,
      "page_number": 1,
      "length": 829,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2164,
      "page_number": 1,
      "length": 761,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2165,
      "page_number": 1355,
      "length": 908,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class in",
        "class is"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2166,
      "page_number": 1,
      "length": 815,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2167,
      "page_number": 1,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2168,
      "page_number": 1356,
      "length": 693,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2169,
      "page_number": 1,
      "length": 780,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2170,
      "page_number": 1357,
      "length": 963,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "abstract",
        "class",
        "static"
      ],
      "code_patterns": [
        "class packaged"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2171,
      "page_number": 1357,
      "length": 932,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2172,
      "page_number": 1360,
      "length": 952,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2173,
      "page_number": 1,
      "length": 925,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class loads"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2174,
      "page_number": 1362,
      "length": 929,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class loads"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2175,
      "page_number": 1363,
      "length": 910,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2176,
      "page_number": 1365,
      "length": 944,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class encapsulates"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2177,
      "page_number": 1366,
      "length": 819,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2178,
      "page_number": 1368,
      "length": 610,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2179,
      "page_number": 1,
      "length": 676,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "class",
        "class"
      ],
      "code_patterns": [
        "class for"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2180,
      "page_number": 1369,
      "length": 907,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2181,
      "page_number": 1371,
      "length": 874,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 2182,
      "page_number": 1372,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2183,
      "page_number": 1,
      "length": 698,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2184,
      "page_number": 1374,
      "length": 665,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "extends",
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 2185,
      "page_number": 1374,
      "length": 892,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2186,
      "page_number": 1,
      "length": 867,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "final"
      ],
      "code_patterns": [
        "class of"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2187,
      "page_number": 1375,
      "length": 928,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2188,
      "page_number": 1378,
      "length": 926,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "import"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2189,
      "page_number": 1,
      "length": 788,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "import",
        "interface",
        "interface",
        "interface",
        "extends"
      ],
      "code_patterns": [
        "interface \ndefines"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2190,
      "page_number": 1379,
      "length": 834,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "extends"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2191,
      "page_number": 1380,
      "length": 957,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2192,
      "page_number": 1,
      "length": 882,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "class"
      ],
      "code_patterns": [
        "class creates"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2193,
      "page_number": 1383,
      "length": 890,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class encapsulates",
        "class \nis"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2194,
      "page_number": 1383,
      "length": 713,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2195,
      "page_number": 1384,
      "length": 859,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "implements",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 2196,
      "page_number": 1387,
      "length": 695,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2197,
      "page_number": 1,
      "length": 837,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class ListView"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2198,
      "page_number": 1388,
      "length": 674,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "class",
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 2199,
      "page_number": 1,
      "length": 866,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 2200,
      "page_number": 1,
      "length": 775,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2201,
      "page_number": 1389,
      "length": 931,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "class",
        "final"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2202,
      "page_number": 1389,
      "length": 731,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2203,
      "page_number": 1392,
      "length": 705,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2204,
      "page_number": 1,
      "length": 623,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2205,
      "page_number": 1393,
      "length": 762,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "extends",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2206,
      "page_number": 1,
      "length": 885,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class ComboBox"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2207,
      "page_number": 1394,
      "length": 982,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "class",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 2208,
      "page_number": 1395,
      "length": 664,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2209,
      "page_number": 1397,
      "length": 577,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2210,
      "page_number": 1,
      "length": 945,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2211,
      "page_number": 1,
      "length": 261,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.522,
      "has_code_example": false
    },
    {
      "chunk_id": 2212,
      "page_number": 1,
      "length": 935,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2213,
      "page_number": 1398,
      "length": 896,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2214,
      "page_number": 1400,
      "length": 903,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2215,
      "page_number": 1,
      "length": 555,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2216,
      "page_number": 1,
      "length": 776,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2217,
      "page_number": 1401,
      "length": 870,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "final",
        "final",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 2218,
      "page_number": 1402,
      "length": 839,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2219,
      "page_number": 1404,
      "length": 827,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "implements"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2220,
      "page_number": 1,
      "length": 915,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2221,
      "page_number": 1,
      "length": 693,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class TreeView",
        "class TreeItem"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2222,
      "page_number": 1,
      "length": 676,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class TreeItem"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2223,
      "page_number": 1405,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2224,
      "page_number": 1,
      "length": 401,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.802,
      "has_code_example": false
    },
    {
      "chunk_id": 2225,
      "page_number": 1406,
      "length": 830,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2226,
      "page_number": 1,
      "length": 234,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.468,
      "has_code_example": false
    },
    {
      "chunk_id": 2227,
      "page_number": 1410,
      "length": 900,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2228,
      "page_number": 1,
      "length": 976,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "abstract",
        "class"
      ],
      "code_patterns": [
        "class and"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2229,
      "page_number": 1411,
      "length": 660,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2230,
      "page_number": 1,
      "length": 801,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2231,
      "page_number": 1,
      "length": 936,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2232,
      "page_number": 1412,
      "length": 758,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "abstract",
        "class",
        "class",
        "final"
      ],
      "code_patterns": [
        "class is",
        "class as"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 2233,
      "page_number": 1,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2234,
      "page_number": 1,
      "length": 913,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 2235,
      "page_number": 1413,
      "length": 949,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "final",
        "final",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 2236,
      "page_number": 1414,
      "length": 840,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2237,
      "page_number": 1414,
      "length": 927,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class packaged",
        "class for"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2238,
      "page_number": 1,
      "length": 945,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "class",
        "final"
      ],
      "code_patterns": [
        "class encapsulates"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2239,
      "page_number": 1417,
      "length": 431,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 0.962,
      "has_code_example": false
    },
    {
      "chunk_id": 2240,
      "page_number": 1418,
      "length": 970,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2241,
      "page_number": 1,
      "length": 680,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2242,
      "page_number": 1419,
      "length": 454,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.908,
      "has_code_example": false
    },
    {
      "chunk_id": 2243,
      "page_number": 1,
      "length": 966,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class that",
        "class that"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 2244,
      "page_number": 1,
      "length": 992,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "extends"
      ],
      "code_patterns": [
        "class that",
        "class that",
        "class of"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 2245,
      "page_number": 1,
      "length": 268,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.536,
      "has_code_example": false
    },
    {
      "chunk_id": 2246,
      "page_number": 1,
      "length": 458,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.916,
      "has_code_example": false
    },
    {
      "chunk_id": 2247,
      "page_number": 1420,
      "length": 726,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2248,
      "page_number": 1,
      "length": 366,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.732,
      "has_code_example": false
    },
    {
      "chunk_id": 2249,
      "page_number": 1,
      "length": 735,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2250,
      "page_number": 1,
      "length": 887,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2251,
      "page_number": 1421,
      "length": 891,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "implements",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2252,
      "page_number": 1,
      "length": 760,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2253,
      "page_number": 1422,
      "length": 934,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2254,
      "page_number": 1,
      "length": 902,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2255,
      "page_number": 1,
      "length": 956,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2256,
      "page_number": 1423,
      "length": 950,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2257,
      "page_number": 1,
      "length": 236,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.472,
      "has_code_example": false
    },
    {
      "chunk_id": 2258,
      "page_number": 1424,
      "length": 896,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "final",
        "final",
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 2259,
      "page_number": 1427,
      "length": 811,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2260,
      "page_number": 1,
      "length": 989,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2261,
      "page_number": 1428,
      "length": 542,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2262,
      "page_number": 1,
      "length": 997,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2263,
      "page_number": 1429,
      "length": 415,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.83,
      "has_code_example": false
    },
    {
      "chunk_id": 2264,
      "page_number": 1,
      "length": 959,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "final",
        "class"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2265,
      "page_number": 1,
      "length": 941,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "protected",
        "static"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2266,
      "page_number": 1430,
      "length": 964,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2267,
      "page_number": 1431,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2268,
      "page_number": 1,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2269,
      "page_number": 1432,
      "length": 813,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2270,
      "page_number": 1,
      "length": 973,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2271,
      "page_number": 1433,
      "length": 771,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class of",
        "class of"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2272,
      "page_number": 1435,
      "length": 836,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2273,
      "page_number": 1436,
      "length": 945,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2274,
      "page_number": 1436,
      "length": 910,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2275,
      "page_number": 1,
      "length": 796,
      "chunk_type": "text",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "final",
        "final"
      ],
      "code_patterns": [],
      "quality_score": 1.3,
      "has_code_example": false
    },
    {
      "chunk_id": 2276,
      "page_number": 1438,
      "length": 785,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "final",
        "final",
        "final",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.4,
      "has_code_example": false
    },
    {
      "chunk_id": 2277,
      "page_number": 1,
      "length": 750,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2278,
      "page_number": 1439,
      "length": 366,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "final"
      ],
      "code_patterns": [],
      "quality_score": 0.832,
      "has_code_example": false
    },
    {
      "chunk_id": 2279,
      "page_number": 1,
      "length": 985,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2280,
      "page_number": 1,
      "length": 547,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2281,
      "page_number": 1440,
      "length": 903,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2282,
      "page_number": 1441,
      "length": 357,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.714,
      "has_code_example": false
    },
    {
      "chunk_id": 2283,
      "page_number": 1441,
      "length": 972,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2284,
      "page_number": 1442,
      "length": 885,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class is"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2285,
      "page_number": 1448,
      "length": 493,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.986,
      "has_code_example": false
    },
    {
      "chunk_id": 2286,
      "page_number": 1,
      "length": 936,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2287,
      "page_number": 1,
      "length": 774,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2288,
      "page_number": 1,
      "length": 937,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2289,
      "page_number": 1451,
      "length": 974,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2290,
      "page_number": 1,
      "length": 942,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "extends",
        "interface"
      ],
      "code_patterns": [
        "class that",
        "interface is"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2291,
      "page_number": 1452,
      "length": 891,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "public",
        "public"
      ],
      "code_patterns": [
        "public T getN (",
        "public void setN ("
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2292,
      "page_number": 1453,
      "length": 764,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "public",
        "public",
        "public",
        "public"
      ],
      "code_patterns": [
        "public T getN (",
        "public void setN (",
        "public void setN ("
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 2293,
      "page_number": 1454,
      "length": 860,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "public",
        "Protected",
        "private",
        "Interface"
      ],
      "code_patterns": [
        "interface type"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2294,
      "page_number": 1454,
      "length": 471,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface enables",
        "interface defines"
      ],
      "quality_score": 1.642,
      "has_code_example": true
    },
    {
      "chunk_id": 2295,
      "page_number": 1,
      "length": 958,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "package",
        "class",
        "implements",
        "class",
        "class",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class that",
        "class bname",
        "class must",
        "class and"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2296,
      "page_number": 1,
      "length": 395,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class and"
      ],
      "quality_score": 1.09,
      "has_code_example": true
    },
    {
      "chunk_id": 2297,
      "page_number": 1,
      "length": 909,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class that",
        "class that"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 2298,
      "page_number": 1455,
      "length": 923,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "implements",
        "transient",
        "transient"
      ],
      "code_patterns": [
        "class libraries",
        "class of"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 2299,
      "page_number": 1,
      "length": 294,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "transient"
      ],
      "code_patterns": [],
      "quality_score": 0.688,
      "has_code_example": false
    },
    {
      "chunk_id": 2300,
      "page_number": 1456,
      "length": 924,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2301,
      "page_number": 1457,
      "length": 755,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "static",
        "static",
        "Class"
      ],
      "code_patterns": [
        "class provides"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 2302,
      "page_number": 1,
      "length": 554,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "static",
        "Class",
        "class"
      ],
      "code_patterns": [
        "class describes"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2303,
      "page_number": 1,
      "length": 825,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class represents",
        "class represents"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2304,
      "page_number": 1458,
      "length": 951,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "private",
        "private",
        "class",
        "extends"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2305,
      "page_number": 1460,
      "length": 973,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "final",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class of",
        "class of",
        "class is"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2306,
      "page_number": 1461,
      "length": 975,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "final",
        "class",
        "class"
      ],
      "code_patterns": [
        "class is",
        "class \nfile"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2307,
      "page_number": 1463,
      "length": 689,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2308,
      "page_number": 1,
      "length": 953,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "static"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2309,
      "page_number": 1,
      "length": 567,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2310,
      "page_number": 1,
      "length": 547,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "Interface"
      ],
      "code_patterns": [
        "interface known"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2311,
      "page_number": 1464,
      "length": 968,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class libraries"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2312,
      "page_number": 1,
      "length": 980,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2313,
      "page_number": 1,
      "length": 973,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2314,
      "page_number": 1,
      "length": 385,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.77,
      "has_code_example": false
    },
    {
      "chunk_id": 2315,
      "page_number": 1465,
      "length": 837,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2316,
      "page_number": 1,
      "length": 781,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2317,
      "page_number": 1,
      "length": 974,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class libraries"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2318,
      "page_number": 1466,
      "length": 887,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2319,
      "page_number": 1,
      "length": 900,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class file"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2320,
      "page_number": 1467,
      "length": 979,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \nfile"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2321,
      "page_number": 1468,
      "length": 928,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "package",
        "package",
        "class"
      ],
      "code_patterns": [
        "class of",
        "class provides"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2322,
      "page_number": 1,
      "length": 833,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class file"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2323,
      "page_number": 1469,
      "length": 489,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.978,
      "has_code_example": false
    },
    {
      "chunk_id": 2324,
      "page_number": 1,
      "length": 857,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "Package"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2325,
      "page_number": 1470,
      "length": 941,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "Package",
        "package",
        "package",
        "interface",
        "class",
        "implements",
        "interface",
        "Interface",
        "package",
        "Class"
      ],
      "code_patterns": [
        "interface or",
        "class that"
      ],
      "quality_score": 2.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2326,
      "page_number": 1470,
      "length": 960,
      "chunk_type": "technical",
      "java_keywords_count": 5,
      "java_keywords": [
        "package",
        "Class",
        "Implements",
        "Interface",
        "interface"
      ],
      "code_patterns": [],
      "quality_score": 1.5,
      "has_code_example": false
    },
    {
      "chunk_id": 2327,
      "page_number": 1471,
      "length": 972,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface allows",
        "interface are"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2328,
      "page_number": 1472,
      "length": 961,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "Interface",
        "interface",
        "Interface",
        "interface",
        "Interface",
        "interface"
      ],
      "code_patterns": [
        "interface enables",
        "interface enables",
        "interface enables"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2329,
      "page_number": 1473,
      "length": 947,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "Class",
        "class",
        "implements",
        "Class",
        "class",
        "extends"
      ],
      "code_patterns": [
        "class provides",
        "class extends"
      ],
      "quality_score": 2.0,
      "has_code_example": true
    },
    {
      "chunk_id": 2330,
      "page_number": 1,
      "length": 944,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "Class",
        "class",
        "extends",
        "extends"
      ],
      "code_patterns": [
        "class extends"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 2331,
      "page_number": 1,
      "length": 730,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "interface"
      ],
      "code_patterns": [
        "interface includes"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2332,
      "page_number": 1474,
      "length": 966,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2333,
      "page_number": 1476,
      "length": 901,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "Package",
        "Interface"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2334,
      "page_number": 1477,
      "length": 859,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "Class",
        "Interface",
        "interface",
        "Interface",
        "interface"
      ],
      "code_patterns": [
        "class in",
        "interface enables",
        "interface enables"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2335,
      "page_number": 1477,
      "length": 963,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "Interface",
        "interface",
        "interface",
        "Interface",
        "interface",
        "Class"
      ],
      "code_patterns": [
        "interface enables",
        "interface are",
        "interface enables"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2336,
      "page_number": 1479,
      "length": 943,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "Class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class encapsulates"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2337,
      "page_number": 1480,
      "length": 905,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "Class"
      ],
      "code_patterns": [
        "class are"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2338,
      "page_number": 1480,
      "length": 917,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "Class",
        "class",
        "extends",
        "class",
        "class"
      ],
      "code_patterns": [
        "class extends",
        "class are",
        "class provides"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 2339,
      "page_number": 1482,
      "length": 879,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2340,
      "page_number": 1,
      "length": 947,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2341,
      "page_number": 1483,
      "length": 975,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2342,
      "page_number": 1484,
      "length": 843,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2343,
      "page_number": 1,
      "length": 798,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2344,
      "page_number": 1485,
      "length": 859,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2345,
      "page_number": 1487,
      "length": 567,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2346,
      "page_number": 1,
      "length": 952,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2347,
      "page_number": 1,
      "length": 475,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.95,
      "has_code_example": false
    },
    {
      "chunk_id": 2348,
      "page_number": 1488,
      "length": 494,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 0.988,
      "has_code_example": false
    },
    {
      "chunk_id": 2349,
      "page_number": 1489,
      "length": 938,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2350,
      "page_number": 1490,
      "length": 905,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2351,
      "page_number": 1490,
      "length": 548,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "static",
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2352,
      "page_number": 1,
      "length": 987,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 1.1,
      "has_code_example": false
    },
    {
      "chunk_id": 2353,
      "page_number": 1491,
      "length": 828,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "package",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class or"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2354,
      "page_number": 1491,
      "length": 826,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2355,
      "page_number": 1,
      "length": 888,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class or"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2356,
      "page_number": 1492,
      "length": 879,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class or"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2357,
      "page_number": 1,
      "length": 420,
      "chunk_type": "text",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [],
      "quality_score": 0.94,
      "has_code_example": false
    },
    {
      "chunk_id": 2358,
      "page_number": 1,
      "length": 967,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "class",
        "package",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface in"
      ],
      "quality_score": 1.8,
      "has_code_example": true
    },
    {
      "chunk_id": 2359,
      "page_number": 1493,
      "length": 965,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "implements"
      ],
      "code_patterns": [
        "class that"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2360,
      "page_number": 1,
      "length": 946,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "static",
        "static",
        "class",
        "class",
        "static",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class or"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 2361,
      "page_number": 1494,
      "length": 968,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class will"
      ],
      "quality_score": 1.5999999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 2362,
      "page_number": 1495,
      "length": 921,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "import",
        "annotation",
        "class"
      ],
      "code_patterns": [
        "class will",
        "class specification"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 2363,
      "page_number": 1498,
      "length": 790,
      "chunk_type": "text",
      "java_keywords_count": 2,
      "java_keywords": [
        "import",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 1.2,
      "has_code_example": false
    },
    {
      "chunk_id": 2364,
      "page_number": 1499,
      "length": 791,
      "chunk_type": "code",
      "java_keywords_count": 12,
      "java_keywords": [
        "Abstract",
        "abstract",
        "Abstract",
        "Abstract",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface \nAbstractButton",
        "class \nAbstractCollection",
        "class \nAbstractList",
        "class \nAbstractMap",
        "class \nAbstractQueue",
        "class \nAbstractSequentialList",
        "class \nAbstractSet",
        "class \naccept"
      ],
      "quality_score": 3.8000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 2365,
      "page_number": 1500,
      "length": 790,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface \nActionEvent",
        "class \nJavaFX",
        "interface \nactionPerformed",
        "class \nAdjustmentListener",
        "interface \nadjustmentValueChanged",
        "class \nAlgorithms"
      ],
      "quality_score": 2.8000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 2366,
      "page_number": 1501,
      "length": 844,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "interface",
        "Annotation",
        "interface",
        "Annotation",
        "interface"
      ],
      "code_patterns": [
        "interface \nAnnotation",
        "interface \nAnnotation",
        "interface \nappendCodePoint"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 2367,
      "page_number": 1502,
      "length": 834,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "package",
        "interface",
        "interface",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nmethods",
        "interface \nmethods",
        "interface \nappletviewer",
        "class \nApplication",
        "class \nareFieldsSet",
        "class \nArray"
      ],
      "quality_score": 2.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2368,
      "page_number": 1503,
      "length": 854,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nArray",
        "class \narraycopy",
        "class \nArrayIndexOutOfBoundsException",
        "class \nexample",
        "class \nArrayStoreException"
      ],
      "quality_score": 2.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2369,
      "page_number": 1504,
      "length": 878,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "interface",
        "interface",
        "Abstract",
        "class"
      ],
      "code_patterns": [
        "class \nAtomicLong",
        "class \nAttributeView",
        "interface \nAudioClip",
        "interface \nAutoboxing",
        "interface \nAutomatic",
        "class \n\nB"
      ],
      "quality_score": 2.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2370,
      "page_number": 1505,
      "length": 868,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "class",
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \n\nB",
        "class \nBaseStream",
        "interface \nmethods",
        "class \nmethods",
        "interface \nBCP",
        "interface \nBeans",
        "interface \nBiFunction",
        "interface \nBinary",
        "interface \nbinarySearch",
        "class \nmethods",
        "class \n\nand"
      ],
      "quality_score": 4.300000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 2371,
      "page_number": 1506,
      "length": 946,
      "chunk_type": "code",
      "java_keywords_count": 17,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \n\nand",
        "interface \nBorderFactory",
        "class \nBorderLayout",
        "class \nexample",
        "class \nmethods",
        "class \nmethods",
        "class \nBufferedOutputStream",
        "class \nBufferedReader",
        "class \nBufferedWriter",
        "class \nBuffering",
        "class \nAWT",
        "class \nButtonGroup",
        "class \nButtonModel",
        "interface \nButtons",
        "class \nmethods",
        "class \n\n\nByteArrayOutputStream"
      ],
      "quality_score": 5.9,
      "has_code_example": true
    },
    {
      "chunk_id": 2372,
      "page_number": 1507,
      "length": 808,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \n\n\nByteArrayOutputStream",
        "class \n\nByteBuffer",
        "class \nget",
        "class \nconstants",
        "interface \nCallSite",
        "class \ncancel",
        "class \nAWT",
        "class \nCaretEvent",
        "class \nCase",
        "class into"
      ],
      "quality_score": 4.0,
      "has_code_example": true
    },
    {
      "chunk_id": 2373,
      "page_number": 1508,
      "length": 960,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "final",
        "Interface",
        "interface",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class into",
        "interface \nChannel",
        "interface \nChannel",
        "class \nand",
        "class \nCharacter",
        "class \ncharacteristics",
        "class \nCharArrayWriter",
        "class \ncharAt"
      ],
      "quality_score": 3.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2374,
      "page_number": 1509,
      "length": 795,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "Class",
        "class",
        "class",
        "class",
        "CLASS",
        "Class",
        "abstract"
      ],
      "code_patterns": [
        "class \nchars",
        "interface \nCharsets",
        "class \nAWT",
        "class \nCheckboxMenuItem",
        "class \nchecked",
        "class \nChoice",
        "class \nChoice",
        "class \nmethods",
        "class filename",
        "class keyword"
      ],
      "quality_score": 4.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2375,
      "page_number": 1510,
      "length": 803,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "final",
        "class",
        "class",
        "public",
        "class",
        "interface",
        "class",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class \ninner",
        "class \nname",
        "class \nClassFileTransformer",
        "interface \nClassLoader",
        "class \nclassModifiers",
        "class \nclear",
        "interface \nCloneNotSupportedException",
        "interface \nClosures"
      ],
      "quality_score": 3.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2376,
      "page_number": 1511,
      "length": 894,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "static",
        "synchronized",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface \nmethods",
        "class \nalgorithms"
      ],
      "quality_score": 1.7999999999999998,
      "has_code_example": true
    },
    {
      "chunk_id": 2377,
      "page_number": 1512,
      "length": 880,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class \nalgorithms",
        "interface \nCollectors",
        "class \nColor",
        "class \nComboBoxBase",
        "class \nComboBoxModel",
        "interface \nComment",
        "interface \nComparable",
        "interface \nComparator",
        "interface \ncomparator",
        "class \nCompiler"
      ],
      "quality_score": 4.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2378,
      "page_number": 1513,
      "length": 902,
      "chunk_type": "code",
      "java_keywords_count": 12,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nCompiler",
        "class \nComponentAdapter",
        "class \ncomponentAdded",
        "class \ncomponentHidden",
        "interface \ncomponentMoved",
        "class names",
        "class \nConcurrentLinkedDeque",
        "class \nConcurrentSkipListMap",
        "class \nConcurrentSkipListSet",
        "class \nCondition",
        "class \n\nconnect",
        "class \nmethods"
      ],
      "quality_score": 4.6000000000000005,
      "has_code_example": true
    },
    {
      "chunk_id": 2379,
      "page_number": 1514,
      "length": 942,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nmethods",
        "class \nConstructor",
        "class hierarchy",
        "interface \nContainer",
        "class \nContainer",
        "class \nContainerEvent",
        "class \nContainerListener",
        "interface \nContainment",
        "class \n\n\nContextMenuEvent"
      ],
      "quality_score": 3.8,
      "has_code_example": true
    },
    {
      "chunk_id": 2380,
      "page_number": 1515,
      "length": 900,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "interface",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \n\n\nContextMenuEvent",
        "class \n\ncontinue",
        "class \nControl",
        "class or",
        "class \nmethods",
        "class \nCookieManager",
        "class \nCookiePolicy",
        "interface \nCookies",
        "interface \ncopy",
        "class \nCopyOnWriteArraySet",
        "class \ncopySign",
        "class \nCountedCompleter",
        "class \n\ncountStackFrames"
      ],
      "quality_score": 4.9,
      "has_code_example": true
    },
    {
      "chunk_id": 2381,
      "page_number": 1516,
      "length": 901,
      "chunk_type": "code",
      "java_keywords_count": 17,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "annotation",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class \nCurrency",
        "class \nmethods",
        "class \nCyclicBarrier",
        "class \n\nD",
        "class \nmethods",
        "class \nDataInput",
        "interface \nDataInputStream",
        "class \nDataOutput",
        "interface \nDataOutputStream",
        "class \nDate",
        "class \nmethods",
        "class \nDateTimeFormatter",
        "class \nDeadlock",
        "class \nDecrement",
        "interface method",
        "class \ndefaults"
      ],
      "quality_score": 5.9,
      "has_code_example": true
    },
    {
      "chunk_id": 2382,
      "page_number": 1517,
      "length": 954,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "annotation",
        "interface",
        "class",
        "class",
        "class",
        "annotation",
        "interface",
        "class",
        "class",
        "abstract",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface method",
        "class \ndefaults",
        "class \nDelegation",
        "interface \nmethods",
        "class \nDiamond",
        "class \nabstract",
        "class \nreflection",
        "class \nDirectoryStream",
        "interface \ndispose"
      ],
      "quality_score": 4.1,
      "has_code_example": true
    },
    {
      "chunk_id": 2383,
      "page_number": 1518,
      "length": 902,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "annotation",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class \nDirectoryStream",
        "interface \ndispose",
        "interface \nDocument",
        "class \nDosFileAttributeView",
        "interface \nDot",
        "class \nmethods",
        "class \nDoubleAdder",
        "class \nDoubleBinaryOperator",
        "interface \nDoubleBuffer",
        "class \ndoubles",
        "interface \nDoubleSummaryStatistics",
        "class \ndoubleToLongBits"
      ],
      "quality_score": 4.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2384,
      "page_number": 1519,
      "length": 722,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "class",
        "class",
        "static",
        "static",
        "static",
        "class"
      ],
      "code_patterns": [
        "class \nDynamic",
        "class \nEffects",
        "class \nend"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2385,
      "page_number": 1520,
      "length": 910,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "class",
        "enum",
        "Enum",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nend",
        "class \nmethods",
        "interface \nEnumeration",
        "class type",
        "class \nEnumSet",
        "class \nfactory",
        "class \nErrors"
      ],
      "quality_score": 3.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2386,
      "page_number": 1521,
      "length": 867,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nEvent",
        "interface \nEventListener",
        "interface \nEventListenerProxy",
        "class \nEventObject",
        "class \nEventSetDescriptor",
        "class \nException",
        "class \n\nException"
      ],
      "quality_score": 3.1000000000000005,
      "has_code_example": true
    },
    {
      "chunk_id": 2387,
      "page_number": 1522,
      "length": 863,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "final",
        "class",
        "interface",
        "class",
        "interface",
        "extends",
        "interface"
      ],
      "code_patterns": [
        "class \nexec",
        "interface \nExecutors",
        "class \nExecutorService",
        "interface \nexists",
        "interface \n\nF"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2388,
      "page_number": 1523,
      "length": 817,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "class",
        "final",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class \nField",
        "class \ninstance",
        "class \nFileDialog",
        "class \nFileFilter",
        "interface \nFileInputStream",
        "class \nFilenameFilter",
        "interface \nFileNotFoundException",
        "class \nFileReader",
        "class \nFiles",
        "class \nmethods",
        "class \nFileSystem",
        "class \n\nFileSystems",
        "class \nFileVisitor",
        "interface \nFileVisitResult"
      ],
      "quality_score": 5.300000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 2389,
      "page_number": 1524,
      "length": 754,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "final",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nFileVisitor",
        "interface \nFileVisitResult",
        "class \nfill",
        "class \nFilterInputStream",
        "class \nFilterOutputStream",
        "class \nFilterReader",
        "class \nFilterWriter",
        "class \nfinal",
        "class inheritance",
        "class \nmethods"
      ],
      "quality_score": 4.1,
      "has_code_example": true
    },
    {
      "chunk_id": 2390,
      "page_number": 1525,
      "length": 884,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "class",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class \nfloatValue",
        "class \nFlowPane",
        "class \nflush",
        "interface \nFocusAdapter",
        "class \nFocusEvent",
        "class \nfocusGained",
        "interface \nfocusLost",
        "class \nmethods",
        "interface \nand"
      ],
      "quality_score": 3.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2391,
      "page_number": 1526,
      "length": 944,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \ncommon",
        "class \nFormat",
        "interface \nFormattableFlags",
        "class \nFormatted"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2392,
      "page_number": 1527,
      "length": 853,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "interface",
        "abstract",
        "annotation",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nFrame",
        "interface \nFunctional",
        "interface \nFXCollections",
        "class \n\nG",
        "class \nand"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2393,
      "page_number": 1528,
      "length": 856,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \nget"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2394,
      "page_number": 1529,
      "length": 882,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2395,
      "page_number": 1530,
      "length": 767,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \ngetField"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2396,
      "page_number": 1531,
      "length": 852,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2397,
      "page_number": 1532,
      "length": 869,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2398,
      "page_number": 1533,
      "length": 833,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "Interface",
        "Interface"
      ],
      "code_patterns": [
        "class \nprogram"
      ],
      "quality_score": 1.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2399,
      "page_number": 1534,
      "length": 918,
      "chunk_type": "code",
      "java_keywords_count": 16,
      "java_keywords": [
        "Interface",
        "Interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "Interface",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \ndrawing",
        "class \nGraphicsContext",
        "class \nGraphicsEnvironment",
        "class \nGregorianCalendar",
        "class \nGrid",
        "class \nconstraint",
        "class \ngridheight",
        "class \nGridPane",
        "class \ngridwidth",
        "class \ngroup",
        "class \nHashSet",
        "class \nfrom",
        "class \nand"
      ],
      "quality_score": 5.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2400,
      "page_number": 1535,
      "length": 936,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nHashSet",
        "class \nfrom",
        "class \nand",
        "class \nport",
        "class \n\nHTTP",
        "class \n\n\nHttpServlet"
      ],
      "quality_score": 2.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2401,
      "page_number": 1536,
      "length": 839,
      "chunk_type": "code",
      "java_keywords_count": 14,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "interface",
        "interface",
        "class",
        "interface",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class \n\n\nHttpServlet",
        "class \n\nmethods",
        "interface \nmethods",
        "interface \nmethods",
        "interface \nmethods",
        "class \nmethods",
        "interface \nIcons",
        "class \nIEEEremainder",
        "class \n\nAWT",
        "interface \nImageFilter",
        "class \nImageIcon",
        "class \nImageObserver",
        "interface \n\n\nImageProducer"
      ],
      "quality_score": 5.0,
      "has_code_example": true
    },
    {
      "chunk_id": 2402,
      "page_number": 1537,
      "length": 858,
      "chunk_type": "code",
      "java_keywords_count": 17,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "interface",
        "interface",
        "class",
        "implements",
        "import",
        "static",
        "import",
        "class",
        "class",
        "class",
        "class",
        "class",
        "final",
        "annotation"
      ],
      "code_patterns": [
        "interface \nImageFilter",
        "class \nImageIcon",
        "class \nImageObserver",
        "interface \n\n\nImageProducer",
        "interface \n\nimageUpdate",
        "class \nIMG",
        "class \nInet6Address",
        "class \nInetAddress",
        "class \nInetSocketAddress",
        "class \ninfinity",
        "class \nInheritance"
      ],
      "quality_score": 4.9,
      "has_code_example": true
    },
    {
      "chunk_id": 2403,
      "page_number": 1538,
      "length": 788,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "static",
        "class",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nprogram",
        "class \nInputMismatchException",
        "class \nmethods",
        "class \ninsert",
        "class \nInstance",
        "class \nSee",
        "class \nInstantiationException",
        "interface \nint",
        "class \nInteger",
        "class \n\nconstructors"
      ],
      "quality_score": 4.1,
      "has_code_example": true
    },
    {
      "chunk_id": 2404,
      "page_number": 1539,
      "length": 804,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "interface",
        "Interface",
        "static",
        "Interface",
        "Interface",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface keyword",
        "class \nints",
        "interface \n\nIntSummaryStatistics",
        "class \nintValue"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2405,
      "page_number": 1540,
      "length": 930,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "class",
        "package",
        "package"
      ],
      "code_patterns": [
        "class \nintValue",
        "class \nusing",
        "class \nio"
      ],
      "quality_score": 2.1,
      "has_code_example": true
    },
    {
      "chunk_id": 2406,
      "page_number": 1541,
      "length": 755,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "interface"
      ],
      "code_patterns": [
        "class \nItemListener"
      ],
      "quality_score": 1.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2407,
      "page_number": 1542,
      "length": 784,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "interface",
        "interface",
        "synchronized",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class \nItemListener",
        "interface \n\n\nItemSelectable",
        "interface \nitemStateChanged",
        "interface \nIterable",
        "interface \nIteration",
        "interface \nmethods",
        "class \nJava"
      ],
      "quality_score": 3.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2408,
      "page_number": 1,
      "length": 851,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "Native",
        "Interface",
        "package",
        "package",
        "package",
        "class",
        "package",
        "class",
        "class",
        "class",
        "class",
        "package",
        "package",
        "package",
        "interface"
      ],
      "code_patterns": [
        "class \njava",
        "class \njava",
        "interface \njava"
      ],
      "quality_score": 3.1,
      "has_code_example": true
    },
    {
      "chunk_id": 2409,
      "page_number": 1,
      "length": 160,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "package",
        "annotation",
        "package"
      ],
      "code_patterns": [
        "interface \njava"
      ],
      "quality_score": 0.9199999999999999,
      "has_code_example": true
    },
    {
      "chunk_id": 2410,
      "page_number": 1,
      "length": 129,
      "chunk_type": "technical",
      "java_keywords_count": 4,
      "java_keywords": [
        "annotation",
        "package",
        "package",
        "package"
      ],
      "code_patterns": [],
      "quality_score": 0.658,
      "has_code_example": false
    },
    {
      "chunk_id": 2411,
      "page_number": 1544,
      "length": 962,
      "chunk_type": "code",
      "java_keywords_count": 30,
      "java_keywords": [
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "class",
        "class",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package"
      ],
      "code_patterns": [
        "class \njava"
      ],
      "quality_score": 4.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2412,
      "page_number": 1545,
      "length": 872,
      "chunk_type": "code",
      "java_keywords_count": 19,
      "java_keywords": [
        "class",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "class",
        "package",
        "package",
        "package",
        "package"
      ],
      "code_patterns": [
        "class \ncompiling",
        "class \njavafx"
      ],
      "quality_score": 3.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 2413,
      "page_number": 1546,
      "length": 882,
      "chunk_type": "code",
      "java_keywords_count": 24,
      "java_keywords": [
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "package",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nJCheckBox",
        "class \nJCheckBoxMenuItem",
        "class \nJComboBox",
        "class \nJComponent",
        "class \nJDialog",
        "class \nJDK",
        "class \nJFrame",
        "class \nJIT",
        "class \nJLayeredPane",
        "class \nJList",
        "class \nJMenu",
        "class \nmnemonic",
        "class \nJMenuItem",
        "class \naccelerator",
        "class \nJoy",
        "class \nJPEG"
      ],
      "quality_score": 6.6000000000000005,
      "has_code_example": true
    },
    {
      "chunk_id": 2414,
      "page_number": 1547,
      "length": 773,
      "chunk_type": "code",
      "java_keywords_count": 23,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class \nJPEG",
        "class \n\n\nand",
        "class \nJRadioButtonMenuItem",
        "class \nJRootPane",
        "class \nJScrollBar",
        "class \nJSeparator",
        "class \nJScrollPane",
        "class \nJSpinner",
        "class \nJTabbedPane",
        "class \nJTable",
        "class \nJTextComponent",
        "class \nJTextField",
        "class \nJToggleButton",
        "class \nJToggleButton",
        "class \nJToolbar",
        "class \nadding",
        "class \nJump",
        "class \n\nK",
        "class \nKeyboard",
        "class \nkeyCombination",
        "class \nKeyListener",
        "interface \nkeyPressed",
        "class \n\nkeyTyped"
      ],
      "quality_score": 7.9,
      "has_code_example": true
    },
    {
      "chunk_id": 2415,
      "page_number": 1548,
      "length": 718,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class \nAWT",
        "class \nLambda",
        "interface \nLazy"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 2416,
      "page_number": 1549,
      "length": 972,
      "chunk_type": "code",
      "java_keywords_count": 17,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "interface",
        "class",
        "class",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface \nLazy",
        "class \nLibrary",
        "class \nLineNumberReader",
        "class \nlines",
        "class \nLinkedBlockingQueue",
        "class \nLinkedHashMap",
        "class \nLinkedHashSet",
        "class \nLinkedList",
        "class \nexample",
        "class \nList",
        "interface \nfrom",
        "interface \nmethods",
        "class \nListSelectionEvent",
        "class \n\nListSelectionListener",
        "interface \nListSelectionModel",
        "interface \nListView",
        "class \n\n\nLiterals"
      ],
      "quality_score": 6.1000000000000005,
      "has_code_example": true
    },
    {
      "chunk_id": 2417,
      "page_number": 1550,
      "length": 918,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "interface",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface \nListSelectionModel",
        "interface \nListView",
        "class \n\n\nLiterals",
        "class \nregular",
        "class \nLocalDateTime",
        "class \nLocale",
        "class \nLocale",
        "class \nLocalTime",
        "class \nLock",
        "interface \nmethods",
        "class \nmethods",
        "class \nLongAdder",
        "class \nlongBitsToDouble",
        "class \nlongs",
        "interface \nlongValue"
      ],
      "quality_score": 5.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2418,
      "page_number": 1,
      "length": 493,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "interface",
        "interface",
        "static",
        "PRIVATE"
      ],
      "code_patterns": [
        "interface \nmethods",
        "interface \nmethods"
      ],
      "quality_score": 1.786,
      "has_code_example": true
    },
    {
      "chunk_id": 2419,
      "page_number": 1552,
      "length": 793,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "interface",
        "static",
        "PRIVATE",
        "class",
        "class",
        "class",
        "static",
        "import",
        "class",
        "class",
        "static",
        "interface",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface \nmethods",
        "class \nmapToDouble",
        "class \nmatcher",
        "class \nrounding",
        "class \nMember",
        "class \naccess",
        "interface \nMemory",
        "class \nMemoryImageSource",
        "class \nMenu",
        "class \nAWT"
      ],
      "quality_score": 4.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2420,
      "page_number": 1553,
      "length": 710,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nAWT",
        "class \nAWT"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2421,
      "page_number": 1554,
      "length": 824,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "class",
        "Annotation",
        "class",
        "static",
        "abstract",
        "Abstract",
        "interface",
        "final",
        "interface",
        "Interface",
        "native"
      ],
      "code_patterns": [
        "class \nAWT",
        "class \nMethod",
        "class version",
        "interface \ndispatch"
      ],
      "quality_score": 2.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2422,
      "page_number": 1555,
      "length": 889,
      "chunk_type": "code",
      "java_keywords_count": 12,
      "java_keywords": [
        "static",
        "synchronized",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class \nMethodHandle",
        "class \nmethodModifiers",
        "class \nMIME",
        "class \nmouseClicked",
        "class \nmouseExited",
        "interface \nMouseMotionAdapter",
        "class \n\nMouseMotionListener",
        "interface \nmouseMoved"
      ],
      "quality_score": 3.8000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 2423,
      "page_number": 1556,
      "length": 945,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "class",
        "class",
        "interface",
        "class",
        "Native",
        "annotation",
        "native"
      ],
      "code_patterns": [
        "interface \nmouseMoved",
        "class \n\nMouseWheelListener",
        "interface \nmouseWheelMoved",
        "class \nmultiplyExact",
        "class \nand",
        "interface \nMVC",
        "class \nNaN"
      ],
      "quality_score": 3.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2424,
      "page_number": 1557,
      "length": 826,
      "chunk_type": "code",
      "java_keywords_count": 2,
      "java_keywords": [
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface \nmethods",
        "interface \n\n\nmethods"
      ],
      "quality_score": 1.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2425,
      "page_number": 1558,
      "length": 844,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \nNode"
      ],
      "quality_score": 1.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2426,
      "page_number": 1559,
      "length": 872,
      "chunk_type": "code",
      "java_keywords_count": 4,
      "java_keywords": [
        "class",
        "class",
        "class",
        "abstract"
      ],
      "code_patterns": [
        "class \nNumberFormatException",
        "class \nas",
        "class methods",
        "class reference",
        "class \nOBJECT"
      ],
      "quality_score": 2.4,
      "has_code_example": true
    },
    {
      "chunk_id": 2427,
      "page_number": 1560,
      "length": 891,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "interface",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "interface \nmethods",
        "class \nmethods",
        "interface \nmethods",
        "class \nmethods",
        "class \nObservable",
        "class \nmethods",
        "interface \nOctals",
        "interface \nOperator"
      ],
      "quality_score": 3.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2428,
      "page_number": 1561,
      "length": 841,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "annotation",
        "abstract",
        "final",
        "class",
        "Package"
      ],
      "code_patterns": [
        "class \nmethods",
        "class \nOptionalInt",
        "class \nOptionalLong",
        "class \nOR",
        "class \nmethods",
        "class \nOverloading",
        "class \nand"
      ],
      "quality_score": 3.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2429,
      "page_number": 1562,
      "length": 843,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "Package",
        "Package",
        "class",
        "package",
        "class",
        "class",
        "final"
      ],
      "code_patterns": [
        "class \nmethods",
        "class \nPaint",
        "class \nPanes"
      ],
      "quality_score": 2.3000000000000003,
      "has_code_example": true
    },
    {
      "chunk_id": 2430,
      "page_number": 1563,
      "length": 934,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "class",
        "class",
        "native",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nparse",
        "class \nPasswords",
        "interface \nconverting",
        "class \nPattern",
        "class \nPattern",
        "class \nPersistence",
        "class \ncompatibility"
      ],
      "quality_score": 3.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2431,
      "page_number": 1564,
      "length": 861,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "native",
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class \ncompatibility",
        "class \nPipedOutputStream",
        "class \nPipedReader",
        "class \nPipedWriter",
        "class \nPixelGrabber",
        "class \nPlatform",
        "class \nPlatform",
        "class \nPointers",
        "class \nPolymorphism",
        "class \nPopupMenu",
        "class \nPopupMenuEvent",
        "class \nPosixFileAttributeView",
        "interface \n\npostVisitDirectory",
        "interface \npreferredLayoutSize"
      ],
      "quality_score": 5.300000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 2432,
      "page_number": 1565,
      "length": 950,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "interface",
        "interface",
        "interface",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "private",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface \nPrimitiveIterator",
        "interface \nPrimitiveIterator",
        "interface \nPrimitiveIterator",
        "interface \nprint",
        "class \nPrintWriter",
        "class \nPriorityBlockingQueue",
        "class \nPriorityQueue",
        "class \nprivate",
        "class \nmethods",
        "class \nmethods",
        "class \nProcessBuilder",
        "class \nmethods"
      ],
      "quality_score": 4.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2433,
      "page_number": 1566,
      "length": 789,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "interface",
        "class",
        "class",
        "class",
        "protected",
        "public",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class \nmethods",
        "interface \nPropertyDescriptor",
        "class \nPropertyPermission",
        "class \nPropertyResourceBundle",
        "class \nPropertyVetoException",
        "class \nput",
        "class \nputValue",
        "interface \n\nmethods"
      ],
      "quality_score": 3.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2434,
      "page_number": 1567,
      "length": 832,
      "chunk_type": "code",
      "java_keywords_count": 13,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "interface",
        "interface",
        "class",
        "interface",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface \n\nmethods",
        "class \nRadioMenuItem",
        "class \nRadix",
        "class \nmethods",
        "interface \nRandomAccessFile",
        "class \nrange",
        "interface \nReadableByteChannel",
        "interface \nreadAttributes",
        "class \nmethods",
        "interface \nReal",
        "class \n\nRecursiveTask",
        "class \nexample",
        "class \nreduce"
      ],
      "quality_score": 4.9,
      "has_code_example": true
    },
    {
      "chunk_id": 2435,
      "page_number": 1568,
      "length": 839,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "class",
        "class",
        "class",
        "interface",
        "annotation"
      ],
      "code_patterns": [
        "class \nexample",
        "class \nreduce",
        "class \nregionMatches",
        "interface \nRemote"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2436,
      "page_number": 1569,
      "length": 876,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "annotation",
        "class",
        "class",
        "class",
        "annotation",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nreset",
        "class \nmethods",
        "class \nresume",
        "class \nexample",
        "class \nprogram"
      ],
      "quality_score": 2.7,
      "has_code_example": true
    },
    {
      "chunk_id": 2437,
      "page_number": 1570,
      "length": 871,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "class",
        "annotation",
        "Abstract",
        "class",
        "class",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "interface \nimplementing",
        "class \nexecuting",
        "class \nRuntimePermission",
        "class \n\nS",
        "class \nprogram",
        "class \nclosing",
        "class \n\nschedule",
        "interface \nScheduledThreadPoolExecutor",
        "class \nScientific"
      ],
      "quality_score": 3.9000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2438,
      "page_number": 1571,
      "length": 894,
      "chunk_type": "code",
      "java_keywords_count": 18,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "class",
        "native",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "static",
        "transient",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "interface \nScheduledThreadPoolExecutor",
        "class \nScientific",
        "class \nScrollPane",
        "class \nsearch",
        "class \nseek",
        "interface \nselect",
        "class \nSelectors",
        "class \nsend",
        "class \nSeparatorMenuItem",
        "class \nSeparators",
        "class \nsequential",
        "interface \nSerialization",
        "class \n\nservice",
        "class \nServlet"
      ],
      "quality_score": 5.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2439,
      "page_number": 1572,
      "length": 877,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "interface",
        "interface",
        "interface",
        "class",
        "class",
        "class",
        "interface",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class \nServlet",
        "interface \n\n\nmethods",
        "interface \nServletContext",
        "interface \nmethods",
        "class \nServletInputStream",
        "class \nServletOutputStream",
        "class \nServletRequest",
        "interface \nmethods",
        "interface \nmethods",
        "interface \nfrom"
      ],
      "quality_score": 4.0,
      "has_code_example": true
    },
    {
      "chunk_id": 2440,
      "page_number": 1573,
      "length": 812,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2441,
      "page_number": 1574,
      "length": 782,
      "chunk_type": "text",
      "java_keywords_count": 0,
      "java_keywords": [],
      "code_patterns": [],
      "quality_score": 1.0,
      "has_code_example": false
    },
    {
      "chunk_id": 2442,
      "page_number": 1575,
      "length": 716,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nSheridan",
        "class \nmethods",
        "class \nshortValue",
        "class \nSimpleDateFormat",
        "class \nformatting",
        "class \nSimpleTimeZone",
        "class \nsin",
        "class \nSocket"
      ],
      "quality_score": 3.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2443,
      "page_number": 1576,
      "length": 879,
      "chunk_type": "code",
      "java_keywords_count": 15,
      "java_keywords": [
        "class",
        "class",
        "class",
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "interface",
        "class",
        "class",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class \nSocket",
        "class \nSocketChannel",
        "class \nSocketException",
        "interface \nmethods",
        "interface \nmethods",
        "interface \nmethods",
        "interface \nSpliterator",
        "interface \nSpliterator",
        "interface \nSpliterator",
        "interface \nsqrt",
        "class \nmethods",
        "class \nmethods",
        "class \n\nStampedLock",
        "interface \nStandardCopyOption",
        "class \n\n\nenumeration"
      ],
      "quality_score": 5.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2444,
      "page_number": 1577,
      "length": 914,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "class",
        "static",
        "Static",
        "import",
        "interface"
      ],
      "code_patterns": [
        "interface \nStandardCopyOption",
        "class \n\n\nenumeration",
        "interface \nmethods"
      ],
      "quality_score": 2.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2445,
      "page_number": 1578,
      "length": 798,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "strictfp",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nString",
        "class \nconstructors"
      ],
      "quality_score": 1.7000000000000002,
      "has_code_example": true
    },
    {
      "chunk_id": 2446,
      "page_number": 1579,
      "length": 852,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface"
      ],
      "code_patterns": [
        "class \nmethods",
        "class \nStringBuilder",
        "class \nand",
        "class \nStringReader",
        "class \nStringTokenizer",
        "class \nmethods",
        "class \nstrokeLine",
        "class \nsubList",
        "interface default",
        "class constructors"
      ],
      "quality_score": 3.8,
      "has_code_example": true
    },
    {
      "chunk_id": 2447,
      "page_number": 1580,
      "length": 890,
      "chunk_type": "code",
      "java_keywords_count": 5,
      "java_keywords": [
        "abstract",
        "interface",
        "annotation",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class constructors",
        "class \n\nabstract",
        "interface \nSwingUtilities",
        "class \nswitch"
      ],
      "quality_score": 2.3,
      "has_code_example": true
    },
    {
      "chunk_id": 2448,
      "page_number": 1581,
      "length": 872,
      "chunk_type": "code",
      "java_keywords_count": 10,
      "java_keywords": [
        "class",
        "synchronized",
        "synchronized",
        "synchronized",
        "class",
        "class",
        "static",
        "import",
        "class",
        "annotation"
      ],
      "code_patterns": [
        "class \nvia",
        "class \nSystem",
        "class \nmethods",
        "class \ntailMap"
      ],
      "quality_score": 2.8,
      "has_code_example": true
    },
    {
      "chunk_id": 2449,
      "page_number": 1582,
      "length": 808,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "class",
        "class",
        "class",
        "class",
        "class",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class \nText",
        "class \nAWT",
        "class \nTextEvent",
        "class \nTextField",
        "class \nAWT",
        "interface \ntextValueChanged",
        "class \nconstructors"
      ],
      "quality_score": 3.1000000000000005,
      "has_code_example": true
    },
    {
      "chunk_id": 2450,
      "page_number": 1583,
      "length": 744,
      "chunk_type": "code",
      "java_keywords_count": 7,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface \nThreadGroup",
        "class \nmethods",
        "class \nThreadPoolExecutor",
        "class \nthrow",
        "class \nmethods",
        "class \n\nmethods",
        "class \nmethods"
      ],
      "quality_score": 3.1000000000000005,
      "has_code_example": true
    },
    {
      "chunk_id": 2451,
      "page_number": 1584,
      "length": 759,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "class",
        "class",
        "interface",
        "interface",
        "class",
        "class",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nmethods",
        "class \nmethods",
        "interface \ntoFile",
        "interface \nToggle",
        "class \nToggleGroup",
        "class \ntoHexString",
        "class \n\nToolbars",
        "class \nTooltips"
      ],
      "quality_score": 3.4000000000000004,
      "has_code_example": true
    },
    {
      "chunk_id": 2452,
      "page_number": 1585,
      "length": 808,
      "chunk_type": "code",
      "java_keywords_count": 16,
      "java_keywords": [
        "class",
        "transient",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "class",
        "class",
        "interface",
        "interface",
        "class",
        "class",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "class \nTooltips",
        "class \nTransforms",
        "class \ntranslatePoint",
        "class \nTreeExpansionListener",
        "interface \nTreeItem",
        "class \nTreeMap",
        "class \nexample",
        "class \nTreeModelListener",
        "interface \nTreeNode",
        "interface \nTreePath",
        "class \nTrees",
        "class \n\nTreeSelectionListener",
        "interface \nTreeSelectionModel",
        "class \nTreeView",
        "class \n\n\ntrim"
      ],
      "quality_score": 5.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2453,
      "page_number": 1586,
      "length": 763,
      "chunk_type": "code",
      "java_keywords_count": 8,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "class",
        "interface",
        "class",
        "static",
        "class"
      ],
      "code_patterns": [
        "interface \nTreeSelectionModel",
        "class \nTreeView",
        "class \n\n\ntrim",
        "class hierarchies",
        "interface \nType",
        "class hierarchies",
        "class \nused"
      ],
      "quality_score": 3.2,
      "has_code_example": true
    },
    {
      "chunk_id": 2454,
      "page_number": 1587,
      "length": 823,
      "chunk_type": "code",
      "java_keywords_count": 3,
      "java_keywords": [
        "class",
        "interface",
        "interface"
      ],
      "code_patterns": [
        "class as",
        "interface \nUnavailableException",
        "interface \nUnchecked"
      ],
      "quality_score": 1.9000000000000001,
      "has_code_example": true
    },
    {
      "chunk_id": 2455,
      "page_number": 1588,
      "length": 960,
      "chunk_type": "code",
      "java_keywords_count": 6,
      "java_keywords": [
        "interface",
        "class",
        "class",
        "class",
        "class",
        "annotation"
      ],
      "code_patterns": [
        "interface \nUnchecked",
        "class \nURL",
        "class \nmethods",
        "class \nuseDelimiter",
        "class \n\nV"
      ],
      "quality_score": 2.6,
      "has_code_example": true
    },
    {
      "chunk_id": 2456,
      "page_number": 1589,
      "length": 756,
      "chunk_type": "code",
      "java_keywords_count": 11,
      "java_keywords": [
        "final",
        "final",
        "interface",
        "interface",
        "class",
        "interface",
        "class",
        "volatile",
        "interface",
        "class",
        "class"
      ],
      "code_patterns": [
        "interface \ninterface",
        "class \nlegacy",
        "interface \nViewport",
        "class \nvolatile",
        "interface \nWeakHashMap",
        "class \nWeb",
        "class \nweightx"
      ],
      "quality_score": 3.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2457,
      "page_number": 1590,
      "length": 898,
      "chunk_type": "code",
      "java_keywords_count": 9,
      "java_keywords": [
        "class",
        "class",
        "class",
        "interface",
        "class",
        "interface",
        "interface",
        "interface",
        "class"
      ],
      "code_patterns": [
        "class \nweightx",
        "class \nWindow",
        "class \nwindowClosed",
        "interface \nwindowDeactivated",
        "class \nWindowFocusListener",
        "interface \nwindowGainedFocus",
        "interface \nwindowLostFocus",
        "interface \nWork"
      ],
      "quality_score": 3.5,
      "has_code_example": true
    },
    {
      "chunk_id": 2458,
      "page_number": 1591,
      "length": 343,
      "chunk_type": "code",
      "java_keywords_count": 1,
      "java_keywords": [
        "class"
      ],
      "code_patterns": [
        "class \n\n\nmethods"
      ],
      "quality_score": 0.986,
      "has_code_example": true
    }
  ]
}